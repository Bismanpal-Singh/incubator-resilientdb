#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_message_manager</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/dee/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_206__message__manager.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_message_manager</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md940"></a>
autotoc_md940</h2>
<p>layout: default title: "Message Manager" parent: "Browser Use" </p>
<h2><a class="anchor" id="autotoc_md941"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md942"></a>
Chapter 6: Message Manager - Keeping the Conversation Straight</h1>
<p>In the <a class="el" href="../../de/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_205__action__controller______registry.html">previous chapter</a>, we learned how the <code>Action Controller</code> and <code>Registry</code> act as the Agent's "hands" and "toolbox", executing the specific actions decided by the LLM planner. But how does the LLM get all the information it needs to make those decisions in the first place? How does the Agent keep track of the ongoing conversation, including what it "saw" on the page and what happened after each action?</p>
<p>Imagine you're having a long, multi-step discussion with an assistant about a complex task. If the assistant has a poor memory, they might forget earlier instructions, the current status, or previous results, making it impossible to proceed correctly. LLMs face a similar challenge: they need the conversation history for context, but they have a limited memory (called the "context window").</p>
<p>This is the problem the <b>Message Manager</b> solves.</p>
<h2><a class="anchor" id="autotoc_md943"></a>
What Problem Does the Message Manager Solve?</h2>
<p>The <code>Agent</code> needs to have a conversation with the LLM. This conversation isn't just chat; it includes:</p>
<ol type="1">
<li><b>Initial Instructions:</b> The core rules from the <a class="el" href="../../dd/d81/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_202__system__prompt.html">System Prompt</a>.</li>
<li><b>The Task:</b> The overall goal the Agent needs to achieve.</li>
<li><b>Observations:</b> What the Agent currently "sees" in the browser (<a class="el" href="../../dd/da5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_203__browsercontext.html">BrowserContext</a> state, including the <a class="el" href="../../d0/df8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_204__dom__representation.html">DOM Representation</a>).</li>
<li><b>Action Results:</b> What happened after the last action was performed (<a class="el" href="../../de/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_205__action__controller______registry.html">Action Controller &amp; Registry</a>).</li>
<li><b>LLM's Plan:</b> The sequence of actions the LLM decided on.</li>
</ol>
<p>The Message Manager solves several key problems:</p>
<ul>
<li><b>Organizes History:</b> It structures the conversation chronologically, keeping track of who said what (System, User/Agent State, AI/LLM Plan).</li>
<li><b>Formats Messages:</b> It ensures the browser state, action results, and even images are formatted correctly so the LLM can understand them.</li>
<li><b>Tracks Size:</b> It keeps count of the "tokens" (roughly, words or parts of words) used in the conversation history.</li>
<li><b>Manages Limits:</b> It helps prevent the conversation history from exceeding the LLM's context window limit, potentially by removing older parts of the conversation if it gets too long.</li>
</ul>
<p>Think of the <code>MessageManager</code> as a meticulous secretary for the Agent-LLM conversation. It takes clear, concise notes, presents the current situation accurately, and ensures the conversation doesn't ramble on for too long, keeping everything within the LLM's "attention span".</p>
<h2><a class="anchor" id="autotoc_md944"></a>
Meet the Message Manager: The Conversation Secretary</h2>
<p>The <code>MessageManager</code> (found in <code>agent/message_manager/service.py</code>) is responsible for managing the list of messages that are sent to the LLM in each step.</p>
<p>Here are its main jobs:</p>
<ol type="1">
<li><b>Initialization:</b> When the <code>Agent</code> starts, the <code>MessageManager</code> is created. It immediately adds the foundational messages:<ul>
<li>The <code>SystemMessage</code> containing the rules from the <a class="el" href="../../dd/d81/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_202__system__prompt.html">System Prompt</a>.</li>
<li>A <code>HumanMessage</code> stating the overall <code>task</code>.</li>
<li>Other initial setup messages (like examples or sensitive data placeholders).</li>
</ul>
</li>
<li><b>Adding Browser State:</b> Before asking the LLM what to do next, the <code>Agent</code> gets the current <code>BrowserState</code>. It then tells the <code>MessageManager</code> to add this information as a <code>HumanMessage</code>. This message includes the simplified DOM map, the current URL, and potentially a screenshot (if <code>use_vision</code> is enabled). It also includes the results (<code>ActionResult</code>) from the <em>previous</em> step, so the LLM knows what happened last.</li>
<li><b>Adding LLM Output:</b> After the LLM responds with its plan (<code>AgentOutput</code>), the <code>Agent</code> tells the <code>MessageManager</code> to add this plan as an <code>AIMessage</code>. This typically includes the LLM's reasoning and the list of actions to perform.</li>
<li><b>Adding Action Results (Indirectly):</b> The results from the <code>Controller.act</code> call (<code>ActionResult</code>) aren't added as separate messages <em>after</em> the action. Instead, they are included in the <em>next</em> <code>HumanMessage</code> that contains the browser state (see step 2). This keeps the context tight: "Here's the current page, and here's what happened right before we got here."</li>
<li><b>Providing Messages to LLM:</b> When the <code>Agent</code> is ready to call the LLM, it asks the <code>MessageManager</code> for the current conversation history (<code>get_messages()</code>).</li>
<li><b>Token Management:</b> Every time a message is added, the <code>MessageManager</code> calculates how many tokens it adds (<code>_count_tokens</code>) and updates the total. If the total exceeds the limit (<code>max_input_tokens</code>), it might trigger a truncation strategy (<code>cut_messages</code>) to shorten the history, usually by removing parts of the oldest user state message or removing the image first.</li>
</ol>
<h2><a class="anchor" id="autotoc_md945"></a>
How the Agent Uses the Message Manager</h2>
<p>Let's revisit the simplified <code>Agent.step</code> method from <a class="el" href="../../de/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_201__agent.html">Chapter 1</a> and highlight the <code>MessageManager</code> interactions (using <code>self._message_manager</code>):</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: agent/service.py (Simplified step method - Highlighting MessageManager) ---</span></div>
<div class="line"><span class="keyword">class </span>Agent:</div>
<div class="line">    <span class="comment"># ... (init, run) ...</span></div>
<div class="line">    <span class="keyword">async def </span>step(self, step_info: Optional[AgentStepInfo] = <span class="keywordtype">None</span>) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">        logger.info(f<span class="stringliteral">&quot;üìç Step {self.state.n_steps}&quot;</span>)</div>
<div class="line">        state = <span class="keywordtype">None</span></div>
<div class="line">        model_output = <span class="keywordtype">None</span></div>
<div class="line">        result: list[ActionResult] = []</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="comment"># 1. Get current state from the browser</span></div>
<div class="line">            state = await self.browser_context.get_state() <span class="comment"># Uses BrowserContext</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment"># 2. Add state + PREVIOUS result to message history via MessageManager</span></div>
<div class="line">            <span class="comment">#    &#39;self.state.last_result&#39; holds the outcome of the *previous* step&#39;s action</span></div>
<div class="line">            self._message_manager.add_state_message(</div>
<div class="line">                state,</div>
<div class="line">                self.state.last_result, <span class="comment"># Result from previous action</span></div>
<div class="line">                step_info,</div>
<div class="line">                self.settings.use_vision <span class="comment"># Tell it whether to include image</span></div>
<div class="line">            )</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># 3. Get the complete, formatted message history for the LLM</span></div>
<div class="line">            input_messages = self._message_manager.get_messages()</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># 4. Get LLM&#39;s decision on the next action(s)</span></div>
<div class="line">            model_output = await self.get_next_action(input_messages) <span class="comment"># Calls the LLM</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment"># --- Agent increments step counter ---</span></div>
<div class="line">            self.state.n_steps += 1</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># 5. Remove the potentially large state message before adding the compact AI response</span></div>
<div class="line">            <span class="comment">#    (This is an optimization mentioned in the provided code)</span></div>
<div class="line">            self._message_manager._remove_last_state_message()</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># 6. Add the LLM&#39;s response (the plan) to the history</span></div>
<div class="line">            self._message_manager.add_model_output(model_output)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># 7. Execute the action(s) using the Controller</span></div>
<div class="line">            result = await self.multi_act(model_output.action) <span class="comment"># Uses Controller</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment"># 8. Store the result of THIS action. It will be used in the *next* step&#39;s</span></div>
<div class="line">            <span class="comment">#    call to self._message_manager.add_state_message()</span></div>
<div class="line">            self.state.last_result = result</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># ... (Record step details, handle success/failure) ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">            <span class="comment"># Handle errors...</span></div>
<div class="line">            result = await self._handle_step_error(e)</div>
<div class="line">            self.state.last_result = result</div>
<div class="line">        <span class="comment"># ... (finally block) ...</span></div>
</div><!-- fragment --><p>This flow shows the cycle: add state/previous result -&gt; get messages -&gt; call LLM -&gt; add LLM response -&gt; execute action -&gt; store result for <em>next</em> state message.</p>
<h2><a class="anchor" id="autotoc_md946"></a>
How it Works Under the Hood: Managing the Flow</h2>
<p>Let's visualize the key interactions during one step of the Agent loop involving the <code>MessageManager</code>:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Agent</div>
<div class="line">    participant BC as BrowserContext</div>
<div class="line">    participant MM as MessageManager</div>
<div class="line">    participant LLM</div>
<div class="line">    participant Controller</div>
<div class="line"> </div>
<div class="line">    Note over Agent: Start of step</div>
<div class="line">    Agent-&gt;&gt;BC: get_state()</div>
<div class="line">    BC--&gt;&gt;Agent: Current BrowserState (DOM map, URL, screenshot?)</div>
<div class="line">    Note over Agent: Have BrowserState and `last_result` from previous step</div>
<div class="line">    Agent-&gt;&gt;MM: add_state_message(BrowserState, last_result)</div>
<div class="line">    MM-&gt;&gt;MM: Format state/result into HumanMessage (with text/image)</div>
<div class="line">    MM-&gt;&gt;MM: Calculate tokens for new message</div>
<div class="line">    MM-&gt;&gt;MM: Add HumanMessage to internal history list</div>
<div class="line">    MM-&gt;&gt;MM: Update total token count</div>
<div class="line">    MM-&gt;&gt;MM: Check token limit, potentially call cut_messages()</div>
<div class="line">    Note over Agent: Ready to ask LLM</div>
<div class="line">    Agent-&gt;&gt;MM: get_messages()</div>
<div class="line">    MM--&gt;&gt;Agent: Return List[BaseMessage] (System, Task, State1, Plan1, State2...)</div>
<div class="line">    Agent-&gt;&gt;LLM: Invoke LLM with message list</div>
<div class="line">    LLM--&gt;&gt;Agent: LLM Response (AgentOutput containing plan)</div>
<div class="line">    Note over Agent: Got LLM&#39;s plan</div>
<div class="line">    Agent-&gt;&gt;MM: _remove_last_state_message() # Optimization</div>
<div class="line">    MM-&gt;&gt;MM: Remove last (large) HumanMessage from list</div>
<div class="line">    Agent-&gt;&gt;MM: add_model_output(AgentOutput)</div>
<div class="line">    MM-&gt;&gt;MM: Format plan into AIMessage (with tool calls)</div>
<div class="line">    MM-&gt;&gt;MM: Calculate tokens for AIMessage</div>
<div class="line">    MM-&gt;&gt;MM: Add AIMessage to internal history list</div>
<div class="line">    MM-&gt;&gt;MM: Update total token count</div>
<div class="line">    Note over Agent: Ready to execute plan</div>
<div class="line">    Agent-&gt;&gt;Controller: multi_act(AgentOutput.action)</div>
<div class="line">    Controller--&gt;&gt;Agent: List[ActionResult] (Result of this step&#39;s actions)</div>
<div class="line">    Agent-&gt;&gt;Agent: Store ActionResult in `self.state.last_result` (for next step)</div>
<div class="line">    Note over Agent: End of step</div>
</div><!-- fragment --><p>This shows how <code>MessageManager</code> sits between the Agent, the Browser State, and the LLM, managing the history list and token counts.</p>
<h2><a class="anchor" id="autotoc_md947"></a>
Diving Deeper into the Code (<code>agent/message_manager/service.py</code>)</h2>
<p>Let's look at simplified versions of key methods in <code>MessageManager</code>.</p>
<p><b>1. Initialization (<code>__init__</code> and <code>_init_messages</code>)</b></p>
<p>When the <code>Agent</code> creates the <code>MessageManager</code>, it passes the task and the already-formatted <code>SystemMessage</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: agent/message_manager/service.py (Simplified __init__) ---</span></div>
<div class="line"><span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> SystemMessage, HumanMessage, AIMessage, ToolMessage</div>
<div class="line"><span class="comment"># ... other imports ...</span></div>
<div class="line"><span class="keyword">from</span> browser_use.agent.views <span class="keyword">import</span> MessageManagerState <span class="comment"># Internal state storage</span></div>
<div class="line"><span class="keyword">from</span> browser_use.agent.message_manager.views <span class="keyword">import</span> MessageMetadata, ManagedMessage <span class="comment"># Message wrapper</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MessageManager:</div>
<div class="line">    <span class="keyword">def </span>__init__(</div>
<div class="line">        self,</div>
<div class="line">        task: str,</div>
<div class="line">        system_message: SystemMessage, <span class="comment"># Received from Agent</span></div>
<div class="line">        settings: MessageManagerSettings = MessageManagerSettings(),</div>
<div class="line">        state: MessageManagerState = MessageManagerState(), <span class="comment"># Stores history</span></div>
<div class="line">    ):</div>
<div class="line">        self.task = task</div>
<div class="line">        self.settings = settings <span class="comment"># Max tokens, image settings, etc.</span></div>
<div class="line">        self.state = state <span class="comment"># Holds the &#39;history&#39; object</span></div>
<div class="line">        self.system_prompt = system_message</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Only initialize if history is empty (e.g., not resuming from saved state)</span></div>
<div class="line">        <span class="keywordflow">if</span> len(self.state.history.messages) == 0:</div>
<div class="line">            self._init_messages()</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>_init_messages(self) -&gt; None:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Add the initial fixed messages to the history.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Add the main system prompt (rules)</span></div>
<div class="line">        self._add_message_with_tokens(self.system_prompt)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Add the user&#39;s task</span></div>
<div class="line">        task_message = HumanMessage(</div>
<div class="line">            content=f<span class="stringliteral">&#39;Your ultimate task is: &quot;&quot;&quot;{self.task}&quot;&quot;&quot;...&#39;</span></div>
<div class="line">        )</div>
<div class="line">        self._add_message_with_tokens(task_message)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Add other setup messages (context, sensitive data info, examples)</span></div>
<div class="line">        <span class="comment"># ... (simplified - see full code for details) ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Example: Add a placeholder for where the main history begins</span></div>
<div class="line">        placeholder_message = HumanMessage(content=<span class="stringliteral">&#39;[Your task history memory starts here]&#39;</span>)</div>
<div class="line">        self._add_message_with_tokens(placeholder_message)</div>
</div><!-- fragment --><p>This sets up the foundational context for the LLM.</p>
<p><b>2. Adding Browser State (<code>add_state_message</code>)</b></p>
<p>This method takes the current <code>BrowserState</code> and the previous <code>ActionResult</code>, formats them into a <code>HumanMessage</code> (potentially multi-modal with image and text parts), and adds it to the history.</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: agent/message_manager/service.py (Simplified add_state_message) ---</span></div>
<div class="line"><span class="comment"># ... imports ...</span></div>
<div class="line"><span class="keyword">from</span> browser_use.browser.views <span class="keyword">import</span> BrowserState</div>
<div class="line"><span class="keyword">from</span> browser_use.agent.views <span class="keyword">import</span> ActionResult, AgentStepInfo</div>
<div class="line"><span class="keyword">from</span> browser_use.agent.prompts <span class="keyword">import</span> AgentMessagePrompt <span class="comment"># Helper to format state</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MessageManager:</div>
<div class="line">    <span class="comment"># ... (init) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>add_state_message(</div>
<div class="line">        self,</div>
<div class="line">        state: BrowserState, <span class="comment"># The current view of the browser</span></div>
<div class="line">        result: Optional[List[ActionResult]] = <span class="keywordtype">None</span>, <span class="comment"># Result from *previous* action</span></div>
<div class="line">        step_info: Optional[AgentStepInfo] = <span class="keywordtype">None</span>,</div>
<div class="line">        use_vision=<span class="keyword">True</span>, <span class="comment"># Flag to include screenshot</span></div>
<div class="line">    ) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Add browser state and previous result as a human message.&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Add any &#39;memory&#39; messages from the previous result first (if any)</span></div>
<div class="line">        <span class="keywordflow">if</span> result:</div>
<div class="line">            <span class="keywordflow">for</span> r <span class="keywordflow">in</span> result:</div>
<div class="line">                <span class="keywordflow">if</span> r.include_in_memory <span class="keywordflow">and</span> (r.extracted_content <span class="keywordflow">or</span> r.error):</div>
<div class="line">                    content = f<span class="stringliteral">&quot;Action result: {r.extracted_content}&quot;</span> <span class="keywordflow">if</span> r.extracted_content <span class="keywordflow">else</span> f<span class="stringliteral">&quot;Action error: {r.error}&quot;</span></div>
<div class="line">                    msg = HumanMessage(content=content)</div>
<div class="line">                    self._add_message_with_tokens(msg)</div>
<div class="line">                    result = <span class="keywordtype">None</span> <span class="comment"># Don&#39;t include again in the main state message</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Use a helper class to format the BrowserState (+ optional remaining result)</span></div>
<div class="line">        <span class="comment"># into the correct message structure (text + optional image)</span></div>
<div class="line">        state_prompt = AgentMessagePrompt(</div>
<div class="line">            state,</div>
<div class="line">            result, <span class="comment"># Pass any remaining result info</span></div>
<div class="line">            include_attributes=self.settings.include_attributes,</div>
<div class="line">            step_info=step_info,</div>
<div class="line">        )</div>
<div class="line">        <span class="comment"># Get the formatted message (could be complex list for vision)</span></div>
<div class="line">        state_message = state_prompt.get_user_message(use_vision)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Add the formatted message (with token calculation) to history</span></div>
<div class="line">        self._add_message_with_tokens(state_message)</div>
</div><!-- fragment --><p><b>3. Adding Model Output (<code>add_model_output</code>)</b></p>
<p>This takes the LLM's plan (<code>AgentOutput</code>) and formats it as an <code>AIMessage</code> with specific "tool calls" structure that many models expect.</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: agent/message_manager/service.py (Simplified add_model_output) ---</span></div>
<div class="line"><span class="comment"># ... imports ...</span></div>
<div class="line"><span class="keyword">from</span> browser_use.agent.views <span class="keyword">import</span> AgentOutput</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MessageManager:</div>
<div class="line">    <span class="comment"># ... (init, add_state_message) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>add_model_output(self, model_output: AgentOutput) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Add model output (the plan) as an AI message with tool calls.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Format the output according to OpenAI&#39;s tool calling standard</span></div>
<div class="line">        tool_calls = [</div>
<div class="line">            {</div>
<div class="line">                <span class="stringliteral">&#39;name&#39;</span>: <span class="stringliteral">&#39;AgentOutput&#39;</span>, <span class="comment"># The &#39;tool&#39; name</span></div>
<div class="line">                <span class="stringliteral">&#39;args&#39;</span>: model_output.model_dump(mode=<span class="stringliteral">&#39;json&#39;</span>, exclude_unset=<span class="keyword">True</span>), <span class="comment"># The LLM&#39;s JSON output</span></div>
<div class="line">                <span class="stringliteral">&#39;id&#39;</span>: str(self.state.tool_id), <span class="comment"># Unique ID for the call</span></div>
<div class="line">                <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;tool_call&#39;</span>,</div>
<div class="line">            }</div>
<div class="line">        ]</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Create the AIMessage containing the tool calls</span></div>
<div class="line">        msg = AIMessage(</div>
<div class="line">            content=<span class="stringliteral">&#39;&#39;</span>, <span class="comment"># Content is often empty when using tool calls</span></div>
<div class="line">            tool_calls=tool_calls,</div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Add it to history</span></div>
<div class="line">        self._add_message_with_tokens(msg)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Add a corresponding empty ToolMessage (required by some models)</span></div>
<div class="line">        self.add_tool_message(content=<span class="stringliteral">&#39;&#39;</span>) <span class="comment"># Content depends on tool execution result</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>add_tool_message(self, content: str) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Add tool message to history (often confirms tool call receipt/result)&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># ToolMessage links back to the AIMessage&#39;s tool_call_id</span></div>
<div class="line">        msg = ToolMessage(content=content, tool_call_id=str(self.state.tool_id))</div>
<div class="line">        self.state.tool_id += 1 <span class="comment"># Increment for next potential tool call</span></div>
<div class="line">        self._add_message_with_tokens(msg)</div>
</div><!-- fragment --><p><b>4. Adding Messages and Counting Tokens (<code>_add_message_with_tokens</code>, <code>_count_tokens</code>)</b></p>
<p>This is the core function called by others to add any message to the history, ensuring token counts are tracked.</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: agent/message_manager/service.py (Simplified _add_message_with_tokens) ---</span></div>
<div class="line"><span class="comment"># ... imports ...</span></div>
<div class="line"><span class="keyword">from</span> langchain_core.messages <span class="keyword">import</span> BaseMessage</div>
<div class="line"><span class="keyword">from</span> browser_use.agent.message_manager.views <span class="keyword">import</span> MessageMetadata, ManagedMessage</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MessageManager:</div>
<div class="line">    <span class="comment"># ... (other methods) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>_add_message_with_tokens(self, message: BaseMessage, position: int | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Internal helper to add any message with its token count metadata.&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 1. Optionally filter sensitive data (replace actual data with placeholders)</span></div>
<div class="line">        <span class="comment"># if self.settings.sensitive_data:</span></div>
<div class="line">        <span class="comment">#    message = self._filter_sensitive_data(message) # Simplified</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 2. Count the tokens in the message</span></div>
<div class="line">        token_count = self._count_tokens(message)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 3. Create metadata object</span></div>
<div class="line">        metadata = MessageMetadata(tokens=token_count)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 4. Add the message and its metadata to the history list</span></div>
<div class="line">        <span class="comment">#    (self.state.history is a MessageHistory object)</span></div>
<div class="line">        self.state.history.add_message(message, metadata, position)</div>
<div class="line">        <span class="comment">#    Note: self.state.history.add_message also updates the total token count</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 5. Check if history exceeds token limit and truncate if needed</span></div>
<div class="line">        self.cut_messages() <span class="comment"># Check and potentially trim history</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>_count_tokens(self, message: BaseMessage) -&gt; int:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Estimate tokens in a message.&quot;&quot;&quot;</span></div>
<div class="line">        tokens = 0</div>
<div class="line">        <span class="keywordflow">if</span> isinstance(message.content, list): <span class="comment"># Multi-modal (text + image)</span></div>
<div class="line">            <span class="keywordflow">for</span> item <span class="keywordflow">in</span> message.content:</div>
<div class="line">                <span class="keywordflow">if</span> isinstance(item, dict) <span class="keywordflow">and</span> <span class="stringliteral">&#39;image_url&#39;</span> <span class="keywordflow">in</span> item:</div>
<div class="line">                    <span class="comment"># Add fixed cost for images</span></div>
<div class="line">                    tokens += self.settings.image_tokens</div>
<div class="line">                <span class="keywordflow">elif</span> isinstance(item, dict) <span class="keywordflow">and</span> <span class="stringliteral">&#39;text&#39;</span> <span class="keywordflow">in</span> item:</div>
<div class="line">                    <span class="comment"># Estimate tokens based on text length</span></div>
<div class="line">                    tokens += len(item[<span class="stringliteral">&#39;text&#39;</span>]) // self.settings.estimated_characters_per_token</div>
<div class="line">        <span class="keywordflow">elif</span> isinstance(message.content, str): <span class="comment"># Text message</span></div>
<div class="line">            text = message.content</div>
<div class="line">            <span class="keywordflow">if</span> hasattr(message, <span class="stringliteral">&#39;tool_calls&#39;</span>): <span class="comment"># Add tokens for tool call structure</span></div>
<div class="line">                 text += str(getattr(message, <span class="stringliteral">&#39;tool_calls&#39;</span>, <span class="stringliteral">&#39;&#39;</span>))</div>
<div class="line">            tokens += len(text) // self.settings.estimated_characters_per_token</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> tokens</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>cut_messages(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Trim messages if total tokens exceed the limit.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Calculate how many tokens we are over the limit</span></div>
<div class="line">        diff = self.state.history.current_tokens - self.settings.max_input_tokens</div>
<div class="line">        <span class="keywordflow">if</span> diff &lt;= 0:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="comment"># We are within limits</span></div>
<div class="line"> </div>
<div class="line">        logger.debug(f<span class="stringliteral">&quot;Token limit exceeded by {diff}. Trimming history.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Strategy:</span></div>
<div class="line">        <span class="comment"># 1. Try removing the image from the *last* (most recent) state message if present.</span></div>
<div class="line">        <span class="comment">#    (Code logic finds the last message, checks content list, removes image item, updates counts)</span></div>
<div class="line">        <span class="comment"># ... (Simplified - see full code for image removal logic) ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 2. If still over limit after image removal (or no image was present),</span></div>
<div class="line">        <span class="comment">#    trim text content from the *end* of the last state message.</span></div>
<div class="line">        <span class="comment">#    Calculate proportion to remove, shorten string, create new message.</span></div>
<div class="line">        <span class="comment"># ... (Simplified - see full code for text trimming logic) ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Ensure we don&#39;t get stuck if trimming isn&#39;t enough (raise error)</span></div>
<div class="line">        <span class="keywordflow">if</span> self.state.history.current_tokens &gt; self.settings.max_input_tokens:</div>
<div class="line">             <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Max token limit reached even after trimming.&quot;</span>)</div>
</div><!-- fragment --><p>This shows the basic mechanics of adding messages, calculating their approximate size, and applying strategies to keep the history within the LLM's context window limit.</p>
<h2><a class="anchor" id="autotoc_md948"></a>
Conclusion</h2>
<p>The <code>MessageManager</code> is the Agent's conversation secretary. It meticulously records the dialogue between the Agent (reporting browser state and action results) and the LLM (providing analysis and action plans), starting from the initial <code>System Prompt</code> and task definition.</p>
<p>Crucially, it formats these messages correctly, tracks the conversation's size using token counts, and implements strategies to keep the history concise enough for the LLM's limited context window. Without the <code>MessageManager</code>, the Agent would quickly lose track of the conversation, and the LLM wouldn't have the necessary context to guide the browser effectively.</p>
<p>Many of the objects managed and passed around by the <code>MessageManager</code>, like <code>BrowserState</code>, <code>ActionResult</code>, and <code>AgentOutput</code>, are defined as specific data structures. In the next chapter, we'll take a closer look at these important <b>Data Structures (Views)</b>.</p>
<p><a class="el" href="../../dc/db2/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_207__data__structures____views__.html">Next Chapter: Data Structures (Views)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
