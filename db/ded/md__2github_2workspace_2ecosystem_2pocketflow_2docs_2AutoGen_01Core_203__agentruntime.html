#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_agentruntime</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/ded/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_203__agentruntime.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_agentruntime</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md715"></a>
autotoc_md715</h2>
<p>layout: default title: "AgentRuntime" parent: "AutoGen Core" </p>
<h2><a class="anchor" id="autotoc_md716"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md717"></a>
Chapter 3: AgentRuntime - The Office Manager</h1>
<p>In <a class="el" href="../../d6/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_201__agent.html">Chapter 1: Agent</a>, we met the workers (<code>Agent</code>) of our system. In <a class="el" href="../../d8/ddc/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_202__messaging__system____topic______subscription__.html">Chapter 2: Messaging System</a>, we saw how they can communicate broadly using topics and subscriptions. But who hires these agents? Who actually delivers the messages, whether direct or published? And who keeps the whole system running smoothly?</p>
<p>This is where the <b><code>AgentRuntime</code></b> comes in. It's the central nervous system, the operating system, or perhaps the most fitting analogy: <b>the office manager</b> for all your agents.</p>
<h2><a class="anchor" id="autotoc_md718"></a>
Motivation: Why Do We Need an Office Manager?</h2>
<p>Imagine an office full of employees (Agents). You have researchers, writers, maybe coders.</p><ul>
<li>How does a new employee get hired and set up?</li>
<li>When one employee wants to send a memo directly to another, who makes sure it gets to the right desk?</li>
<li>When someone posts an announcement on the company bulletin board (publishes to a topic), who ensures everyone who signed up for that type of announcement sees it?</li>
<li>Who starts the workday and ensures everything keeps running?</li>
</ul>
<p>Without an office manager, it would be chaos! The <code>AgentRuntime</code> serves this crucial role in AutoGen Core. It handles:</p>
<ol type="1">
<li><b>Agent Creation:</b> "Onboarding" new agents when they are needed.</li>
<li><b>Message Routing:</b> Delivering direct messages (<code>send_message</code>) and published messages (<code>publish_message</code>).</li>
<li><b>Lifecycle Management:</b> Starting, running, and stopping the whole system.</li>
<li><b>State Management:</b> Keeping track of the overall system state (optional).</li>
</ol>
<h2><a class="anchor" id="autotoc_md719"></a>
Key Concepts: Understanding the Manager's Job</h2>
<p>Let's break down the main responsibilities of the <code>AgentRuntime</code>:</p>
<ol type="1">
<li><p class="startli"><b>Agent Instantiation (Hiring):</b></p><ul>
<li>You don't usually create agent objects directly (like <code>my_agent = ResearcherAgent()</code>). Why? Because the agent needs to know <em>about</em> the runtime (the office it works in) to send messages, publish announcements, etc.</li>
<li>Instead, you tell the <code>AgentRuntime</code>: "I need an agent of type 'researcher'. Here's a recipe (a **factory function**) for how to create one." This is done using <code>runtime.register_factory(...)</code>.</li>
<li>When a message needs to go to a 'researcher' agent with a specific key (e.g., 'researcher-01'), the runtime checks if it already exists. If not, it uses the registered factory function to create (instantiate) the agent.</li>
<li><b>Crucially</b>, while creating the agent, the runtime provides special context (<code>AgentInstantiationContext</code>) so the new agent automatically gets its unique <code>AgentId</code> and a reference to the <code>AgentRuntime</code> itself. This is like giving a new employee their ID badge and telling them who the office manager is.</li>
</ul>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md720"></a>
Simplified Concept - How a BaseAgent gets its ID and runtime access</h1>
<h1><a class="anchor" id="autotoc_md721"></a>
From: _agent_instantiation.py and _base_agent.py</h1>
<h1><a class="anchor" id="autotoc_md722"></a>
Inside the agent's <b>init</b> method (when inheriting from BaseAgent):</h1>
<p>class MyAgent(BaseAgent): def <b>init</b>(self, description: str): </p>
<h1><a class="anchor" id="autotoc_md723"></a>
This magic happens <em>because</em> the AgentRuntime is creating the agent</h1>
<h1><a class="anchor" id="autotoc_md724"></a>
inside a special context.</h1>
<p>self._runtime = AgentInstantiationContext.current_runtime() # Gets the manager self._id = AgentInstantiationContext.current_agent_id() # Gets its own ID self._description = description </p>
<h1><a class="anchor" id="autotoc_md725"></a>
... rest of initialization ...</h1>
<p>``` This ensures agents are properly integrated into the system from the moment they are created.</p>
<ol type="1">
<li><b>Message Delivery (Mail Room):</b><ul>
<li><b>Direct Send (<code>send_message</code>):</b> When an agent calls <code>await agent_context.send_message(message, recipient_id)</code>, it's actually telling the <code>AgentRuntime</code>, "Please deliver this `message` directly to the agent identified by `recipient_id`." The runtime finds the recipient agent (creating it if necessary) and calls its <code>on_message</code> method. It's like putting a specific name on an envelope and handing it to the mail room.</li>
<li><b>Publish (<code>publish_message</code>):</b> When an agent calls <code>await agent_context.publish_message(message, topic_id)</code>, it tells the runtime, "Post this `message` to the announcement board named `topic_id`." The runtime then checks its list of <b>subscriptions</b> (who signed up for which boards). For every matching subscription, it figures out the correct recipient agent(s) (based on the subscription rule) and delivers the message to their <code>on_message</code> method.</li>
</ul>
</li>
<li><b>Lifecycle Management (Opening/Closing the Office):</b><ul>
<li>The runtime needs to be started to begin processing messages. Typically, you call <code>runtime.start()</code>. This usually kicks off a background process or loop that watches for incoming messages.</li>
<li>When work is done, you need to stop the runtime gracefully. <code>runtime.stop_when_idle()</code> is common â€“ it waits until all messages currently in the queue have been processed, then stops. <code>runtime.stop()</code> stops more abruptly.</li>
</ul>
</li>
<li><b>State Management (Office Records):</b><ul>
<li>The runtime can save the state of <em>all</em> the agents it manages (<code>runtime.save_state()</code>) and load it back later (<code>runtime.load_state()</code>). This is useful for pausing and resuming complex multi-agent interactions. It can also save/load state for individual agents (<code>runtime.agent_save_state()</code> / <code>runtime.agent_load_state()</code>). We'll touch more on state in <a class="el" href="../../da/dd4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_207__memory.html">Chapter 7: Memory</a>.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md726"></a>
Use Case Example: Running Our Researcher and Writer</h2>
<p>Let's finally run the Researcher/Writer scenario from Chapters 1 and 2. We need the <code>AgentRuntime</code> to make it happen.</p>
<p><b>Goal:</b></p><ol type="1">
<li>Create a runtime.</li>
<li>Register factories for a 'researcher' and a 'writer' agent.</li>
<li>Tell the runtime that 'writer' agents are interested in "research.facts.available" topics (add subscription).</li>
<li>Start the runtime.</li>
<li>Send an initial <code>ResearchTopic</code> message to a 'researcher' agent.</li>
<li>Let the system run (Researcher publishes facts, Runtime delivers to Writer via subscription, Writer processes).</li>
<li>Stop the runtime when idle.</li>
</ol>
<p><b>Code Snippets (Simplified):</b></p>
<div class="fragment"><div class="line"><span class="comment"># 0. Imports and Message Definitions (from previous chapters)</span></div>
<div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</div>
<div class="line"><span class="keyword">from</span> autogen_core <span class="keyword">import</span> (</div>
<div class="line">    AgentId, BaseAgent, SingleThreadedAgentRuntime, TopicId,</div>
<div class="line">    MessageContext, TypeSubscription, AgentInstantiationContext</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@dataclass</span></div>
<div class="line"><span class="keyword">class </span>ResearchTopic: topic: str</div>
<div class="line"><span class="preprocessor">@dataclass</span></div>
<div class="line"><span class="keyword">class </span>ResearchFacts: topic: str; facts: list[str]</div>
</div><!-- fragment --><p> These are the messages our agents will exchange.</p>
<div class="fragment"><div class="line"><span class="comment"># 1. Define Agent Logic (using BaseAgent)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ResearcherAgent(BaseAgent):</div>
<div class="line">    <span class="keyword">async def </span>on_message_impl(self, message: ResearchTopic, ctx: MessageContext):</div>
<div class="line">        print(f<span class="stringliteral">&quot;Researcher ({self.id}) got topic: {message.topic}&quot;</span>)</div>
<div class="line">        facts = [f<span class="stringliteral">&quot;Fact 1 about {message.topic}&quot;</span>, f<span class="stringliteral">&quot;Fact 2&quot;</span>]</div>
<div class="line">        results_topic = TopicId(<span class="stringliteral">&quot;research.facts.available&quot;</span>, message.topic)</div>
<div class="line">        <span class="comment"># Use the runtime (via self.publish_message helper) to publish</span></div>
<div class="line">        await self.publish_message(</div>
<div class="line">            ResearchFacts(topic=message.topic, facts=facts), results_topic</div>
<div class="line">        )</div>
<div class="line">        print(f<span class="stringliteral">&quot;Researcher ({self.id}) published facts to {results_topic}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>WriterAgent(BaseAgent):</div>
<div class="line">    <span class="keyword">async def </span>on_message_impl(self, message: ResearchFacts, ctx: MessageContext):</div>
<div class="line">        print(f<span class="stringliteral">&quot;Writer ({self.id}) received facts via topic &#39;{ctx.topic_id}&#39;: {message.facts}&quot;</span>)</div>
<div class="line">        draft = f<span class="stringliteral">&quot;Draft for {message.topic}: {&#39;; &#39;.join(message.facts)}&quot;</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;Writer ({self.id}) created draft: &#39;{draft}&#39;&quot;</span>)</div>
<div class="line">        <span class="comment"># This agent doesn&#39;t send further messages in this example</span></div>
</div><!-- fragment --><p> Here we define the behavior of our two agent types, inheriting from <code>BaseAgent</code> which gives us <code>self.id</code>, <code>self.publish_message</code>, etc.</p>
<div class="fragment"><div class="line"><span class="comment"># 2. Define Agent Factories</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>researcher_factory():</div>
<div class="line">    <span class="comment"># Gets runtime/id via AgentInstantiationContext inside BaseAgent.__init__</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Runtime is creating a ResearcherAgent...&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> ResearcherAgent(description=<span class="stringliteral">&quot;I research topics.&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>writer_factory():</div>
<div class="line">    print(<span class="stringliteral">&quot;Runtime is creating a WriterAgent...&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> WriterAgent(description=<span class="stringliteral">&quot;I write drafts from facts.&quot;</span>)</div>
</div><!-- fragment --><p> These simple functions tell the runtime <em>how</em> to create instances of our agents when needed.</p>
<div class="fragment"><div class="line"><span class="comment"># 3. Setup and Run the Runtime</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span><a class="code hl_namespace" href="../../d2/dc1/namespacemain.html">main</a>():</div>
<div class="line">    <span class="comment"># Create the runtime (the office manager)</span></div>
<div class="line">    runtime = SingleThreadedAgentRuntime()</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Register the factories (tell the manager how to hire)</span></div>
<div class="line">    await runtime.register_factory(<span class="stringliteral">&quot;researcher&quot;</span>, researcher_factory)</div>
<div class="line">    await runtime.register_factory(<span class="stringliteral">&quot;writer&quot;</span>, writer_factory)</div>
<div class="line">    print(<span class="stringliteral">&quot;Registered agent factories.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Add the subscription (tell manager who listens to which announcements)</span></div>
<div class="line">    <span class="comment"># Rule: Messages to topics of type &quot;research.facts.available&quot;</span></div>
<div class="line">    <span class="comment"># should go to a &quot;writer&quot; agent whose key matches the topic source.</span></div>
<div class="line">    writer_sub = TypeSubscription(topic_type=<span class="stringliteral">&quot;research.facts.available&quot;</span>, agent_type=<span class="stringliteral">&quot;writer&quot;</span>)</div>
<div class="line">    await runtime.add_subscription(writer_sub)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Added subscription: {writer_sub.id}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Start the runtime (open the office)</span></div>
<div class="line">    runtime.start()</div>
<div class="line">    print(<span class="stringliteral">&quot;Runtime started.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Send the initial message to kick things off</span></div>
<div class="line">    research_task_topic = <span class="stringliteral">&quot;AutoGen Agents&quot;</span></div>
<div class="line">    researcher_instance_id = AgentId(type=<span class="stringliteral">&quot;researcher&quot;</span>, key=research_task_topic)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Sending initial topic &#39;{research_task_topic}&#39; to {researcher_instance_id}&quot;</span>)</div>
<div class="line">    await runtime.send_message(</div>
<div class="line">        message=ResearchTopic(topic=research_task_topic),</div>
<div class="line">        recipient=researcher_instance_id,</div>
<div class="line">    )</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Wait until all messages are processed (wait for work day to end)</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Waiting for runtime to become idle...&quot;</span>)</div>
<div class="line">    await runtime.stop_when_idle()</div>
<div class="line">    print(<span class="stringliteral">&quot;Runtime stopped.&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Run the main function</span></div>
<div class="line">asyncio.run(<a class="code hl_namespace" href="../../d2/dc1/namespacemain.html">main</a>())</div>
<div class="ttc" id="anamespacemain_html"><div class="ttname"><a href="../../d2/dc1/namespacemain.html">main</a></div><div class="ttdef"><b>Definition</b> <a href="../../dc/dba/main_8py_source.html#l00001">main.py:1</a></div></div>
</div><!-- fragment --><p> This script sets up the <code>SingleThreadedAgentRuntime</code>, registers the blueprints (factories) and communication rules (subscription), starts the process, and then shuts down cleanly.</p>
<p><b>Expected Output (Conceptual Order):</b></p>
<div class="fragment"><div class="line">Registered agent factories.</div>
<div class="line">Added subscription: type=research.facts.available=&gt;agent=writer</div>
<div class="line">Runtime started.</div>
<div class="line">Sending initial topic &#39;AutoGen Agents&#39; to researcher/AutoGen Agents</div>
<div class="line">Waiting for runtime to become idle...</div>
<div class="line">Runtime is creating a ResearcherAgent...  # First time researcher/AutoGen Agents is needed</div>
<div class="line">Researcher (researcher/AutoGen Agents) got topic: AutoGen Agents</div>
<div class="line">Researcher (researcher/AutoGen Agents) published facts to research.facts.available/AutoGen Agents</div>
<div class="line">Runtime is creating a WriterAgent...      # First time writer/AutoGen Agents is needed (due to subscription)</div>
<div class="line">Writer (writer/AutoGen Agents) received facts via topic &#39;research.facts.available/AutoGen Agents&#39;: [&#39;Fact 1 about AutoGen Agents&#39;, &#39;Fact 2&#39;]</div>
<div class="line">Writer (writer/AutoGen Agents) created draft: &#39;Draft for AutoGen Agents: Fact 1 about AutoGen Agents; Fact 2&#39;</div>
<div class="line">Runtime stopped.</div>
</div><!-- fragment --><p> You can see the runtime orchestrating the creation of agents and the flow of messages based on the initial request and the subscription rule.</p>
<h2><a class="anchor" id="autotoc_md727"></a>
Under the Hood: How the Manager Works</h2>
<p>Let's peek inside the <code>SingleThreadedAgentRuntime</code> (a common implementation provided by AutoGen Core) to understand the flow.</p>
<p><b>Core Idea:</b> It uses an internal queue (<code>_message_queue</code>) to hold incoming requests (<code>send_message</code>, <code>publish_message</code>). A background task continuously takes items from the queue and processes them one by one (though the <em>handling</em> of a message might involve <code>await</code> and allow other tasks to run).</p>
<p><b>1. Agent Creation (<code>_get_agent</code>, <code>_invoke_agent_factory</code>)</b></p>
<p>When the runtime needs an agent instance (e.g., to deliver a message) that hasn't been created yet:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Runtime as AgentRuntime</div>
<div class="line">    participant Factory as Agent Factory Func</div>
<div class="line">    participant AgentCtx as AgentInstantiationContext</div>
<div class="line">    participant Agent as New Agent Instance</div>
<div class="line"> </div>
<div class="line">    Runtime-&gt;&gt;Runtime: Check if agent instance exists (e.g., in `_instantiated_agents` dict)</div>
<div class="line">    alt Agent Not Found</div>
<div class="line">        Runtime-&gt;&gt;Runtime: Find registered factory for agent type</div>
<div class="line">        Runtime-&gt;&gt;AgentCtx: Set current runtime &amp; agent_id</div>
<div class="line">        activate AgentCtx</div>
<div class="line">        Runtime-&gt;&gt;Factory: Call factory function()</div>
<div class="line">        activate Factory</div>
<div class="line">        Factory-&gt;&gt;AgentCtx: (Inside Agent.__init__) Get current runtime</div>
<div class="line">        AgentCtx--&gt;&gt;Factory: Return runtime</div>
<div class="line">        Factory-&gt;&gt;AgentCtx: (Inside Agent.__init__) Get current agent_id</div>
<div class="line">        AgentCtx--&gt;&gt;Factory: Return agent_id</div>
<div class="line">        Factory--&gt;&gt;Runtime: Return new Agent instance</div>
<div class="line">        deactivate Factory</div>
<div class="line">        Runtime-&gt;&gt;AgentCtx: Clear context</div>
<div class="line">        deactivate AgentCtx</div>
<div class="line">        Runtime-&gt;&gt;Runtime: Store new agent instance</div>
<div class="line">    end</div>
<div class="line">    Runtime-&gt;&gt;Runtime: Return agent instance</div>
</div><!-- fragment --><ul>
<li>The runtime looks up the factory function registered for the required <code>AgentId.type</code>.</li>
<li>It uses <code>AgentInstantiationContext.populate_context</code> to temporarily store its own reference and the target <code>AgentId</code>.</li>
<li>It calls the factory function.</li>
<li>Inside the agent's <code>__init__</code> (usually via <code>BaseAgent</code>), <code>AgentInstantiationContext.current_runtime()</code> and <code>AgentInstantiationContext.current_agent_id()</code> are called to retrieve the context set by the runtime.</li>
<li>The factory returns the fully initialized agent instance.</li>
<li>The runtime stores this instance for future use.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># From: _agent_instantiation.py (Simplified)</span></div>
<div class="line"><span class="keyword">class </span>AgentInstantiationContext:</div>
<div class="line">    _CONTEXT_VAR = ContextVar(<span class="stringliteral">&quot;agent_context&quot;</span>) <span class="comment"># Stores (runtime, agent_id)</span></div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@classmethod</span></div>
<div class="line">    <span class="preprocessor">@contextmanager</span></div>
<div class="line">    <span class="keyword">def </span>populate_context(cls, ctx: tuple[AgentRuntime, AgentId]):</div>
<div class="line">        token = cls._CONTEXT_VAR.<a class="code hl_function" href="../../d7/da6/pybind__kv__service_8cpp.html#a26ae8807a2b3217bb2339bd18aaaa4e6">set</a>(ctx) <span class="comment"># Store context for this block</span></div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="keywordflow">yield</span> <span class="comment"># Code inside the &#39;with&#39; block runs here</span></div>
<div class="line">        <span class="keywordflow">finally</span>:</div>
<div class="line">            cls._CONTEXT_VAR.reset(token) <span class="comment"># Clean up context</span></div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@classmethod</span></div>
<div class="line">    <span class="keyword">def </span>current_runtime(cls) -&gt; AgentRuntime:</div>
<div class="line">        <span class="keywordflow">return</span> cls._CONTEXT_VAR.<a class="code hl_function" href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get</a>()[0] <span class="comment"># Retrieve runtime from context</span></div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@classmethod</span></div>
<div class="line">    <span class="keyword">def </span>current_agent_id(cls) -&gt; AgentId:</div>
<div class="line">        <span class="keywordflow">return</span> cls._CONTEXT_VAR.<a class="code hl_function" href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get</a>()[1] <span class="comment"># Retrieve agent_id from context</span></div>
<div class="ttc" id="apybind__kv__service_8cpp_html_a26ae8807a2b3217bb2339bd18aaaa4e6"><div class="ttname"><a href="../../d7/da6/pybind__kv__service_8cpp.html#a26ae8807a2b3217bb2339bd18aaaa4e6">set</a></div><div class="ttdeci">bool set(std::string key, std::string value, std::string config_path)</div><div class="ttdef"><b>Definition</b> <a href="../../d7/da6/pybind__kv__service_8cpp_source.html#l00051">pybind_kv_service.cpp:51</a></div></div>
<div class="ttc" id="apybind__kv__service_8cpp_html_abe6524afb3a69dc9a4c314e11f96f29f"><div class="ttname"><a href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get</a></div><div class="ttdeci">std::string get(std::string key, std::string config_path)</div><div class="ttdef"><b>Definition</b> <a href="../../d7/da6/pybind__kv__service_8cpp_source.html#l00039">pybind_kv_service.cpp:39</a></div></div>
</div><!-- fragment --><p> This context manager pattern ensures the correct runtime and ID are available <em>only</em> during the agent's creation by the runtime.</p>
<p><b>2. Direct Messaging (<code>send_message</code> -&gt; <code>_process_send</code>)</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Sender as Sending Agent/Code</div>
<div class="line">    participant Runtime as AgentRuntime</div>
<div class="line">    participant Queue as Internal Queue</div>
<div class="line">    participant Recipient as Recipient Agent</div>
<div class="line"> </div>
<div class="line">    Sender-&gt;&gt;+Runtime: send_message(msg, recipient_id, ...)</div>
<div class="line">    Runtime-&gt;&gt;Runtime: Create Future (for response)</div>
<div class="line">    Runtime-&gt;&gt;+Queue: Put SendMessageEnvelope(msg, recipient_id, future)</div>
<div class="line">    Runtime--&gt;&gt;-Sender: Return awaitable Future</div>
<div class="line">    Note over Queue, Runtime: Background task picks up envelope</div>
<div class="line">    Runtime-&gt;&gt;Runtime: _process_send(envelope)</div>
<div class="line">    Runtime-&gt;&gt;+Recipient: _get_agent(recipient_id) (creates if needed)</div>
<div class="line">    Recipient--&gt;&gt;-Runtime: Return Agent instance</div>
<div class="line">    Runtime-&gt;&gt;+Recipient: on_message(msg, context)</div>
<div class="line">    Recipient-&gt;&gt;Recipient: Process message...</div>
<div class="line">    Recipient--&gt;&gt;-Runtime: Return response value</div>
<div class="line">    Runtime-&gt;&gt;Runtime: Set Future result with response value</div>
</div><!-- fragment --><ul>
<li><code>send_message</code> creates a <code>Future</code> object (a placeholder for the eventual result) and wraps the message details in a <code>SendMessageEnvelope</code>.</li>
<li>This envelope is put onto the internal <code>_message_queue</code>.</li>
<li>The background task picks up the envelope.</li>
<li><code>_process_send</code> gets the recipient agent instance (using <code>_get_agent</code>).</li>
<li>It calls the recipient's <code>on_message</code> method.</li>
<li>When <code>on_message</code> returns a result, <code>_process_send</code> sets the result on the <code>Future</code> object, which makes the original <code>await runtime.send_message(...)</code> call return the value.</li>
</ul>
<p><b>3. Publish/Subscribe (<code>publish_message</code> -&gt; <code>_process_publish</code>)</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Publisher as Publishing Agent/Code</div>
<div class="line">    participant Runtime as AgentRuntime</div>
<div class="line">    participant Queue as Internal Queue</div>
<div class="line">    participant SubManager as SubscriptionManager</div>
<div class="line">    participant Subscriber as Subscribed Agent</div>
<div class="line"> </div>
<div class="line">    Publisher-&gt;&gt;+Runtime: publish_message(msg, topic_id, ...)</div>
<div class="line">    Runtime-&gt;&gt;+Queue: Put PublishMessageEnvelope(msg, topic_id)</div>
<div class="line">    Runtime--&gt;&gt;-Publisher: Return (None for publish)</div>
<div class="line">    Note over Queue, Runtime: Background task picks up envelope</div>
<div class="line">    Runtime-&gt;&gt;Runtime: _process_publish(envelope)</div>
<div class="line">    Runtime-&gt;&gt;+SubManager: get_subscribed_recipients(topic_id)</div>
<div class="line">    SubManager-&gt;&gt;SubManager: Find matching subscriptions</div>
<div class="line">    SubManager-&gt;&gt;SubManager: Map subscriptions to AgentIds</div>
<div class="line">    SubManager--&gt;&gt;-Runtime: Return list of recipient AgentIds</div>
<div class="line">    loop For each recipient AgentId</div>
<div class="line">        Runtime-&gt;&gt;+Subscriber: _get_agent(recipient_id) (creates if needed)</div>
<div class="line">        Subscriber--&gt;&gt;-Runtime: Return Agent instance</div>
<div class="line">        Runtime-&gt;&gt;+Subscriber: on_message(msg, context with topic_id)</div>
<div class="line">        Subscriber-&gt;&gt;Subscriber: Process message...</div>
<div class="line">        Subscriber--&gt;&gt;-Runtime: Return (usually None for publish)</div>
<div class="line">    end</div>
</div><!-- fragment --><ul>
<li><code>publish_message</code> wraps the message in a <code>PublishMessageEnvelope</code> and puts it on the queue.</li>
<li>The background task picks it up.</li>
<li><code>_process_publish</code> asks the <code>SubscriptionManager</code> (<code>_subscription_manager</code>) for all <code>AgentId</code>s that are subscribed to the given <code>topic_id</code>.</li>
<li>The <code>SubscriptionManager</code> checks its registered <code>Subscription</code> objects (<code>_subscriptions</code> list, added via <code>add_subscription</code>). For each <code>Subscription</code> where <code>is_match(topic_id)</code> is true, it calls <code>map_to_agent(topic_id)</code> to get the target <code>AgentId</code>.</li>
<li>For each resulting <code>AgentId</code>, the runtime gets the agent instance and calls its <code>on_message</code> method, providing the <code>topic_id</code> in the <code>MessageContext</code>.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># From: _runtime_impl_helpers.py (SubscriptionManager simplified)</span></div>
<div class="line"><span class="keyword">class </span>SubscriptionManager:</div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        self._subscriptions: List[Subscription] = []</div>
<div class="line">        <span class="comment"># Optimization cache can be added here</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>add_subscription(self, subscription: Subscription):</div>
<div class="line">        self._subscriptions.append(subscription)</div>
<div class="line">        <span class="comment"># Clear cache if any</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>get_subscribed_recipients(self, topic: TopicId) -&gt; List[AgentId]:</div>
<div class="line">        recipients = []</div>
<div class="line">        <span class="keywordflow">for</span> sub <span class="keywordflow">in</span> self._subscriptions:</div>
<div class="line">            <span class="keywordflow">if</span> sub.is_match(topic):</div>
<div class="line">                recipients.append(sub.map_to_agent(topic))</div>
<div class="line">        <span class="keywordflow">return</span> recipients</div>
</div><!-- fragment --><p> The <code>SubscriptionManager</code> simply iterates through registered subscriptions to find matches when a message is published.</p>
<h2><a class="anchor" id="autotoc_md728"></a>
Next Steps</h2>
<p>You now understand the <code>AgentRuntime</code> - the essential coordinator that brings Agents to life, manages their communication, and runs the entire show. It handles agent creation via factories, routes direct and published messages, and manages the system's lifecycle.</p>
<p>With the core concepts of <code>Agent</code>, <code>Messaging</code>, and <code>AgentRuntime</code> covered, we can start looking at more specialized building blocks. Next, we'll explore how agents can use external capabilities:</p>
<ul>
<li><a class="el" href="../../d8/d8c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_204__tool.html">Chapter 4: Tool</a>: How to give agents tools (like functions or APIs) to perform specific actions beyond just processing messages.</li>
</ul>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
