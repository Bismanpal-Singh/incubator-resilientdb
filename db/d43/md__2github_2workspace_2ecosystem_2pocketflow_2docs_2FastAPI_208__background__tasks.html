#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 08_background_tasks</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/d43/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_208__background__tasks.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">08_background_tasks</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1826"></a>
autotoc_md1826</h2>
<p>layout: default title: "Background Tasks" parent: "FastAPI" </p>
<h2><a class="anchor" id="autotoc_md1827"></a>
nav_order: 8</h2>
<h1><a class="anchor" id="autotoc_md1828"></a>
Chapter 8: Background Tasks</h1>
<p>Welcome back! In <a class="el" href="../../d9/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_207__security__utilities.html">Chapter 7: Security Utilities</a>, we learned how to protect our API endpoints using FastAPI's security features. Now, let's explore how to perform actions <em>after</em> we've already sent a response back to the user.</p>
<h2><a class="anchor" id="autotoc_md1829"></a>
What Problem Does This Solve?</h2>
<p>Imagine a user registers on your website. When they submit their registration form, your API endpoint needs to:</p>
<ol type="1">
<li>Create the new user account in the database.</li>
<li>Send a welcome email to the user.</li>
<li>Send a notification to an admin.</li>
<li>Return a "Success!" message to the user.</li>
</ol>
<p>Creating the user (step 1) is quick and essential before confirming success. But sending emails or notifications (steps 2 and 3) can sometimes be slow. Should the user have to wait several extra seconds just for the emails to be sent before they see the "Success!" message? Probably not! It would be much better if the API could send the "Success!" response immediately after creating the user, and then handle sending the emails <em>in the background</em>.</p>
<p>This is exactly what <b>Background Tasks</b> allow you to do in FastAPI. They let you define operations that need to happen <em>after</em> the response has been sent to the client, ensuring your users get a fast response time for the main action.</p>
<p><b>Analogy:</b> Think of your path operation function as having a conversation with the user (sending the response). Once the main conversation is finished, you might hand off a follow-up task (like mailing a letter) to an assistant to complete later, so you don't keep the user waiting. Background Tasks are like that helpful assistant.</p>
<h2><a class="anchor" id="autotoc_md1830"></a>
Key Concepts</h2>
<ol type="1">
<li><b><code>BackgroundTasks</code> Object:</b> A special object provided by FastAPI that holds a list of tasks to be run later.</li>
<li><b>Dependency Injection:</b> You get access to this object by declaring it as a parameter in your path operation function, just like we learned in <a class="el" href="../../dd/dd7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_205__dependency__injection.html">Chapter 5: Dependency Injection</a>. Example: <code>def my_endpoint(background_tasks: BackgroundTasks): ...</code>.</li>
<li><b><code>add_task()</code> Method:</b> You use the <code>add_task()</code> method on the <code>BackgroundTasks</code> object to schedule a function to run in the background. You provide the function itself and any arguments it needs. Example: <code>background_tasks.add_task(send_welcome_email, user.email, user.name)</code>.</li>
<li><b>Post-Response Execution:</b> FastAPI (specifically, the underlying Starlette framework) ensures that all functions added via <code>add_task()</code> are executed <em>only after</em> the response has been successfully sent back to the client.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1831"></a>
Using Background Tasks</h2>
<p>Let's create a simple example. Imagine we want to write a message to a log file <em>after</em> sending a notification response to the user.</p>
<p><b>Step 1: Import <code>BackgroundTasks</code></b></p>
<p>First, import the necessary class from <code>fastapi</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># main.py (or your router file)</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> BackgroundTasks, FastAPI</div>
<div class="line"> </div>
<div class="line">app = FastAPI()</div>
</div><!-- fragment --><p><b>Step 2: Define the Task Function</b></p>
<p>This is the function you want to run in the background. It can be a regular <code>def</code> function or an <code>async def</code> function.</p>
<div class="fragment"><div class="line"><span class="comment"># A function to simulate writing to a log</span></div>
<div class="line"><span class="comment"># In a real app, this might send an email, process data, etc.</span></div>
<div class="line"><span class="keyword">def </span>write_log(message: str):</div>
<div class="line">    <span class="comment"># Simulate writing to a file</span></div>
<div class="line">    <span class="keyword">with</span> open(<span class="stringliteral">&quot;log.txt&quot;</span>, mode=<span class="stringliteral">&quot;a&quot;</span>) <span class="keyword">as</span> log_file:</div>
<div class="line">        log_file.write(message + <span class="stringliteral">&quot;\n&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Log written: {message}&quot;</span>) <span class="comment"># Also print to console for demo</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li>This is a simple Python function <code>write_log</code> that takes a <code>message</code> string.</li>
<li>It opens a file named <code>log.txt</code> in "append" mode (<code>a</code>) and writes the message to it.</li>
<li>We also print to the console so we can easily see when it runs during testing.</li>
</ul>
<p><b>Step 3: Inject <code>BackgroundTasks</code> and use <code>add_task</code></b></p>
<p>Now, modify your path operation function to accept <code>BackgroundTasks</code> as a parameter and use its <code>add_task</code> method.</p>
<div class="fragment"><div class="line"><span class="preprocessor">@app.post(&quot;/send-notification/{email}&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>send_notification(</div>
<div class="line">    email: str,</div>
<div class="line">    background_tasks: BackgroundTasks <span class="comment"># Inject BackgroundTasks</span></div>
<div class="line">):</div>
<div class="line">    <span class="comment"># The message we want to log in the background</span></div>
<div class="line">    log_message = f<span class="stringliteral">&quot;Notification sent to: {email}&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Add the task to run after the response</span></div>
<div class="line">    background_tasks.add_task(write_log, log_message) <span class="comment"># Schedule write_log</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Return the response immediately</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;message&quot;</span>: <span class="stringliteral">&quot;Notification sent successfully!&quot;</span>}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>background_tasks: BackgroundTasks</code>: We declare a parameter named <code>background_tasks</code> with the type hint <code>BackgroundTasks</code>. FastAPI's dependency injection system will automatically create and provide a <code>BackgroundTasks</code> object here.</li>
<li><code>background_tasks.add_task(write_log, log_message)</code>: This is the crucial line.<ul>
<li>We call the <code>add_task</code> method on the injected <code>background_tasks</code> object.</li>
<li>The first argument is the function we want to run in the background (<code>write_log</code>).</li>
<li>The subsequent arguments (<code>log_message</code>) are the arguments that will be passed to our <code>write_log</code> function when it's eventually called.</li>
</ul>
</li>
<li><code>return {"message": "Notification sent successfully!"}</code>: The function returns its response <em>without</em> waiting for <code>write_log</code> to finish.</li>
</ul>
<p><b>How it Behaves:</b></p>
<ol type="1">
<li><b>Run the App:</b> <code>uvicorn main:app --reload</code></li>
<li><b>Send a Request:</b> Use <code>curl</code> or the <code>/docs</code> UI to send a <code>POST</code> request to <code>/send-notification/test@example.com</code>. <code>bash curl -X POST <a href="http://127.0.0.1:8000/send-notification/test">http://127.0.0.1:8000/send-notification/test</a>@example.com </code></li>
<li><b>Immediate Response:</b> You will immediately receive the JSON response: <code>json {"message":"Notification sent successfully!"} </code></li>
<li><b>Background Execution:</b> <em>After</em> the response above has been sent, look at your Uvicorn console output. You will see the message: <code> Log written: Notification sent to: test@example.com </code> Also, check your project directory. A file named <code>log.txt</code> will have been created (or appended to) with the content: <code> Notification sent to: test@example.com </code></li>
</ol>
<p>This demonstrates that the <code>write_log</code> function ran <em>after</em> the client received the success message, preventing any delay for the user.</p>
<h2><a class="anchor" id="autotoc_md1832"></a>
How it Works Under the Hood (Simplified)</h2>
<p>What's happening behind the scenes when you use <code>BackgroundTasks</code>?</p>
<ol type="1">
<li><b>Request In:</b> A request arrives at your FastAPI application (e.g., <code>POST /send-notification/test@example.com</code>).</li>
<li><b>Dependency Injection:</b> FastAPI processes the request, routes it to <code>send_notification</code>, and prepares its dependencies. It sees the <code>background_tasks: BackgroundTasks</code> parameter and creates an empty <code>BackgroundTasks</code> object instance.</li>
<li><b>Path Function Runs:</b> Your <code>send_notification</code> function is called with the <code>email</code> and the empty <code>background_tasks</code> object.</li>
<li><b><code>add_task</code> Called:</b> Your code calls <code>background_tasks.add_task(write_log, log_message)</code>. This doesn't <em>run</em> <code>write_log</code> yet; it just adds the function (<code>write_log</code>) and its arguments (<code>log_message</code>) to an internal list within the <code>background_tasks</code> object.</li>
<li><b>Response Returned:</b> Your path function finishes and returns the dictionary <code>{"message": "Notification sent successfully!"}</code>.</li>
<li><b>Middleware Magic (Starlette):</b> FastAPI (using Starlette middleware) takes the response object <em>and</em> the <code>background_tasks</code> object (which now contains the scheduled task).</li>
<li><b>Response Sent:</b> The middleware sends the HTTP response (<code>200 OK</code> with the JSON body) back to the client over the network.</li>
<li><b>Tasks Executed:</b> <em>After</em> the response has been sent, the Starlette middleware iterates through the tasks stored in the <code>background_tasks</code> object. For each task, it calls the stored function (<code>write_log</code>) with the stored arguments (<code>log_message</code>). This happens in the server's process, separate from the initial request-response flow.</li>
</ol>
<p>Here's a simplified sequence diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client</div>
<div class="line">    participant FastAPIApp as FastAPI App (via Starlette)</div>
<div class="line">    participant PathFunc as send_notification</div>
<div class="line">    participant BGTasks as BackgroundTasks Object</div>
<div class="line">    participant BGExecutor as Background Task Executor (Starlette)</div>
<div class="line">    participant TaskFunc as write_log</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;+FastAPIApp: POST /send-notification/test@example.com</div>
<div class="line">    FastAPIApp-&gt;&gt;FastAPIApp: Route to send_notification</div>
<div class="line">    FastAPIApp-&gt;&gt;+PathFunc: Call send_notification(email=&quot;...&quot;, background_tasks=BGTasks)</div>
<div class="line">    PathFunc-&gt;&gt;+BGTasks: background_tasks.add_task(write_log, &quot;...&quot;)</div>
<div class="line">    BGTasks--&gt;&gt;-PathFunc: Task added to internal list</div>
<div class="line">    PathFunc--&gt;&gt;-FastAPIApp: Return response {&quot;message&quot;: &quot;...&quot;}</div>
<div class="line">    Note over FastAPIApp: FastAPI/Starlette prepares to send response AND notes background tasks</div>
<div class="line">    FastAPIApp--&gt;&gt;-Client: Send HTTP 200 OK Response</div>
<div class="line">    Note over FastAPIApp: Response sent, now run background tasks</div>
<div class="line">    FastAPIApp-&gt;&gt;+BGExecutor: Execute tasks from BGTasks object</div>
<div class="line">    BGExecutor-&gt;&gt;+TaskFunc: Call write_log(&quot;...&quot;)</div>
<div class="line">    TaskFunc-&gt;&gt;TaskFunc: Write to log.txt</div>
<div class="line">    TaskFunc--&gt;&gt;-BGExecutor: Task finished</div>
<div class="line">    BGExecutor--&gt;&gt;-FastAPIApp: All tasks finished</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1833"></a>
Code Connections</h3>
<ul>
<li><b><code>fastapi.BackgroundTasks</code></b>: This class (in <code>fastapi/background.py</code>) inherits directly from <code>starlette.background.BackgroundTasks</code>. It mostly just provides type hints and documentation specific to FastAPI.</li>
<li><b><code>BackgroundTasks.add_task</code></b>: This method simply calls the <code>add_task</code> method of the parent Starlette class.</li>
<li><b><code>starlette.background.BackgroundTasks</code></b>: This is where the core logic resides (in the <code>starlette</code> library, which FastAPI builds upon). It stores tasks as tuples of <code>(callable, args, kwargs)</code>.</li>
<li><b><code>starlette.middleware.exceptions.ExceptionMiddleware</code> (and potentially others):</b> Starlette's middleware stack, particularly around exception handling and response sending, is responsible for checking if a <code>BackgroundTasks</code> object exists on the response object after the main endpoint code has run. If tasks exist, the middleware ensures they are executed <em>after</em> the response is sent using <code>anyio.create_task_group().start_soon()</code> or similar mechanisms. See <code>starlette.responses.Response.__call__</code>.</li>
</ul>
<p>Essentially, FastAPI provides a convenient way (via dependency injection) to access Starlette's background task functionality.</p>
<h2><a class="anchor" id="autotoc_md1834"></a>
Conclusion</h2>
<p>You've learned how to use FastAPI's <code>BackgroundTasks</code> to perform operations <em>after</em> sending a response to the client!</p>
<ul>
<li>You understand that this is useful for <b>slow or non-critical tasks</b> (like sending emails or notifications) that shouldn't delay the user's primary action.</li>
<li>You learned to inject the <b><code>BackgroundTasks</code></b> object as a dependency.</li>
<li>You saw how to schedule functions using the <b><code>add_task(func, *args, **kwargs)</code></b> method.</li>
<li>You understand that these tasks run <b>after the response</b> has been delivered.</li>
</ul>
<p>This feature helps you build more responsive APIs by deferring non-essential work.</p>
<p>This chapter concludes our core introduction to FastAPI! We've covered setting up applications, defining routes, handling parameters and data validation, using dependency injection, handling errors, securing endpoints, and now running background tasks. With these building blocks, you can create powerful and efficient web APIs.</p>
<p>Where do you go from here? You can dive deeper into the official FastAPI documentation to explore advanced topics like WebSockets, middleware, bigger application structures, testing, and deployment. Happy coding!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
