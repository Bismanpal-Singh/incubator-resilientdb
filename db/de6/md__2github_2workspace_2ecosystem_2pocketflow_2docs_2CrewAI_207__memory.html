#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 07_memory</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/de6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_207__memory.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">07_memory</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1556"></a>
autotoc_md1556</h2>
<p>layout: default title: "Memory" parent: "CrewAI" </p>
<h2><a class="anchor" id="autotoc_md1557"></a>
nav_order: 7</h2>
<h1><a class="anchor" id="autotoc_md1558"></a>
Chapter 7: Memory - Giving Your Crew Recall</h1>
<p>In the <a class="el" href="../../da/d0f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_206__llm.html">previous chapter</a>, we looked at the Large Language Model (<a class="el" href="../../da/d0f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_206__llm.html">LLM</a>) – the "brain" that allows each <a class="el" href="../../d2/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_202__agent.html">Agent</a> to understand, reason, and generate text. Now we have agents that can think, perform <a class="el" href="../../d1/dae/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_203__task.html">Task</a>s using <a class="el" href="../../d0/dbf/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_204__tool.html">Tool</a>s, and follow a <a class="el" href="../../de/d7d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_205__process.html">Process</a>.</p>
<p>But imagine a team working on a complex project over several days. What if every morning, they completely forgot everything they discussed and learned the previous day? They'd waste a lot of time repeating work and asking the same questions. By default, AI agents often behave like this – they only remember the immediate conversation.</p>
<p>How can we give our CrewAI team the ability to remember past information? That's where <b>Memory</b> comes in!</p>
<h2><a class="anchor" id="autotoc_md1559"></a>
Why Do We Need Memory?</h2>
<p>AI Agents, especially when working together in a <a class="el" href="../../d4/d90/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_201__crew.html">Crew</a>, often need to build upon previous interactions or knowledge gained during their work. Without memory:</p>
<ul>
<li>An agent might ask for the same information multiple times.</li>
<li>Context from an earlier task might be lost by the time a later task runs.</li>
<li>The crew can't easily learn from past experiences across different projects or runs.</li>
<li>Tracking specific details about key people, places, or concepts mentioned during the process becomes difficult.</li>
</ul>
<p><b>Problem Solved:</b> Memory provides <a class="el" href="../../d2/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_202__agent.html">Agent</a>s and the <a class="el" href="../../d4/d90/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_201__crew.html">Crew</a> with the ability to store and recall past interactions, information, and insights. It's like giving your AI team shared notes, a collective memory, or institutional knowledge.</p>
<h2><a class="anchor" id="autotoc_md1560"></a>
What is Memory in CrewAI?</h2>
<p>Think of Memory as the <b>storage system</b> for your Crew's experiences and knowledge. It allows the Crew to persist information beyond a single interaction or task execution. CrewAI implements different kinds of memory to handle different needs:</p>
<ol type="1">
<li><b><code>ShortTermMemory</code></b>:<ul>
<li><b>Analogy:</b> Like your computer's RAM or a person's short-term working memory.</li>
<li><b>Purpose:</b> Holds immediate context and information relevant <em>within the current run</em> of the Crew. What happened in the previous task? What was just discussed?</li>
<li><b>How it helps:</b> Ensures that the output of one task is available and easily accessible as context for the next task within the same <code>kickoff()</code> execution. It helps maintain the flow of conversation and information <em>during</em> a single job.</li>
</ul>
</li>
<li><b><code>LongTermMemory</code></b>:<ul>
<li><b>Analogy:</b> Like a team's documented "lessons learned" database or a long-term knowledge base.</li>
<li><b>Purpose:</b> Stores insights, evaluations, and key takeaways <em>across multiple runs</em> of the Crew. Did a similar task succeed or fail in the past? What strategies worked well?</li>
<li><b>How it helps:</b> Allows the Crew to improve over time by recalling past performance on similar tasks. (Note: Effective use often involves evaluating task outcomes, which can be an advanced topic).</li>
</ul>
</li>
<li><b><code>EntityMemory</code></b>:<ul>
<li><b>Analogy:</b> Like a CRM (Customer Relationship Management) system, a character sheet in a game, or index cards about important topics.</li>
<li><b>Purpose:</b> Tracks specific entities (like people, companies, projects, concepts) mentioned during the Crew's execution and stores details and relationships about them. Who is "Dr. Evans"? What is "Project Phoenix"?</li>
<li><b>How it helps:</b> Maintains consistency and detailed knowledge about key subjects, preventing the Crew from forgetting important details about who or what it's dealing with.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md1561"></a>
How Does Memory Help?</h2>
<p>Using memory makes your Crew more effective:</p>
<ul>
<li><b>Better Context:</b> Agents have access to relevant past information, leading to more informed decisions and responses.</li>
<li><b>Efficiency:</b> Avoids redundant questions and re-work by recalling previously established facts or results.</li>
<li><b>Learning (LTM):</b> Enables the Crew to get better over time based on past performance.</li>
<li><b>Consistency (Entity):</b> Keeps track of important details about recurring topics or entities.</li>
<li><b>Shared Understanding:</b> Helps create a common ground of knowledge for all agents in the Crew.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1562"></a>
Using Memory in Your Crew</h2>
<p>The simplest way to start using memory is by enabling it when you define your <code>Crew</code>. Setting <code>memory=True</code> activates the core memory components (ShortTerm and Entity Memory) for context building within a run.</p>
<p>Let's add memory to our trip planning <code>Crew</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># Assuming &#39;researcher&#39; and &#39;planner&#39; agents are defined (Chapter 2)</span></div>
<div class="line"><span class="comment"># Assuming &#39;task1&#39; and &#39;task2&#39; are defined (Chapter 3)</span></div>
<div class="line"><span class="comment"># Assuming an LLM is configured (Chapter 6)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> crewai <span class="keyword">import</span> Crew, Process</div>
<div class="line"> </div>
<div class="line"><span class="comment"># researcher = Agent(...)</span></div>
<div class="line"><span class="comment"># planner = Agent(...)</span></div>
<div class="line"><span class="comment"># task1 = Task(...)</span></div>
<div class="line"><span class="comment"># task2 = Task(...)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the crew WITH memory enabled</span></div>
<div class="line">trip_crew_with_memory = Crew(</div>
<div class="line">  agents=[researcher, planner],</div>
<div class="line">  tasks=[task1, task2],</div>
<div class="line">  process=Process.sequential,</div>
<div class="line">  memory=<span class="keyword">True</span>  <span class="comment"># &lt;-- Enable memory features!</span></div>
<div class="line">  <span class="comment"># verbose=2</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Start the work. Agents will now leverage memory.</span></div>
<div class="line"><span class="comment"># result = trip_crew_with_memory.kickoff()</span></div>
<div class="line"><span class="comment"># print(result)</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>We simply add the <code>memory=True</code> parameter when creating the <code>Crew</code>.</li>
<li><b>What does this do?</b> Behind the scenes, CrewAI initializes <code>ShortTermMemory</code> and <code>EntityMemory</code> for this crew.</li>
<li><b>How is it used?</b><ul>
<li><b>ShortTermMemory:</b> As tasks complete within this <code>kickoff()</code> run, their outputs and key interactions can be stored. When the next task starts, CrewAI automatically queries this memory for relevant recent context to add to the prompt for the next agent. This makes the context flow smoother than just passing the raw output of the previous task.</li>
<li><b>EntityMemory:</b> As agents discuss entities (e.g., "Lisbon," "May birthday trip"), the memory tries to capture details about them. If "Lisbon" is mentioned again later, the memory can provide the stored details ("Coastal city, known for trams and Fado music...") as context.</li>
</ul>
</li>
<li><b>LongTermMemory:</b> While <code>memory=True</code> sets up the <em>potential</em> for LTM, actively using it to learn across multiple runs often requires additional steps like task evaluation or explicit saving mechanisms, which are more advanced topics beyond this basic introduction. For now, focus on the benefits of STM and Entity Memory for within-run context.</li>
</ul>
<p>By just adding <code>memory=True</code>, your agents automatically get better at remembering what's going on <em>within the current job</em>.</p>
<h2><a class="anchor" id="autotoc_md1563"></a>
How Memory Works Internally (Simplified)</h2>
<p>So, what happens "under the hood" when <code>memory=True</code> and an agent starts a task?</p>
<ol type="1">
<li><b>Task Execution Start:</b> The <a class="el" href="../../d4/d90/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_201__crew.html">Crew</a> assigns a <a class="el" href="../../d1/dae/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_203__task.html">Task</a> to an <a class="el" href="../../d2/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_202__agent.html">Agent</a>.</li>
<li><b>Context Gathering:</b> Before calling the <a class="el" href="../../da/d0f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_206__llm.html">LLM</a>, the Crew interacts with its <b>Memory Module</b> (specifically, the <code>ContextualMemory</code> orchestrator). It asks, "What relevant memories do we have for this task, considering the description and any immediate context?"</li>
<li><b>Memory Module Queries:</b> The <code>ContextualMemory</code> then queries the different active memory types:<ul>
<li>It asks <code>ShortTermMemory</code>: "Show me recent interactions or results related to this query." (Uses RAG/vector search on recent data).</li>
<li>It asks <code>EntityMemory</code>: "Tell me about entities mentioned in this query." (Uses RAG/vector search on stored entity data).</li>
<li><em>If LTM were being actively queried (less common automatically):</em> "Any long-term insights related to this type of task?" (Usually queries a database like SQLite).</li>
</ul>
</li>
<li><b>Context Consolidation:</b> The Memory Module gathers the relevant snippets from each memory type.</li>
<li><b>Prompt Augmentation:</b> This retrieved memory context is combined with the original task description, expected output, and any direct context (like the previous task's raw output).</li>
<li><b>LLM Call:</b> This augmented, richer prompt is sent to the agent's <a class="el" href="../../da/d0f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_206__llm.html">LLM</a>.</li>
<li><b>Agent Response:</b> The agent generates its response, now informed by the retrieved memories.</li>
<li><b>Memory Update:</b> As the task completes, its key interactions and outputs are processed and potentially saved back into ShortTermMemory and EntityMemory for future use within this run.</li>
</ol>
<p>Let's visualize this context-building flow:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant C as Crew</div>
<div class="line">    participant A as Agent</div>
<div class="line">    participant CtxMem as ContextualMemory</div>
<div class="line">    participant STM as ShortTermMemory</div>
<div class="line">    participant EM as EntityMemory</div>
<div class="line">    participant LLM as Agent&#39;s LLM</div>
<div class="line"> </div>
<div class="line">    C-&gt;&gt;A: Execute Task(description, current_context)</div>
<div class="line">    Note over A: Need to build full prompt context.</div>
<div class="line">    A-&gt;&gt;CtxMem: Get memory context for task query</div>
<div class="line">    CtxMem-&gt;&gt;STM: Search(task_query)</div>
<div class="line">    STM--&gt;&gt;CtxMem: Recent memories (e.g., &quot;Found Lisbon earlier&quot;)</div>
<div class="line">    CtxMem-&gt;&gt;EM: Search(task_query)</div>
<div class="line">    EM--&gt;&gt;CtxMem: Entity details (e.g., &quot;Lisbon: Capital of Portugal&quot;)</div>
<div class="line">    CtxMem--&gt;&gt;A: Combined Memory Snippets</div>
<div class="line">    A-&gt;&gt;A: Assemble Final Prompt (Task Desc + Current Context + Memory Snippets)</div>
<div class="line">    A-&gt;&gt;LLM: Process Augmented Prompt</div>
<div class="line">    LLM--&gt;&gt;A: Generate Response</div>
<div class="line">    A--&gt;&gt;C: Task Result</div>
<div class="line">    Note over C: Crew updates memories (STM, EM) with task results.</div>
</div><!-- fragment --><p><b>Diving into the Code (High Level)</b></p>
<ul>
<li><p class="startli"><b><code>crewai/crew.py</code>:</b> When you set <code>memory=True</code> in the <code>Crew</code> constructor, the <code>create_crew_memory</code> validator method (triggered by Pydantic) initializes instances of <code>ShortTermMemory</code>, <code>LongTermMemory</code>, and <code>EntityMemory</code> and stores them in private attributes like <code>_short_term_memory</code>.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1564"></a>
Simplified from crewai/crew.py</h1>
<p>class Crew(BaseModel): memory: bool = Field(default=False, ...) _short_term_memory: Optional[InstanceOf[ShortTermMemory]] = PrivateAttr() _long_term_memory: Optional[InstanceOf[LongTermMemory]] = PrivateAttr() _entity_memory: Optional[InstanceOf[EntityMemory]] = PrivateAttr() </p>
<h1><a class="anchor" id="autotoc_md1565"></a>
... other fields ...</h1>
<p>@model_validator(mode="after") def create_crew_memory(self) -&gt; "Crew": if self.memory: </p>
<h1><a class="anchor" id="autotoc_md1566"></a>
Simplified: Initializes memory objects if memory=True</h1>
<p>self._long_term_memory = LongTermMemory(...) self._short_term_memory = ShortTermMemory(crew=self, ...) self._entity_memory = EntityMemory(crew=self, ...) return self ```</p>
<ul>
<li><p class="startli"><b><code>crewai/memory/contextual/contextual_memory.py</code>:</b> This class is responsible for orchestrating the retrieval from different memory types. Its <code>build_context_for_task</code> method takes the task information and queries the relevant memories.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1567"></a>
Simplified from crewai/memory/contextual/contextual_memory.py</h1>
<p>class ContextualMemory: def <b>init</b>(self, stm: ShortTermMemory, ltm: LongTermMemory, em: EntityMemory, ...): self.stm = stm self.ltm = ltm self.em = em </p>
<h1><a class="anchor" id="autotoc_md1568"></a>
...</h1>
<p>def build_context_for_task(self, task, context) -&gt; str: query = f"{task.description} {context}".strip() if not query: return ""</p>
<p>memory_context = [] </p>
<h1><a class="anchor" id="autotoc_md1569"></a>
Fetch relevant info from Short Term Memory</h1>
<p>memory_context.append(self._fetch_stm_context(query)) </p>
<h1><a class="anchor" id="autotoc_md1570"></a>
Fetch relevant info from Entity Memory</h1>
<p>memory_context.append(self._fetch_entity_context(query)) </p>
<h1><a class="anchor" id="autotoc_md1571"></a>
Fetch relevant info from Long Term Memory (if applicable)</h1>
<h1><a class="anchor" id="autotoc_md1572"></a>
memory_context.append(self._fetch_ltm_context(task.description))</h1>
<p>return "\n".join(filter(None, memory_context))</p>
<p>def _fetch_stm_context(self, query) -&gt; str: stm_results = self.stm.search(query) </p>
<h1><a class="anchor" id="autotoc_md1573"></a>
... format results ...</h1>
<p>return formatted_results if stm_results else ""</p>
<p>def _fetch_entity_context(self, query) -&gt; str: em_results = self.em.search(query) </p>
<h1><a class="anchor" id="autotoc_md1574"></a>
... format results ...</h1>
<p>return formatted_results if em_results else "" ```</p>
<ul>
<li><b>Memory Types (<code>short_term_memory.py</code>, <code>entity_memory.py</code>, <code>long_term_memory.py</code>):</b><ul>
<li><code>ShortTermMemory</code> and <code>EntityMemory</code> typically use <code>RAGStorage</code> (<code>crewai/memory/storage/rag_storage.py</code>), which often relies on a vector database like ChromaDB to store embeddings of text snippets and find similar ones based on a query.</li>
<li><code>LongTermMemory</code> typically uses <code>LTMSQLiteStorage</code> (<code>crewai/memory/storage/ltm_sqlite_storage.py</code>) to save structured data about task evaluations (like descriptions, scores, suggestions) into an SQLite database file.</li>
</ul>
</li>
</ul>
<p>The key idea is that <code>memory=True</code> sets up these storage systems and the <code>ContextualMemory</code> orchestrator, which automatically enriches agent prompts with relevant remembered information.</p>
<h2><a class="anchor" id="autotoc_md1575"></a>
Conclusion</h2>
<p>You've learned about the crucial concept of <b>Memory</b> in CrewAI! Memory gives your agents the ability to recall past information, preventing them from being purely stateless. We explored the three main types:</p>
<ul>
<li><b><code>ShortTermMemory</code></b>: For context within the current run.</li>
<li><b><code>LongTermMemory</code></b>: For insights across multiple runs (more advanced).</li>
<li><b><code>EntityMemory</code></b>: For tracking specific people, places, or concepts.</li>
</ul>
<p>Enabling memory with <code>memory=True</code> in your <code>Crew</code> is the first step to making your agents more context-aware and efficient, primarily leveraging Short Term and Entity memory automatically.</p>
<p>But what if your agents need access to a large body of pre-existing information, like company documentation, technical manuals, or a specific set of research papers? That's static information, not necessarily memories of <em>interactions</em>. How do we provide that? That's where the concept of <b>Knowledge</b> comes in. Let's explore that next!</p>
<p><b>Next:</b> <a class="el" href="../../dd/d7a/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2CrewAI_208__knowledge.html">Chapter 8: Knowledge - Providing External Information</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
