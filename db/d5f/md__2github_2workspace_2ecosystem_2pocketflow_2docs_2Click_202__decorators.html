#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 02_decorators</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('db/d5f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Click_202__decorators.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">02_decorators</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1177"></a>
autotoc_md1177</h2>
<p>layout: default title: "Decorators" parent: "Click" </p>
<h2><a class="anchor" id="autotoc_md1178"></a>
nav_order: 2</h2>
<h1><a class="anchor" id="autotoc_md1179"></a>
Chapter 2: Decorators: Magic Wands for Your Functions</h1>
<p>In <a class="el" href="../../dd/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Click_201__command______group.html">Chapter 1: Commands and Groups</a>, we learned how to create basic command-line actions (<code>Command</code>) and group them together (<code>Group</code>). You might have noticed those strange <code>@click.command()</code> and <code>@click.group()</code> lines above our functions. What are they, and why do we use them?</p>
<p>Those are <b>Decorators</b>, and they are the heart of how you build Click applications! Think of them as special annotations or modifiers you place <em>on top</em> of your Python functions to give them command-line superpowers.</p>
<h2><a class="anchor" id="autotoc_md1180"></a>
Why Decorators? Making Life Easier</h2>
<p>Imagine you didn't have decorators. To create a simple command like <code>hello</code> from Chapter 1, you might have to write something like this (this is <em>not</em> real Click code, just an illustration):</p>
<div class="fragment"><div class="line"><span class="comment"># NOT how Click works, but imagine...</span></div>
<div class="line"><span class="keyword">import</span> click</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>hello_logic():</div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;My command&#39;s help text&quot;&quot;&quot;</span></div>
<div class="line">  print(<span class="stringliteral">&quot;Hello World!&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Manually create a Command object</span></div>
<div class="line">hello_command = click.Command(</div>
<div class="line">  name=<span class="stringliteral">&#39;hello&#39;</span>,      <span class="comment"># Give it a name</span></div>
<div class="line">  callback=hello_logic, <span class="comment"># Tell it which function to run</span></div>
<div class="line">  help=hello_logic.__doc__ <span class="comment"># Copy the help text</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&#39;__main__&#39;</span>:</div>
<div class="line">  <span class="comment"># Manually parse arguments and run</span></div>
<div class="line">  <span class="comment"># (This part would be complex!)</span></div>
<div class="line">  <span class="keywordflow">pass</span></div>
</div><!-- fragment --><p>That looks like a lot more work! You have to:</p>
<ol type="1">
<li>Write the function (<code>hello_logic</code>).</li>
<li>Manually create a <code>Command</code> object.</li>
<li>Explicitly tell the <code>Command</code> object its name, which function to run (<code>callback</code>), and its help text.</li>
</ol>
<p>Now, let's remember the Click way from Chapter 1:</p>
<div class="fragment"><div class="line"><span class="comment"># The actual Click way</span></div>
<div class="line"><span class="keyword">import</span> click</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@click.command()</span> <span class="comment"># &lt;-- The Decorator!</span></div>
<div class="line"><span class="keyword">def </span>hello():</div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;A simple command that says Hello World&quot;&quot;&quot;</span></div>
<div class="line">  print(<span class="stringliteral">&quot;Hello World!&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&#39;__main__&#39;</span>:</div>
<div class="line">  hello()</div>
</div><!-- fragment --><p>Much cleaner, right? The <code>@click.command()</code> decorator handles creating the <code>Command</code> object, figuring out the name (<code>hello</code>), and grabbing the help text from the docstring (<code>"""..."""</code>) all automatically!</p>
<p>Decorators let you <em>declare</em> what you want ("this function is a command") right next to the function's code, making your CLI definition much more readable and concise.</p>
<h2><a class="anchor" id="autotoc_md1181"></a>
What is a Decorator in Python? (A Quick Peek)</h2>
<p>Before diving deeper into Click's decorators, let's understand what a decorator <em>is</em> in Python itself.</p>
<p>In Python, a decorator is essentially a function that takes another function as input and returns a <em>modified</em> version of that function. It's like wrapping a gift: you still have the original gift inside, but the wrapping adds something extra.</p>
<p>The <code>@</code> symbol is just syntactic sugar – a shortcut – for applying a decorator.</p>
<p>Here's a super simple example (not using Click):</p>
<div class="fragment"><div class="line"><span class="comment"># A simple Python decorator</span></div>
<div class="line"><span class="keyword">def </span>simple_decorator(func):</div>
<div class="line">  <span class="keyword">def </span>wrapper():</div>
<div class="line">    print(<span class="stringliteral">&quot;Something is happening before the function is called.&quot;</span>)</div>
<div class="line">    func() <span class="comment"># Call the original function</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Something is happening after the function is called.&quot;</span>)</div>
<div class="line">  <span class="keywordflow">return</span> wrapper <span class="comment"># Return the modified function</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@simple_decorator</span> <span class="comment"># Apply the decorator</span></div>
<div class="line"><span class="keyword">def </span>say_whee():</div>
<div class="line">  print(<span class="stringliteral">&quot;Whee!&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Now, when we call say_whee...</span></div>
<div class="line">say_whee()</div>
</div><!-- fragment --><p>Running this would print:</p>
<div class="fragment"><div class="line">Something is happening before the function is called.</div>
<div class="line">Whee!</div>
<div class="line">Something is happening after the function is called.</div>
</div><!-- fragment --><p>See? <code>simple_decorator</code> took our <code>say_whee</code> function and wrapped it with extra print statements. The <code>@simple_decorator</code> line is equivalent to writing <code>say_whee = simple_decorator(say_whee)</code> after defining <code>say_whee</code>.</p>
<p>Click's decorators (<code>@click.command</code>, <code>@click.group</code>, etc.) do something similar, but instead of just printing, they wrap your function inside Click's <code>Command</code> or <code>Group</code> objects and configure them.</p>
<h2><a class="anchor" id="autotoc_md1182"></a>
Click's Main Decorators</h2>
<p>Click provides several decorators. The most common ones you'll use are:</p>
<ul>
<li><code>@click.command()</code>: Turns a function into a single CLI command.</li>
<li><code>@click.group()</code>: Turns a function into a container for other commands.</li>
<li><code>@click.option()</code>: Adds an <em>option</em> (like <code>--name</code> or <code>-v</code>) to your command. Options are typically optional parameters.</li>
<li><code>@click.argument()</code>: Adds an <em>argument</em> (like a required filename) to your command. Arguments are typically required and positional.</li>
</ul>
<p>We already saw <code>@click.command</code> and <code>@click.group</code> in Chapter 1. Let's focus on how decorators streamline adding commands to groups and introduce options.</p>
<h2><a class="anchor" id="autotoc_md1183"></a>
Decorators in Action: Simplifying Groups and Adding Options</h2>
<p>Remember the <code>multi_app.py</code> example from Chapter 1? We had to define the group <code>cli</code> and the commands <code>hello</code> and <code>goodbye</code> separately, then manually attach them using <code>cli.add_command()</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># multi_app_v1.py (from Chapter 1)</span></div>
<div class="line"><span class="keyword">import</span> click</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@click.group()</span></div>
<div class="line"><span class="keyword">def </span>cli():</div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;A simple tool with multiple commands.&quot;&quot;&quot;</span></div>
<div class="line">  <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line">@click.command()</div>
<div class="line"><span class="keyword">def </span>hello():</div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;Says Hello World&quot;&quot;&quot;</span></div>
<div class="line">  print(<span class="stringliteral">&quot;Hello World!&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@click.command()</span></div>
<div class="line"><span class="keyword">def </span>goodbye():</div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;Says Goodbye World&quot;&quot;&quot;</span></div>
<div class="line">  print(<span class="stringliteral">&quot;Goodbye World!&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Manual attachment</span></div>
<div class="line">cli.add_command(hello)</div>
<div class="line">cli.add_command(goodbye)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&#39;__main__&#39;</span>:</div>
<div class="line">  cli()</div>
</div><!-- fragment --><p>Decorators provide a more elegant way! If you have a <code>@click.group()</code>, you can use <em>its</em> <code>.command()</code> method as a decorator to automatically attach the command.</p>
<p>Let's rewrite <code>multi_app.py</code> using this decorator pattern and also add a simple name option to the <code>hello</code> command using <code>@click.option</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># multi_app_v2.py (using decorators more effectively)</span></div>
<div class="line"><span class="keyword">import</span> click</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 1. Create the main group</span></div>
<div class="line"><span class="preprocessor">@click.group()</span></div>
<div class="line"><span class="keyword">def </span>cli():</div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;A simple tool with multiple commands.&quot;&quot;&quot;</span></div>
<div class="line">  <span class="keywordflow">pass</span> <span class="comment"># Group function still doesn&#39;t need to do much</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 2. Define &#39;hello&#39; and attach it to &#39;cli&#39; using a decorator</span></div>
<div class="line"><span class="preprocessor">@cli.command()</span> <span class="comment"># &lt;-- Decorator from the &#39;cli&#39; group object!</span></div>
<div class="line"><span class="preprocessor">@click.option(&#39;--name&#39;, default=&#39;World&#39;, help=&#39;Who to greet.&#39;)</span></div>
<div class="line"><span class="keyword">def </span>hello(name): <span class="comment"># The &#39;name&#39; parameter matches the option</span></div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;Says Hello&quot;&quot;&quot;</span></div>
<div class="line">  print(f<span class="stringliteral">&quot;Hello {name}!&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 3. Define &#39;goodbye&#39; and attach it to &#39;cli&#39; using a decorator</span></div>
<div class="line"><span class="preprocessor">@cli.command()</span> <span class="comment"># &lt;-- Decorator from the &#39;cli&#39; group object!</span></div>
<div class="line"><span class="keyword">def </span>goodbye():</div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;Says Goodbye&quot;&quot;&quot;</span></div>
<div class="line">  print(<span class="stringliteral">&quot;Goodbye World!&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># No need for cli.add_command() anymore!</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&#39;__main__&#39;</span>:</div>
<div class="line">  cli()</div>
</div><!-- fragment --><p>What changed?</p>
<ol type="1">
<li>Instead of <code>@click.command()</code>, we used <code>@cli.command()</code> above <code>hello</code> and <code>goodbye</code>. This tells Click, "This function is a command, *and* it belongs to the `cli` group." No more manual <code>cli.add_command()</code> needed!</li>
<li>We added &lsquo;@click.option(&rsquo;&ndash;name', default='World', help='Who to greet.')<code>right below</code>@cli.command()<code>for the</code>hello<code>function. This adds a command-line option named</code>&ndash;name<code>.</code></li>
<li><code> The</code>hello<code>function now accepts an argument</code>name<code>. Click automatically passes the value provided via the</code>&ndash;name<code>option to this function parameter. If the user doesn't provide</code>&ndash;name<code>, it uses the</code>default='World'`.</li>
</ol>
<p><b>Let's run this new version:</b></p>
<p>Check the help for the main command:</p>
<div class="fragment"><div class="line">$ python multi_app_v2.py --help</div>
<div class="line">Usage: multi_app_v2.py [OPTIONS] COMMAND [ARGS]...</div>
<div class="line"> </div>
<div class="line">  A simple tool with multiple commands.</div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">  --help  Show this message and exit.</div>
<div class="line"> </div>
<div class="line">Commands:</div>
<div class="line">  goodbye  Says Goodbye</div>
<div class="line">  hello    Says Hello</div>
</div><!-- fragment --><p>Now check the help for the <code>hello</code> subcommand:</p>
<div class="fragment"><div class="line">$ python multi_app_v2.py hello --help</div>
<div class="line">Usage: multi_app_v2.py hello [OPTIONS]</div>
<div class="line"> </div>
<div class="line">  Says Hello</div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">  --name TEXT  Who to greet.  [default: World]</div>
<div class="line">  --help       Show this message and exit.</div>
</div><!-- fragment --><p>See? The <code>--name</code> option is listed, along with its help text and default value!</p>
<p>Finally, run <code>hello</code> with and without the option:</p>
<div class="fragment"><div class="line">$ python multi_app_v2.py hello</div>
<div class="line">Hello World!</div>
<div class="line"> </div>
<div class="line">$ python multi_app_v2.py hello --name Alice</div>
<div class="line">Hello Alice!</div>
</div><!-- fragment --><p>It works! Decorators made adding the command to the group cleaner, and adding the option was as simple as adding another decorator line and a function parameter. We'll learn much more about configuring options and arguments in the next chapter, <a class="el" href="../../db/dbc/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Click_203__parameter____option______argument__.html">Parameter (Option / Argument)</a>.</p>
<h2><a class="anchor" id="autotoc_md1184"></a>
How Click Decorators Work (Under the Hood)</h2>
<p>So what's the "magic" behind these <code>@</code> symbols in Click?</p>
<ol type="1">
<li><b>Decorator Functions:</b> When you write <code>@click.command()</code> or <code>@click.option()</code>, you're calling functions defined in Click (specifically in <code>decorators.py</code>). These functions are designed to <em>return another function</em> (the actual decorator).</li>
<li><b>Wrapping the User Function:</b> Python takes the function you defined (e.g., <code>hello</code>) and passes it to the decorator function returned in step 1.</li>
<li><b>Attaching Information:</b><ul>
<li><code>@click.option</code> / <code>@click.argument</code>: These decorators typically don't create the final <code>Command</code> object immediately. Instead, they attach the parameter information (like the option name <code>--name</code>, type, default value) to your function object itself, often using a special temporary attribute (like <code>__click_params__</code>). They then return the <em>original function</em>, but now with this extra metadata attached.</li>
<li><code>@click.command</code> / <code>@click.group</code>: This decorator usually runs <em>last</em> (decorators are applied bottom-up). It looks for any parameter information attached by previous <code>@option</code> or <code>@argument</code> decorators (like <code>__click_params__</code>). It then creates the actual <code>Command</code> or <code>Group</code> object (defined in <code>core.py</code>), configures it with the command name, help text (from the docstring), the attached parameters, and stores your original function as the <code>callback</code> to be executed. It returns this newly created <code>Command</code> or <code>Group</code> object, effectively replacing your original function definition with the Click object.</li>
</ul>
</li>
<li><b>Group Attachment:</b> When you use <code>@cli.command()</code>, the <code>@cli.command()</code> decorator not only creates the <code>Command</code> object but also automatically calls <code>cli.add_command()</code> to register the new command with the <code>cli</code> group object.</li>
</ol>
<p>Here's a simplified sequence diagram showing what happens when you define the <code>hello</code> command in <code>multi_app_v2.py</code>:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant PythonInterpreter</div>
<div class="line">    participant click_option as @click.option(&#39;--name&#39;)</div>
<div class="line">    participant hello_func as hello(name)</div>
<div class="line">    participant cli_command as @cli.command()</div>
<div class="line">    participant cli_Group as cli (Group Object)</div>
<div class="line">    participant hello_Command as hello (New Command Object)</div>
<div class="line"> </div>
<div class="line">    Note over PythonInterpreter, hello_func: Python processes decorators bottom-up</div>
<div class="line">    PythonInterpreter-&gt;&gt;click_option: Processes @click.option(&#39;--name&#39;, ...) decorator</div>
<div class="line">    click_option-&gt;&gt;hello_func: Attaches Option info (like in __click_params__)</div>
<div class="line">    click_option--&gt;&gt;PythonInterpreter: Returns original hello_func (with attached info)</div>
<div class="line"> </div>
<div class="line">    PythonInterpreter-&gt;&gt;cli_command: Processes @cli.command() decorator</div>
<div class="line">    cli_command-&gt;&gt;hello_func: Reads function name, docstring, attached params (__click_params__)</div>
<div class="line">    cli_command-&gt;&gt;hello_Command: Creates new Command object for &#39;hello&#39;</div>
<div class="line">    cli_command-&gt;&gt;cli_Group: Calls cli.add_command(hello_Command)</div>
<div class="line">    cli_command--&gt;&gt;PythonInterpreter: Returns the new hello_Command object</div>
<div class="line"> </div>
<div class="line">    Note over PythonInterpreter: &#39;hello&#39; in the code now refers to the Command object</div>
</div><!-- fragment --><p>The key takeaway is that decorators allow Click to gather all the necessary information (function logic, command name, help text, options, arguments) right where you define the function, and build the corresponding Click objects behind the scenes. You can find the implementation details in <code>click/decorators.py</code> and <code>click/core.py</code>. The <code>_param_memo</code> helper function in <code>decorators.py</code> is often used internally by <code>@option</code> and <code>@argument</code> to attach parameter info to the function before <code>@command</code> processes it.</p>
<h2><a class="anchor" id="autotoc_md1185"></a>
Conclusion</h2>
<p>Decorators are fundamental to Click's design philosophy. They provide a clean, readable, and <em>declarative</em> way to turn your Python functions into powerful command-line interface components.</p>
<p>You've learned:</p>
<ul>
<li>Decorators are Python features (<code>@</code>) that modify functions.</li>
<li>Click uses decorators like <code>@click.command</code>, <code>@click.group</code>, <code>@click.option</code>, and <code>@click.argument</code> extensively.</li>
<li>Decorators handle the creation and configuration of <code>Command</code>, <code>Group</code>, <code>Option</code>, and <code>Argument</code> objects for you.</li>
<li>Using decorators like <code>@group.command()</code> automatically attaches commands to groups.</li>
<li>They make defining your CLI structure intuitive and keep related code together.</li>
</ul>
<p>We've only scratched the surface of <code>@click.option</code> and <code>@click.argument</code>. How do you make options required? How do you handle different data types (numbers, files)? How do you define arguments that take multiple values? We'll explore all of this in the next chapter!</p>
<p>Next up: <a class="el" href="../../db/dbc/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Click_203__parameter____option______argument__.html">Chapter 3: Parameter (Option / Argument)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
