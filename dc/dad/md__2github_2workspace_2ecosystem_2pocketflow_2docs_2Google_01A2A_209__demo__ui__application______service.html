#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 09_demo_ui_application___service</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/dad/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_209__demo__ui__application______service.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">09_demo_ui_application___service</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2050"></a>
autotoc_md2050</h2>
<p>layout: default title: "Demo UI Application &amp; Service" parent: "Google A2A" </p>
<h2><a class="anchor" id="autotoc_md2051"></a>
nav_order: 9</h2>
<h1><a class="anchor" id="autotoc_md2052"></a>
Chapter 9: Demo UI Application &amp; Service</h1>
<p>In the <a class="el" href="../../dc/ddf/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_208__multi__agent__orchestration____host__agent__.html">previous chapter</a>, we explored how a <b>Host Agent</b> can act like a project manager, coordinating multiple specialized agents using the A2A protocol to achieve complex goals. We've learned about Agent Cards, Tasks, the protocol itself, servers, clients, task logic, streaming, and orchestration. That's a lot of building blocks!</p>
<p>But how do we see all these pieces working together in a real, interactive way? Just reading about protocols and servers is like reading the blueprints for a car. Wouldn't it be more helpful to actually <em>see</em> the car drive?</p>
<p>That's where the <b>Demo UI Application &amp; Service</b> comes in. It solves the problem: <b>How can we visualize and interact with the A2A protocol and multi-agent systems in action?</b></p>
<h2><a class="anchor" id="autotoc_md2053"></a>
What is the Demo UI Application &amp; Service? The Control Room</h2>
<p>Imagine a space mission control room. You have:</p>
<ul>
<li><b>Big Screens (UI):</b> Showing the rocket's status, communication logs, astronaut locations, etc.</li>
<li><b>Flight Controllers (Backend Service):</b> People at consoles managing specific parts of the mission, talking to different teams, and updating the screens.</li>
<li><b>Astronauts &amp; Ground Crew (A2A Agents):</b> The actual experts doing the work (flying, repairing, analyzing), communicating back via radio (A2A protocol).</li>
</ul>
<p>The <b>Demo UI Application &amp; Service</b> is like that control room for our A2A agents:</p>
<ol type="1">
<li><b>Demo UI Application:</b> This is the web-based frontend, built using a Python framework called <a href="https://github.com/mesop-dev/mesop">Mesop</a>. It provides the "big screens" – a chat interface where you can talk to agents, see their responses (including special content like forms or images), view lists of available agents, and inspect the communication flow.</li>
<li><b>Backend Service (<code>ConversationServer</code>):</b> This is the "flight controller" software running behind the scenes. It's a backend web service (built using FastAPI in Python) that the UI application talks to. It's <em>not</em> the main <a class="el" href="../../dc/ddf/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_208__multi__agent__orchestration____host__agent__.html">Host Agent</a> itself, but rather an <b>intermediary</b>. It manages the user's conversations, receives events from the UI (like sending a message), communicates with the actual agent logic (like the Host Agent), and sends state updates back to the UI so the screens stay current.</li>
</ol>
<p>Think of it as a user-friendly window into the world of A2A, letting you watch and participate as agents collaborate.</p>
<h2><a class="anchor" id="autotoc_md2054"></a>
Key Components</h2>
<p>Let's break down the two main parts:</p>
<h3><a class="anchor" id="autotoc_md2055"></a>
1. Frontend (Mesop UI Application)</h3>
<p>This is what you see and interact with in your web browser. Mesop allows building UIs purely in Python. Key features include:</p>
<ul>
<li><b>Chat Interface:</b> Displays the conversation history between you and the agent system. (<code>demo/ui/components/conversation.py</code>)</li>
<li><b>Input Box:</b> Where you type your messages to the agent. (<code>demo/ui/components/conversation.py</code>)</li>
<li><b>Agent Management:</b> Allows adding new agents by providing their <a class="el" href="../../d7/d4e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_201__agent__card.html">Agent Card</a> URL. (<code>demo/ui/pages/agent_list.py</code>)</li>
<li><b>Rich Content Rendering:</b> Can display not just text, but also interactive forms sent by agents (<code>demo/ui/components/form_render.py</code>), images, etc.</li>
<li><b>Task/Event Views:</b> Provides ways to inspect the underlying <a class="el" href="../../d2/d9c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_202__task.html">Tasks</a> and communication events happening via A2A. (<code>demo/ui/pages/task_list.py</code>, <code>demo/ui/pages/event_list.py</code>)</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># File: demo/ui/components/conversation.py (Simplified Snippet)</span></div>
<div class="line"><span class="comment"># ... imports ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@me.component</span></div>
<div class="line"><span class="keyword">def </span>conversation():</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Conversation component&quot;&quot;&quot;</span></div>
<div class="line">    page_state = me.state(PageState) <span class="comment"># Local page state</span></div>
<div class="line">    app_state = me.state(AppState)   <span class="comment"># Global application state</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... loop to display existing messages using chat_bubble component ...</span></div>
<div class="line">    <span class="keywordflow">for</span> message <span class="keywordflow">in</span> app_state.messages:</div>
<div class="line">        <span class="keywordflow">if</span> is_form(message):</div>
<div class="line">          render_form(message, app_state) <span class="comment"># Special handling for forms</span></div>
<div class="line">        <span class="comment"># ... other message types ...</span></div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">          chat_bubble(message, message.message_id) <span class="comment"># Display regular chat message</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># --- Input area ---</span></div>
<div class="line">    <span class="keyword">with</span> me.box(style=me.Style(display=<span class="stringliteral">&quot;flex&quot;</span>, flex_direction=<span class="stringliteral">&quot;row&quot;</span>, ...)):</div>
<div class="line">        me.input(</div>
<div class="line">            label=<span class="stringliteral">&quot;How can I help you?&quot;</span>,</div>
<div class="line">            on_enter=send_message_enter, <span class="comment"># Function to call when user presses Enter</span></div>
<div class="line">            <span class="comment"># ... other attributes ...</span></div>
<div class="line">        )</div>
<div class="line">        <span class="keyword">with</span> me.content_button(on_click=send_message_button): <span class="comment"># Button handler</span></div>
<div class="line">            me.icon(icon=<span class="stringliteral">&quot;send&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span>send_message_enter(e: me.InputEnterEvent):</div>
<div class="line">    <span class="comment"># ... (get state) ...</span></div>
<div class="line">    message_content = e.value</div>
<div class="line">    message_id = str(uuid.uuid4())</div>
<div class="line">    <span class="comment"># Store something to indicate a background task is running</span></div>
<div class="line">    app_state = me.state(AppState)</div>
<div class="line">    app_state.background_tasks[message_id] = <span class="stringliteral">&quot;Processing...&quot;</span></div>
<div class="line">    <span class="keywordflow">yield</span> <span class="comment"># Update UI to show indicator</span></div>
<div class="line">    <span class="comment"># Call the backend service to actually send the message</span></div>
<div class="line">    await send_message(message_content, message_id)</div>
<div class="line">    <span class="keywordflow">yield</span> <span class="comment"># Allow UI to potentially update again</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>This Mesop component defines the chat interface.</li>
<li>It uses <code>app_state</code> (defined in <code>demo/ui/state/state.py</code>) to access the current list of messages and display them.</li>
<li>It renders an <code>me.input</code> field. When the user presses Enter (<code>on_enter</code>), the <code>send_message_enter</code> function is called.</li>
<li><code>send_message_enter</code> gets the user's text, updates the state to show a "Processing..." indicator, and then calls <code>send_message</code> (defined in <code>demo/ui/state/host_agent_service.py</code>) which actually communicates with the backend <code>ConversationServer</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md2056"></a>
2. Backend (<code>ConversationServer</code>)</h3>
<p>This FastAPI server acts as the bridge between the simple HTTP/JSON communication from the UI and the potentially more complex agent interactions (which might involve A2A or frameworks like Google ADK).</p>
<ul>
<li><b>API Endpoints:</b> Exposes simple HTTP endpoints (e.g., <code>/message/send</code>, <code>/conversation/list</code>) that the UI's client can call. (<code>demo/ui/service/server/server.py</code>)</li>
<li><b>Conversation Management:</b> Keeps track of different chat sessions.</li>
<li><b>State Management:</b> Holds the application state (messages, tasks, agents) that the UI needs to display.</li>
<li><b>Agent Interaction Logic:</b> Contains the logic to forward requests from the UI to the actual agent system (e.g., the ADK <a class="el" href="../../dc/ddf/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_208__multi__agent__orchestration____host__agent__.html">Host Agent</a>). (<code>demo/ui/service/server/adk_host_manager.py</code>)</li>
<li><b>Callback Handling:</b> Receives updates (like task status changes or new artifacts) from the agent system and updates its internal state.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># File: demo/ui/service/server/server.py (Simplified Snippet)</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> APIRouter, Request</div>
<div class="line"><span class="keyword">from</span> common.types <span class="keyword">import</span> Message</div>
<div class="line"><span class="keyword">from</span> .adk_host_manager <span class="keyword">import</span> ADKHostManager <span class="comment"># Implements agent interaction logic</span></div>
<div class="line"><span class="comment"># ... other imports ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ConversationServer:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, router: APIRouter):</div>
<div class="line">        <span class="comment"># Choose the manager (e.g., ADKHostManager uses the Host Agent)</span></div>
<div class="line">        self.manager = ADKHostManager()</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Define API route for sending messages</span></div>
<div class="line">        router.add_api_route(</div>
<div class="line">            <span class="stringliteral">&quot;/message/send&quot;</span>,</div>
<div class="line">            self._send_message, <span class="comment"># Maps URL to the _send_message method</span></div>
<div class="line">            methods=[<span class="stringliteral">&quot;POST&quot;</span>])</div>
<div class="line">        <span class="comment"># ... other routes (/conversation/list, /task/list, etc.) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>_send_message(self, request: Request):</div>
<div class="line">        message_data = await request.json()</div>
<div class="line">        <span class="comment"># Parse the message data sent by the UI client</span></div>
<div class="line">        message = Message(**message_data[<span class="stringliteral">&#39;params&#39;</span>])</div>
<div class="line">        <span class="comment"># Add necessary metadata (IDs, etc.)</span></div>
<div class="line">        message = self.manager.sanitize_message(message)</div>
<div class="line">        <span class="comment"># --- Crucial Part: Pass message to the agent logic ---</span></div>
<div class="line">        <span class="comment"># Run the actual agent processing in a background thread</span></div>
<div class="line">        <span class="comment"># so the API call returns quickly to the UI.</span></div>
<div class="line">        thread = threading.Thread(</div>
<div class="line">           target=<span class="keyword">lambda</span>: asyncio.run(self.manager.process_message(message))</div>
<div class="line">        )</div>
<div class="line">        thread.start()</div>
<div class="line">        <span class="comment"># Return an immediate confirmation to the UI</span></div>
<div class="line">        <span class="keywordflow">return</span> SendMessageResponse(result=MessageInfo(</div>
<div class="line">            message_id=message.metadata[<span class="stringliteral">&#39;message_id&#39;</span>],</div>
<div class="line">            <span class="comment"># ... other info ...</span></div>
<div class="line">        ))</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>The <code>ConversationServer</code> sets up API routes using FastAPI.</li>
<li>The <code>_send_message</code> method handles requests to the <code>/message/send</code> endpoint.</li>
<li>It parses the <code>Message</code> sent from the UI client.</li>
<li>It calls <code>self.manager.process_message(message)</code>. The <code>manager</code> (here, <code>ADKHostManager</code>) is responsible for actually interacting with the underlying agent system (<a class="el" href="../../dc/ddf/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_208__multi__agent__orchestration____host__agent__.html">Host Agent</a>).</li>
<li>Crucially, <code>process_message</code> is run in a separate thread so the API can respond quickly, acknowledging receipt, while the potentially long-running agent work happens in the background.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2057"></a>
How It Works: The Flow of a Message</h2>
<p>Let's trace what happens when you type "Hello" and press Enter in the Demo UI:</p>
<ol type="1">
<li><b>UI (Mesop):</b> The <code>on_enter</code> event triggers <code>send_message_enter</code> in <code>conversation.py</code>.</li>
<li><b>UI State:</b> <code>send_message_enter</code> updates the <code>AppState</code> to show a "Processing" indicator.</li>
<li><b>UI Client (<code>host_agent_service.py</code>):</b> <code>send_message_enter</code> calls <code>SendMessage(message)</code>. This function uses the <code>ConversationClient</code> to make an HTTP POST request to the <code>ConversationServer</code>'s <code>/message/send</code> endpoint, sending the user's message as JSON. <code>python @section autotoc_md2058 File: demo/ui/state/host_agent_service.py (Simplified Snippet) async def SendMessage(message: Message) -&gt; str | None: client = ConversationClient(server_url) # Backend server URL try: @section autotoc_md2059 Make HTTP POST request to backend API response = await client.send_message(SendMessageRequest(params=message)) return response.result # Contains confirmation IDs except Exception as e: print("Failed to send message: ", e) </code></li>
<li><b>Backend Service (<code>server.py</code>):</b> The <code>_send_message</code> method on the <code>ConversationServer</code> receives the POST request.</li>
<li><b>Backend Service Logic (<code>adk_host_manager.py</code>):</b> <code>_send_message</code> calls <code>self.manager.process_message(message)</code> (running in a background thread). <code>python @section autotoc_md2060 File: demo/ui/service/server/adk_host_manager.py (Simplified Snippet) async def process_message(self, message: Message): @section autotoc_md2061 ... (Store message, add event) ... @section autotoc_md2062 Get conversation context conversation_id = message.metadata.get('conversation_id') @section autotoc_md2063 --- Interact with the actual agent (e.g., Google ADK Runner) --- async for event in self._host_runner.run_async( user_id=self.user_id, session_id=conversation_id, new_message=self.adk_content_from_message(message) # Convert to agent format ): @section autotoc_md2064 Process events coming *back* from the agent self.add_event(...) # Store for UI event log @section autotoc_md2065 ... potentially update task status via task_callback ... @section autotoc_md2066 ... (Store final response message) ... @section autotoc_md2067 Remove pending indicator self._pending_message_ids.remove(get_message_id(message)) </code></li>
<li><b>Agent Processing:</b> <code>process_message</code> uses the ADK <code>Runner</code> (<code>self._host_runner</code>) to send the message to the configured agent (our <a class="el" href="../../dc/ddf/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_208__multi__agent__orchestration____host__agent__.html">Host Agent</a>). The Host Agent might then use its own <a class="el" href="../../dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html">A2A Client</a> logic to talk to downstream agents via A2A.</li>
<li><b>Agent Response/Updates:</b> As the agent system works, it sends back events (potentially via <a class="el" href="../../d0/d60/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_207__streaming__communication____sse__.html">Streaming Communication (SSE)</a> if using A2A, or via ADK callbacks). The <code>ADKHostManager</code>'s <code>task_callback</code> or the <code>run_async</code> loop processes these updates, storing new messages, updating task statuses, and storing artifacts.</li>
<li><b>UI Polling (<code>page_scaffold.py</code>):</b> Meanwhile, the Mesop UI periodically polls the <code>ConversationServer</code> for state updates using an <code>async_poller</code> component. This poller triggers <code>UpdateAppState</code> in <code>host_agent_service.py</code>. <code>python @section autotoc_md2068 File: demo/ui/components/page_scaffold.py (Simplified Snippet) async def refresh_app_state(e: mel.WebEvent): # Triggered by poller yield app_state = me.state(AppState) @section autotoc_md2069 Call backend service to get the latest state await UpdateAppState(app_state, app_state.current_conversation_id) yield @section autotoc_md2070 ... in page_scaffold component setup ... async_poller(action=..., trigger_event=refresh_app_state) </code></li>
<li><b>Backend State Request (<code>host_agent_service.py</code>):</b> <code>UpdateAppState</code> calls various <code>ConversationServer</code> endpoints (like <code>/conversation/list</code>, <code>/message/list</code>, <code>/task/list</code>) to get the latest messages, tasks, etc.</li>
<li><b>Backend Response:</b> The <code>ConversationServer</code> returns the current state data from its <code>manager</code>.</li>
<li><b>UI Update:</b> <code>UpdateAppState</code> updates the global <code>AppState</code> in Mesop with the fresh data. Because Mesop automatically re-renders when state changes, the UI updates to show the agent's response, remove the "Processing" indicator, and update task lists.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2071"></a>
Under the Hood: Sequence Diagram</h2>
<p>This diagram shows the high-level flow for sending a message and getting a response, involving the UI, the Backend Service, and the Agent Logic (like the Host Agent).</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant UI as Mesop Frontend</div>
<div class="line">    participant BClient as Backend Client (host_agent_service)</div>
<div class="line">    participant BServer as Backend Service (ConversationServer)</div>
<div class="line">    participant Manager as Backend Manager (ADKHostManager)</div>
<div class="line">    participant Agent as Agent Logic (Host Agent / ADK)</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;UI: Type message, press Enter</div>
<div class="line">    UI-&gt;&gt;BClient: Call SendMessage(msg)</div>
<div class="line">    BClient-&gt;&gt;BServer: POST /message/send (JSON: msg)</div>
<div class="line">    BServer-&gt;&gt;Manager: Call process_message(msg) [async]</div>
<div class="line">    BServer--&gt;&gt;BClient: 200 OK (Ack)</div>
<div class="line">    BClient--&gt;&gt;UI: Return (UI shows processing)</div>
<div class="line"> </div>
<div class="line">    Note over Manager, Agent: Agent processing happens...</div>
<div class="line">    Manager-&gt;&gt;Agent: Run agent with message</div>
<div class="line">    Agent--&gt;&gt;Manager: Agent produces results/updates</div>
<div class="line">    Manager-&gt;&gt;Manager: Store results/state updates</div>
<div class="line"> </div>
<div class="line">    loop UI Polling for Updates</div>
<div class="line">        UI-&gt;&gt;BClient: Call UpdateAppState()</div>
<div class="line">        BClient-&gt;&gt;BServer: POST /message/list, /task/list, etc.</div>
<div class="line">        BServer-&gt;&gt;Manager: Get current state data</div>
<div class="line">        Manager--&gt;&gt;BServer: Return state data</div>
<div class="line">        BServer--&gt;&gt;BClient: 200 OK (JSON: state)</div>
<div class="line">        BClient-&gt;&gt;UI: Update Mesop AppState</div>
<div class="line">        Note over UI: Mesop re-renders with new data (agent response)</div>
<div class="line">    end</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2072"></a>
Conclusion</h2>
<p>The Demo UI Application and its associated <code>ConversationServer</code> backend provide a crucial, practical tool for the Google A2A project. They act as an interactive "control room" allowing you to:</p>
<ul>
<li><b>Visualize</b> conversations involving one or more A2A agents.</li>
<li><b>Interact</b> with the system by sending messages.</li>
<li><b>Observe</b> how components like the <a class="el" href="../../dc/ddf/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_208__multi__agent__orchestration____host__agent__.html">Host Agent</a> delegate tasks using the A2A protocol.</li>
<li><b>Inspect</b> the state of <a class="el" href="../../d2/d9c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_202__task.html">Tasks</a> and communication events.</li>
<li><b>Experiment</b> by adding new agents via their <a class="el" href="../../d7/d4e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_201__agent__card.html">Agent Cards</a>.</li>
</ul>
<p>It brings together all the concepts we've discussed – servers, clients, tasks, streaming, orchestration – into a tangible demonstration, making the abstract protocol concrete and easier to understand. This completes our journey through the core concepts of the Google A2A protocol and its demonstration application!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
