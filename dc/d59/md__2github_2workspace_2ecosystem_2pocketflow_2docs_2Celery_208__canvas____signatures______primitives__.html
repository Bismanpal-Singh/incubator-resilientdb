#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 08_canvas__signatures___primitives_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_208__canvas____signatures______primitives__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">08_canvas__signatures___primitives_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1093"></a>
autotoc_md1093</h2>
<p>layout: default title: "Canvas (Signatures &amp; Primitives)" parent: "Celery" </p>
<h2><a class="anchor" id="autotoc_md1094"></a>
nav_order: 8</h2>
<h1><a class="anchor" id="autotoc_md1095"></a>
Chapter 8: Canvas (Signatures &amp; Primitives) - Building Task Workflows</h1>
<p>In the previous chapter, <a class="el" href="../../dd/d67/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_207__beat____scheduler__.html">Chapter 7: Beat (Scheduler)</a>, we learned how to schedule tasks to run automatically at specific times using Celery Beat. This is great for recurring jobs. But what if you need to run a sequence of tasks, where one task depends on the result of another? Or run multiple tasks in parallel and then collect their results?</p>
<p>Imagine you're building a feature where a user uploads an article, and you need to:</p><ol type="1">
<li>Fetch the article content from a URL.</li>
<li>Process the text to extract keywords.</li>
<li>Process the text to detect the language.</li>
<li>Once <em>both</em> processing steps are done, save the article and the extracted metadata to your database.</li>
</ol>
<p>Simply running these tasks independently won't work. Keyword extraction and language detection can happen at the same time, but only <em>after</em> the content is fetched. Saving can only happen <em>after</em> both processing steps are complete. How do you orchestrate this multi-step workflow?</p>
<p>This is where <b>Celery Canvas</b> comes in. It provides the building blocks to design complex task workflows.</p>
<h2><a class="anchor" id="autotoc_md1096"></a>
What Problem Does Canvas Solve?</h2>
<p>Canvas helps you connect individual <a class="el" href="../../d5/db8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_203__task.html">Task</a>s together to form more sophisticated processes. It solves the problem of defining dependencies and flow control between tasks. Instead of just firing off tasks one by one and hoping they complete in the right order or manually checking results, Canvas lets you declare the desired workflow structure directly.</p>
<p>Think of it like having different types of Lego bricks:</p><ul>
<li>Some bricks represent a single task.</li>
<li>Other bricks let you connect tasks end-to-end (run in sequence).</li>
<li>Some let you stack bricks side-by-side (run in parallel).</li>
<li>Others let you build a structure where several parallel steps must finish before the next piece is added.</li>
</ul>
<p>Canvas gives you these connecting bricks for your Celery tasks.</p>
<h2><a class="anchor" id="autotoc_md1097"></a>
Key Concepts: Signatures and Primitives</h2>
<p>The core ideas in Canvas are <b>Signatures</b> and <b>Workflow Primitives</b>.</p>
<ol type="1">
<li><p class="startli"><b>Signature (<code>signature</code> or <code>.s()</code>): The Basic Building Block</b></p><ul>
<li>A <code>Signature</code> wraps up everything needed to call a single task: the task's name, the arguments (<code>args</code>), the keyword arguments (<code>kwargs</code>), and any execution options (like <code>countdown</code>, <code>eta</code>, queue name).</li>
<li>Think of it as a <b>pre-filled request form</b> or a <b>recipe card</b> for a specific task execution. It doesn't <em>run</em> the task immediately; it just holds the plan for running it.</li>
<li>The easiest way to create a signature is using the <code>.s()</code> shortcut on a task function.</li>
</ul>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md1098"></a>
tasks.py</h1>
<p>from celery_app import app # Assuming app is defined in celery_app.py</p>
<p>@app.task def add(x, y): return x + y</p>
<h1><a class="anchor" id="autotoc_md1099"></a>
Create a signature for add(2, 3)</h1>
<p>add_sig = add.s(2, 3)</p>
<h1><a class="anchor" id="autotoc_md1100"></a>
add_sig now holds the 'plan' to run add(2, 3)</h1>
<p>print(f"Signature: {add_sig}") print(f"Task name: {add_sig.task}") print(f"Arguments: {add_sig.args}")</p>
<h1><a class="anchor" id="autotoc_md1101"></a>
To actually run it, you call .delay() or .apply_async() ON the signature</h1>
<h1><a class="anchor" id="autotoc_md1102"></a>
result_promise = add_sig.delay()</h1>
<p>```</p>
<p><b>Output:</b> <code>text Signature: tasks.add(2, 3) Task name: tasks.add Arguments: (2, 3) </code></p>
<ol type="1">
<li><b>Primitives: Connecting the Blocks</b> Canvas provides several functions (primitives) to combine signatures into workflows:<ul>
<li><b><code>chain</code>:</b> Links tasks sequentially. The result of the first task is passed as the first argument to the second task, and so on.<ul>
<li>Analogy: An assembly line where each station passes its output to the next.</li>
<li>Syntax: <code>(sig1 | sig2 | sig3)</code> or <code>chain(sig1, sig2, sig3)</code></li>
</ul>
</li>
<li><b><code>group</code>:</b> Runs a list of tasks in parallel. It returns a special result object that helps track the group.<ul>
<li>Analogy: Hiring several workers to do similar jobs independently at the same time.</li>
<li>Syntax: <code>group(sig1, sig2, sig3)</code></li>
</ul>
</li>
<li><b><code>chord</code>:</b> Runs a group of tasks in parallel (the "header"), and <em>then</em>, once <em>all</em> tasks in the group have finished successfully, it runs a single callback task (the "body") with the results of the header tasks.<ul>
<li>Analogy: A team of researchers works on different parts of a project in parallel. Once everyone is done, a lead researcher collects all the findings to write the final report.</li>
<li>Syntax: <code>chord(group(header_sigs), body_sig)</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>There are other primitives like <code>chunks</code>, <code>xmap</code>, and <code>starmap</code>, but <code>chain</code>, <code>group</code>, and <code>chord</code> are the most fundamental ones for building workflows.</p>
<h2><a class="anchor" id="autotoc_md1103"></a>
How to Use Canvas: Building the Article Processing Workflow</h2>
<p>Let's build the workflow we described earlier: Fetch -&gt; (Process Keywords &amp; Detect Language in parallel) -&gt; Save.</p>
<p><b>1. Define the Tasks</b></p>
<p>First, we need our basic tasks. Let's create dummy versions in <code>tasks.py</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># tasks.py</span></div>
<div class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"><span class="keyword">import</span> random</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>fetch_data(url):</div>
<div class="line">    print(f<span class="stringliteral">&quot;Fetching data from {url}...&quot;</span>)</div>
<div class="line">    time.sleep(1)</div>
<div class="line">    <span class="comment"># Simulate fetching some data</span></div>
<div class="line">    data = f<span class="stringliteral">&quot;Content from {url} - {random.randint(1, 100)}&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Fetched: {data}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> data</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>process_part_a(data):</div>
<div class="line">    print(f<span class="stringliteral">&quot;Processing Part A for: {data}&quot;</span>)</div>
<div class="line">    time.sleep(2)</div>
<div class="line">    result_a = f<span class="stringliteral">&quot;Keywords for &#39;{data}&#39;&quot;</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Part A finished.&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> result_a</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>process_part_b(data):</div>
<div class="line">    print(f<span class="stringliteral">&quot;Processing Part B for: {data}&quot;</span>)</div>
<div class="line">    time.sleep(3) <span class="comment"># Simulate slightly longer processing</span></div>
<div class="line">    result_b = f<span class="stringliteral">&quot;Language for &#39;{data}&#39;&quot;</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Part B finished.&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> result_b</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>combine_results(results):</div>
<div class="line">    <span class="comment"># &#39;results&#39; will be a list containing the return values</span></div>
<div class="line">    <span class="comment"># of process_part_a and process_part_b</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Combining results: {results}&quot;</span>)</div>
<div class="line">    time.sleep(1)</div>
<div class="line">    final_output = f<span class="stringliteral">&quot;Combined: {results[0]} | {results[1]}&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Final Output: {final_output}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> final_output</div>
</div><!-- fragment --><p><b>2. Define the Workflow Using Canvas</b></p>
<p>Now, in a separate script or Python shell, let's define the workflow using signatures and primitives.</p>
<div class="fragment"><div class="line"><span class="comment"># run_workflow.py</span></div>
<div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> chain, group, chord</div>
<div class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> fetch_data, process_part_a, process_part_b, combine_results</div>
<div class="line"> </div>
<div class="line"><span class="comment"># The URL we want to process</span></div>
<div class="line">article_url = <span class="stringliteral">&quot;http://example.com/article1&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the workflow structure</span></div>
<div class="line"><span class="comment"># 1. Fetch data. The result (data) is passed to the next step.</span></div>
<div class="line"><span class="comment"># 2. The next step is a chord:</span></div>
<div class="line"><span class="comment">#    - Header: A group running process_part_a and process_part_b in parallel.</span></div>
<div class="line"><span class="comment">#              Both tasks receive the &#39;data&#39; from fetch_data.</span></div>
<div class="line"><span class="comment">#    - Body: combine_results receives a list of results from the group.</span></div>
<div class="line"> </div>
<div class="line">workflow = chain(</div>
<div class="line">    fetch_data.s(article_url),              <span class="comment"># Step 1: Fetch</span></div>
<div class="line">    chord(                                  <span class="comment"># Step 2: Chord</span></div>
<div class="line">        group(process_part_a.s(), process_part_b.s()), <span class="comment"># Header: Parallel processing</span></div>
<div class="line">        combine_results.s()                            <span class="comment"># Body: Combine results</span></div>
<div class="line">    )</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Workflow definition:\n{workflow}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Start the workflow</span></div>
<div class="line">print(<span class="stringliteral">&quot;\nSending workflow to Celery...&quot;</span>)</div>
<div class="line">result_promise = workflow.apply_async()</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Workflow sent! Final result ID: {result_promise.id}&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;Run a Celery worker to execute the tasks.&quot;</span>)</div>
<div class="line"><span class="comment"># You can optionally wait for the final result:</span></div>
<div class="line"><span class="comment"># final_result = result_promise.get()</span></div>
<div class="line"><span class="comment"># print(f&quot;\nWorkflow finished! Final result: {final_result}&quot;)</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>We import <code>chain</code>, <code>group</code>, <code>chord</code> from <code>celery</code>.</li>
<li>We import our task functions.</li>
<li><code>fetch_data.s(article_url)</code>: Creates a signature for the first step.</li>
<li><code>process_part_a.s()</code> and <code>process_part_b.s()</code>: Create signatures for the parallel tasks. Note that we <em>don't</em> provide the <code>data</code> argument here. <code>chain</code> automatically passes the result of <code>fetch_data</code> to the <em>next</em> task in the sequence. Since the next task is a <code>chord</code> containing a <code>group</code>, Celery cleverly passes the <code>data</code> to <em>each</em> task within that group.</li>
<li><code>combine_results.s()</code>: Creates the signature for the final step (the chord's body). It doesn't need arguments initially because the <code>chord</code> will automatically pass the list of results from the header group to it.</li>
<li><code>chain(...)</code>: Connects <code>fetch_data</code> to the <code>chord</code>.</li>
<li><code>chord(group(...), ...)</code>: Defines that the group must finish before <code>combine_results</code> is called.</li>
<li><code>group(...)</code>: Defines that <code>process_part_a</code> and <code>process_part_b</code> run in parallel.</li>
<li><code>workflow.apply_async()</code>: This sends the <em>first</em> task (<code>fetch_data</code>) to the broker. The rest of the workflow is encoded in the task's options (like <code>link</code> or <code>chord</code> information) so that Celery knows what to do next after each step completes.</li>
</ul>
<p>If you run this script (and have a <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a> running), you'll see the tasks execute in the worker logs, respecting the defined dependencies and parallelism. <code>fetch_data</code> runs first, then <code>process_part_a</code> and <code>process_part_b</code> run concurrently, and finally <code>combine_results</code> runs after both A and B are done.</p>
<h2><a class="anchor" id="autotoc_md1104"></a>
How It Works Internally (Simplified Walkthrough)</h2>
<p>Let's trace a simpler workflow: <code>my_chain = (add.s(2, 2) | add.s(4))</code></p>
<ol type="1">
<li><b>Workflow Definition:</b> When you create <code>my_chain</code>, Celery creates a <code>chain</code> object containing the signatures <code>add.s(2, 2)</code> and <code>add.s(4)</code>.</li>
<li><b>Sending (<code>my_chain.apply_async()</code>):</b><ul>
<li>Celery looks at the first task in the chain: <code>add.s(2, 2)</code>.</li>
<li>It prepares to send this task message to the <a class="el" href="../../d3/dd5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_204__broker__connection____amqp__.html">Broker Connection (AMQP)</a>.</li>
<li>Crucially, it adds a special option to the message, often called <code>link</code> (or uses the <code>chain</code> field in newer protocols). This option contains the <em>signature</em> of the next task in the chain: <code>add.s(4)</code>.</li>
<li>The message for <code>add(2, 2)</code> (with the link to <code>add(4)</code>) is sent to the broker.</li>
</ul>
</li>
<li><b>Worker 1 Executes First Task:</b><ul>
<li>A <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a> picks up the message for <code>add(2, 2)</code>.</li>
<li>It runs the <code>add</code> function with arguments <code>(2, 2)</code>. The result is <code>4</code>.</li>
<li>The worker stores the result <code>4</code> in the <a class="el" href="../../d3/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_206__result__backend.html">Result Backend</a> (if configured).</li>
<li>The worker notices the <code>link</code> option in the original message, pointing to <code>add.s(4)</code>.</li>
</ul>
</li>
<li><b>Worker 1 Sends Second Task:</b><ul>
<li>The worker takes the result of the first task (<code>4</code>).</li>
<li>It uses the linked signature <code>add.s(4)</code>.</li>
<li>It <em>prepends</em> the result (<code>4</code>) to the arguments of the linked signature, making it effectively <code>add.s(4, 4)</code>. <em>(Note: The original <code>4</code> in <code>add.s(4)</code> came from the chain definition, the first <code>4</code> is the result)</em>.</li>
<li>It sends a <em>new</em> message to the broker for <code>add(4, 4)</code>.</li>
</ul>
</li>
<li><b>Worker 2 Executes Second Task:</b><ul>
<li>Another (or the same) worker picks up the message for <code>add(4, 4)</code>.</li>
<li>It runs <code>add(4, 4)</code>. The result is <code>8</code>.</li>
<li>It stores the result <code>8</code> in the backend.</li>
<li>There are no more links, so the chain is complete.</li>
</ul>
</li>
</ol>
<p><code>group</code> works by sending all task messages in the group concurrently. <code>chord</code> is more complex; it involves the workers coordinating via the <a class="el" href="../../d3/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_206__result__backend.html">Result Backend</a> to count completed tasks in the header before the callback task is finally sent.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client as Your Code</div>
<div class="line">    participant Canvas as workflow = chain(...)</div>
<div class="line">    participant Broker as Message Broker</div>
<div class="line">    participant Worker as Celery Worker</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;Canvas: workflow.apply_async()</div>
<div class="line">    Note over Canvas: Prepare msg for add(2, 2) with link=add.s(4)</div>
<div class="line">    Canvas-&gt;&gt;Broker: Send Task 1 msg (&#39;add&#39;, (2, 2), link=add.s(4), id=T1)</div>
<div class="line">    Broker--&gt;&gt;Canvas: Ack</div>
<div class="line">    Canvas--&gt;&gt;Client: Return AsyncResult(id=T2) # ID of the *last* task in chain</div>
<div class="line"> </div>
<div class="line">    Worker-&gt;&gt;Broker: Fetch msg (T1)</div>
<div class="line">    Broker--&gt;&gt;Worker: Deliver Task 1 msg</div>
<div class="line">    Worker-&gt;&gt;Worker: Execute add(2, 2) -&gt; returns 4</div>
<div class="line">    Note over Worker: Store result 4 for T1 in Backend</div>
<div class="line">    Worker-&gt;&gt;Worker: Check &#39;link&#39; option -&gt; add.s(4)</div>
<div class="line">    Note over Worker: Prepare msg for add(4, 4) using result 4 + linked args</div>
<div class="line">    Worker-&gt;&gt;Broker: Send Task 2 msg (&#39;add&#39;, (4, 4), id=T2)</div>
<div class="line">    Broker--&gt;&gt;Worker: Ack</div>
<div class="line">    Worker-&gt;&gt;Broker: Ack Task 1 msg complete</div>
<div class="line"> </div>
<div class="line">    Worker-&gt;&gt;Broker: Fetch msg (T2)</div>
<div class="line">    Broker--&gt;&gt;Worker: Deliver Task 2 msg</div>
<div class="line">    Worker-&gt;&gt;Worker: Execute add(4, 4) -&gt; returns 8</div>
<div class="line">    Note over Worker: Store result 8 for T2 in Backend</div>
<div class="line">    Worker-&gt;&gt;Broker: Ack Task 2 msg complete</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1105"></a>
Code Dive: Canvas Implementation</h2>
<p>The logic for signatures and primitives resides primarily in <code>celery/canvas.py</code>.</p>
<ul>
<li><p class="startli"><b><code>Signature</code> Class:</b></p><ul>
<li>Defined in <code>celery/canvas.py</code>. It's essentially a dictionary subclass holding <code>task</code>, <code>args</code>, <code>kwargs</code>, <code>options</code>, etc.</li>
<li>The <code>.s()</code> method on a <code>Task</code> instance (in <code>celery/app/task.py</code>) is a shortcut to create a <code>Signature</code>.</li>
<li><code>apply_async</code>: Prepares arguments/options by calling <code>_merge</code> and then delegates to <code>self.type.apply_async</code> (the task's method) or <code>app.send_task</code>.</li>
<li><code>link</code>, <code>link_error</code>: Methods that modify the <code>options</code> dictionary to add callbacks.</li>
<li><code>__or__</code>: The pipe operator (<code>|</code>) overload. It checks the type of the right-hand operand (<code>other</code>) and constructs a <code>_chain</code> object accordingly.</li>
</ul>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1106"></a>
Simplified from celery/canvas.py</h1>
<p>class Signature(dict): </p>
<h1><a class="anchor" id="autotoc_md1107"></a>
... methods like <b>init</b>, clone, set, apply_async ...</h1>
<p>def link(self, callback): </p>
<h1><a class="anchor" id="autotoc_md1108"></a>
Appends callback signature to the 'link' list in options</h1>
<p>return self.append_to_list_option('link', callback)</p>
<p>def link_error(self, errback): </p>
<h1><a class="anchor" id="autotoc_md1109"></a>
Appends errback signature to the 'link_error' list in options</h1>
<p>return self.append_to_list_option('link_error', errback)</p>
<p>def <b>or</b>(self, other): </p>
<h1><a class="anchor" id="autotoc_md1110"></a>
Called when you use the pipe '|' operator</h1>
<p>if isinstance(other, Signature): </p>
<h1><a class="anchor" id="autotoc_md1111"></a>
task | task -&gt; chain</h1>
<p>return _chain(self, other, app=self._app) </p>
<h1><a class="anchor" id="autotoc_md1112"></a>
... other cases for group, chain ...</h1>
<p>return NotImplemented ```</p>
<ul>
<li><p class="startli"><b><code>_chain</code> Class:</b></p><ul>
<li>Also in <code>celery/canvas.py</code>, inherits from <code>Signature</code>. Its <code>task</code> name is hardcoded to &lsquo;'celery.chain&rsquo;<code>. The actual task signatures are stored in</code>kwargs['tasks']<code>. *</code>apply_async<code>/</code>run<code>: Contains the logic to handle sending the first task with the rest of the chain embedded in the options (either via</code>link<code>for protocol 1 or the</code>chain<code>message property for protocol 2). *</code>prepare_steps`: This complex method recursively unwraps nested primitives (like a chain within a chain, or a group that needs to become a chord) and sets up the linking between steps.</li>
</ul>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1113"></a>
Simplified concept from celery/canvas.py (chain execution)</h1>
<p>class _chain(Signature): </p>
<h1><a class="anchor" id="autotoc_md1114"></a>
... <b>init</b>, <b>or</b> ...</h1>
<p>def apply_async(self, args=None, kwargs=None, **options): </p>
<h1><a class="anchor" id="autotoc_md1115"></a>
... handle always_eager ...</h1>
<p>return self.run(args, kwargs, app=self.app, **options)</p>
<p>def run(self, args=None, kwargs=None, app=None, **options): </p>
<h1><a class="anchor" id="autotoc_md1116"></a>
... setup ...</h1>
<p>tasks, results = self.prepare_steps(...) # Unroll and freeze tasks</p>
<p>if results: # If there are tasks to run first_task = tasks.pop() # Get the first task (list is reversed) remaining_chain = tasks if tasks else None</p>
<h1><a class="anchor" id="autotoc_md1117"></a>
Determine how to pass the chain info (link vs. message field)</h1>
<p>use_link = self._use_link # ... logic to decide ...</p>
<p>if use_link: </p>
<h1><a class="anchor" id="autotoc_md1118"></a>
Protocol 1: Link first task to the second task</h1>
<p>if remaining_chain: first_task.link(remaining_chain.pop()) </p>
<h1><a class="anchor" id="autotoc_md1119"></a>
(Worker handles subsequent links)</h1>
<p>options_to_apply = options # Pass original options else: </p>
<h1><a class="anchor" id="autotoc_md1120"></a>
Protocol 2: Embed the rest of the reversed chain in options</h1>
<p>options_to_apply = ChainMap({'chain': remaining_chain}, options)</p>
<h1><a class="anchor" id="autotoc_md1121"></a>
Send the <em>first</em> task only</h1>
<p>result_from_apply = first_task.apply_async(**options_to_apply) </p>
<h1><a class="anchor" id="autotoc_md1122"></a>
Return AsyncResult of the <em>last</em> task in the original chain</h1>
<p>return results[0] ```</p>
<ul>
<li><b><code>group</code> Class:</b><ul>
<li>In <code>celery/canvas.py</code>. Its <code>task</code> name is &lsquo;'celery.group&rsquo;<code>. *</code>apply_async<code>: Iterates through its</code>tasks<code>, freezes each one (assigning a common</code>group_id<code>), sends their messages, and collects the</code>AsyncResult<code>objects into a</code>GroupResult<code>. It uses a</code>barrier<code>(from the</code>vine<code>library) to track completion.</code></li>
</ul>
</li>
<li><code> **</code>chord<code>Class:**<ul>
<li>In</li>
</ul>
</code>celery/canvas.py<code>. Its</code>task<code>name is</code>'celery.chord'<code>. *</code>apply_async<code>/</code>run<code>: Coordinates with the result backend (</code>backend.apply_chord<code>). It typically runs the header</code>group<code>first, configuring it to notify the backend upon completion. The backend then triggers the</code>body` task once the count is reached.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1123"></a>
Conclusion</h2>
<p>Celery Canvas transforms simple tasks into powerful workflow components.</p>
<ul>
<li>A <b>Signature</b> (<code>task.s()</code>) captures the details for a single task call without running it.</li>
<li>Primitives like <b><code>chain</code></b> (<code>|</code>), <b><code>group</code></b>, and <b><code>chord</code></b> combine signatures to define complex execution flows:<ul>
<li><code>chain</code>: Sequence (output of one to input of next).</li>
<li><code>group</code>: Parallel execution.</li>
<li><code>chord</code>: Parallel execution followed by a callback with all results.</li>
</ul>
</li>
<li>You compose these primitives like building with Lego bricks to model your application's logic.</li>
<li>Calling <code>.apply_async()</code> on a workflow primitive starts the process by sending the first task(s), embedding the rest of the workflow logic in the task options or using backend coordination.</li>
</ul>
<p>Canvas allows you to move complex orchestration logic out of your application code and into Celery, making your tasks more modular and your overall system more robust.</p>
<p>Now that you can build and run complex workflows, how do you monitor what's happening inside Celery? How do you know when tasks start, finish, or fail in real-time?</p>
<p><b>Next:</b> <a class="el" href="../../d4/daa/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_209__events.html">Chapter 9: Events</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
