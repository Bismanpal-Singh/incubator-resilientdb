#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 08_agentlogger___monitor</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/dee/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_208__agentlogger______monitor.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">08_agentlogger___monitor</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md3196"></a>
autotoc_md3196</h2>
<p>layout: default title: "AgentLogger &amp; Monitor" parent: "SmolaAgents" </p>
<h2><a class="anchor" id="autotoc_md3197"></a>
nav_order: 8</h2>
<h1><a class="anchor" id="autotoc_md3198"></a>
Chapter 8: AgentLogger &amp; Monitor - Observing Your Agent in Action</h1>
<p>Welcome to the final chapter of the SmolaAgents tutorial! In <a class="el" href="../../d6/df3/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_207__agenttype.html">Chapter 7: AgentType</a>, we saw how <code>SmolaAgents</code> handles different kinds of data like text, images, and audio using specialized containers. Now that our agent can perform complex tasks (<a class="el" href="../../dc/d92/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_201__multistepagent.html">Chapter 1: MultiStepAgent</a>), use various <a class="el" href="../../d4/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_203__tool.html">Tools</a>, remember its progress (<a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">Chapter 4: AgentMemory</a>), and even handle diverse data types, a new question arises: <b>How do we actually see what the agent is doing?</b></p>
<p>What if the agent gets stuck in a loop? What if it uses the wrong tool or gives an unexpected answer? How can we peek inside its "mind" to understand its reasoning, track its actions, and maybe figure out what went wrong or how well it's performing?</p>
<h2><a class="anchor" id="autotoc_md3199"></a>
The Problem: Flying Blind</h2>
<p>Imagine driving a car with no dashboard. You wouldn't know your speed, fuel level, or if the engine was overheating. You'd be driving blind! Or imagine an airplane without its "black box" flight recorder – after an incident, it would be much harder to understand what happened.</p>
<p><img src="https://img.icons8.com/ios/50/000000/car--v1.png" alt="Car with no dashboard" class="inline"/> ❓❓❓</p>
<p>Running an AI agent without visibility is similar. Without seeing its internal steps, thoughts, and actions, debugging problems or understanding its behavior becomes incredibly difficult. We need a way to observe the agent in real-time and record its performance.</p>
<h2><a class="anchor" id="autotoc_md3200"></a>
The Solution: The Dashboard (<code>AgentLogger</code>) and Black Box (<code>Monitor</code>)</h2>
<p><code>SmolaAgents</code> provides two key components to give you this visibility:</p>
<ol type="1">
<li><b><code>AgentLogger</code> (The Dashboard):</b> This component provides <b>structured, real-time logging</b> of the agent's activities directly to your console (or wherever you run your Python script). It uses a library called <code>rich</code> to display colorful, formatted output, making it easy to follow:<ul>
<li>Which step the agent is on.</li>
<li>The LLM's thoughts and the action it plans to take.</li>
<li>Which <a class="el" href="../../d4/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_203__tool.html">Tool</a> is being called and with what arguments.</li>
<li>The results (observations) from the tool.</li>
<li>Any errors encountered. It's like watching the car's speedometer, fuel gauge, and warning lights as you drive.</li>
</ul>
</li>
<li><b><code>Monitor</code> (The Black Box):</b> This component works quietly in the background, <b>tracking key performance metrics</b> during the agent's run. It records data like:<ul>
<li>How long each step took (duration).</li>
<li>How many tokens the LLM used for input and output (if the <a class="el" href="../../dc/db5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_202__model__interface.html">Model Interface</a> provides this). This data isn't usually displayed as prominently as the logger's output but is stored and can be used later for analysis, cost calculation, or identifying performance bottlenecks. It's like the airplane's flight data recorder.</li>
</ul>
</li>
</ol>
<p>Both <code>AgentLogger</code> and <code>Monitor</code> are automatically set up and used by the <code>MultiStepAgent</code>, making observation easy!</p>
<h2><a class="anchor" id="autotoc_md3201"></a>
<code>AgentLogger</code>: Your Real-Time Dashboard</h2>
<p>The <code>AgentLogger</code> is your primary window into the agent's live execution. It makes the <b>Think -&gt; Act -&gt; Observe</b> cycle visible.</p>
<p><b>How It's Used (Automatic!)</b></p>
<p>When you create a <code>MultiStepAgent</code>, it automatically creates an <code>AgentLogger</code> instance, usually stored in <code>self.logger</code>. Throughout the agent's <code>run</code> process, various methods within the agent call <code>self.logger</code> to print information:</p>
<ul>
<li><code>agent.run()</code> calls <code>self.logger.log_task()</code> to show the initial task.</li>
<li><code>agent._execute_step()</code> calls <code>self.logger.log_rule()</code> to mark the beginning of a new step.</li>
<li>If the agent uses code (like <code>CodeAgent</code>), it calls <code>self.logger.log_code()</code> to show the code being executed.</li>
<li>It logs tool calls using <code>self.logger.log()</code>.</li>
<li>It logs observations using <code>self.logger.log()</code>.</li>
<li>It logs errors using <code>self.logger.log_error()</code>.</li>
<li>It logs the final answer using <code>self.logger.log()</code>.</li>
</ul>
<p><b>Example Output (Simulated)</b></p>
<p>The <code>AgentLogger</code> uses <code>rich</code> to make the output colorful and easy to read. Here's a simplified idea of what you might see in your console for our "Capital and Weather" example:</p>
<div class="fragment"><div class="line">╭─[bold] New run ─ ToolCallingAgent [/bold]────────────────────────────────╮</div>
<div class="line">│                                                                       │</div>
<div class="line">│ [bold]What is the capital of France, and what is its current weather?[/bold] │</div>
<div class="line">│                                                                       │</div>
<div class="line">╰────────────────────────── LiteLLMModel - gpt-3.5-turbo ─╯</div>
<div class="line"> </div>
<div class="line">━━━[bold] Step 1 [/bold]━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</div>
<div class="line">INFO     ╭─ Thinking... ───────────────────────────────────────────────────╮</div>
<div class="line">INFO     │ Thought: The user wants the capital of France and its weather.│</div>
<div class="line">INFO     │ First, I need to find the capital. I can use the search tool. │</div>
<div class="line">INFO     ╰─────────────────────────────────────────────────────────────────╯</div>
<div class="line">INFO     Panel(Text(&quot;Calling tool: &#39;search&#39; with arguments: {&#39;query&#39;: &#39;Capital of France&#39;}&quot;))</div>
<div class="line">INFO     Observations: Paris</div>
<div class="line">DEBUG    [Step 1: Duration 1.52 seconds| Input tokens: 150 | Output tokens: 50]</div>
<div class="line"> </div>
<div class="line">━━━[bold] Step 2 [/bold]━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</div>
<div class="line">INFO     ╭─ Thinking... ───────────────────────────────────────────────────╮</div>
<div class="line">INFO     │ Thought: I have the capital, which is Paris. Now I need the   │</div>
<div class="line">INFO     │ weather for Paris. I can use the weather tool.                │</div>
<div class="line">INFO     ╰─────────────────────────────────────────────────────────────────╯</div>
<div class="line">INFO     Panel(Text(&quot;Calling tool: &#39;weather&#39; with arguments: {&#39;location&#39;: &#39;Paris&#39;}&quot;))</div>
<div class="line">INFO     Observations: Sunny, 25°C</div>
<div class="line">DEBUG    [Step 2: Duration 1.81 seconds| Input tokens: 210 | Output tokens: 105]</div>
<div class="line"> </div>
<div class="line">━━━[bold] Step 3 [/bold]━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━</div>
<div class="line">INFO     ╭─ Thinking... ───────────────────────────────────────────────────╮</div>
<div class="line">INFO     │ Thought: I have both the capital (Paris) and the weather      │</div>
<div class="line">INFO     │ (Sunny, 25°C). I have fulfilled the user&#39;s request. I should  │</div>
<div class="line">INFO     │ use the final_answer tool.                                    │</div>
<div class="line">INFO     ╰─────────────────────────────────────────────────────────────────╯</div>
<div class="line">INFO     Panel(Text(&quot;Calling tool: &#39;final_answer&#39; with arguments: {&#39;answer&#39;: &#39;The capital of France is Paris, and the current weather there is Sunny, 25°C.&#39;}&quot;))</div>
<div class="line">INFO     [bold #d4b702]Final answer:[/bold #d4b702] The capital of France is Paris, and the current weather there is Sunny, 25°C.</div>
<div class="line">DEBUG    [Step 3: Duration 1.25 seconds| Input tokens: 280 | Output tokens: 170]</div>
</div><!-- fragment --><p><em>(Note: This is a conceptual representation. The exact formatting, colors, and details might vary. The "Thinking..." part is simulated; the logger typically shows the raw model output or parsed action.)</em></p>
<p><b>Log Levels</b></p>
<p>You can control how much detail the logger shows using the <code>verbosity_level</code> parameter when creating the agent:</p>
<ul>
<li><code>LogLevel.INFO</code> (Default): Shows the main steps, tool calls, observations, final answer, and errors. Good for general use.</li>
<li><code>LogLevel.DEBUG</code>: Shows everything <code>INFO</code> shows, plus the detailed LLM inputs/outputs and performance metrics from the <code>Monitor</code>. Useful for deep debugging.</li>
<li><code>LogLevel.ERROR</code>: Only shows critical error messages.</li>
<li><code>LogLevel.OFF</code>: Shows nothing.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">from</span> smolagents <span class="keyword">import</span> CodeAgent</div>
<div class="line"><span class="keyword">from</span> smolagents.models <span class="keyword">import</span> LiteLLMModel</div>
<div class="line"><span class="keyword">from</span> smolagents.monitoring <span class="keyword">import</span> LogLevel <span class="comment"># Import LogLevel</span></div>
<div class="line"> </div>
<div class="line">llm = LiteLLMModel(model_id=<span class="stringliteral">&quot;gpt-3.5-turbo&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create an agent with DEBUG level logging</span></div>
<div class="line">agent_debug = CodeAgent(</div>
<div class="line">    model=llm,</div>
<div class="line">    tools=[],</div>
<div class="line">    verbosity_level=LogLevel.DEBUG <span class="comment"># Set the level here</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># This agent will print more detailed logs when run</span></div>
<div class="line"><span class="comment"># agent_debug.run(&quot;What is 2+2?&quot;)</span></div>
</div><!-- fragment --><p><b>Code Glimpse (<code>monitoring.py</code> and <code>agents.py</code>)</b></p>
<ul>
<li><p class="startli"><b><code>AgentLogger</code> Class:</b> It uses the <code>rich.console.Console</code> to print formatted output based on the log level.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3202"></a>
&mdash; File: monitoring.py (Simplified AgentLogger) &mdash;</h1>
<p>from enum import IntEnum from rich.console import Console from rich.panel import Panel from rich.syntax import Syntax from rich.rule import Rule </p>
<h1><a class="anchor" id="autotoc_md3203"></a>
... other rich imports ...</h1>
<p>class LogLevel(IntEnum): OFF = -1 ERROR = 0 INFO = 1 DEBUG = 2</p>
<p>YELLOW_HEX = "#d4b702" # Used for styling</p>
<p>class AgentLogger: def <b>init</b>(self, level: LogLevel = LogLevel.INFO): self.level = level </p>
<h1><a class="anchor" id="autotoc_md3204"></a>
The core object from the 'rich' library for printing</h1>
<p>self.console = Console()</p>
<p>def log(self, *args, level: LogLevel = LogLevel.INFO, **kwargs): """Logs a message if the level is sufficient.""" if level &lt;= self.level: self.console.print(*args, **kwargs)</p>
<p>def log_error(self, error_message: str): """Logs an error message.""" self.log(error_message, style="bold red", level=LogLevel.ERROR)</p>
<p>def log_code(self, title: str, content: str, level: LogLevel = LogLevel.INFO): """Logs a Python code block with syntax highlighting.""" self.log( Panel(Syntax(content, lexer="python", ...), title=title, ...), level=level )</p>
<p>def log_rule(self, title: str, level: LogLevel = LogLevel.INFO): """Logs a horizontal rule separator.""" self.log(Rule("[bold]" + title, style=YELLOW_HEX), level=level)</p>
<p>def log_task(self, content: str, subtitle: str, title: Optional[str] = None, level: LogLevel = LogLevel.INFO): """Logs the initial task.""" self.log(Panel(f"\n[bold]{content}\n", title=title, subtitle=subtitle, ...), level=level)</p>
<h1><a class="anchor" id="autotoc_md3205"></a>
... other helper methods for specific formatting ...</h1>
<p>```</p>
<ul>
<li><p class="startli"><b>Agent Using the Logger:</b> The <code>MultiStepAgent</code> calls <code>self.logger</code> methods.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3206"></a>
&mdash; File: agents.py (Simplified Agent using Logger) &mdash;</h1>
<p>from .monitoring import AgentLogger, LogLevel</p>
<p>class MultiStepAgent: def <b>init</b>(self, ..., verbosity_level: LogLevel = LogLevel.INFO): </p>
<h1><a class="anchor" id="autotoc_md3207"></a>
... other setup ...</h1>
<p>self.logger = AgentLogger(level=verbosity_level) </p>
<h1><a class="anchor" id="autotoc_md3208"></a>
...</h1>
<p>def run(self, task: str, ...): </p>
<h1><a class="anchor" id="autotoc_md3209"></a>
...</h1>
<p>self.logger.log_task(content=self.task, ..., level=LogLevel.INFO) </p>
<h1><a class="anchor" id="autotoc_md3210"></a>
... call _run ...</h1>
<p>def _execute_step(self, task: str, memory_step: ActionStep): self.logger.log_rule(f"Step {self.step_number}", level=LogLevel.INFO) try: </p>
<h1><a class="anchor" id="autotoc_md3211"></a>
... (Think phase: LLM call) ...</h1>
<h1><a class="anchor" id="autotoc_md3212"></a>
... (Act phase: Execute tool/code) ...</h1>
<h1><a class="anchor" id="autotoc_md3213"></a>
Example for CodeAgent:</h1>
<h1><a class="anchor" id="autotoc_md3214"></a>
self.logger.log_code("Executing code:", code_action, level=LogLevel.INFO)</h1>
<h1><a class="anchor" id="autotoc_md3215"></a>
observation = self.python_executor(code_action)</h1>
<h1><a class="anchor" id="autotoc_md3216"></a>
Example for ToolCallingAgent:</h1>
<h1><a class="anchor" id="autotoc_md3217"></a>
self.logger.log(Panel(f"Calling tool: '{tool_name}' ..."), level=LogLevel.INFO)</h1>
<h1><a class="anchor" id="autotoc_md3218"></a>
observation = self.execute_tool_call(tool_name, arguments)</h1>
<h1><a class="anchor" id="autotoc_md3219"></a>
... (Observe phase) ...</h1>
<p>self.logger.log(f"Observations: {observation}", level=LogLevel.INFO)</p>
<h1><a class="anchor" id="autotoc_md3220"></a>
... (Handle final answer) ...</h1>
<h1><a class="anchor" id="autotoc_md3221"></a>
if final_answer:</h1>
<h1><a class="anchor" id="autotoc_md3222"></a>
self.logger.log(f"Final answer: {final_answer}", style=f"bold {YELLOW_HEX}", level=LogLevel.INFO)</h1>
<p>except AgentError as e: </p>
<h1><a class="anchor" id="autotoc_md3223"></a>
Log errors using the logger's error method</h1>
<p>action_step.error = e # Store error in memory self.logger.log_error(f"Error in step {self.step_number}: {e}") # Display error</p>
<h1><a class="anchor" id="autotoc_md3224"></a>
...</h1>
<p>```</p>
<h2><a class="anchor" id="autotoc_md3225"></a>
<code>Monitor</code>: Your Performance Black Box</h2>
<p>While the <code>AgentLogger</code> shows you <em>what</em> the agent is doing, the <code>Monitor</code> tracks <em>how well</em> it's doing it in terms of performance.</p>
<p><b>How It's Used (Automatic!)</b></p>
<p>The <code>MultiStepAgent</code> also creates a <code>Monitor</code> instance (<code>self.monitor</code>). The monitor's main job is done via its <code>update_metrics</code> method. This method is automatically added to a list of <code>step_callbacks</code> in the agent. At the end of every single step, the agent calls all functions in <code>step_callbacks</code>, including <code>self.monitor.update_metrics</code>.</p>
<p>Inside <code>update_metrics</code>, the monitor:</p><ol type="1">
<li>Accesses the <code>ActionStep</code> object for the just-completed step from <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">AgentMemory</a>.</li>
<li>Reads the <code>duration</code> recorded in the <code>ActionStep</code>.</li>
<li>Accesses the agent's <a class="el" href="../../dc/db5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_202__model__interface.html">Model Interface</a> (<code>self.tracked_model</code>) to get the token counts (<code>last_input_token_count</code>, <code>last_output_token_count</code>) for the LLM call made during that step (if available).</li>
<li>Updates its internal totals (e.g., <code>total_input_token_count</code>).</li>
<li>Uses the <code>AgentLogger</code> (passed during initialization) to print these metrics, but typically only at the <code>DEBUG</code> log level, so they don't clutter the default <code>INFO</code> output.</li>
</ol>
<p><b>Example Output (at <code>DEBUG</code> level)</b></p>
<p>If you run the agent with <code>verbosity_level=LogLevel.DEBUG</code>, you'll see the monitor's output added at the end of each step log:</p>
<div class="fragment"><div class="line">[...]</div>
<div class="line">INFO     Observations: Paris</div>
<div class="line">DEBUG    [Step 1: Duration 1.52 seconds| Input tokens: 150 | Output tokens: 50]  # &lt;-- Monitor Output</div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line">INFO     Observations: Sunny, 25°C</div>
<div class="line">DEBUG    [Step 2: Duration 1.81 seconds| Input tokens: 210 | Output tokens: 105] # &lt;-- Monitor Output</div>
<div class="line"> </div>
<div class="line">[...]</div>
<div class="line">INFO     [bold #d4b702]Final answer:[/bold #d4b702] The capital of France is Paris, ...</div>
<div class="line">DEBUG    [Step 3: Duration 1.25 seconds| Input tokens: 280 | Output tokens: 170] # &lt;-- Monitor Output</div>
</div><!-- fragment --><p><b>Code Glimpse (<code>monitoring.py</code> and <code>agents.py</code>)</b></p>
<ul>
<li><p class="startli"><b><code>Monitor</code> Class:</b> Tracks metrics and logs them.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3226"></a>
&mdash; File: monitoring.py (Simplified Monitor) &mdash;</h1>
<p>from .memory import ActionStep # Needs access to step data from .models import Model # Needs access to model token counts from .monitoring import AgentLogger, LogLevel # Uses the logger to print</p>
<p>class Monitor: def <b>init</b>(self, tracked_model: Model, logger: AgentLogger): self.step_durations = [] self.tracked_model = tracked_model # Reference to the agent's model self.logger = logger # Uses the logger to output metrics self.total_input_token_count = 0 self.total_output_token_count = 0 </p>
<h1><a class="anchor" id="autotoc_md3227"></a>
... potentially other metrics ...</h1>
<p>def reset(self): """Resets metrics for a new run.""" self.step_durations = [] self.total_input_token_count = 0 self.total_output_token_count = 0</p>
<p>def update_metrics(self, step_log: ActionStep): """Callback function called after each step.""" </p>
<h1><a class="anchor" id="autotoc_md3228"></a>
1. Get duration from the step log</h1>
<p>step_duration = step_log.duration self.step_durations.append(step_duration)</p>
<p>console_outputs = f"[Step {len(self.step_durations)}: Duration {step_duration:.2f} seconds"</p>
<h1><a class="anchor" id="autotoc_md3229"></a>
2. Get token counts from the model (if available)</h1>
<p>input_tokens = getattr(self.tracked_model, "last_input_token_count", None) output_tokens = getattr(self.tracked_model, "last_output_token_count", None)</p>
<p>if input_tokens is not None and output_tokens is not None: self.total_input_token_count += input_tokens self.total_output_token_count += output_tokens </p>
<h1><a class="anchor" id="autotoc_md3230"></a>
4. Format metrics string</h1>
<p>console_outputs += ( f"| Input tokens: {self.total_input_token_count:,}" f" | Output tokens: {self.total_output_token_count:,}" ) console_outputs += "]"</p>
<h1><a class="anchor" id="autotoc_md3231"></a>
5. Log metrics using the logger (at DEBUG level)</h1>
<p>self.logger.log(console_outputs, level=LogLevel.DEBUG) # Note: logs at DEBUG</p>
<h1><a class="anchor" id="autotoc_md3232"></a>
... methods to get totals, averages etc. ...</h1>
<p>```</p>
<ul>
<li><p class="startli"><b>Agent Setting Up the Monitor:</b></p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3233"></a>
&mdash; File: agents.py (Simplified Agent setup for Monitor) &mdash;</h1>
<p>from .monitoring import Monitor from .memory import ActionStep</p>
<p>class MultiStepAgent: def <b>init</b>(self, ..., model: Model, step_callbacks: Optional[List[Callable]] = None): </p>
<h1><a class="anchor" id="autotoc_md3234"></a>
... setup logger ...</h1>
<p>self.model = model # Store the model self.monitor = Monitor(self.model, self.logger) # Create Monitor</p>
<h1><a class="anchor" id="autotoc_md3235"></a>
Add monitor's update method to callbacks</h1>
<p>self.step_callbacks = step_callbacks if step_callbacks is not None else [] self.step_callbacks.append(self.monitor.update_metrics) </p>
<h1><a class="anchor" id="autotoc_md3236"></a>
...</h1>
<p>def _finalize_step(self, memory_step: ActionStep, step_start_time: float): """Called at the very end of each step.""" memory_step.end_time = time.time() memory_step.duration = memory_step.end_time - step_start_time</p>
<h1><a class="anchor" id="autotoc_md3237"></a>
Call all registered callbacks, including monitor.update_metrics</h1>
<p>for callback in self.step_callbacks: </p>
<h1><a class="anchor" id="autotoc_md3238"></a>
Pass the completed step data to the callback</h1>
<p>callback(memory_step) </p>
<h1><a class="anchor" id="autotoc_md3239"></a>
...</h1>
<p>def run(self, ..., reset: bool = True): </p>
<h1><a class="anchor" id="autotoc_md3240"></a>
...</h1>
<p>if reset: self.memory.reset() self.monitor.reset() # Reset monitor metrics on new run </p>
<h1><a class="anchor" id="autotoc_md3241"></a>
...</h1>
<p>```</p>
<h2><a class="anchor" id="autotoc_md3242"></a>
Conclusion</h2>
<p>The <code>AgentLogger</code> and <code>Monitor</code> are your essential tools for observing and understanding your <code>SmolaAgents</code>.</p>
<ul>
<li><b><code>AgentLogger</code></b> acts as the real-time dashboard, giving you formatted, colorful console output of the agent's steps, thoughts, actions, and errors, crucial for debugging and following along.</li>
<li><b><code>Monitor</code></b> acts as the performance black box, tracking metrics like step duration and token usage, which are logged (usually at the <code>DEBUG</code> level) and useful for analysis and optimization.</li>
</ul>
<p>You've learned:</p>
<ul>
<li>Why visibility into agent execution is critical.</li>
<li>The roles of <code>AgentLogger</code> (dashboard) and <code>Monitor</code> (black box).</li>
<li>How they are automatically used by <code>MultiStepAgent</code>.</li>
<li>How <code>AgentLogger</code> provides readable, step-by-step output using <code>rich</code>.</li>
<li>How <code>Monitor</code> tracks performance metrics via step callbacks.</li>
<li>How to control log verbosity using <code>LogLevel</code>.</li>
</ul>
<p>With these tools, you're no longer flying blind! You can confidently run your agents, watch them work, understand their performance, and diagnose issues when they arise.</p>
<p>This concludes our introductory tour of the core concepts in <code>SmolaAgents</code>. We hope these chapters have given you a solid foundation to start building your own intelligent agents. Happy coding!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
