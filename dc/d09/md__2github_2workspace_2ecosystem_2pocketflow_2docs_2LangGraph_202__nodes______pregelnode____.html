#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 02_nodes___pregelnode__</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_202__nodes______pregelnode____.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">02_nodes___pregelnode__</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2114"></a>
autotoc_md2114</h2>
<p>layout: default title: "Nodes (PregelNode)" parent: "LangGraph" </p>
<h2><a class="anchor" id="autotoc_md2115"></a>
nav_order: 2</h2>
<h1><a class="anchor" id="autotoc_md2116"></a>
Chapter 2: Nodes (<code>PregelNode</code>) - The Workers of Your Graph</h1>
<p>In <a class="el" href="../../df/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_201__graph______stategraph.html">Chapter 1: Graph / StateGraph</a>, we learned how <code>StateGraph</code> acts as a blueprint or a flowchart for our application. It defines the overall structure and the shared "whiteboard" (the State) that holds information.</p>
<p>But who actually does the work? If the <code>StateGraph</code> is the assembly line blueprint, who are the workers on the line?</p>
<p>That's where <b>Nodes</b> come in!</p>
<h2><a class="anchor" id="autotoc_md2117"></a>
What Problem Do Nodes Solve?</h2>
<p>Think back to our cake baking analogy from Chapter 1. We had steps like "mix dry ingredients," "mix wet ingredients," "combine," etc. Each of these distinct actions needs to be performed by someone or something.</p>
<p>In LangGraph, <b>Nodes</b> represent these individual units of work or computation steps within your graph.</p>
<ul>
<li><b>Analogy:</b> Imagine chefs in a kitchen (the graph). Each chef (node) has a specific task: one chops vegetables, another mixes the sauce, another cooks the main course. They all work with shared ingredients (the state) from the pantry and fridge, and they put their finished components back for others to use.</li>
</ul>
<p>Nodes are the core building blocks that perform the actual logic of your application.</p>
<h2><a class="anchor" id="autotoc_md2118"></a>
Key Concepts: What Makes a Node?</h2>
<ol type="1">
<li><b>The Action:</b> At its heart, a node is usually a Python function or a LangChain Runnable. This is the code that gets executed when the node runs.</li>
<li><b>Input:</b> A node typically reads data it needs from the shared graph <b>State</b>. It receives the <em>current</em> state when it's invoked. In our <code>StateGraph</code> example from Chapter 1, both <code>add_one</code> and <code>multiply_by_two</code> received the <code>state</code> dictionary containing the current <code>value</code>.</li>
<li><b>Execution:</b> The node runs its defined logic (the function or Runnable).</li>
<li><b>Output:</b> After executing, a node in a <code>StateGraph</code> returns a dictionary. This dictionary specifies <em>which parts</em> of the shared state the node wants to <em>update</em> and what the new values should be. LangGraph takes care of merging these updates back into the main state.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2119"></a>
Adding Nodes to Your Graph (<code>add_node</code>)</h2>
<p>How do we tell our <code>StateGraph</code> about these workers? We use the <code>add_node</code> method.</p>
<p>Let's revisit the code from Chapter 1:</p>
<p><b>Step 1: Define the Node Functions</b></p>
<p>These are our "workers". They take the state and return updates.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the state structure (the whiteboard)</span></div>
<div class="line"><span class="keyword">class </span>MyState(TypedDict):</div>
<div class="line">    value: int</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node 1: Adds 1 to the value</span></div>
<div class="line"><span class="keyword">def </span>add_one(state: MyState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Running Adder Node ---&quot;</span>)</div>
<div class="line">    current_value = state[<span class="stringliteral">&#39;value&#39;</span>]</div>
<div class="line">    new_value = current_value + 1</div>
<div class="line">    print(f<span class="stringliteral">&quot;Input value: {current_value}, Output value: {new_value}&quot;</span>)</div>
<div class="line">    <span class="comment"># Return *only* the key we want to update</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;value&quot;</span>: new_value}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node 2: Multiplies the value by 2</span></div>
<div class="line"><span class="keyword">def </span>multiply_by_two(state: MyState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Running Multiplier Node ---&quot;</span>)</div>
<div class="line">    current_value = state[<span class="stringliteral">&#39;value&#39;</span>]</div>
<div class="line">    new_value = current_value * 2</div>
<div class="line">    print(f<span class="stringliteral">&quot;Input value: {current_value}, Output value: {new_value}&quot;</span>)</div>
<div class="line">    <span class="comment"># Return the update</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;value&quot;</span>: new_value}</div>
</div><!-- fragment --><p><b>Step 2: Create the Graph and Add Nodes</b></p>
<p>Here's where we hire our workers and assign them names on the assembly line.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the graph builder linked to our state</span></div>
<div class="line">workflow = StateGraph(MyState)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Add the first node:</span></div>
<div class="line"><span class="comment"># Give it the name &quot;adder&quot; and tell it to use the &#39;add_one&#39; function</span></div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;adder&quot;</span>, add_one)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Add the second node:</span></div>
<div class="line"><span class="comment"># Give it the name &quot;multiplier&quot; and tell it to use the &#39;multiply_by_two&#39; function</span></div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;multiplier&quot;</span>, multiply_by_two)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># (Edges like set_entry_point, add_edge, etc. define the flow *between* nodes)</span></div>
<div class="line"><span class="comment"># ... add edges and compile ...</span></div>
</div><!-- fragment --><ul>
<li><code>workflow.add_node("adder", add_one)</code>: This line registers the <code>add_one</code> function as a node within the <code>workflow</code> graph. We give it the unique name <code>"adder"</code>. When the graph needs to execute the "adder" step, it will call our <code>add_one</code> function.</li>
<li><code>workflow.add_node("multiplier", multiply_by_two)</code>: Similarly, this registers the <code>multiply_by_two</code> function under the name <code>"multiplier"</code>.</li>
</ul>
<p>It's that simple! You define what a step does (the function) and then register it with <code>add_node</code>, giving it a name so you can connect it using edges later.</p>
<h2><a class="anchor" id="autotoc_md2120"></a>
How Do Nodes Actually Run? (Under the Hood)</h2>
<p>You've defined the functions and added them as nodes. What happens internally when the graph executes?</p>
<ol type="1">
<li><b>Triggering:</b> The <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> (LangGraph's internal coordinator) determines which node should run next based on the graph's structure (edges) and the current state. For example, after the <code>START</code> point, it knows to run the entry point node ("adder" in our example).</li>
<li><b>Reading State:</b> Before running the node's function (<code>add_one</code>), the engine reads the necessary information from the shared state. It knows what the function needs (the <code>MyState</code> dictionary). This reading happens via mechanisms called <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a>, which manage the shared state.</li>
<li><b>Invoking the Function:</b> The engine calls the node's function (e.g., <code>add_one</code>), passing the state it just read (&lsquo;{'value&rsquo;: 5}<code>).</code></li>
<li><code> **Executing Logic:** Your function's code runs (e.g.,</code>5 + 1<code>).</code></li>
<li><code> **Receiving Updates:** The engine receives the dictionary returned by the function (e.g.,</code>{'value': 6}<code>).</code></li>
<li><code> **Writing State:** The engine uses [Channels](<a class="el" href="../../d5/d9b/03__channels_8md.html">03_channels.md</a>) again to update the shared state with the information from the returned dictionary. The state on the "whiteboard" is now modified (e.g., becomes</code>{'value': 6}`).</li>
<li><b>Next Step:</b> The engine then looks for the next edge originating from the completed node ("adder") to determine what runs next ("multiplier").</li>
</ol>
<p>Here's a simplified view of the "adder" node executing:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Engine as Pregel Engine</div>
<div class="line">    participant State (via Channels)</div>
<div class="line">    participant AdderNode as adder (add_one func)</div>
<div class="line"> </div>
<div class="line">    Engine-&gt;&gt;State (via Channels): Read &#39;value&#39; (current state is {&#39;value&#39;: 5})</div>
<div class="line">    State (via Channels)--&gt;&gt;Engine: Returns {&#39;value&#39;: 5}</div>
<div class="line">    Engine-&gt;&gt;AdderNode: Invoke add_one({&#39;value&#39;: 5})</div>
<div class="line">    Note over AdderNode: Function executes: 5 + 1 = 6</div>
<div class="line">    AdderNode--&gt;&gt;Engine: Return {&#39;value&#39;: 6}</div>
<div class="line">    Engine-&gt;&gt;State (via Channels): Write update: &#39;value&#39; = 6</div>
<div class="line">    State (via Channels)--&gt;&gt;Engine: Acknowledge (state is now {&#39;value&#39;: 6})</div>
<div class="line">    Engine-&gt;&gt;Engine: Find next node based on edge from &quot;adder&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2121"></a>
A Peek at the Code (<code>graph/state.py</code>, <code>pregel/read.py</code>)</h2>
<p>Let's look at simplified snippets to see how this maps to the code:</p>
<ul>
<li><b><code>StateGraph.add_node</code> (<code>graph/state.py</code>)</b>: ```python </li>
</ul>
<h1><a class="anchor" id="autotoc_md2122"></a>
Simplified view</h1>
<p>class StateGraph(Graph): </p>
<h1><a class="anchor" id="autotoc_md2123"></a>
... (other methods) ...</h1>
<p>def add_node( self, node: str, # The name you give the node (e.g., "adder") action: RunnableLike, # The function or Runnable (e.g., add_one) *, </p>
<h1><a class="anchor" id="autotoc_md2124"></a>
... other optional parameters ...</h1>
<p>input: Optional[Type[Any]] = None, # Optional: specific input type for this node ) -&gt; Self: </p>
<h1><a class="anchor" id="autotoc_md2125"></a>
... (checks for valid name, etc.) ...</h1>
<p>if node in self.channels: # Can't use a state key name as a node name raise ValueError(...)</p>
<h1><a class="anchor" id="autotoc_md2126"></a>
Converts your function into a standard LangChain Runnable if needed</h1>
<p>runnable = coerce_to_runnable(action, ...)</p>
<h1><a class="anchor" id="autotoc_md2127"></a>
Stores the node's details, including the runnable and input schema</h1>
<p>self.nodes[node] = StateNodeSpec( runnable=runnable, metadata=None, # Optional metadata input=input or self.schema, # Default to graph's main state schema </p>
<h1><a class="anchor" id="autotoc_md2128"></a>
... other details ...</h1>
<p>) return self ``<code> When you call</code>add_node<code>, LangGraph stores your function (</code>action<code>) under the given</code>node<code>name. It wraps your function into a standard</code>Runnable<code>object (</code>coerce_to_runnable<code>) and keeps track of what input schema it expects (usually the graph's main state schema). This stored information is a</code>StateNodeSpec`.</p>
<ul>
<li><b><code>CompiledStateGraph.attach_node</code> (<code>graph/state.py</code>)</b>: ```python </li>
</ul>
<h1><a class="anchor" id="autotoc_md2129"></a>
Simplified view (during graph.compile())</h1>
<p>class CompiledStateGraph(CompiledGraph): </p>
<h1><a class="anchor" id="autotoc_md2130"></a>
... (other methods) ...</h1>
<p>def attach_node(self, key: str, node: Optional[StateNodeSpec]) -&gt; None: </p>
<h1><a class="anchor" id="autotoc_md2131"></a>
... (handles START node specially) ...</h1>
<p>if node is not None: </p>
<h1><a class="anchor" id="autotoc_md2132"></a>
Determine what parts of the state this node needs to read</h1>
<p>input_schema = node.input input_values = list(self.builder.schemas[input_schema]) # Keys to read</p>
<h1><a class="anchor" id="autotoc_md2133"></a>
Create the internal representation: PregelNode</h1>
<p>self.nodes[key] = PregelNode( triggers=[f"branch:to:{key}"], # When should this node run? (Connected via Channels) channels=input_values, # What state keys does it read? mapper=_pick_mapper(...), # How to format the input state for the function writers=[ChannelWrite(...)], # How to write the output back to state (via Channels) bound=node.runnable, # The actual function/Runnable to execute! </p>
<h1><a class="anchor" id="autotoc_md2134"></a>
... other internal details ...</h1>
<p>) </p>
<h1><a class="anchor" id="autotoc_md2135"></a>
...</h1>
<p>``<code> During the</code>compile()<code>step, the information stored in</code>StateNodeSpec<code>is used to create the actual operational node object, which is internally called</code>PregelNode<code>. This</code>PregelNode` is the real "worker" managed by the execution engine.</p>
<ul>
<li><b><code>PregelNode</code> (<code>pregel/read.py</code>)</b>: ```python </li>
</ul>
<h1><a class="anchor" id="autotoc_md2136"></a>
Simplified view</h1>
<p>class PregelNode(Runnable): channels: Union[list[str], Mapping[str, str]] # State keys to read as input triggers: list[str] # Channel updates that activate this node mapper: Optional[Callable[[Any], Any]] # Function to format input state writers: list[Runnable] # Runnables to write output back to Channels bound: Runnable[Any, Any] # &lt;&lt; THE ACTUAL FUNCTION/RUNNABLE YOU PROVIDED &gt;&gt; </p>
<h1><a class="anchor" id="autotoc_md2137"></a>
... other attributes like retry policy, tags, etc. ...</h1>
<p>def <b>init</b>(self, *, channels, triggers, writers, bound, ...) -&gt; None: self.channels = channels self.triggers = list(triggers) self.writers = writers or [] self.bound = bound # Your code lives here! </p>
<h1><a class="anchor" id="autotoc_md2138"></a>
... initialize other attributes ...</h1>
<h1><a class="anchor" id="autotoc_md2139"></a>
... (methods for execution, handled by the Pregel engine) ...</h1>
<p>``<code> The</code>PregelNode<code>object encapsulates everything needed to run your node: *</code>bound<code>: This holds the actual function or Runnable you passed to</code>add_node<code>. *</code>channels<code>: Specifies which parts of the state (managed by [Channels](<a class="el" href="../../d5/d9b/03__channels_8md.html">03_channels.md</a>)) to read as input. *</code>triggers<code>: Specifies which [Channels](<a class="el" href="../../d5/d9b/03__channels_8md.html">03_channels.md</a>) must be updated to make this node eligible to run. *</code>writers<code>: Defines how the output of</code>bound` should be written back to the state using <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a>.</p>
<p>Don't worry too much about <code>PregelNode</code> details right now. The key idea is that <code>add_node</code> registers your function, and <code>compile</code> turns it into an executable component (<code>PregelNode</code>) that the graph engine can manage, telling it when to run, what state to read, and how to write results back.</p>
<h2><a class="anchor" id="autotoc_md2140"></a>
Conclusion</h2>
<p>You've now learned about the "workers" in your LangGraph application: <b>Nodes</b>.</p>
<ul>
<li>Nodes are the individual computational steps defined by Python functions or LangChain Runnables.</li>
<li>They read from the shared <code>StateGraph</code> state.</li>
<li>They execute their logic.</li>
<li>They return dictionaries specifying updates to the state.</li>
<li>You add them to your graph using <code>graph.add_node("node_name", your_function)</code>.</li>
<li>Internally, they are represented as <code>PregelNode</code> objects, managed by the execution engine.</li>
</ul>
<p>We have the blueprint (<code>StateGraph</code>) and the workers (<code>Nodes</code>). But how exactly does information get passed around? How does the "adder" node's output (&lsquo;{'value&rsquo;: 6}`) reliably get to the "multiplier" node? How is the state managed efficiently?</p>
<p>That's the role of <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Chapter 3: Channels</a>, the communication system of the graph.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
