#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_error_handling</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/d8a/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_206__error__handling.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_error_handling</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1814"></a>
autotoc_md1814</h2>
<p>layout: default title: "Error Handling" parent: "FastAPI" </p>
<h2><a class="anchor" id="autotoc_md1815"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md1816"></a>
Chapter 6: Error Handling</h1>
<p>Welcome back! In <a class="el" href="../../dd/dd7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_205__dependency__injection.html">Chapter 5: Dependency Injection</a>, we learned how to structure our code using dependencies to manage common tasks like pagination or database sessions. This helps keep our code clean and reusable.</p>
<p>But what happens when things don't go as planned? A user might request data that doesn't exist, or they might send invalid input. Our API needs a way to gracefully handle these situations and inform the client about what went wrong.</p>
<p><b>Our Goal Today:</b> Learn how FastAPI helps us manage errors effectively, both for problems we expect (like "item not found") and for unexpected issues like invalid input data.</p>
<h2><a class="anchor" id="autotoc_md1817"></a>
What Problem Does This Solve?</h2>
<p>Imagine our online store API. We have an endpoint like <code>/items/{item_id}</code> to fetch details about a specific item. What should happen if a user tries to access <code>/items/9999</code> but there's no item with ID 9999 in our database?</p>
<p>If we don't handle this, our application might crash or return a confusing, generic server error (like <code>500 Internal Server Error</code>). This isn't helpful for the person using our API. They need clear feedback: "The item you asked for doesn't exist."</p>
<p>Similarly, if a user tries to <em>create</em> an item (<code>POST /items/</code>) but forgets to include the required <code>price</code> field in the JSON body, we shouldn't just crash. We need to tell them, "You forgot the price field!"</p>
<p>FastAPI provides a structured way to handle these different types of errors, ensuring clear communication with the client. Think of it as setting up clear emergency procedures for your API.</p>
<h2><a class="anchor" id="autotoc_md1818"></a>
Key Concepts</h2>
<ol type="1">
<li><b><code>HTTPException</code> for Expected Errors:</b><ul>
<li>These are errors you anticipate might occur based on the client's request, like requesting a non-existent resource or lacking permissions.</li>
<li>You can <b>raise</b> <code>HTTPException</code> directly in your code.</li>
<li>You specify an appropriate HTTP <b>status code</b> (like <code>404 Not Found</code>, <code>403 Forbidden</code>) and a helpful <b>detail message</b> (like <code>"Item not found"</code>).</li>
<li>FastAPI catches this exception and automatically sends a properly formatted JSON error response to the client.</li>
</ul>
</li>
<li><b><code>RequestValidationError</code> for Invalid Input:</b><ul>
<li>This error occurs when the data sent by the client in the request (path parameters, query parameters, or request body) fails the validation rules defined by your type hints and Pydantic models (as seen in <a class="el" href="../../d0/d13/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_202__path__operations______parameter__declaration.html">Chapter 2: Path Operations &amp; Parameter Declaration</a> and <a class="el" href="../../d5/df9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_203__data__validation______serialization____pydantic__.html">Chapter 3: Data Validation &amp; Serialization (Pydantic)</a>).</li>
<li>FastAPI <b>automatically</b> catches these validation errors.</li>
<li>It sends back a <code>422 Unprocessable Entity</code> response containing detailed information about <em>which</em> fields were invalid and <em>why</em>. You usually don't need to write extra code for this!</li>
</ul>
</li>
<li><b>Custom Exception Handlers:</b><ul>
<li>For more advanced scenarios, you can define your <em>own</em> functions to handle specific types of exceptions (either built-in Python exceptions or custom ones you create).</li>
<li>This gives you full control over how errors are logged and what response is sent back to the client.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md1819"></a>
Using <code>HTTPException</code> for Expected Errors</h2>
<p>Let's solve our "item not found" problem using <code>HTTPException</code>.</p>
<ol type="1">
<li><p class="startli"><b>Import <code>HTTPException</code>:</b></p>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md1820"></a>
main.py or your router file</h1>
<p>from fastapi import FastAPI, HTTPException</p>
<p>app = FastAPI() # Or use your APIRouter</p>
<h1><a class="anchor" id="autotoc_md1821"></a>
Simple in-memory storage (like from Chapter 4)</h1>
<p>fake_items_db = {1: {"name": "Foo"}, 2: {"name": "Bar"}} ```</p>
<p><b>Explanation:</b> We import <code>HTTPException</code> directly from <code>fastapi</code>.</p>
<ol type="1">
<li><p class="startli"><b>Check and Raise in Your Path Operation:</b></p>
<p class="startli">```python @app.get("/items/{item_id}") async def read_item(item_id: int): </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md1822"></a>
Check if the requested item_id exists in our "database"</h1>
<p>if item_id not in fake_items_db: </p>
<h1><a class="anchor" id="autotoc_md1823"></a>
If not found, raise HTTPException!</h1>
<p>raise HTTPException(status_code=404, detail="Item not found")</p>
<h1><a class="anchor" id="autotoc_md1824"></a>
If found, proceed normally</h1>
<p>return {"item": fake_items_db[item_id]} ```</p>
<p><b>Explanation:</b></p><ul>
<li>Inside <code>read_item</code>, we check if the <code>item_id</code> exists as a key in our <code>fake_items_db</code> dictionary.</li>
<li>If <code>item_id</code> is <em>not</em> found, we <code>raise HTTPException(...)</code>.<ul>
<li><code>status_code=404</code>: We use the standard HTTP status code <code>404 Not Found</code>. FastAPI knows many common status codes (you can also use <code>from starlette import status; raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, ...)</code> for more readability).</li>
<li><code>detail="Item not found"</code>: We provide a human-readable message explaining the error. This will be sent back to the client in the JSON response body.</li>
</ul>
</li>
<li>If the item <em>is</em> found, the <code>raise</code> statement is skipped, and the function returns the item details as usual.</li>
</ul>
<p><b>How it Behaves:</b></p>
<ul>
<li><b>Request:</b> Client sends <code>GET /items/1</code><ul>
<li><b>Response (Status Code 200):</b> <code>json {"item": {"name": "Foo"}} </code></li>
</ul>
</li>
<li><b>Request:</b> Client sends <code>GET /items/99</code><ul>
<li><b>Response (Status Code 404):</b> <code>json {"detail": "Item not found"} </code></li>
</ul>
</li>
</ul>
<p>FastAPI automatically catches the <code>HTTPException</code> you raised and sends the correct HTTP status code along with the <code>detail</code> message formatted as JSON.</p>
<h2><a class="anchor" id="autotoc_md1825"></a>
Automatic Handling of <code>RequestValidationError</code></h2>
<p>You've already seen this in action without realizing it! When you define Pydantic models for your request bodies or use type hints for path/query parameters, FastAPI automatically validates incoming data.</p>
<p>Let's revisit the <code>create_item</code> example from <a class="el" href="../../d5/df9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_203__data__validation______serialization____pydantic__.html">Chapter 3: Data Validation &amp; Serialization (Pydantic)</a>:</p>
<div class="fragment"><div class="line"><span class="comment"># main.py or your router file</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</div>
<div class="line"> </div>
<div class="line">app = FastAPI()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Pydantic model requiring name and price</span></div>
<div class="line"><span class="keyword">class </span>Item(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    price: float</div>
<div class="line">    description: str | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.post(&quot;/items/&quot;)</span></div>
<div class="line"><span class="comment"># Expects request body matching the Item model</span></div>
<div class="line"><span class="keyword">async def </span>create_item(item: Item):</div>
<div class="line">    <span class="comment"># If execution reaches here, validation PASSED automatically.</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;message&quot;</span>: <span class="stringliteral">&quot;Item received!&quot;</span>, <span class="stringliteral">&quot;item_data&quot;</span>: item.model_dump()}</div>
</div><!-- fragment --><p><b>How it Behaves (Automatically):</b></p>
<ul>
<li><b>Request:</b> Client sends <code>POST /items/</code> with a <em>valid</em> JSON body: <code>json { "name": "Gadget", "price": 19.95 } </code><ul>
<li><b>Response (Status Code 200):</b> <code>json { "message": "Item received!", "item_data": { "name": "Gadget", "price": 19.95, "description": null } } </code></li>
</ul>
</li>
<li><b>Request:</b> Client sends <code>POST /items/</code> with an <em>invalid</em> JSON body (missing <code>price</code>): <code>json { "name": "Widget" } </code><ul>
<li><b>Response (Status Code 422):</b> FastAPI <em>automatically</em> intercepts this before <code>create_item</code> runs and sends: <code>json { "detail": [ { "type": "missing", "loc": [ "body", "price" ], "msg": "Field required", "input": { "name": "Widget" }, "url": "..." // Link to Pydantic error docs } ] } </code></li>
</ul>
</li>
<li><b>Request:</b> Client sends <code>POST /items/</code> with an <em>invalid</em> JSON body (wrong type for <code>price</code>): <code>json { "name": "Doohickey", "price": "cheap" } </code><ul>
<li><b>Response (Status Code 422):</b> FastAPI automatically sends: <code>json { "detail": [ { "type": "float_parsing", "loc": [ "body", "price" ], "msg": "Input should be a valid number, unable to parse string as a number", "input": "cheap", "url": "..." } ] } </code></li>
</ul>
</li>
</ul>
<p>Notice that we didn't write any <code>try...except</code> blocks or <code>if</code> statements in <code>create_item</code> to handle these validation issues. FastAPI and Pydantic take care of it, providing detailed error messages that tell the client exactly what went wrong and where (<code>loc</code>). This is a huge time saver!</p>
<h2><a class="anchor" id="autotoc_md1826"></a>
Custom Exception Handlers (A Quick Look)</h2>
<p>Sometimes, you might want to handle specific errors in a unique way. Maybe you want to log a particular error to a monitoring service, or perhaps you need to return error responses in a completely custom format different from FastAPI's default.</p>
<p>FastAPI allows you to register <b>exception handlers</b> using the <code>@app.exception_handler()</code> decorator.</p>
<p><b>Example:</b> Imagine you have a custom error <code>UnicornNotFound</code> and want to return a <code>418 I'm a teapot</code> status code when it occurs.</p>
<ol type="1">
<li><p class="startli"><b>Define the Custom Exception:</b></p>
<p class="startli"><code>python @section autotoc_md1827 Can be in your main file or a separate exceptions.py class UnicornNotFound(Exception): def __init__(self, name: str): self.name = name </code></p>
</li>
<li><p class="startli"><b>Define the Handler Function:</b></p>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md1828"></a>
main.py</h1>
<p>from fastapi import FastAPI, Request from fastapi.responses import JSONResponse </p>
<h1><a class="anchor" id="autotoc_md1829"></a>
Assuming UnicornNotFound is defined above or imported</h1>
<p>app = FastAPI()</p>
<h1><a class="anchor" id="autotoc_md1830"></a>
Decorator registers this function to handle UnicornNotFound errors</h1>
<p>@app.exception_handler(UnicornNotFound) async def unicorn_exception_handler(request: Request, exc: UnicornNotFound): </p>
<h1><a class="anchor" id="autotoc_md1831"></a>
This function runs whenever UnicornNotFound is raised</h1>
<p>return JSONResponse( status_code=418, # I'm a teapot! content={"message": f"Oops! Can't find unicorn named: {exc.name}."}, ) ```</p>
<p><b>Explanation:</b></p><ul>
<li><code>@app.exception_handler(UnicornNotFound)</code>: This tells FastAPI that the <code>unicorn_exception_handler</code> function should be called whenever an error of type <code>UnicornNotFound</code> is raised <em>and not caught</em> elsewhere.</li>
<li>The handler function receives the <code>request</code> object and the exception instance (<code>exc</code>).</li>
<li>It returns a <code>JSONResponse</code> with the desired status code (418) and a custom content dictionary.</li>
</ul>
<p><b>Raise the Custom Exception in a Path Operation:</b></p>
<p><code>python @app.get("/unicorns/{name}") async def read_unicorn(name: str): if name == "yolo": @section autotoc_md1832 Raise our custom exception raise UnicornNotFound(name=name) return {"unicorn_name": name, "message": "Unicorn exists!"} </code></p>
<p><b>How it Behaves:</b></p>
<ul>
<li><b>Request:</b> <code>GET /unicorns/sparklehoof</code><ul>
<li><b>Response (Status Code 200):</b> <code>json {"unicorn_name": "sparklehoof", "message": "Unicorn exists!"} </code></li>
</ul>
</li>
<li><b>Request:</b> <code>GET /unicorns/yolo</code><ul>
<li><b>Response (Status Code 418):</b> (Handled by <code>unicorn_exception_handler</code>) <code>json {"message": "Oops! Can't find unicorn named: yolo."} </code></li>
</ul>
</li>
</ul>
<p>Custom handlers provide flexibility, but for most common API errors, <code>HTTPException</code> and the automatic <code>RequestValidationError</code> handling are sufficient.</p>
<h2><a class="anchor" id="autotoc_md1833"></a>
How it Works Under the Hood (Simplified)</h2>
<p>When an error occurs during a request, FastAPI follows a process to decide how to respond:</p>
<p><b>Scenario 1: Raising <code>HTTPException</code></b></p>
<ol type="1">
<li><b>Raise:</b> Your path operation code (e.g., <code>read_item</code>) executes <code>raise HTTPException(status_code=404, detail="Item not found")</code>.</li>
<li><b>Catch:</b> FastAPI's internal request/response cycle catches this specific <code>HTTPException</code>.</li>
<li><b>Find Handler:</b> FastAPI checks if there's a custom handler registered for <code>HTTPException</code>. If not (which is usually the case unless you override it), it uses its <b>default handler</b> for <code>HTTPException</code>.</li>
<li><b>Default Handler Executes:</b> The default handler (<code>fastapi.exception_handlers.http_exception_handler</code>) takes the <code>status_code</code> and <code>detail</code> from the exception you raised.</li>
<li><b>Create Response:</b> It creates a <code>starlette.responses.JSONResponse</code> containing <code>{"detail": exc.detail}</code> and sets the status code to <code>exc.status_code</code>.</li>
<li><b>Send Response:</b> This JSON response is sent back to the client.</li>
</ol>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client</div>
<div class="line">    participant FastAPIApp as FastAPI App</div>
<div class="line">    participant RouteHandler as Route Handler (read_item)</div>
<div class="line">    participant DefaultHTTPExceptionHandler as Default HTTPException Handler</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;+FastAPIApp: GET /items/99</div>
<div class="line">    FastAPIApp-&gt;&gt;+RouteHandler: Call read_item(item_id=99)</div>
<div class="line">    RouteHandler-&gt;&gt;RouteHandler: Check DB: item 99 not found</div>
<div class="line">    RouteHandler--&gt;&gt;-FastAPIApp: raise HTTPException(404, &quot;Item not found&quot;)</div>
<div class="line">    Note over FastAPIApp: Catches HTTPException</div>
<div class="line">    FastAPIApp-&gt;&gt;+DefaultHTTPExceptionHandler: Handle the exception instance</div>
<div class="line">    DefaultHTTPExceptionHandler-&gt;&gt;DefaultHTTPExceptionHandler: Extract status_code=404, detail=&quot;Item not found&quot;</div>
<div class="line">    DefaultHTTPExceptionHandler--&gt;&gt;-FastAPIApp: Return JSONResponse(status=404, content={&quot;detail&quot;: &quot;...&quot;})</div>
<div class="line">    FastAPIApp--&gt;&gt;-Client: Send 404 JSON Response</div>
</div><!-- fragment --><p><b>Scenario 2: Automatic <code>RequestValidationError</code></b></p>
<ol type="1">
<li><b>Request:</b> Client sends <code>POST /items/</code> with invalid data (e.g., missing <code>price</code>).</li>
<li><b>Parameter/Body Parsing:</b> FastAPI tries to parse the request body and validate it against the <code>Item</code> Pydantic model before calling <code>create_item</code>.</li>
<li><b>Pydantic Raises:</b> Pydantic's validation fails and raises a <code>pydantic.ValidationError</code>.</li>
<li><b>FastAPI Wraps:</b> FastAPI catches the <code>pydantic.ValidationError</code> and wraps it inside its own <code>fastapi.exceptions.RequestValidationError</code> to add context.</li>
<li><b>Catch:</b> FastAPI's internal request/response cycle catches the <code>RequestValidationError</code>.</li>
<li><b>Find Handler:</b> FastAPI looks for a handler for <code>RequestValidationError</code> and finds its default one.</li>
<li><b>Default Handler Executes:</b> The default handler (<code>fastapi.exception_handlers.request_validation_exception_handler</code>) takes the <code>RequestValidationError</code>.</li>
<li><b>Extract &amp; Format Errors:</b> It calls the <code>.errors()</code> method on the exception to get the list of validation errors provided by Pydantic. It then formats this list into the standard structure (with <code>loc</code>, <code>msg</code>, <code>type</code>).</li>
<li><b>Create Response:</b> It creates a <code>JSONResponse</code> with status code <code>422</code> and the formatted error details as the content.</li>
<li><b>Send Response:</b> This 422 JSON response is sent back to the client. Your <code>create_item</code> function was never even called.</li>
</ol>
<h3><a class="anchor" id="autotoc_md1834"></a>
Code Connections</h3>
<ul>
<li><b><code>fastapi.exceptions.HTTPException</code></b>: The class you import and raise for expected client errors. Defined in <code>fastapi/exceptions.py</code>. It inherits from <code>starlette.exceptions.HTTPException</code>.</li>
<li><b><code>fastapi.exception_handlers.http_exception_handler</code></b>: The default function that handles <code>HTTPException</code>. Defined in <code>fastapi/exception_handlers.py</code>. It creates a <code>JSONResponse</code>.</li>
<li><b><code>fastapi.exceptions.RequestValidationError</code></b>: The exception FastAPI raises internally when Pydantic validation fails for request data. Defined in <code>fastapi/exceptions.py</code>.</li>
<li><b><code>fastapi.exception_handlers.request_validation_exception_handler</code></b>: The default function that handles <code>RequestValidationError</code>. Defined in <code>fastapi/exception_handlers.py</code>. It calls <code>jsonable_encoder(exc.errors())</code> and creates a 422 <code>JSONResponse</code>.</li>
<li>**<code>@app.exception_handler(ExceptionType)</code>**: The decorator used on the <code>FastAPI</code> app instance to register your own custom handler functions. The <code>exception_handler</code> method is part of the <code>FastAPI</code> class in <code>fastapi/applications.py</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1835"></a>
Conclusion</h2>
<p>You've learned how FastAPI helps you manage errors gracefully!</p>
<ul>
<li>You can handle <b>expected client errors</b> (like "not found") by raising <b><code>HTTPException</code></b> with a specific <code>status_code</code> and <code>detail</code> message.</li>
<li>FastAPI <b>automatically handles validation errors</b> (<code>RequestValidationError</code>) when incoming data doesn't match your Pydantic models or type hints, returning detailed <code>422</code> responses.</li>
<li>You can define <b>custom exception handlers</b> for fine-grained control over error responses and logging using <code>@app.exception_handler()</code>.</li>
</ul>
<p>Using these tools makes your API more robust, predictable, and easier for clients to interact with, even when things go wrong. Clear error messages are a crucial part of a good API design.</p>
<p>Now that we know how to handle errors, let's think about another critical aspect: security. How do we protect our endpoints, ensuring only authorized users can access certain data or perform specific actions?</p>
<p>Ready to secure your API? Let's move on to <a class="el" href="../../d9/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_207__security__utilities.html">Chapter 7: Security Utilities</a>!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
