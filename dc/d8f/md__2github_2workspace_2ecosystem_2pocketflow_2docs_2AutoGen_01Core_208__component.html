#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 08_component</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_208__component.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">08_component</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md811"></a>
autotoc_md811</h2>
<p>layout: default title: "Component" parent: "AutoGen Core" </p>
<h2><a class="anchor" id="autotoc_md812"></a>
nav_order: 8</h2>
<h1><a class="anchor" id="autotoc_md813"></a>
Chapter 8: Component - The Standardized Building Blocks</h1>
<p>Welcome to Chapter 8! In our journey so far, we've met several key players in AutoGen Core:</p><ul>
<li><a class="el" href="../../d6/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_201__agent.html">Agents</a>: The workers.</li>
<li><a class="el" href="../../d8/ddc/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_202__messaging__system____topic______subscription__.html">Messaging System</a>: How they communicate.</li>
<li><a class="el" href="../../db/ded/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_203__agentruntime.html">AgentRuntime</a>: The manager.</li>
<li><a class="el" href="../../d8/d8c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_204__tool.html">Tools</a>: Their special skills.</li>
<li><a class="el" href="../../d8/df2/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_205__chatcompletionclient.html">ChatCompletionClient</a>: How they talk to LLMs.</li>
<li><a class="el" href="../../dd/dc3/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_206__chatcompletioncontext.html">ChatCompletionContext</a>: How they remember recent chat history.</li>
<li><a class="el" href="../../da/dd4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_207__memory.html">Memory</a>: How they remember things long-term.</li>
</ul>
<p>Now, imagine you've built a fantastic agent system using these parts. You've configured a specific <code>ChatCompletionClient</code> to use OpenAI's <code>gpt-4o</code> model, and you've set up a <code>ListMemory</code> (from Chapter 7) to store user preferences. How do you save this exact setup so you can easily recreate it later, or share it with a friend? And what if you later want to swap out the <code>gpt-4o</code> client for a different one, like Anthropic's Claude, without rewriting your agent's core logic?</p>
<p>This is where the <b><code>Component</code></b> concept comes in. It provides a standard way to define, configure, save, and load these reusable building blocks.</p>
<h2><a class="anchor" id="autotoc_md814"></a>
Motivation: Making Setups Portable and Swappable</h2>
<p>Think of the parts we've used so far – <code>ChatCompletionClient</code>, <code>Memory</code>, <code>Tool</code> – like specialized <b>Lego bricks</b>. Each brick has a specific function (connecting to an LLM, remembering things, performing an action).</p>
<p>Wouldn't it be great if:</p><ol type="1">
<li>Each Lego brick had a standard way to describe its properties (like "Red 2x4 Brick")?</li>
<li>You could easily save the description of all the bricks used in your creation (your agent system)?</li>
<li>Someone else could take that description and automatically rebuild your exact creation?</li>
<li>You could easily swap a "Red 2x4 Brick" for a "Blue 2x4 Brick" without having to rebuild everything around it?</li>
</ol>
<p>The <code>Component</code> abstraction in AutoGen Core provides exactly this! It makes your building blocks <b>configurable</b>, <b>savable</b>, <b>loadable</b>, and <b>swappable</b>.</p>
<h2><a class="anchor" id="autotoc_md815"></a>
Key Concepts: Understanding Components</h2>
<p>Let's break down what makes the Component system work:</p>
<ol type="1">
<li><b>Component:</b> A class (like <code>ListMemory</code> or <code>OpenAIChatCompletionClient</code>) that is designed to be a standard, reusable building block. It performs a specific role within the AutoGen ecosystem. Many core classes inherit from <code>Component</code> or related base classes.</li>
<li><b>Configuration (<code>Config</code>):</b> Every Component has specific settings. For example, an <code>OpenAIChatCompletionClient</code> needs an API key and a model name. A <code>ListMemory</code> might have a name. These settings are defined in a standard way, usually using a Pydantic <code>BaseModel</code> specific to that component type. This <code>Config</code> acts like the "specification sheet" for the component instance.</li>
<li><b>Saving Settings (<code>_to_config</code> method):</b> A Component instance knows how to generate its <em>current</em> configuration. It has an internal method, <code>_to_config()</code>, that returns a <code>Config</code> object representing its settings. This is like asking a configured Lego brick, "What color and size are you?"</li>
<li><b>Loading Settings (<code>_from_config</code> class method):</b> A Component <em>class</em> knows how to create a <em>new</em> instance of itself from a given configuration. It has a class method, <code>_from_config(config)</code>, that takes a <code>Config</code> object and builds a new, configured component instance. This is like having instructions: "Build a brick with this color and size."</li>
<li><p class="startli"><b><code>ComponentModel</code> (The Box):</b> This is the standard package format used to save and load components. It's like the label and instructions on the Lego box. A <code>ComponentModel</code> contains:</p><ul>
<li><code>provider</code>: A string telling AutoGen <em>which</em> Python class to use (e.g., <code>"autogen_core.memory.ListMemory"</code>).</li>
<li><code>config</code>: A dictionary holding the specific settings for this instance (the output of <code>_to_config()</code>).</li>
<li><code>component_type</code>: The general role of the component (e.g., <code>"memory"</code>, <code>"model"</code>, <code>"tool"</code>).</li>
<li>Other metadata like <code>version</code>, <code>description</code>, <code>label</code>.</li>
</ul>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md816"></a>
From: _component_config.py (Conceptual Structure)</h1>
<p>from pydantic import BaseModel from typing import Dict, Any</p>
<p>class ComponentModel(BaseModel): provider: str # Path to the class (e.g., "autogen_core.memory.ListMemory") config: Dict[str, Any] # The specific settings for this instance component_type: str | None = None # Role (e.g., "memory") </p>
<h1><a class="anchor" id="autotoc_md817"></a>
... other fields like version, description, label ...</h1>
<p>``<code> This</code>ComponentModel` is what you typically save to a file (often as JSON or YAML).</p>
<h2><a class="anchor" id="autotoc_md818"></a>
Use Case Example: Saving and Loading <code>ListMemory</code></h2>
<p>Let's see how this works with the <code>ListMemory</code> we used in <a class="el" href="../../da/dd4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_207__memory.html">Chapter 7: Memory</a>.</p>
<p><b>Goal:</b></p><ol type="1">
<li>Create a <code>ListMemory</code> instance.</li>
<li>Save its configuration using the Component system (<code>dump_component</code>).</li>
<li>Load that configuration to create a <em>new</em>, identical <code>ListMemory</code> instance (<code>load_component</code>).</li>
</ol>
<p><b>Step 1: Create and Configure a <code>ListMemory</code></b></p>
<p>First, let's make a memory component. <code>ListMemory</code> is already designed as a Component.</p>
<div class="fragment"><div class="line"><span class="comment"># File: create_memory_component.py</span></div>
<div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"><span class="keyword">from</span> autogen_core.memory <span class="keyword">import</span> ListMemory, MemoryContent</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create an instance of ListMemory</span></div>
<div class="line">my_memory = ListMemory(name=<span class="stringliteral">&quot;user_prefs_v1&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Add some content (from Chapter 7 example)</span></div>
<div class="line"><span class="keyword">async def </span>add_content():</div>
<div class="line">    pref = MemoryContent(content=<span class="stringliteral">&quot;Use formal style&quot;</span>, mime_type=<span class="stringliteral">&quot;text/plain&quot;</span>)</div>
<div class="line">    await my_memory.add(pref)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Created memory &#39;{my_memory.name}&#39; with content: {my_memory.content}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">asyncio.run(add_content())</div>
<div class="line"><span class="comment"># Output: Created memory &#39;user_prefs_v1&#39; with content: [MemoryContent(content=&#39;Use formal style&#39;, mime_type=&#39;text/plain&#39;, metadata=None)]</span></div>
</div><!-- fragment --><p> We have our configured <code>my_memory</code> instance.</p>
<p><b>Step 2: Save the Configuration (<code>dump_component</code>)</b></p>
<p>Now, let's ask this component instance to describe itself by creating a <code>ComponentModel</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># File: save_memory_config.py</span></div>
<div class="line"><span class="comment"># Assume &#39;my_memory&#39; exists from the previous step</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Dump the component&#39;s configuration into a ComponentModel</span></div>
<div class="line">memory_model = my_memory.dump_component()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Let&#39;s print it (converting to dict for readability)</span></div>
<div class="line">print(<span class="stringliteral">&quot;Saved ComponentModel:&quot;</span>)</div>
<div class="line">print(memory_model.model_dump_json(indent=2))</div>
</div><!-- fragment --><p><b>Expected Output:</b> </p><div class="fragment"><div class="line">Saved ComponentModel:</div>
<div class="line">{</div>
<div class="line">  &quot;provider&quot;: &quot;autogen_core.memory.ListMemory&quot;,</div>
<div class="line">  &quot;component_type&quot;: &quot;memory&quot;,</div>
<div class="line">  &quot;version&quot;: 1,</div>
<div class="line">  &quot;component_version&quot;: 1,</div>
<div class="line">  &quot;description&quot;: &quot;ListMemory stores memory content in a simple list.&quot;,</div>
<div class="line">  &quot;label&quot;: &quot;ListMemory&quot;,</div>
<div class="line">  &quot;config&quot;: {</div>
<div class="line">    &quot;name&quot;: &quot;user_prefs_v1&quot;,</div>
<div class="line">    &quot;memory_contents&quot;: [</div>
<div class="line">      {</div>
<div class="line">        &quot;content&quot;: &quot;Use formal style&quot;,</div>
<div class="line">        &quot;mime_type&quot;: &quot;text/plain&quot;,</div>
<div class="line">        &quot;metadata&quot;: null</div>
<div class="line">      }</div>
<div class="line">    ]</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Look at the output! <code>dump_component</code> created a <code>ComponentModel</code> that contains:</p><ul>
<li><code>provider</code>: Exactly which class to use (<code>autogen_core.memory.ListMemory</code>).</li>
<li><code>config</code>: The specific settings, including the <code>name</code> and even the <code>memory_contents</code> we added!</li>
<li><code>component_type</code>: Its role is <code>"memory"</code>.</li>
<li>Other useful info like description and version.</li>
</ul>
<p>You could save this JSON structure to a file (<code>my_memory_config.json</code>).</p>
<p><b>Step 3: Load the Configuration (<code>load_component</code>)</b></p>
<p>Now, imagine you're starting a new script or sharing the config file. You can load this <code>ComponentModel</code> to recreate the memory instance.</p>
<div class="fragment"><div class="line"><span class="comment"># File: load_memory_config.py</span></div>
<div class="line"><span class="keyword">from</span> autogen_core <span class="keyword">import</span> ComponentModel</div>
<div class="line"><span class="keyword">from</span> autogen_core.memory <span class="keyword">import</span> ListMemory <span class="comment"># Need the class for type hint/loading</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Assume &#39;memory_model&#39; is the ComponentModel we just created</span></div>
<div class="line"><span class="comment"># (or loaded from a file)</span></div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Loading component from ComponentModel (Provider: {memory_model.provider})...&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Use the ComponentLoader mechanism (available on Component classes)</span></div>
<div class="line"><span class="comment"># to load the model. We specify the expected type (ListMemory).</span></div>
<div class="line">loaded_memory: ListMemory = ListMemory.load_component(memory_model)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Successfully loaded memory!&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;- Name: {loaded_memory.name}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;- Content: {loaded_memory.content}&quot;</span>)</div>
</div><!-- fragment --><p><b>Expected Output:</b> </p><div class="fragment"><div class="line">Loading component from ComponentModel (Provider: autogen_core.memory.ListMemory)...</div>
<div class="line">Successfully loaded memory!</div>
<div class="line">- Name: user_prefs_v1</div>
<div class="line">- Content: [MemoryContent(content=&#39;Use formal style&#39;, mime_type=&#39;text/plain&#39;, metadata=None)]</div>
</div><!-- fragment --><p> Success! <code>load_component</code> read the <code>ComponentModel</code>, found the right class (<code>ListMemory</code>), used its <code>_from_config</code> method with the saved <code>config</code> data, and created a brand new <code>loaded_memory</code> instance that is identical to our original <code>my_memory</code>.</p>
<p><b>Benefits Shown:</b></p><ul>
<li><b>Reproducibility:</b> We saved the exact state (including content!) and loaded it perfectly.</li>
<li><b>Configuration:</b> We could easily save this to a JSON/YAML file and manage it outside our Python code.</li>
<li><b>Modularity (Conceptual):</b> If <code>ListMemory</code> and <code>VectorDBMemory</code> were both Components of type "memory", we could potentially load either one from a configuration file just by changing the <code>provider</code> and <code>config</code> in the file, without altering the agent code that <em>uses</em> the memory component (assuming the agent interacts via the standard <code>Memory</code> interface from Chapter 7).</li>
</ul>
<h2><a class="anchor" id="autotoc_md819"></a>
Under the Hood: How Saving and Loading Work</h2>
<p>Let's peek behind the curtain.</p>
<p><b>Saving (<code>dump_component</code>) Flow:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant MyMemory as my_memory (ListMemory instance)</div>
<div class="line">    participant ListMemConfig as ListMemoryConfig (Pydantic Model)</div>
<div class="line">    participant CompModel as ComponentModel</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;+MyMemory: dump_component()</div>
<div class="line">    MyMemory-&gt;&gt;MyMemory: Calls internal self._to_config()</div>
<div class="line">    MyMemory-&gt;&gt;+ListMemConfig: Creates Config object (name=&quot;...&quot;, contents=[...])</div>
<div class="line">    ListMemConfig--&gt;&gt;-MyMemory: Returns Config object</div>
<div class="line">    MyMemory-&gt;&gt;MyMemory: Gets provider string (&quot;autogen_core.memory.ListMemory&quot;)</div>
<div class="line">    MyMemory-&gt;&gt;MyMemory: Gets component_type (&quot;memory&quot;), version, etc.</div>
<div class="line">    MyMemory-&gt;&gt;+CompModel: Creates ComponentModel(provider=..., config=config_dict, ...)</div>
<div class="line">    CompModel--&gt;&gt;-MyMemory: Returns ComponentModel instance</div>
<div class="line">    MyMemory--&gt;&gt;-User: Returns ComponentModel instance</div>
</div><!-- fragment --><ol type="1">
<li>You call <code>my_memory.dump_component()</code>.</li>
<li>It calls its own <code>_to_config()</code> method. For <code>ListMemory</code>, this gathers the <code>name</code> and current <code>_contents</code>.</li>
<li><code>_to_config()</code> returns a <code>ListMemoryConfig</code> object (a Pydantic model) holding these values.</li>
<li><code>dump_component()</code> takes this <code>ListMemoryConfig</code> object, converts its data into a dictionary (<code>config</code> field).</li>
<li>It figures out its own class path (<code>provider</code>) and other metadata (<code>component_type</code>, <code>version</code>, etc.).</li>
<li>It packages all this into a <code>ComponentModel</code> object and returns it.</li>
</ol>
<p><b>Loading (<code>load_component</code>) Flow:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant Loader as ComponentLoader (e.g., ListMemory.load_component)</div>
<div class="line">    participant Importer as Python Import System</div>
<div class="line">    participant ListMemClass as ListMemory (Class definition)</div>
<div class="line">    participant ListMemConfig as ListMemoryConfig (Pydantic Model)</div>
<div class="line">    participant NewMemory as New ListMemory Instance</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;+Loader: load_component(component_model)</div>
<div class="line">    Loader-&gt;&gt;Loader: Reads provider (&quot;autogen_core.memory.ListMemory&quot;) from model</div>
<div class="line">    Loader-&gt;&gt;+Importer: Imports the class `autogen_core.memory.ListMemory`</div>
<div class="line">    Importer--&gt;&gt;-Loader: Returns ListMemory class object</div>
<div class="line">    Loader-&gt;&gt;+ListMemClass: Checks if it&#39;s a valid Component class</div>
<div class="line">    Loader-&gt;&gt;ListMemClass: Gets expected config schema (ListMemoryConfig)</div>
<div class="line">    Loader-&gt;&gt;+ListMemConfig: Validates `config` dict from model against schema</div>
<div class="line">    ListMemConfig--&gt;&gt;-Loader: Returns validated ListMemoryConfig object</div>
<div class="line">    Loader-&gt;&gt;+ListMemClass: Calls _from_config(validated_config)</div>
<div class="line">    ListMemClass-&gt;&gt;+NewMemory: Creates new ListMemory instance using config</div>
<div class="line">    NewMemory--&gt;&gt;-ListMemClass: Returns new instance</div>
<div class="line">    ListMemClass--&gt;&gt;-Loader: Returns new instance</div>
<div class="line">    Loader--&gt;&gt;-User: Returns the new ListMemory instance</div>
</div><!-- fragment --><ol type="1">
<li>You call <code>ListMemory.load_component(memory_model)</code>.</li>
<li>The loader reads the <code>provider</code> string from <code>memory_model</code>.</li>
<li>It dynamically imports the class specified by <code>provider</code>.</li>
<li>It verifies this class is a proper <code>Component</code> subclass.</li>
<li>It finds the configuration schema defined by the class (e.g., <code>ListMemoryConfig</code>).</li>
<li>It validates the <code>config</code> dictionary from <code>memory_model</code> using this schema.</li>
<li>It calls the class's <code>_from_config()</code> method, passing the validated configuration object.</li>
<li><code>_from_config()</code> uses the configuration data to initialize and return a new instance of the class (e.g., a new <code>ListMemory</code> with the loaded name and content).</li>
<li>The loader returns this newly created instance.</li>
</ol>
<p><b>Code Glimpse:</b></p>
<p>The core logic lives in <code>_component_config.py</code>.</p>
<ul>
<li><p class="startli"><b><code>Component</code> Base Class:</b> Classes like <code>ListMemory</code> inherit from <code>Component</code>. This requires them to define <code>component_type</code>, <code>component_config_schema</code>, and implement <code>_to_config()</code> and <code>_from_config()</code>.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md820"></a>
From: _component_config.py (Simplified Concept)</h1>
<p>from pydantic import BaseModel from typing import Type, TypeVar, Generic, ClassVar </p>
<h1><a class="anchor" id="autotoc_md821"></a>
... other imports</h1>
<p>ConfigT = TypeVar("ConfigT", bound=BaseModel)</p>
<p>class Component(Generic[ConfigT]): # Generic over its config type </p>
<h1><a class="anchor" id="autotoc_md822"></a>
Required Class Variables for Concrete Components</h1>
<p>component_type: ClassVar[str] component_config_schema: Type[ConfigT]</p>
<h1><a class="anchor" id="autotoc_md823"></a>
Required Instance Method for Saving</h1>
<p>def _to_config(self) -&gt; ConfigT: raise NotImplementedError</p>
<h1><a class="anchor" id="autotoc_md824"></a>
Required Class Method for Loading</h1>
<p>@classmethod def _from_config(cls, config: ConfigT) -&gt; Self: raise NotImplementedError</p>
<h1><a class="anchor" id="autotoc_md825"></a>
dump_component and load_component are also part of the system</h1>
<h1><a class="anchor" id="autotoc_md826"></a>
(often inherited from base classes like ComponentBase)</h1>
<p>def dump_component(self) -&gt; ComponentModel: ... @classmethod def load_component(cls, model: ComponentModel | Dict[str, Any]) -&gt; Self: ... ```</p>
<ul>
<li><b><code>ComponentModel</code>:</b> As shown before, a Pydantic model to hold the <code>provider</code>, <code>config</code>, <code>type</code>, etc.</li>
<li><b><code>dump_component</code> Implementation (Conceptual):</b> ```python </li>
</ul>
<h1><a class="anchor" id="autotoc_md827"></a>
Inside ComponentBase or similar</h1>
<p>def dump_component(self) -&gt; ComponentModel: </p>
<h1><a class="anchor" id="autotoc_md828"></a>
1. Get the specific config from the instance</h1>
<p>obj_config: BaseModel = self._to_config() config_dict = obj_config.model_dump() # Convert to dictionary</p>
<h1><a class="anchor" id="autotoc_md829"></a>
2. Determine the provider string (class path)</h1>
<p>provider_str = _type_to_provider_str(self.__class__) </p>
<h1><a class="anchor" id="autotoc_md830"></a>
(Handle overrides like self.component_provider_override)</h1>
<h1><a class="anchor" id="autotoc_md831"></a>
3. Get other metadata</h1>
<p>comp_type = self.component_type comp_version = self.component_version </p>
<h1><a class="anchor" id="autotoc_md832"></a>
... description, label ...</h1>
<h1><a class="anchor" id="autotoc_md833"></a>
4. Create and return the ComponentModel</h1>
<p>model = ComponentModel( provider=provider_str, config=config_dict, component_type=comp_type, version=comp_version, </p>
<h1><a class="anchor" id="autotoc_md834"></a>
... other metadata ...</h1>
<p>) return model ```</p>
<ul>
<li><b><code>load_component</code> Implementation (Conceptual):</b> ```python </li>
</ul>
<h1><a class="anchor" id="autotoc_md835"></a>
Inside ComponentLoader or similar</h1>
<p>@classmethod def load_component(cls, model: ComponentModel | Dict[str, Any]) -&gt; Self: </p>
<h1><a class="anchor" id="autotoc_md836"></a>
1. Ensure we have a ComponentModel object</h1>
<p>if isinstance(model, dict): loaded_model = ComponentModel(**model) else: loaded_model = model</p>
<h1><a class="anchor" id="autotoc_md837"></a>
2. Import the class based on the provider string</h1>
<p>provider_str = loaded_model.provider </p>
<h1><a class="anchor" id="autotoc_md838"></a>
... (handle WELL_KNOWN_PROVIDERS mapping) ...</h1>
<p>module_path, class_name = provider_str.rsplit(".", 1) module = importlib.import_module(module_path) component_class = getattr(module, class_name)</p>
<h1><a class="anchor" id="autotoc_md839"></a>
3. Validate the class and config</h1>
<p>if not is_component_class(component_class): # Check it's a valid Component raise TypeError(...) schema = component_class.component_config_schema validated_config = schema.model_validate(loaded_model.config)</p>
<h1><a class="anchor" id="autotoc_md840"></a>
4. Call the class's factory method to create instance</h1>
<p>instance = component_class._from_config(validated_config)</p>
<h1><a class="anchor" id="autotoc_md841"></a>
5. Return the instance (after type checks)</h1>
<p>return instance ```</p>
<p>This system provides a powerful and consistent way to manage the building blocks of your AutoGen applications.</p>
<h2><a class="anchor" id="autotoc_md842"></a>
Wrapping Up</h2>
<p>Congratulations! You've reached the end of our core concepts tour. You now understand the <code>Component</code> model – AutoGen Core's standard way to define configurable, savable, and loadable building blocks like <code>Memory</code>, <code>ChatCompletionClient</code>, <code>Tool</code>, and even aspects of <code>Agents</code> themselves.</p>
<ul>
<li><b>Components</b> are like standardized Lego bricks.</li>
<li>They use <b><code>_to_config</code></b> to describe their settings.</li>
<li>They use <b><code>_from_config</code></b> to be built from settings.</li>
<li><b><code>ComponentModel</code></b> is the standard "box" storing the provider and config, enabling saving/loading (often via JSON/YAML).</li>
</ul>
<p>This promotes:</p><ul>
<li><b>Modularity:</b> Easily swap implementations (e.g., different LLM clients).</li>
<li><b>Reproducibility:</b> Save and load exact agent system configurations.</li>
<li><b>Configuration:</b> Manage settings in external files.</li>
</ul>
<p>With these eight core concepts (<code>Agent</code>, <code>Messaging</code>, <code>AgentRuntime</code>, <code>Tool</code>, <code>ChatCompletionClient</code>, <code>ChatCompletionContext</code>, <code>Memory</code>, and <code>Component</code>), you have a solid foundation for understanding and building powerful multi-agent applications with AutoGen Core!</p>
<p>Happy building!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
