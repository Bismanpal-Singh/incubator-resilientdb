#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_response___tool_call_handling</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_205__response______tool__call__handling.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_response___tool_call_handling</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1293"></a>
autotoc_md1293</h2>
<p>layout: default title: "Response &amp; Tool Call Handling" parent: "Codex" </p>
<h2><a class="anchor" id="autotoc_md1294"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md1295"></a>
Chapter 5: Response &amp; Tool Call Handling</h1>
<p>In the <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">previous chapter</a>, we learned how Codex decides <em>if</em> it's allowed to perform an action suggested by the AI, acting like a security guard based on the rules you set. But how does Codex understand the AI's response in the first place, especially when the AI wants to do something specific, like run a command or change a file?</p>
<p>That's where <b>Response &amp; Tool Call Handling</b> comes in. Think of this part of Codex as its "ears" and "hands." It listens carefully to the instructions coming back from the AI model (the "response") and, if the AI asks to perform an action (a "tool call"), it figures out <em>exactly</em> what the AI wants to do (like which command to run or what file change to make) and gets ready to do it.</p>
<h2><a class="anchor" id="autotoc_md1296"></a>
What's the Big Idea? Listening to the AI Assistant</h2>
<p>Imagine you ask your super-smart assistant (the AI model) to do something like:</p>
<p><code>codex "What's the status of my project? Use git status."</code></p>
<p>The AI doesn't just send back plain text like "Okay, I'll run it." Instead, it sends back a more structured message, almost like filling out a form:</p>
<ul>
<li><b>Text Part:</b> "Okay, I will check the status of your project."</li>
<li><b>Action Part (Tool Call):</b><ul>
<li><b>Tool Name:</b> <code>shell</code> (meaning: use the command line)</li>
<li><b>Arguments:</b> <code>["git", "status"]</code> (meaning: the specific command to run)</li>
</ul>
</li>
</ul>
<p>Codex needs to understand this structured response. It needs to:</p>
<ol type="1">
<li>Recognize the plain text part and show it to you in the <a class="el" href="../../dd/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_201__terminal__ui____ink__components__.html">Terminal UI</a>.</li>
<li>See the "Action Part" (the Tool Call) and understand:<ul>
<li>Which tool the AI wants to use (<code>shell</code>).</li>
<li>What specific details (arguments) are needed for that tool (<code>git status</code>).</li>
</ul>
</li>
</ol>
<p>This system is crucial because it translates the AI's intent into something Codex can actually act upon.</p>
<h2><a class="anchor" id="autotoc_md1297"></a>
Key Concepts</h2>
<ol type="1">
<li><p class="startli"><b>Structured Responses:</b> The OpenAI API doesn't just return a single block of text. It sends back data structured often like JSON. This allows the AI to clearly separate regular conversation text from requests to perform actions.</p>
<p class="startli"><code>json // Simplified idea of an AI response { "id": "response_123", "output": [ { "type": "message", // A regular text message "role": "assistant", "content": [{ "type": "output_text", "text": "Okay, checking the status..." }] }, { "type": "function_call", // A request to use a tool! "name": "shell", "arguments": "{\"command\": [\"git\", \"status\"]}", // Details for the tool "call_id": "call_abc" } ] // ... other info ... } </code> This structure makes it easy for Codex to programmatically understand the different parts of the AI's message.</p>
</li>
<li><b>Tool Calls (Function Calls):</b> When the AI wants to interact with the outside world (run a command, edit a file), it uses a special type of message in the response, often called a "function call" or "tool call". In Codex, common tool names are:<ul>
<li><code>shell</code>: Execute a command in the terminal.</li>
<li><code>apply_patch</code>: Modify a file using a specific format called a "patch".</li>
</ul>
</li>
<li><b>Arguments:</b> The tool call includes the necessary details, called "arguments," usually formatted as a JSON string.<ul>
<li>For the <code>shell</code> tool, the arguments specify the command to run (e.g., <code>{"command": ["git", "status"]}</code>).</li>
<li>For the <code>apply_patch</code> tool, the arguments contain the patch text describing the file changes (e.g., <code>{"patch": "*** Begin Patch..."}</code>).</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md1298"></a>
How It Works: Decoding the AI's Message</h2>
<p>When the <a class="el" href="../../d0/dbd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_203__agent__loop.html">Agent Loop</a> receives a response from the OpenAI API, it goes through these steps:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant OpenAI</div>
<div class="line">    participant AgentLoop as Agent Loop</div>
<div class="line">    participant Parser as Response Parser</div>
<div class="line">    participant UI as Terminal UI</div>
<div class="line">    participant Approval as Approval Check</div>
<div class="line"> </div>
<div class="line">    OpenAI--&gt;&gt;AgentLoop: Sends structured response (Text + Tool Call)</div>
<div class="line">    AgentLoop-&gt;&gt;Parser: Passes raw response data</div>
<div class="line">    Parser-&gt;&gt;Parser: Extracts Text part (&quot;Okay...&quot;)</div>
<div class="line">    Parser--&gt;&gt;AgentLoop: Returns extracted Text</div>
<div class="line">    AgentLoop-&gt;&gt;UI: Sends Text to display (&quot;onItem&quot; callback)</div>
<div class="line">    Parser-&gt;&gt;Parser: Extracts Tool Call part (shell, [&quot;git&quot;, &quot;status&quot;])</div>
<div class="line">    Parser--&gt;&gt;AgentLoop: Returns Tool Name (&quot;shell&quot;) &amp; Arguments ([&quot;git&quot;, &quot;status&quot;])</div>
<div class="line">    AgentLoop-&gt;&gt;Approval: Sends Tool details for policy check</div>
<div class="line">    Note over Approval: Next step: Chapter 4/6</div>
</div><!-- fragment --><ol type="1">
<li><b>Receive Response:</b> The <a class="el" href="../../d0/dbd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_203__agent__loop.html">Agent Loop</a> gets the structured response data from the OpenAI API.</li>
<li><b>Parse:</b> It uses helper functions (often found in <code>utils/parsers.ts</code>) to examine the response structure.</li>
<li><b>Extract Text:</b> If there's a regular text message (<code>"type": "message"</code>), it's extracted and sent to the <a class="el" href="../../dd/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_201__terminal__ui____ink__components__.html">Terminal UI</a> via the <code>onItem</code> callback to be displayed.</li>
<li><b>Extract Tool Call:</b> If there's a tool call (<code>"type": "function_call"</code>):<ul>
<li>The <b>tool name</b> (e.g., <code>shell</code>) is identified.</li>
<li>The <b>arguments</b> string is extracted.</li>
<li>The arguments string (which is often JSON) is parsed to get the actual details (e.g., the <code>command</code> array <code>["git", "status"]</code>).</li>
</ul>
</li>
<li><b>Prepare for Action:</b> The Agent Loop now knows the specific tool and its arguments. It packages this information (tool name + parsed arguments) and prepares for the next stage: checking the <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy &amp; Security</a> and, if approved, proceeding to <a class="el" href="../../dd/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_206__command__execution______sandboxing.html">Command Execution &amp; Sandboxing</a>.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1299"></a>
Under the Hood: Parsing the Details</h2>
<p>Let's look at simplified code snippets showing how this parsing happens.</p>
<h3><a class="anchor" id="autotoc_md1300"></a>
In the Agent Loop (<code>agent-loop.ts</code>)</h3>
<p>The <code>AgentLoop</code> processes events streamed from the OpenAI API. When a complete response arrives or a specific tool call item is identified, it needs handling.</p>
<div class="fragment"><div class="line">// File: codex-cli/src/utils/agent/agent-loop.ts (Simplified)</div>
<div class="line"> </div>
<div class="line">// Inside the loop processing OpenAI stream events...</div>
<div class="line">for await (const event of stream) {</div>
<div class="line">  if (event.type === &quot;response.output_item.done&quot;) {</div>
<div class="line">    const item = event.item; // Could be text, function_call, etc.</div>
<div class="line">    this.onItem(item as ResponseItem); // Send to UI</div>
<div class="line"> </div>
<div class="line">    // If it&#39;s a tool call, mark it for later processing</div>
<div class="line">    if (item.type === &quot;function_call&quot;) {</div>
<div class="line">      // Store item.call_id or item details</div>
<div class="line">      // to handle after the stream finishes</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  if (event.type === &quot;response.completed&quot;) {</div>
<div class="line">    // Process the full response output once the stream is done</div>
<div class="line">    for (const item of event.response.output) {</div>
<div class="line">      if (item.type === &quot;function_call&quot;) {</div>
<div class="line">        // *** This is where we handle the tool call! ***</div>
<div class="line">        // Calls a helper function like handleFunctionCall</div>
<div class="line">        const toolResults = await this.handleFunctionCall(item);</div>
<div class="line">        // Prepare results to potentially send back to AI</div>
<div class="line">        turnInput.push(...toolResults);</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    lastResponseId = event.response.id;</div>
<div class="line">  }</div>
<div class="line">  // ... other event types ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Helper function to process the tool call details</div>
<div class="line">private async handleFunctionCall(item: ResponseFunctionToolCall): Promise&lt;Array&lt;ResponseInputItem&gt;&gt; {</div>
<div class="line">  const name = item.name; // e.g., &quot;shell&quot;</div>
<div class="line">  const rawArguments = item.arguments; // e.g., &quot;{\&quot;command\&quot;: [\&quot;git\&quot;, \&quot;status\&quot;]}&quot;</div>
<div class="line">  const callId = item.call_id;</div>
<div class="line"> </div>
<div class="line">  // *** Use a parser to get structured arguments ***</div>
<div class="line">  const args = parseToolCallArguments(rawArguments ?? &quot;{}&quot;); // From parsers.ts</div>
<div class="line"> </div>
<div class="line">  if (args == null) {</div>
<div class="line">    // Handle error: arguments couldn&#39;t be parsed</div>
<div class="line">    return [/* error output item */];</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  let outputText = `Error: Unknown function ${name}`;</div>
<div class="line">  let metadata = {};</div>
<div class="line"> </div>
<div class="line">  // Check which tool was called</div>
<div class="line">  if (name === &quot;shell&quot;) {</div>
<div class="line">    // *** Prepare for execution ***</div>
<div class="line">    // Call handleExecCommand, which checks approval and runs the command</div>
<div class="line">    const result = await handleExecCommand(</div>
<div class="line">      args, // Contains { cmd: [&quot;git&quot;, &quot;status&quot;], ... }</div>
<div class="line">      this.config,</div>
<div class="line">      this.approvalPolicy,</div>
<div class="line">      this.getCommandConfirmation, // Function to ask user via UI</div>
<div class="line">      /* ... cancellation signal ... */</div>
<div class="line">    );</div>
<div class="line">    outputText = result.outputText;</div>
<div class="line">    metadata = result.metadata;</div>
<div class="line">  } else if (name === &quot;apply_patch&quot;) {</div>
<div class="line">    // Similar logic, potentially using execApplyPatch after approval check</div>
<div class="line">    // It would parse args.patch using logic from parse-apply-patch.ts</div>
<div class="line">  }</div>
<div class="line">  // ... other tools ...</div>
<div class="line"> </div>
<div class="line">  // Create the result message to send back to the AI</div>
<div class="line">  const outputItem: ResponseInputItem.FunctionCallOutput = {</div>
<div class="line">    type: &quot;function_call_output&quot;,</div>
<div class="line">    call_id: callId,</div>
<div class="line">    output: JSON.stringify({ output: outputText, metadata }),</div>
<div class="line">  };</div>
<div class="line">  return [outputItem];</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>The loop iterates through the response <code>output</code> items.</li>
<li>If an item is a <code>function_call</code>, the <code>handleFunctionCall</code> helper is called.</li>
<li><code>handleFunctionCall</code> extracts the <code>name</code> and <code>arguments</code>.</li>
<li>It crucially calls <code>parseToolCallArguments</code> (from <code>utils/parsers.ts</code>) to turn the JSON string <code>arguments</code> into a usable object.</li>
<li>Based on the <code>name</code> (<code>shell</code>, <code>apply_patch</code>), it calls the appropriate execution handler (like <code>handleExecCommand</code>), passing the parsed arguments. This handler coordinates with the <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy &amp; Security</a> and <a class="el" href="../../dd/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_206__command__execution______sandboxing.html">Command Execution &amp; Sandboxing</a> systems.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1301"></a>
In the Parsers (<code>parsers.ts</code>)</h3>
<p>This file contains helpers to decode the tool call details.</p>
<div class="fragment"><div class="line">// File: codex-cli/src/utils/parsers.ts (Simplified)</div>
<div class="line">import { formatCommandForDisplay } from &quot;src/format-command.js&quot;;</div>
<div class="line">// ... other imports ...</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Parses the raw JSON string from a tool call&#39;s arguments.</div>
<div class="line"> * Expects specific shapes for known tools like &#39;shell&#39;.</div>
<div class="line"> */</div>
<div class="line">export function parseToolCallArguments(</div>
<div class="line">  rawArguments: string,</div>
<div class="line">): ExecInput | undefined { // ExecInput contains { cmd, workdir, timeoutInMillis }</div>
<div class="line">  let json: unknown;</div>
<div class="line">  try {</div>
<div class="line">    json = JSON.parse(rawArguments); // Basic JSON parsing</div>
<div class="line">  } catch (err) {</div>
<div class="line">    // Handle JSON parse errors</div>
<div class="line">    return undefined;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  if (typeof json !== &quot;object&quot; || json == null) return undefined;</div>
<div class="line"> </div>
<div class="line">  // Look for &#39;command&#39; or &#39;cmd&#39; property, expecting an array of strings</div>
<div class="line">  const { cmd, command, patch /* other possible args */ } = json as Record&lt;string, unknown&gt;;</div>
<div class="line">  const commandArray = toStringArray(cmd) ?? toStringArray(command);</div>
<div class="line"> </div>
<div class="line">  // If it&#39;s a shell command, require the command array</div>
<div class="line">  if (commandArray != null) {</div>
<div class="line">    return {</div>
<div class="line">      cmd: commandArray,</div>
<div class="line">      // Optional: extract workdir and timeout too</div>
<div class="line">      workdir: typeof (json as any).workdir === &quot;string&quot; ? (json as any).workdir : undefined,</div>
<div class="line">      timeoutInMillis: typeof (json as any).timeout === &quot;number&quot; ? (json as any).timeout : undefined,</div>
<div class="line">    };</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // If it&#39;s an apply_patch command, require the patch string</div>
<div class="line">  if (typeof patch === &#39;string&#39;) {</div>
<div class="line">    // Return a structure indicating it&#39;s a patch, maybe:</div>
<div class="line">    // return { type: &#39;patch&#39;, patch: patch }; // Or incorporate into ExecInput if unified</div>
<div class="line">    // For simplicity here, let&#39;s assume handleFunctionCall routes based on name,</div>
<div class="line">    // so we might just return the raw parsed JSON for patch.</div>
<div class="line">    // But a structured return is better. Let&#39;s adapt ExecInput slightly for demo:</div>
<div class="line">    return { cmd: [&#39;apply_patch&#39;], patch: patch }; // Use a placeholder cmd</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  return undefined; // Unknown or invalid arguments structure</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Helper to check if an object is an array of strings</div>
<div class="line">function toStringArray(obj: unknown): Array&lt;string&gt; | undefined {</div>
<div class="line">  if (Array.isArray(obj) &amp;&amp; obj.every((item) =&gt; typeof item === &quot;string&quot;)) {</div>
<div class="line">    return obj as Array&lt;string&gt;;</div>
<div class="line">  }</div>
<div class="line">  return undefined;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Parses a full FunctionCall item for display/review purposes.</div>
<div class="line"> */</div>
<div class="line">export function parseToolCall(</div>
<div class="line">  toolCall: ResponseFunctionToolCall,</div>
<div class="line">): CommandReviewDetails | undefined { // CommandReviewDetails has { cmd, cmdReadableText, ... }</div>
<div class="line">  // Use the argument parser</div>
<div class="line">  const args = parseToolCallArguments(toolCall.arguments);</div>
<div class="line">  if (args == null) return undefined;</div>
<div class="line"> </div>
<div class="line">  // Format the command nicely for display</div>
<div class="line">  const cmdReadableText = formatCommandForDisplay(args.cmd);</div>
<div class="line"> </div>
<div class="line">  // ... potentially add auto-approval info ...</div>
<div class="line"> </div>
<div class="line">  return {</div>
<div class="line">    cmd: args.cmd,</div>
<div class="line">    cmdReadableText: cmdReadableText,</div>
<div class="line">    // ... other details ...</div>
<div class="line">  };</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><code>parseToolCallArguments</code> takes the raw JSON string (<code>{"command": ["git", "status"]}</code>) and uses <code>JSON.parse</code>.</li>
<li>It then checks if the parsed object has the expected structure (e.g., a <code>command</code> property that is an array of strings for <code>shell</code>, or a <code>patch</code> string for <code>apply_patch</code>).</li>
<li>It returns a structured object (<code>ExecInput</code>) containing the validated arguments, or <code>undefined</code> if parsing fails.</li>
<li><code>parseToolCall</code> uses <code>parseToolCallArguments</code> and then formats the command nicely for display using <code>formatCommandForDisplay</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1302"></a>
Handling Patches (<code>parse-apply-patch.ts</code>)</h3>
<p>When the tool is <code>apply_patch</code>, the arguments contain a multi-line string describing the changes. Codex has specific logic to parse this format.</p>
<div class="fragment"><div class="line">// File: codex-cli/src/utils/agent/parse-apply-patch.ts (Conceptual)</div>
<div class="line"> </div>
<div class="line">// Defines types like ApplyPatchOp (create, delete, update)</div>
<div class="line"> </div>
<div class="line">export function parseApplyPatch(patch: string): Array&lt;ApplyPatchOp&gt; | null {</div>
<div class="line">  // 1. Check for &quot;*** Begin Patch&quot; and &quot;*** End Patch&quot; markers.</div>
<div class="line">  if (!patch.startsWith(&quot;*** Begin Patch\n&quot;) || !patch.endsWith(&quot;\n*** End Patch&quot;)) {</div>
<div class="line">    return null; // Invalid format</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // 2. Extract the body between the markers.</div>
<div class="line">  const patchBody = /* ... extract body ... */;</div>
<div class="line">  const lines = patchBody.split(&#39;\n&#39;);</div>
<div class="line"> </div>
<div class="line">  const operations: Array&lt;ApplyPatchOp&gt; = [];</div>
<div class="line">  for (const line of lines) {</div>
<div class="line">    // 3. Check for operation markers:</div>
<div class="line">    if (line.startsWith(&quot;*** Add File: &quot;)) {</div>
<div class="line">      operations.push({ type: &quot;create&quot;, path: /* path */, content: &quot;&quot; });</div>
<div class="line">    } else if (line.startsWith(&quot;*** Delete File: &quot;)) {</div>
<div class="line">      operations.push({ type: &quot;delete&quot;, path: /* path */ });</div>
<div class="line">    } else if (line.startsWith(&quot;*** Update File: &quot;)) {</div>
<div class="line">      operations.push({ type: &quot;update&quot;, path: /* path */, update: &quot;&quot;, added: 0, deleted: 0 });</div>
<div class="line">    } else if (operations.length &gt; 0) {</div>
<div class="line">      // 4. If inside an operation, parse the content/diff lines (+/-)</div>
<div class="line">      const lastOp = operations[operations.length - 1];</div>
<div class="line">      // ... add line content to create/update operation ...</div>
<div class="line">    } else {</div>
<div class="line">      // Invalid line outside of an operation</div>
<div class="line">      return null;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  return operations; // Return the list of parsed operations</div>
<div class="line">}</div>
</div><!-- fragment --><p>This parser specifically understands the <code>*** Add File:</code>, <code>*** Delete File:</code>, <code>*** Update File:</code> markers and the <code>+</code>/<code>-</code> lines within patches to figure out exactly which files to change and how.</p>
<h3><a class="anchor" id="autotoc_md1303"></a>
Displaying Tool Calls (<code>terminal-chat-response-item.tsx</code>)</h3>
<p>The UI needs to show tool calls differently from regular messages.</p>
<div class="fragment"><div class="line">// File: codex-cli/src/components/chat/terminal-chat-response-item.tsx (Simplified)</div>
<div class="line">import { parseToolCall } from &quot;../../utils/parsers&quot;;</div>
<div class="line">// ... other imports: Box, Text from ink ...</div>
<div class="line"> </div>
<div class="line">export default function TerminalChatResponseItem({ item }: { item: ResponseItem }): React.ReactElement {</div>
<div class="line">  switch (item.type) {</div>
<div class="line">    case &quot;message&quot;:</div>
<div class="line">      // ... render regular message ...</div>
<div class="line">      break;</div>
<div class="line">    case &quot;function_call&quot;: // &lt;-- Handle tool calls</div>
<div class="line">      return &lt;TerminalChatResponseToolCall message={item} /&gt;;</div>
<div class="line">    case &quot;function_call_output&quot;:</div>
<div class="line">      // ... render tool output ...</div>
<div class="line">      break;</div>
<div class="line">    // ... other cases ...</div>
<div class="line">  }</div>
<div class="line">  // ... fallback ...</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">function TerminalChatResponseToolCall({ message }: { message: ResponseFunctionToolCallItem }) {</div>
<div class="line">  // Use the parser to get displayable details</div>
<div class="line">  const details = parseToolCall(message); // From parsers.ts</div>
<div class="line"> </div>
<div class="line">  if (!details) return &lt;Text color=&quot;red&quot;&gt;Invalid tool call&lt;/Text&gt;;</div>
<div class="line"> </div>
<div class="line">  return (</div>
<div class="line">    &lt;Box flexDirection=&quot;column&quot;&gt;</div>
<div class="line">      &lt;Text color=&quot;magentaBright&quot; bold&gt;command&lt;/Text&gt;</div>
<div class="line">      {/* Display the nicely formatted command */}</div>
<div class="line">      &lt;Text&gt;&lt;Text dimColor&gt;$&lt;/Text&gt; {details.cmdReadableText}&lt;/Text&gt;</div>
<div class="line">    &lt;/Box&gt;</div>
<div class="line">  );</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>The main component checks the <code>item.type</code>.</li>
<li>If it's <code>function_call</code>, it renders a specific component (<code>TerminalChatResponseToolCall</code>).</li>
<li>This component uses <code>parseToolCall</code> (from <code>utils/parsers.ts</code>) to get the details and displays the command in a distinct style (e.g., with a <code>$</code> prefix and magenta color).</li>
</ul>
<h2><a class="anchor" id="autotoc_md1304"></a>
Conclusion</h2>
<p>You've now seen how Codex acts as an interpreter for the AI. It doesn't just receive text; it receives structured instructions. The <b>Response &amp; Tool Call Handling</b> system is responsible for parsing these instructions, figuring out if the AI wants to use a tool (like <code>shell</code> or <code>apply_patch</code>), and extracting the precise arguments needed for that tool. This crucial step translates the AI's intentions into actionable details that Codex can then use to interact with your system, always respecting the rules set by the <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy &amp; Security</a>.</p>
<p>Now that Codex understands <em>what</em> command the AI wants to run (e.g., <code>git status</code>), how does it actually <em>execute</em> that command safely, especially if running in <code>full-auto</code> mode? That's the topic of our next chapter.</p>
<p>Next up: <a class="el" href="../../dd/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_206__command__execution______sandboxing.html">Command Execution &amp; Sandboxing</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
