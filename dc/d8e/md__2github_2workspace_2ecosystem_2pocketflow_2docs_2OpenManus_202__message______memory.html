#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 02_message___memory</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_202__message______memory.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">02_message___memory</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2621"></a>
autotoc_md2621</h2>
<p>layout: default title: "Message &amp; Memory" parent: "OpenManus" </p>
<h2><a class="anchor" id="autotoc_md2622"></a>
nav_order: 2</h2>
<h1><a class="anchor" id="autotoc_md2623"></a>
Chapter 2: Message / Memory - Remembering the Conversation</h1>
<p>In <a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">Chapter 1: The LLM - Your Agent's Brainpower</a>, we learned how our agent uses the <code>LLM</code> class to access its "thinking" capabilities. But just like humans, an agent needs to remember what was said earlier in a conversation to make sense of new requests and respond appropriately.</p>
<p>Imagine asking a friend: "What was the first thing I asked you?". If they have no memory, they can't answer! Agents face the same problem. They need a way to store the conversation history.</p>
<p>This is where <code>Message</code> and <code>Memory</code> come in.</p>
<h2><a class="anchor" id="autotoc_md2624"></a>
What Problem Do They Solve?</h2>
<p>Think about a simple chat:</p>
<ol type="1">
<li><b>You:</b> "What's the weather like in London?"</li>
<li><b>Agent:</b> "It's currently cloudy and 15°C in London."</li>
<li><b>You:</b> "What about Paris?"</li>
</ol>
<p>For the agent to answer your <em>second</em> question ("What about Paris?"), it needs to remember that the <em>topic</em> of the conversation is "weather". Without remembering the first question, the second question is meaningless.</p>
<p><code>Message</code> and <code>Memory</code> provide the structure to:</p>
<ol type="1">
<li>Represent each individual turn (like your question or the agent's answer) clearly.</li>
<li>Store these turns in order, creating a log of the conversation.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2625"></a>
The Key Concepts: Message and Memory</h2>
<p>Let's break these down:</p>
<h3><a class="anchor" id="autotoc_md2626"></a>
1. Message: A Single Turn in the Chat</h3>
<p>A <code>Message</code> object is like a single speech bubble in a chat interface. It represents one specific thing said by someone (or something) at a particular point in the conversation.</p>
<p>Every <code>Message</code> has two main ingredients:</p>
<ul>
<li><b><code>role</code></b>: <em>Who</em> sent this message? This is crucial for the LLM to understand the flow. Common roles are:<ul>
<li><code>user</code>: A message from the end-user interacting with the agent. (e.g., "What's the weather?")</li>
<li><code>assistant</code>: A message <em>from</em> the agent/LLM. (e.g., "The weather is sunny.")</li>
<li><code>system</code>: An initial instruction to guide the agent's overall behavior. (e.g., "You are a helpful weather assistant.")</li>
<li><code>tool</code>: The output or result from a <a class="el" href="../../de/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_204__tool______toolcollection.html">Tool / ToolCollection</a> that the agent used. (e.g., The raw data returned by a weather API tool).</li>
</ul>
</li>
<li><b><code>content</code></b>: <em>What</em> was said? This is the actual text of the message. (e.g., "What's the weather like in London?")</li>
</ul>
<p>There are also optional parts for more advanced uses, like <code>tool_calls</code> (when the assistant decides to use a tool) or <code>base64_image</code> (if an image is included in the message), but <code>role</code> and <code>content</code> are the basics.</p>
<h3><a class="anchor" id="autotoc_md2627"></a>
2. Memory: The Conversation Log</h3>
<p>The <code>Memory</code> object is simply a container, like a list or a notebook, that holds a sequence of <code>Message</code> objects.</p>
<ul>
<li>It keeps track of the entire conversation history (or at least the recent parts).</li>
<li>It stores messages in the order they occurred.</li>
<li>Agents look at the <code>Memory</code> before deciding what to do next, giving them context.</li>
</ul>
<p>Think of <code>Memory</code> as the agent's short-term memory for the current interaction.</p>
<h2><a class="anchor" id="autotoc_md2628"></a>
How Do We Use Them?</h2>
<p>Let's see how you'd typically work with <code>Message</code> and <code>Memory</code> in OpenManus (often, the agent framework handles some of this automatically, but it's good to understand the pieces).</p>
<p><b>1. Creating Messages:</b></p>
<p>The <code>Message</code> class in <code>app/schema.py</code> provides handy shortcuts to create messages with the correct role:</p>
<div class="fragment"><div class="line"><span class="comment"># Import the Message class</span></div>
<div class="line"><span class="keyword">from</span> app.schema <span class="keyword">import</span> Message</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a message from the user</span></div>
<div class="line">user_q = Message.user_message(<span class="stringliteral">&quot;What&#39;s the capital of France?&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a message from the assistant (agent&#39;s response)</span></div>
<div class="line">assistant_a = Message.assistant_message(<span class="stringliteral">&quot;The capital of France is Paris.&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a system instruction</span></div>
<div class="line">system_instruction = Message.system_message(<span class="stringliteral">&quot;You are a helpful geography expert.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;User Message: Role=&#39;{user_q.role}&#39;, Content=&#39;{user_q.content}&#39;&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Assistant Message: Role=&#39;{assistant_a.role}&#39;, Content=&#39;{assistant_a.content}&#39;&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>We import <code>Message</code> from <code>app/schema.py</code>.</li>
<li><code>Message.user_message("...")</code> creates a <code>Message</code> object with <code>role</code> set to <code>user</code>.</li>
<li><code>Message.assistant_message("...")</code> creates one with <code>role</code> set to <code>assistant</code>.</li>
<li><code>Message.system_message("...")</code> creates one with <code>role</code> set to <code>system</code>.</li>
<li>Each of these returns a <code>Message</code> object containing the role and the text content you provided.</li>
</ul>
<p><b>Example Output:</b></p>
<div class="fragment"><div class="line">User Message: Role=&#39;user&#39;, Content=&#39;What&#39;s the capital of France?&#39;</div>
<div class="line">Assistant Message: Role=&#39;assistant&#39;, Content=&#39;The capital of France is Paris.&#39;</div>
</div><!-- fragment --><p><b>2. Storing Messages in Memory:</b></p>
<p>The <code>Memory</code> class (<code>app/schema.py</code>) holds these messages. Agents usually have a <code>memory</code> attribute.</p>
<div class="fragment"><div class="line"><span class="comment"># Import Memory and Message</span></div>
<div class="line"><span class="keyword">from</span> app.schema <span class="keyword">import</span> Message, Memory</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a Memory instance</span></div>
<div class="line">conversation_memory = Memory()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Add messages to the memory</span></div>
<div class="line">conversation_memory.add_message(</div>
<div class="line">    Message.system_message(<span class="stringliteral">&quot;You are a helpful geography expert.&quot;</span>)</div>
<div class="line">)</div>
<div class="line">conversation_memory.add_message(</div>
<div class="line">    Message.user_message(<span class="stringliteral">&quot;What&#39;s the capital of France?&quot;</span>)</div>
<div class="line">)</div>
<div class="line">conversation_memory.add_message(</div>
<div class="line">    Message.assistant_message(<span class="stringliteral">&quot;The capital of France is Paris.&quot;</span>)</div>
<div class="line">)</div>
<div class="line">conversation_memory.add_message(</div>
<div class="line">    Message.user_message(<span class="stringliteral">&quot;What about Spain?&quot;</span>)</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># See the messages stored</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Number of messages in memory: {len(conversation_memory.messages)}&quot;</span>)</div>
<div class="line"><span class="comment"># Print the last message</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Last message: {conversation_memory.messages[-1].to_dict()}&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>We import <code>Memory</code> and <code>Message</code>.</li>
<li><code>conversation_memory = Memory()</code> creates an empty memory store.</li>
<li><code>conversation_memory.add_message(...)</code> adds a <code>Message</code> object to the end of the internal list.</li>
<li><code>conversation_memory.messages</code> gives you access to the list of <code>Message</code> objects currently stored.</li>
<li><code>message.to_dict()</code> converts a <code>Message</code> object into a simple dictionary format, which is often needed for APIs.</li>
</ul>
<p><b>Example Output:</b></p>
<div class="fragment"><div class="line">Number of messages in memory: 4</div>
<div class="line">Last message: {&#39;role&#39;: &#39;user&#39;, &#39;content&#39;: &#39;What about Spain?&#39;}</div>
</div><!-- fragment --><p><b>3. Using Memory for Context:</b></p>
<p>Now, how does the agent use this? Before calling the <a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">LLM</a> to figure out the answer to "What about Spain?", the agent would grab the messages from its <code>Memory</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># (Continuing from previous example)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Agent prepares to ask the LLM</span></div>
<div class="line">messages_for_llm = conversation_memory.to_dict_list()</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;Messages being sent to LLM for context:&quot;</span>)</div>
<div class="line"><span class="keywordflow">for</span> msg <span class="keywordflow">in</span> messages_for_llm:</div>
<div class="line">    print(f<span class="stringliteral">&quot;- {msg}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Simplified: Agent would now pass &#39;messages_for_llm&#39; to llm.ask(...)</span></div>
<div class="line"><span class="comment"># response = await agent.llm.ask(messages=messages_for_llm)</span></div>
<div class="line"><span class="comment"># print(f&quot;LLM would likely respond about the capital of Spain, e.g., &#39;The capital of Spain is Madrid.&#39;&quot;)</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>conversation_memory.to_dict_list()</code> converts all stored <code>Message</code> objects into the list-of-dictionaries format that the <code>llm.ask</code> method expects (as we saw in Chapter 1).</li>
<li>By sending this <em>entire history</em>, the LLM sees:<ol type="1">
<li>Its instructions ("You are a helpful geography expert.")</li>
<li>The first question ("What's the capital of France?")</li>
<li>Its previous answer ("The capital of France is Paris.")</li>
<li>The <em>new</em> question ("What about Spain?")</li>
</ol>
</li>
<li>With this context, the LLM can correctly infer that "What about Spain?" means "What is the capital of Spain?".</li>
</ul>
<h2><a class="anchor" id="autotoc_md2629"></a>
Under the Hood: How It Works</h2>
<p><code>Memory</code> is conceptually simple. It's primarily a wrapper around a standard Python list, ensuring messages are stored correctly and providing convenient methods.</p>
<p>Here's a simplified flow of how an agent uses memory:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant Agent as BaseAgent (app/agent/base.py)</div>
<div class="line">    participant Mem as Memory (app/schema.py)</div>
<div class="line">    participant LLM as LLM Class (app/llm.py)</div>
<div class="line">    participant LLM_API as Actual LLM API</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;+Agent: Sends message (&quot;What about Spain?&quot;)</div>
<div class="line">    Agent-&gt;&gt;+Mem: update_memory(role=&quot;user&quot;, content=&quot;What about Spain?&quot;)</div>
<div class="line">    Mem-&gt;&gt;Mem: Adds Message(role=&#39;user&#39;, ...) to internal list</div>
<div class="line">    Mem--&gt;&gt;-Agent: Memory updated</div>
<div class="line">    Agent-&gt;&gt;Agent: Needs to generate response</div>
<div class="line">    Agent-&gt;&gt;+Mem: Get all messages (memory.messages)</div>
<div class="line">    Mem--&gt;&gt;-Agent: Returns list of Message objects</div>
<div class="line">    Agent-&gt;&gt;Agent: Formats messages to dict list (memory.to_dict_list())</div>
<div class="line">    Agent-&gt;&gt;+LLM: ask(messages=formatted_list)</div>
<div class="line">    LLM-&gt;&gt;LLM_API: Sends request with history</div>
<div class="line">    LLM_API--&gt;&gt;LLM: Receives response (&quot;The capital is Madrid.&quot;)</div>
<div class="line">    LLM--&gt;&gt;-Agent: Returns text response</div>
<div class="line">    Agent-&gt;&gt;+Mem: update_memory(role=&quot;assistant&quot;, content=&quot;The capital is Madrid.&quot;)</div>
<div class="line">    Mem-&gt;&gt;Mem: Adds Message(role=&#39;assistant&#39;, ...) to internal list</div>
<div class="line">    Mem--&gt;&gt;-Agent: Memory updated</div>
<div class="line">    Agent-&gt;&gt;-User: Sends response (&quot;The capital is Madrid.&quot;)</div>
</div><!-- fragment --><p><b>Code Glimpse:</b></p>
<p>Let's look at the core parts in <code>app/schema.py</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified snippet from app/schema.py</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Optional</div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</div>
<div class="line"> </div>
<div class="line"><span class="comment"># (Role enum and other definitions are here)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Message(BaseModel):</div>
<div class="line">    role: str <span class="comment"># Simplified: In reality uses ROLE_TYPE Literal</span></div>
<div class="line">    content: Optional[str] = <span class="keywordtype">None</span></div>
<div class="line">    <span class="comment"># ... other optional fields like tool_calls, name, etc.</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>to_dict(self) -&gt; dict:</div>
<div class="line">        <span class="comment"># Creates a dictionary representation, skipping None values</span></div>
<div class="line">        message_dict = {<span class="stringliteral">&quot;role&quot;</span>: self.role}</div>
<div class="line">        <span class="keywordflow">if</span> self.content <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line">            message_dict[<span class="stringliteral">&quot;content&quot;</span>] = self.content</div>
<div class="line">        <span class="comment"># ... add other fields if they exist ...</span></div>
<div class="line">        <span class="keywordflow">return</span> message_dict</div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@classmethod</span></div>
<div class="line">    <span class="keyword">def </span>user_message(cls, content: str) -&gt; <span class="stringliteral">&quot;Message&quot;</span>:</div>
<div class="line">        <span class="keywordflow">return</span> cls(role=<span class="stringliteral">&quot;user&quot;</span>, content=content)</div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@classmethod</span></div>
<div class="line">    <span class="keyword">def </span>assistant_message(cls, content: Optional[str]) -&gt; <span class="stringliteral">&quot;Message&quot;</span>:</div>
<div class="line">        <span class="keywordflow">return</span> cls(role=<span class="stringliteral">&quot;assistant&quot;</span>, content=content)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... other classmethods like system_message, tool_message ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Memory(BaseModel):</div>
<div class="line">    messages: List[Message] = Field(default_factory=list)</div>
<div class="line">    max_messages: int = 100 <span class="comment"># Example limit</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>add_message(self, message: Message) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Add a single message to the list.&quot;&quot;&quot;</span></div>
<div class="line">        self.messages.append(message)</div>
<div class="line">        <span class="comment"># Optional: Trim old messages if limit exceeded</span></div>
<div class="line">        <span class="keywordflow">if</span> len(self.messages) &gt; self.max_messages:</div>
<div class="line">            self.messages = self.messages[-self.max_messages :]</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>to_dict_list(self) -&gt; List[dict]:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Convert all stored messages to dictionaries.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> [msg.to_dict() <span class="keywordflow">for</span> msg <span class="keywordflow">in</span> self.messages]</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... other methods like clear(), get_recent_messages() ...</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>The <code>Message</code> class uses Pydantic <code>BaseModel</code> for structure and validation. It clearly defines <code>role</code> and <code>content</code>. The classmethods (<code>user_message</code>, etc.) are just convenient ways to create instances with the role pre-filled. <code>to_dict</code> prepares it for API calls.</li>
<li>The <code>Memory</code> class also uses <code>BaseModel</code>. Its main part is <code>messages: List[Message]</code>, which holds the conversation history. <code>add_message</code> simply appends to this list (and optionally trims it). <code>to_dict_list</code> iterates through the stored messages and converts each one using its <code>to_dict</code> method.</li>
</ul>
<p>And here's how an agent might use its memory attribute (simplified from <code>app/agent/base.py</code>):</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified conceptual snippet inspired by app/agent/base.py</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> app.schema <span class="keyword">import</span> Memory, Message, ROLE_TYPE <span class="comment"># Simplified imports</span></div>
<div class="line"><span class="keyword">from</span> app.llm <span class="keyword">import</span> LLM</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SimplifiedAgent:</div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        self.memory = Memory() <span class="comment"># Agent holds a Memory instance</span></div>
<div class="line">        self.llm = LLM() <span class="comment"># Agent has access to the LLM</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>add_user_input(self, text: str):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Adds user input to memory.&quot;&quot;&quot;</span></div>
<div class="line">        user_msg = Message.user_message(text)</div>
<div class="line">        self.memory.add_message(user_msg)</div>
<div class="line">        print(f<span class="stringliteral">&quot;Agent Memory Updated with: {user_msg.to_dict()}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>generate_response(self) -&gt; str:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Generates a response based on memory.&quot;&quot;&quot;</span></div>
<div class="line">        print(<span class="stringliteral">&quot;Agent consulting memory...&quot;</span>)</div>
<div class="line">        messages_for_llm = self.memory.to_dict_list()</div>
<div class="line"> </div>
<div class="line">        print(f<span class="stringliteral">&quot;Sending {len(messages_for_llm)} messages to LLM...&quot;</span>)</div>
<div class="line">        <span class="comment"># The actual call to the LLM</span></div>
<div class="line">        response_text = await self.llm.ask(messages=messages_for_llm)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Add assistant response to memory</span></div>
<div class="line">        assistant_msg = Message.assistant_message(response_text)</div>
<div class="line">        self.memory.add_message(assistant_msg)</div>
<div class="line">        print(f<span class="stringliteral">&quot;Agent Memory Updated with: {assistant_msg.to_dict()}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> response_text</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Example Usage (needs async context)</span></div>
<div class="line"><span class="comment"># agent = SimplifiedAgent()</span></div>
<div class="line"><span class="comment"># agent.add_user_input(&quot;What is the capital of France?&quot;)</span></div>
<div class="line"><span class="comment"># response = await agent.generate_response() # Gets &quot;Paris&quot;</span></div>
<div class="line"><span class="comment"># agent.add_user_input(&quot;What about Spain?&quot;)</span></div>
<div class="line"><span class="comment"># response2 = await agent.generate_response() # Gets &quot;Madrid&quot;</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>The agent has <code>self.memory</code>.</li>
<li>When input arrives (<code>add_user_input</code>), it creates a <code>Message</code> and adds it using <code>self.memory.add_message</code>.</li>
<li>When generating a response (<code>generate_response</code>), it retrieves the history using <code>self.memory.to_dict_list()</code> and passes it to <code>self.llm.ask</code>.</li>
<li>It then adds the LLM's response back into memory as an <code>assistant</code> message.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2630"></a>
Wrapping Up Chapter 2</h2>
<p>You've now learned about <code>Message</code> (a single conversational turn with a role and content) and <code>Memory</code> (the ordered list storing these messages). Together, they provide the crucial context agents need to understand conversations and respond coherently. They act as the agent's short-term memory or chat log.</p>
<p>We have the brain (<a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">LLM</a>) and the memory (<code>Message</code>/<code>Memory</code>). Now we need something to orchestrate the process – to receive input, consult memory, use the LLM, potentially use tools, and manage its state. That's the job of the Agent itself.</p>
<p>Let's move on to <a class="el" href="../../d0/d71/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_203__baseagent.html">Chapter 3: BaseAgent</a> to see how agents are structured and how they use these core components.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
