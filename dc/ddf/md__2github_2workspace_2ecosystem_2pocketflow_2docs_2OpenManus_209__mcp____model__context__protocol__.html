#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 09_mcp__model_context_protocol_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/ddf/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_209__mcp____model__context__protocol__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">09_mcp__model_context_protocol_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2695"></a>
autotoc_md2695</h2>
<p>layout: default title: "MCP (Model Context Protocol)" parent: "OpenManus" </p>
<h2><a class="anchor" id="autotoc_md2696"></a>
nav_order: 9</h2>
<h1><a class="anchor" id="autotoc_md2697"></a>
Chapter 9: MCP (Model Context Protocol)</h1>
<p>Welcome to the final chapter of our core concepts tutorial! In <a class="el" href="../../de/da6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_208__dockersandbox.html">Chapter 8: DockerSandbox</a>, we saw how OpenManus can safely run code in an isolated environment. Now, let's explore a powerful way to extend your agent's capabilities <em>without</em> changing its internal code: the <b>Model Context Protocol (MCP)</b>.</p>
<h2><a class="anchor" id="autotoc_md2698"></a>
What Problem Does MCP Solve?</h2>
<p>Imagine you have an agent running smoothly. Suddenly, you realize you need it to perform a new, specialized task – maybe interacting with a custom company database or using a complex scientific calculation library.</p>
<p>Normally, you might have to:</p><ol type="1">
<li>Stop the agent.</li>
<li>Write new code for the <a class="el" href="../../de/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_204__tool______toolcollection.html">Tool</a> that performs this task.</li>
<li>Add this tool to the agent's code or configuration.</li>
<li>Restart the agent.</li>
</ol>
<p>This process can be cumbersome, especially if you want to add or update tools frequently, or if different people are managing different tools.</p>
<p>What if there was a way for the agent to <b>dynamically discover and use tools</b> provided by a completely separate service? Like plugging in a new USB device, and your computer automatically recognizes and uses it?</p>
<p><b>This is what MCP enables!</b> It defines a standard way for an OpenManus agent (<code>MCPAgent</code>) to connect to an external <b>MCP Server</b>. This server advertises the tools it offers, and the agent can call these tools remotely as if they were built-in.</p>
<p><b>Use Case:</b> Let's say we want our agent to be able to run basic shell commands (like <code>ls</code> or <code>pwd</code>) using the <code>Bash</code> tool. Instead of building the <code>Bash</code> tool directly into the agent, we can run an <code>MCPServer</code> that <em>offers</em> the <code>Bash</code> tool. Our <code>MCPAgent</code> can connect to this server, discover the <code>Bash</code> tool, and use it when needed, all without having the <code>Bash</code> tool's code inside the agent itself. If we later update the <code>Bash</code> tool on the server, the agent automatically gets the new version without needing changes.</p>
<h2><a class="anchor" id="autotoc_md2699"></a>
Key Concepts: The Agent, The Server, and The Rules</h2>
<p>MCP involves a few key players working together:</p>
<ol type="1">
<li><b><code>MCPServer</code> (The Tool Provider):</b><ul>
<li>Think of this as a separate application, like a dedicated "Tool Shop" running independently from your agent.</li>
<li>It holds one or more <a class="el" href="../../de/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_204__tool______toolcollection.html">Tools</a> (like <code>Bash</code>, <code>BrowserUseTool</code>, <code>StrReplaceEditor</code>, or custom ones).</li>
<li>It "advertises" these tools, meaning it can tell connected clients (agents) which tools are available, what they do, and how to use them.</li>
<li>When asked, it executes a tool and sends the result back.</li>
<li>In OpenManus, <code>app/mcp/server.py</code> provides an implementation of this server.</li>
</ul>
</li>
<li><b><code>MCPAgent</code> (The Tool User):</b><ul>
<li>This is a specialized type of <a class="el" href="../../d0/d71/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_203__baseagent.html">BaseAgent</a> designed specifically to talk to an <code>MCPServer</code>.</li>
<li>When it starts, it connects to the specified <code>MCPServer</code>.</li>
<li>It asks the server: "What tools do you have?"</li>
<li>It treats the server's tools as its own available <code>ToolCollection</code>.</li>
<li>When its <a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">LLM</a> decides to use one of these tools, the <code>MCPAgent</code> sends a request to the <code>MCPServer</code> to execute it.</li>
<li>It can even periodically check if the server has added or removed tools and update its capabilities accordingly!</li>
</ul>
</li>
<li><b>The Protocol (The Rules of Communication):</b><ul>
<li>MCP defines the exact format of messages exchanged between the <code>MCPAgent</code> and <code>MCPServer</code>. How does the agent ask for the tool list? How does it request a tool execution? How is the result formatted?</li>
<li>OpenManus supports two main ways (transports) for this communication:<ul>
<li><b>stdio (Standard Input/Output):</b> The agent starts the server process directly and communicates with it using standard text streams (like typing commands in a terminal). This is simpler for local setups.</li>
<li><b>SSE (Server-Sent Events):</b> The agent connects to a running server over the network (using HTTP). This is more suitable if the server is running elsewhere.</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><em>Analogy:</em> Imagine the <code>MCPServer</code> is a smart TV's App Store, offering apps (tools) like Netflix or YouTube. The <code>MCPAgent</code> is a universal remote control. MCP is the protocol that lets the remote connect to the TV, see the available apps, and tell the TV "Launch Netflix" or "Play this video on YouTube". The actual app logic runs on the TV (the server), not the remote (the agent).</p>
<h2><a class="anchor" id="autotoc_md2700"></a>
How Do We Use It?</h2>
<p>Let's see how to run the server and connect an agent using the simple <code>stdio</code> method.</p>
<p><b>1. Run the MCPServer:</b></p>
<p>The server needs to be running first. OpenManus provides a script to run a server that includes standard tools like <code>Bash</code>, <code>Browser</code>, and <code>Editor</code>.</p>
<p>Open a terminal and run:</p>
<div class="fragment"><div class="line"># Make sure you are in the root directory of the OpenManus project</div>
<div class="line"># Use python to run the server module</div>
<div class="line">python -m app.mcp.server --transport stdio</div>
</div><!-- fragment --><p><b>Expected Output (in the server terminal):</b></p>
<div class="fragment"><div class="line">INFO:root:Registered tool: bash</div>
<div class="line">INFO:root:Registered tool: browser</div>
<div class="line">INFO:root:Registered tool: editor</div>
<div class="line">INFO:root:Registered tool: terminate</div>
<div class="line">INFO:root:Starting OpenManus server (stdio mode)</div>
<div class="line"># --- The server is now running and waiting for a connection ---</div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li><code>python -m app.mcp.server</code> tells Python to run the server code located in <code>app/mcp/server.py</code>.</li>
<li><code>--transport stdio</code> specifies that it should listen for connections via standard input/output.</li>
<li>It registers the built-in tools and waits.</li>
</ul>
<p><b>2. Run the MCPAgent (connecting to the server):</b></p>
<p>Now, open a <em>separate</em> terminal. We'll run a script that starts the <code>MCPAgent</code> and tells it how to connect to the server we just started.</p>
<div class="fragment"><div class="line"># In a NEW terminal, in the root directory of OpenManus</div>
<div class="line"># Run the MCP agent runner script</div>
<div class="line">python run_mcp.py --connection stdio --interactive</div>
</div><!-- fragment --><p><b>Expected Output (in the agent terminal):</b></p>
<div class="fragment"><div class="line">INFO:app.config:Configuration loaded successfully from .../config/config.toml</div>
<div class="line">INFO:app.agent.mcp:Initializing MCPAgent with stdio connection...</div>
<div class="line"># ... (potential logs about connecting) ...</div>
<div class="line">INFO:app.tool.mcp:Connected to server with tools: [&#39;bash&#39;, &#39;browser&#39;, &#39;editor&#39;, &#39;terminate&#39;]</div>
<div class="line">INFO:app.agent.mcp:Connected to MCP server via stdio</div>
<div class="line"> </div>
<div class="line">MCP Agent Interactive Mode (type &#39;exit&#39; to quit)</div>
<div class="line"> </div>
<div class="line">Enter your request:</div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li><code>python run_mcp.py</code> runs the agent launcher script.</li>
<li><code>--connection stdio</code> tells the agent to connect using standard input/output. The script (<code>run_mcp.py</code>) knows how to start the server process (<code>python -m app.mcp.server</code>) for this mode.</li>
<li><code>--interactive</code> puts the agent in a mode where you can chat with it.</li>
<li>The agent connects, asks the server for its tools (<code>list_tools</code>), and logs the tools it found (<code>bash</code>, <code>browser</code>, etc.). It's now ready for your requests!</li>
</ul>
<p><b>3. Interact with the Agent (Using a Server Tool):</b></p>
<p>Now, in the agent's interactive prompt, ask it to do something that requires a tool provided by the server, like listing files using <code>bash</code>:</p>
<div class="fragment"><div class="line"># In the agent&#39;s terminal</div>
<div class="line">Enter your request: Use the bash tool to list the files in the current directory.</div>
</div><!-- fragment --><p><b>What Happens:</b></p>
<ol type="1">
<li>The <code>MCPAgent</code> receives your request.</li>
<li>Its <a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">LLM</a> analyzes the request and decides the <code>bash</code> tool is needed, with the command <code>ls</code>.</li>
<li>The agent sees that <code>bash</code> is a tool provided by the connected <code>MCPServer</code>.</li>
<li>The agent sends a <code>call_tool</code> request over <code>stdio</code> to the server: "Please run `bash` with `command='ls'`".</li>
<li>The <code>MCPServer</code> receives the request, finds its <code>Bash</code> tool, and executes <code>ls</code>.</li>
<li>The server captures the output (the list of files).</li>
<li>The server sends the result back to the agent.</li>
<li>The agent receives the result, adds it to its <a class="el" href="../../dc/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_202__message______memory.html">Memory</a>, and might use its LLM again to formulate a user-friendly response based on the tool's output.</li>
</ol>
<p><b>Expected Output (in the agent terminal, may vary):</b></p>
<div class="fragment"><div class="line"># ... (Potential LLM thinking logs) ...</div>
<div class="line">INFO:app.agent.mcp:Executing tool: bash with input {&#39;command&#39;: &#39;ls&#39;}</div>
<div class="line"># ... (Server logs might show execution in its own terminal) ...</div>
<div class="line"> </div>
<div class="line">Agent: The bash tool executed the &#39;ls&#39; command and returned the following output:</div>
<div class="line">[List of files/directories in the project root, e.g.,]</div>
<div class="line">README.md</div>
<div class="line">app</div>
<div class="line">config</div>
<div class="line">run_mcp.py</div>
<div class="line">... etc ...</div>
</div><!-- fragment --><p>Success! The agent used a tool (<code>bash</code>) that wasn't part of its own code, but was provided dynamically by the external <code>MCPServer</code> via the Model Context Protocol. If you added a <em>new</em> tool to the <code>MCPServer</code> code and restarted the server, the agent could potentially discover and use it without needing any changes itself (it periodically refreshes the tool list).</p>
<p>Type <code>exit</code> in the agent's terminal to stop it, then stop the server (usually Ctrl+C in its terminal).</p>
<h2><a class="anchor" id="autotoc_md2701"></a>
Under the Hood: How MCP Communication Flows</h2>
<p>Let's trace the simplified steps when the agent uses a server tool:</p>
<ol type="1">
<li><b>Connect &amp; List:</b> Agent starts, connects to Server (<code>stdio</code> or <code>SSE</code>). Agent sends <code>list_tools</code> request. Server replies with list of tools (<code>name</code>, <code>description</code>, <code>parameters</code>). Agent stores these.</li>
<li><b>User Request:</b> User asks agent to do something (e.g., "list files").</li>
<li><b>LLM Decides:</b> Agent's LLM decides to use <code>bash</code> tool with &lsquo;command='ls&rsquo;<code>.</code></li>
<li><code> **Agent Request:** Agent finds</code>bash<code>in its list of server tools. Sends</code>call_tool<code>request to Server (containing tool name</code>bash<code>and arguments</code>{'command': 'ls'}<code>).</code></li>
<li><code> **Server Executes:** Server receives request. Finds its internal</code>Bash<code>tool. Calls the tool's</code>execute(command='ls')<code>method. The tool runs</code>ls`.</li>
<li><b>Server Response:</b> Server gets the result from the tool (e.g., "README.md\napp\n..."). Sends this result back to the Agent.</li>
<li><b>Agent Processes:</b> Agent receives the result. Updates its memory. Presents the answer to the user.</li>
</ol>
<p><b>Sequence Diagram:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant Agent as MCPAgent</div>
<div class="line">    participant LLM as Agent&#39;s LLM</div>
<div class="line">    participant Server as MCPServer</div>
<div class="line">    participant BashTool as Bash Tool (on Server)</div>
<div class="line"> </div>
<div class="line">    Note over Agent, Server: Initial Connection &amp; list_tools (omitted for brevity)</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;+Agent: &quot;List files using bash&quot;</div>
<div class="line">    Agent-&gt;&gt;+LLM: ask_tool(&quot;List files&quot;, tools=[...bash_schema...])</div>
<div class="line">    LLM--&gt;&gt;-Agent: Decide: call tool &#39;bash&#39;, args={&#39;command&#39;:&#39;ls&#39;}</div>
<div class="line">    Agent-&gt;&gt;+Server: call_tool(name=&#39;bash&#39;, args={&#39;command&#39;:&#39;ls&#39;})</div>
<div class="line">    Server-&gt;&gt;+BashTool: execute(command=&#39;ls&#39;)</div>
<div class="line">    BashTool-&gt;&gt;BashTool: Runs &#39;ls&#39; command</div>
<div class="line">    BashTool--&gt;&gt;-Server: Returns file list string</div>
<div class="line">    Server--&gt;&gt;-Agent: Tool Result (output=file list)</div>
<div class="line">    Agent-&gt;&gt;Agent: Process result, update memory</div>
<div class="line">    Agent--&gt;&gt;-User: &quot;OK, the files are: ...&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2702"></a>
Code Glimpse: Key MCP Components</h2>
<p>Let's look at simplified parts of the relevant files.</p>
<p><b>1. <code>MCPServer</code> (<code>app/mcp/server.py</code>): Registering Tools</b> The server uses the <code>fastmcp</code> library to handle the protocol details. It needs to register the tools it wants to offer.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified snippet from app/mcp/server.py</span></div>
<div class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</div>
<div class="line"><span class="keyword">from</span> app.tool.base <span class="keyword">import</span> BaseTool</div>
<div class="line"><span class="keyword">from</span> app.tool.bash <span class="keyword">import</span> Bash <span class="comment"># Import the tool to offer</span></div>
<div class="line"><span class="keyword">from</span> app.logger <span class="keyword">import</span> logger</div>
<div class="line"><span class="keyword">import</span> json</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MCPServer:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, name: str = <span class="stringliteral">&quot;openmanus&quot;</span>):</div>
<div class="line">        self.server = FastMCP(name) <span class="comment"># The underlying MCP server library</span></div>
<div class="line">        self.tools: Dict[str, BaseTool] = {}</div>
<div class="line">        <span class="comment"># Add tools to offer</span></div>
<div class="line">        self.tools[<span class="stringliteral">&quot;bash&quot;</span>] = Bash()</div>
<div class="line">        <span class="comment"># ... add other tools like Browser, Editor ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>register_tool(self, tool: BaseTool) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Registers a tool&#39;s execute method with the FastMCP server.&quot;&quot;&quot;</span></div>
<div class="line">        tool_name = tool.name</div>
<div class="line">        tool_param = tool.to_param() <span class="comment"># Get schema for the LLM</span></div>
<div class="line">        tool_function = tool_param[<span class="stringliteral">&quot;function&quot;</span>]</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Define the function that the MCP server will expose</span></div>
<div class="line">        <span class="keyword">async def </span>tool_method(**kwargs):</div>
<div class="line">            logger.info(f<span class="stringliteral">&quot;Executing {tool_name} via MCP: {kwargs}&quot;</span>)</div>
<div class="line">            <span class="comment"># Call the actual tool&#39;s execute method</span></div>
<div class="line">            result = await tool.execute(**kwargs)</div>
<div class="line">            logger.info(f<span class="stringliteral">&quot;Result of {tool_name}: {result}&quot;</span>)</div>
<div class="line">            <span class="comment"># Return result (often needs conversion, e.g., to JSON)</span></div>
<div class="line">            <span class="keywordflow">return</span> json.dumps(result.model_dump()) <span class="keywordflow">if</span> hasattr(result, <span class="stringliteral">&quot;model_dump&quot;</span>) <span class="keywordflow">else</span> str(result)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Attach metadata (name, description, parameters) for discovery</span></div>
<div class="line">        tool_method.__name__ = tool_name</div>
<div class="line">        tool_method.__doc__ = self._build_docstring(tool_function)</div>
<div class="line">        tool_method.__signature__ = self._build_signature(tool_function)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Register with the FastMCP library instance</span></div>
<div class="line">        self.server.tool()(tool_method)</div>
<div class="line">        logger.info(f<span class="stringliteral">&quot;Registered tool for MCP: {tool_name}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>register_all_tools(self):</div>
<div class="line">        <span class="keywordflow">for</span> tool <span class="keywordflow">in</span> self.tools.values():</div>
<div class="line">            self.register_tool(tool)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>run(self, transport: str = <span class="stringliteral">&quot;stdio&quot;</span>):</div>
<div class="line">        self.register_all_tools()</div>
<div class="line">        logger.info(f<span class="stringliteral">&quot;Starting MCP server ({transport} mode)&quot;</span>)</div>
<div class="line">        self.server.run(transport=transport) <span class="comment"># Start listening</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Command-line execution part:</span></div>
<div class="line"><span class="comment"># if __name__ == &quot;__main__&quot;:</span></div>
<div class="line"><span class="comment">#    server = MCPServer()</span></div>
<div class="line"><span class="comment">#    server.run(transport=&quot;stdio&quot;) # Or based on args</span></div>
</div><!-- fragment --><p><b>Explanation:</b> The <code>MCPServer</code> creates instances of tools (<code>Bash</code>, etc.) and then uses <code>register_tool</code> to wrap each tool's <code>execute</code> method into a format the <code>fastmcp</code> library understands. This allows the server to advertise the tool (with its name, description, parameters) and call the correct function when the agent makes a <code>call_tool</code> request.</p>
<p><b>2. <code>MCPClients</code> (<code>app/tool/mcp.py</code>): Client-Side Tool Representation</b> The <code>MCPAgent</code> uses this class, which acts like a <code>ToolCollection</code>, but its tools are proxies that make calls to the remote server.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified snippet from app/tool/mcp.py</span></div>
<div class="line"><span class="keyword">from</span> mcp <span class="keyword">import</span> ClientSession <span class="comment"># MCP library for client-side communication</span></div>
<div class="line"><span class="keyword">from</span> mcp.client.stdio <span class="keyword">import</span> stdio_client <span class="comment"># Specific transport handler</span></div>
<div class="line"><span class="keyword">from</span> mcp.types <span class="keyword">import</span> TextContent</div>
<div class="line"><span class="keyword">from</span> app.tool.base <span class="keyword">import</span> BaseTool, ToolResult</div>
<div class="line"><span class="keyword">from</span> app.tool.tool_collection <span class="keyword">import</span> ToolCollection</div>
<div class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> AsyncExitStack</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Represents a single tool on the server, callable from the client</span></div>
<div class="line"><span class="keyword">class </span>MCPClientTool(BaseTool):</div>
<div class="line">    session: Optional[ClientSession] = <span class="keywordtype">None</span> <span class="comment"># Holds the connection</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>execute(self, **kwargs) -&gt; ToolResult:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Execute by calling the remote tool via the MCP session.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.session: <span class="keywordflow">return</span> ToolResult(error=<span class="stringliteral">&quot;Not connected&quot;</span>)</div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="comment"># Make the actual remote call</span></div>
<div class="line">            result = await self.session.call_tool(self.name, kwargs)</div>
<div class="line">            <span class="comment"># Extract text output from the response</span></div>
<div class="line">            content = <span class="stringliteral">&quot;, &quot;</span>.join(</div>
<div class="line">                item.text <span class="keywordflow">for</span> item <span class="keywordflow">in</span> result.content <span class="keywordflow">if</span> isinstance(item, TextContent)</div>
<div class="line">            )</div>
<div class="line">            <span class="keywordflow">return</span> ToolResult(output=content <span class="keywordflow">or</span> <span class="stringliteral">&quot;No output.&quot;</span>)</div>
<div class="line">        <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">            <span class="keywordflow">return</span> ToolResult(error=f<span class="stringliteral">&quot;MCP tool error: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># The collection holding the proxy tools</span></div>
<div class="line"><span class="keyword">class </span>MCPClients(ToolCollection):</div>
<div class="line">    session: Optional[ClientSession] = <span class="keywordtype">None</span></div>
<div class="line">    exit_stack: AsyncExitStack = <span class="keywordtype">None</span> <span class="comment"># Manages connection resources</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>connect_stdio(self, command: str, args: List[str]):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Connect using stdio.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> self.session: await self.disconnect()</div>
<div class="line">        self.exit_stack = AsyncExitStack()</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Set up stdio connection using MCP library helper</span></div>
<div class="line">        server_params = {<span class="stringliteral">&quot;command&quot;</span>: command, <span class="stringliteral">&quot;args&quot;</span>: args} <span class="comment"># Simplified</span></div>
<div class="line">        streams = await self.exit_stack.enter_async_context(</div>
<div class="line">            stdio_client(server_params)</div>
<div class="line">        )</div>
<div class="line">        <span class="comment"># Establish the MCP session over the connection</span></div>
<div class="line">        self.session = await self.exit_stack.enter_async_context(</div>
<div class="line">            ClientSession(*streams)</div>
<div class="line">        )</div>
<div class="line">        await self._initialize_and_list_tools() <span class="comment"># Get tool list from server</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>_initialize_and_list_tools(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Fetch tools from server and create proxy objects.&quot;&quot;&quot;</span></div>
<div class="line">        await self.session.initialize()</div>
<div class="line">        response = await self.session.list_tools() <span class="comment"># Ask server for tools</span></div>
<div class="line"> </div>
<div class="line">        self.tool_map = {}</div>
<div class="line">        <span class="keywordflow">for</span> tool_info <span class="keywordflow">in</span> response.tools:</div>
<div class="line">            <span class="comment"># Create an MCPClientTool instance for each server tool</span></div>
<div class="line">            proxy_tool = MCPClientTool(</div>
<div class="line">                name=tool_info.name,</div>
<div class="line">                description=tool_info.description,</div>
<div class="line">                parameters=tool_info.inputSchema, <span class="comment"># Use schema from server</span></div>
<div class="line">                session=self.session, <span class="comment"># Pass the active session</span></div>
<div class="line">            )</div>
<div class="line">            self.tool_map[tool_info.name] = proxy_tool</div>
<div class="line">        self.tools = tuple(self.tool_map.values())</div>
<div class="line">        logger.info(f<span class="stringliteral">&quot;MCP Client found tools: {list(self.tool_map.keys())}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>disconnect(self):</div>
<div class="line">        <span class="keywordflow">if</span> self.session <span class="keywordflow">and</span> self.exit_stack:</div>
<div class="line">            await self.exit_stack.aclose() <span class="comment"># Clean up connection</span></div>
<div class="line">            <span class="comment"># ... reset state ...</span></div>
</div><!-- fragment --><p><b>Explanation:</b> <code>MCPClients</code> handles the connection (<code>connect_stdio</code>). When connected, it calls <code>list_tools</code> on the server. For each tool reported by the server, it creates a local <code>MCPClientTool</code> proxy object. This proxy object looks like a normal <code>BaseTool</code> (with name, description, parameters), but its <code>execute</code> method doesn't run code locally – instead, it uses the active <code>ClientSession</code> to send a <code>call_tool</code> request back to the server.</p>
<p><b>3. <code>MCPAgent</code> (<code>app/agent/mcp.py</code>): Using MCPClients</b> The agent integrates the <code>MCPClients</code> collection.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified snippet from app/agent/mcp.py</span></div>
<div class="line"><span class="keyword">from</span> app.agent.toolcall <span class="keyword">import</span> ToolCallAgent</div>
<div class="line"><span class="keyword">from</span> app.tool.mcp <span class="keyword">import</span> MCPClients</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MCPAgent(ToolCallAgent):</div>
<div class="line">    <span class="comment"># Use MCPClients as the tool collection</span></div>
<div class="line">    mcp_clients: MCPClients = Field(default_factory=MCPClients)</div>
<div class="line">    available_tools: MCPClients = <span class="keywordtype">None</span> <span class="comment"># Will point to mcp_clients</span></div>
<div class="line"> </div>
<div class="line">    connection_type: str = <span class="stringliteral">&quot;stdio&quot;</span></div>
<div class="line">    <span class="comment"># ... other fields ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>initialize(</div>
<div class="line">        self, command: Optional[str] = <span class="keywordtype">None</span>, args: Optional[List[str]] = <span class="keywordtype">None</span>, ...</div>
<div class="line">    ):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Initialize by connecting the MCPClients instance.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> self.connection_type == <span class="stringliteral">&quot;stdio&quot;</span>:</div>
<div class="line">            <span class="comment"># Tell mcp_clients to connect</span></div>
<div class="line">            await self.mcp_clients.connect_stdio(command=command, args=args <span class="keywordflow">or</span> [])</div>
<div class="line">        <span class="comment"># elif self.connection_type == &quot;sse&quot;: ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># The agent&#39;s tools are now the tools provided by the server</span></div>
<div class="line">        self.available_tools = self.mcp_clients</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Store initial tool schemas for detecting changes later</span></div>
<div class="line">        self.tool_schemas = {t.name: t.parameters <span class="keywordflow">for</span> t <span class="keywordflow">in</span> self.available_tools}</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Add system message about tools...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>_refresh_tools(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Periodically check the server for tool updates.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.mcp_clients.session: <span class="keywordflow">return</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Ask the server for its current list of tools</span></div>
<div class="line">        response = await self.mcp_clients.session.list_tools()</div>
<div class="line">        current_tools = {t.name: t.inputSchema <span class="keywordflow">for</span> t <span class="keywordflow">in</span> response.tools}</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Compare with stored schemas (self.tool_schemas)</span></div>
<div class="line">        <span class="comment"># Detect added/removed tools and update self.tool_schemas</span></div>
<div class="line">        <span class="comment"># Add system messages to memory if tools change</span></div>
<div class="line">        <span class="comment"># ... logic to detect and log changes ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>think(self) -&gt; bool:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Agent&#39;s thinking step.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Refresh tools periodically</span></div>
<div class="line">        <span class="keywordflow">if</span> self.current_step % self._refresh_tools_interval == 0:</div>
<div class="line">            await self._refresh_tools()</div>
<div class="line">            <span class="comment"># Stop if server seems gone (no tools left)</span></div>
<div class="line">            <span class="keywordflow">if</span> <span class="keywordflow">not</span> self.mcp_clients.tool_map: <span class="keywordflow">return</span> <span class="keyword">False</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Use parent class&#39;s think method, which uses self.available_tools</span></div>
<div class="line">        <span class="comment"># (which points to self.mcp_clients) for tool decisions/calls</span></div>
<div class="line">        <span class="keywordflow">return</span> await super().think()</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>cleanup(self):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Disconnect the MCP session when the agent finishes.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> self.mcp_clients.session:</div>
<div class="line">            await self.mcp_clients.disconnect()</div>
</div><!-- fragment --><p><b>Explanation:</b> The <code>MCPAgent</code> holds an instance of <code>MCPClients</code>. In <code>initialize</code>, it tells <code>MCPClients</code> to connect to the server. It sets its own <code>available_tools</code> to point to the <code>MCPClients</code> instance. When the agent's <code>think</code> method (inherited from <code>ToolCallAgent</code>) needs to consider or execute tools, it uses <code>self.available_tools</code>. Because this <em>is</em> the <code>MCPClients</code> object, any tool execution results in a remote call to the <code>MCPServer</code> via the proxy tools. The agent also adds logic to periodically <code>_refresh_tools</code> and <code>cleanup</code> the connection.</p>
<h2><a class="anchor" id="autotoc_md2703"></a>
Wrapping Up Chapter 9</h2>
<p>Congratulations on completing the core concepts tutorial!</p>
<p>In this final chapter, we explored the <b>Model Context Protocol (MCP)</b>. You learned how MCP allows an <code>MCPAgent</code> to connect to an external <code>MCPServer</code> and dynamically discover and use tools hosted by that server. This provides a powerful way to extend agent capabilities with specialized tools without modifying the agent's core code, enabling a flexible, plug-and-play architecture for agent skills.</p>
<p>You've journeyed through the essential building blocks of OpenManus:</p><ul>
<li>The "brain" (<a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">LLM</a>)</li>
<li>Conversation history (<a class="el" href="../../dc/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_202__message______memory.html">Message / Memory</a>)</li>
<li>The agent structure (<a class="el" href="../../d0/d71/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_203__baseagent.html">BaseAgent</a>)</li>
<li>Agent skills (<a class="el" href="../../de/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_204__tool______toolcollection.html">Tool / ToolCollection</a>)</li>
<li>Multi-step task orchestration (<a class="el" href="../../d0/d93/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_205__baseflow.html">BaseFlow</a>)</li>
<li>Data structure definitions (<a class="el" href="../../d6/d4f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_206__schema.html">Schema</a>)</li>
<li>Settings management (<a class="el" href="../../d5/d05/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_207__configuration____config__.html">Configuration (Config)</a>)</li>
<li>Secure code execution (<a class="el" href="../../de/da6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_208__dockersandbox.html">DockerSandbox</a>)</li>
<li>And dynamic external tools (<a class="el" href="../../dc/ddf/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_209__mcp____model__context__protocol__.html">MCP</a>)</li>
</ul>
<p>Armed with this knowledge, you're now well-equipped to start exploring the OpenManus codebase, experimenting with different agents and tools, and building your own intelligent applications! Good luck!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
