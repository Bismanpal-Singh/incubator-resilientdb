#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 08_multi_agent_orchestration__host_agent_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/ddf/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_208__multi__agent__orchestration____host__agent__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">08_multi_agent_orchestration__host_agent_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2041"></a>
autotoc_md2041</h2>
<p>layout: default title: "Multi-Agent Orchestration (Host Agent)" parent: "Google A2A" </p>
<h2><a class="anchor" id="autotoc_md2042"></a>
nav_order: 8</h2>
<h1><a class="anchor" id="autotoc_md2043"></a>
Chapter 8: Multi-Agent Orchestration (Host Agent)</h1>
<p>In the <a class="el" href="../../d0/d60/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_207__streaming__communication____sse__.html">previous chapter</a>, we saw how an agent server can stream updates back to a client using Server-Sent Events (SSE). This is great for keeping users informed during long tasks.</p>
<p>But what if a task is <em>so</em> complex that no single AI agent can handle it alone? Imagine asking an assistant: "Plan a weekend trip to London for me, including flights from New York, a hotel near the British Museum, and suggest two vegetarian restaurants."</p>
<p>One agent might be amazing at finding flights, another specialized in hotel bookings, and a third brilliant at restaurant recommendations. How can we get these specialist agents to work together to fulfill your complex request?</p>
<p>This chapter introduces the concept of <b>Multi-Agent Orchestration</b> using a <b>Host Agent</b>. It solves the problem: <b>How can we coordinate multiple, specialized AI agents to achieve a larger goal?</b></p>
<h2><a class="anchor" id="autotoc_md2044"></a>
What is a Host Agent? The Project Manager AI</h2>
<p>Think of a big project, like building a house. You don't just talk to one person. You have a <b>project manager</b> (or general contractor). They:</p>
<ol type="1">
<li>Receive the high-level goal (build a house).</li>
<li>Understand the different skills needed (plumbing, electrical, framing, etc.).</li>
<li>Find and hire specialists (plumbers, electricians, carpenters).</li>
<li>Assign specific tasks to each specialist.</li>
<li>Coordinate their work and deadlines.</li>
<li>Combine their contributions into the final house.</li>
</ol>
<p>A <b>Host Agent</b> in the A2A world acts exactly like that project manager. It's an AI agent whose main job is <em>not</em> to perform tasks itself, but to <b>coordinate other agents</b>. Specifically, it acts as an <b><a class="el" href="../../dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html">A2A Client</a></b> to <em>other</em> downstream A2A agents.</p>
<p>Here's the flow:</p>
<ol type="1">
<li><b>Receives Request:</b> The Host Agent gets a request from a user or application (e.g., "Plan my London trip").</li>
<li><b>Finds Specialists:</b> It looks at its list of known downstream agents and their <a class="el" href="../../d7/d4e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_201__agent__card.html">Agent Cards</a> to see who has the needed skills (e.g., "Flight Booker Agent", "Hotel Finder Agent").</li>
<li><b>Delegates Tasks:</b> It breaks down the request and sends specific <a class="el" href="../../d2/d9c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_202__task.html">Tasks</a> to the chosen downstream agents using the standard <a class="el" href="../../d8/d90/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_203__a2a__protocol______core__types.html">A2A Protocol &amp; Core Types</a>. For example:<ul>
<li>Sends a task "Find NYC-London flights for next weekend" to the Flight Booker Agent.</li>
<li>Sends a task "Find hotels near British Museum" to the Hotel Finder Agent.</li>
</ul>
</li>
<li><b>Gathers Results:</b> It receives the results (potentially via <a class="el" href="../../d0/d60/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_207__streaming__communication____sse__.html">Streaming Communication (SSE)</a>) from the downstream agents.</li>
<li><b>Combines &amp; Responds:</b> It might combine the flight info and hotel options into a single, coherent response for the original user.</li>
</ol>
<p>The Host Agent is the central coordinator, making multiple agents appear as one unified, more capable agent.</p>
<h2><a class="anchor" id="autotoc_md2045"></a>
How a Host Agent Works (Conceptual)</h2>
<p>Let's imagine we're building a simple Host Agent. It knows about two other agents:</p>
<ul>
<li><code>Joke Teller Agent</code> (at <code><a href="http://joke-agent.com">http://joke-agent.com</a></code>) - Skill: <code>tell_joke</code></li>
<li><code>Summarizer Agent</code> (at <code><a href="http://summary-agent.com">http://summary-agent.com</a></code>) - Skill: <code>summarize_text</code></li>
</ul>
<p>Our Host Agent receives the request: "Tell me a joke and summarize this article: [long article text]"</p>
<p>Here's how the Host Agent's internal logic might work:</p>
<ol type="1">
<li><b>Analyze Request:</b> The Host Agent realizes the request has two parts: telling a joke and summarizing text.</li>
<li><b>Match Skills:</b><ul>
<li>It checks its known agents' <a class="el" href="../../d7/d4e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_201__agent__card.html">Agent Cards</a>.</li>
<li>It sees <code>Joke Teller Agent</code> has the <code>tell_joke</code> skill.</li>
<li>It sees <code>Summarizer Agent</code> has the <code>summarize_text</code> skill.</li>
</ul>
</li>
<li><b>Delegate Task 1 (Joke):</b><ul>
<li>It acts as an <a class="el" href="../../dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html">A2A Client</a>.</li>
<li>It sends a <code>tasks/send</code> request to <code><a href="http://joke-agent.com/a2a">http://joke-agent.com/a2a</a></code> with the message "Tell me a joke".</li>
</ul>
</li>
<li><b>Delegate Task 2 (Summary):</b><ul>
<li>It acts as an <a class="el" href="../../dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html">A2A Client</a> again.</li>
<li>It sends a <code>tasks/send</code> request to <code><a href="http://summary-agent.com/a2a">http://summary-agent.com/a2a</a></code> with the message containing the article text.</li>
</ul>
</li>
<li><b>Await Responses:</b> It waits for both downstream tasks to complete (using their Task IDs to track them). Let's say it gets:<ul>
<li>From Joke Agent: "Why don't scientists trust atoms? Because they make up everything!"</li>
<li>From Summarizer Agent: "[Short summary of the article]"</li>
</ul>
</li>
<li><b>Combine &amp; Reply:</b> It combines these results into a single response for the original user: "Okay, here's a joke: Why don't scientists trust atoms? Because they make up everything! \n\nAnd here's the summary: [Short summary of the article]"</li>
</ol>
<h2><a class="anchor" id="autotoc_md2046"></a>
Example Implementation Snippets (Conceptual Python)</h2>
<p>Building a full Host Agent often involves frameworks like Google's Agent Development Kit (ADK), as seen in <code>samples/python/hosts/multiagent/host_agent.py</code>. However, let's look at the core A2A concepts conceptually.</p>
<p>The Host Agent needs a way to manage connections to downstream agents. We might have a helper class like <code>RemoteAgentConnection</code> (inspired by <code>samples/python/hosts/multiagent/remote_agent_connection.py</code>) which internally uses an <a class="el" href="../../dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html">A2A Client</a>.</p>
<div class="fragment"><div class="line"><span class="comment"># Conceptual Helper Class (Manages client for one downstream agent)</span></div>
<div class="line"><span class="keyword">from</span> common.client <span class="keyword">import</span> A2AClient</div>
<div class="line"><span class="keyword">from</span> common.types <span class="keyword">import</span> AgentCard, TaskSendParams, Task</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RemoteAgentConnection:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, agent_card: AgentCard):</div>
<div class="line">        <span class="comment"># Store the downstream agent&#39;s card</span></div>
<div class="line">        self.card = agent_card</div>
<div class="line">        <span class="comment"># Create an A2A client specifically for this agent</span></div>
<div class="line">        self.client = A2AClient(agent_card=agent_card)</div>
<div class="line">        print(f<span class="stringliteral">&quot;Connection ready for agent: {self.card.name}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>send_task_to_remote(self, params: TaskSendParams) -&gt; Task:</div>
<div class="line">        print(f<span class="stringliteral">&quot;Host sending task {params.id} to {self.card.name}...&quot;</span>)</div>
<div class="line">        <span class="comment"># Use the internal A2A client to send the task</span></div>
<div class="line">        <span class="comment"># (Simplified: assumes non-streaming for clarity)</span></div>
<div class="line">        response = await self.client.send_task(params.model_dump())</div>
<div class="line">        print(f<span class="stringliteral">&quot;Host received response for task {params.id} from {self.card.name}&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> response.result <span class="comment"># Return the final Task object</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>This class holds the <a class="el" href="../../d7/d4e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_201__agent__card.html">Agent Card</a> of a downstream agent.</li>
<li>It creates and holds an <a class="el" href="../../dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html">A2A Client</a> instance configured to talk to that specific agent's A2A server URL.</li>
<li>The <code>send_task_to_remote</code> method takes the task details (<code>TaskSendParams</code>) and uses the internal client to actually send the <a class="el" href="../../d2/d9c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_202__task.html">Task</a> over A2A.</li>
</ul>
<p>Now, the Host Agent's main logic might look something like this:</p>
<div class="fragment"><div class="line"><span class="comment"># Conceptual Host Agent Logic</span></div>
<div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"><span class="keyword">from</span> common.types <span class="keyword">import</span> Message, TextPart, TaskSendParams</div>
<div class="line"><span class="keyword">import</span> uuid</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>HostAgentLogic:</div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        <span class="comment"># Assume agent cards are loaded somehow</span></div>
<div class="line">        joke_agent_card = AgentCard(name=<span class="stringliteral">&quot;Joke Agent&quot;</span>, url=<span class="stringliteral">&quot;http://joke-agent.com/a2a&quot;</span>, ...)</div>
<div class="line">        summary_agent_card = AgentCard(name=<span class="stringliteral">&quot;Summarizer Agent&quot;</span>, url=<span class="stringliteral">&quot;http://summary-agent.com/a2a&quot;</span>, ...)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Create connections to downstream agents</span></div>
<div class="line">        self.remote_connections = {</div>
<div class="line">            <span class="stringliteral">&quot;Joke Agent&quot;</span>: RemoteAgentConnection(joke_agent_card),</div>
<div class="line">            <span class="stringliteral">&quot;Summarizer Agent&quot;</span>: RemoteAgentConnection(summary_agent_card),</div>
<div class="line">        }</div>
<div class="line">        print(<span class="stringliteral">&quot;Host Agent initialized with remote connections.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>handle_user_request(self, user_request_text: str):</div>
<div class="line">        print(f<span class="stringliteral">&quot;Host received user request: {user_request_text}&quot;</span>)</div>
<div class="line">        <span class="comment"># Super simplified logic: If &quot;joke&quot; in request, call Joke Agent.</span></div>
<div class="line">        <span class="comment"># If &quot;summarize&quot; in request, call Summarizer Agent.</span></div>
<div class="line"> </div>
<div class="line">        tasks_to_run = []</div>
<div class="line">        <span class="keywordflow">if</span> <span class="stringliteral">&quot;joke&quot;</span> <span class="keywordflow">in</span> user_request_text.lower():</div>
<div class="line">            joke_conn = self.remote_connections[<span class="stringliteral">&quot;Joke Agent&quot;</span>]</div>
<div class="line">            joke_params = TaskSendParams(</div>
<div class="line">                id=str(uuid.uuid4()),</div>
<div class="line">                message=Message(role=<span class="stringliteral">&quot;user&quot;</span>, parts=[TextPart(text=<span class="stringliteral">&quot;Tell joke&quot;</span>)])</div>
<div class="line">            )</div>
<div class="line">            <span class="comment"># Add the task-sending coroutine to the list</span></div>
<div class="line">            tasks_to_run.append(joke_conn.send_task_to_remote(joke_params))</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> <span class="stringliteral">&quot;summarize&quot;</span> <span class="keywordflow">in</span> user_request_text.lower():</div>
<div class="line">            <span class="comment"># (Assume article_text is extracted from user_request_text)</span></div>
<div class="line">            article_text = <span class="stringliteral">&quot;This is the article to summarize...&quot;</span></div>
<div class="line">            summary_conn = self.remote_connections[<span class="stringliteral">&quot;Summarizer Agent&quot;</span>]</div>
<div class="line">            summary_params = TaskSendParams(</div>
<div class="line">                id=str(uuid.uuid4()),</div>
<div class="line">                message=Message(role=<span class="stringliteral">&quot;user&quot;</span>, parts=[TextPart(text=article_text)])</div>
<div class="line">            )</div>
<div class="line">            tasks_to_run.append(summary_conn.send_task_to_remote(summary_params))</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Run the downstream tasks concurrently</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;Host dispatching {len(tasks_to_run)} tasks...&quot;</span>)</div>
<div class="line">        results = await asyncio.gather(*tasks_to_run)</div>
<div class="line">        print(<span class="stringliteral">&quot;Host gathered results from downstream agents.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Combine results (simplified)</span></div>
<div class="line">        final_response = <span class="stringliteral">&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">for</span> task_result <span class="keywordflow">in</span> results:</div>
<div class="line">            <span class="keywordflow">if</span> task_result.status.message <span class="keywordflow">and</span> task_result.status.message.parts:</div>
<div class="line">                final_response += task_result.status.message.parts[0].text + <span class="stringliteral">&quot;\n&quot;</span></div>
<div class="line"> </div>
<div class="line">        print(f<span class="stringliteral">&quot;Host final response: {final_response}&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> final_response</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Example Usage ---</span></div>
<div class="line"><span class="comment"># async def main():</span></div>
<div class="line"><span class="comment">#     host = HostAgentLogic()</span></div>
<div class="line"><span class="comment">#     await host.handle_user_request(&quot;Tell me a joke and summarize stuff.&quot;)</span></div>
<div class="line"><span class="comment"># asyncio.run(main())</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Initialization:</b> The <code>HostAgentLogic</code> creates <code>RemoteAgentConnection</code> instances for each downstream agent it knows.</li>
<li><b>Request Handling:</b> When <code>handle_user_request</code> is called, it figures out which downstream agents are needed based on the request text (very basic keyword matching here).</li>
<li><b>Prepare Tasks:</b> It prepares the <code>TaskSendParams</code> for each required downstream task.</li>
<li><b>Concurrent Delegation:</b> It uses <code>asyncio.gather</code> to run the <code>send_task_to_remote</code> calls for all needed agents <em>concurrently</em>. This means it doesn't wait for the joke agent to finish before asking the summarizer agent to start.</li>
<li><b>Combine Results:</b> After <code>asyncio.gather</code> finishes (meaning all downstream tasks have completed), it extracts the results from the returned <code>Task</code> objects and combines them into a final response.</li>
</ol>
<p>This example shows the core idea: the Host Agent uses its knowledge of other agents' capabilities and acts as an A2A client to delegate work, potentially in parallel. Real host agents would have much more sophisticated logic for planning, delegation, and result synthesis, possibly using large language models themselves for coordination.</p>
<h2><a class="anchor" id="autotoc_md2047"></a>
Under the Hood: Orchestration Flow</h2>
<p>Let's trace the communication for our "Joke &amp; Summarize" example:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant Host as Host Agent (Server)</div>
<div class="line">    participant HAClient as Host Agent (Internal A2A Client)</div>
<div class="line">    participant Joke as Joke Agent (Server)</div>
<div class="line">    participant Summary as Summarizer Agent (Server)</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;Host: Send Task T0: &quot;Tell joke &amp; summarize...&quot;</div>
<div class="line">    Note over Host: Analyzes request, needs Joke &amp; Summarizer</div>
<div class="line"> </div>
<div class="line">    Host-&gt;&gt;HAClient: Initiate A2A Task T1 to Joke Agent (&quot;Tell joke&quot;)</div>
<div class="line">    HAClient-&gt;&gt;Joke: POST /a2a (tasks/send, id=T1, msg=&quot;Tell joke&quot;)</div>
<div class="line">    Note right of Joke: Joke Agent starts processing T1</div>
<div class="line"> </div>
<div class="line">    Host-&gt;&gt;HAClient: Initiate A2A Task T2 to Summarizer Agent (&quot;Summarize text...&quot;)</div>
<div class="line">    HAClient-&gt;&gt;Summary: POST /a2a (tasks/send, id=T2, msg=&quot;...&quot;)</div>
<div class="line">    Note right of Summary: Summarizer Agent starts processing T2</div>
<div class="line"> </div>
<div class="line">    Joke--&gt;&gt;HAClient: 200 OK (JSON-RPC result: Task T1 object, state=completed, result=&quot;Why..?&quot;)</div>
<div class="line">    HAClient--&gt;&gt;Host: Received result for T1</div>
<div class="line"> </div>
<div class="line">    Summary--&gt;&gt;HAClient: 200 OK (JSON-RPC result: Task T2 object, state=completed, result=&quot;[Summary...]&quot;)</div>
<div class="line">    HAClient--&gt;&gt;Host: Received result for T2</div>
<div class="line"> </div>
<div class="line">    Note over Host: Combines results from T1 and T2</div>
<div class="line">    Host--&gt;&gt;User: Respond Task T0 (state=completed, result=&quot;Joke: ... Summary: ...&quot;)</div>
</div><!-- fragment --><p><b>Steps:</b></p>
<ol type="1">
<li>User sends the initial request (Task T0) to the Host Agent.</li>
<li>The Host Agent's logic determines it needs both the Joke Agent and Summarizer Agent.</li>
<li>The Host Agent uses its internal A2A client capabilities (represented by <code>HAClient</code>) to send Task T1 to the Joke Agent's A2A server endpoint.</li>
<li>Concurrently (or sequentially), the Host Agent uses its client capabilities to send Task T2 to the Summarizer Agent's A2A server endpoint.</li>
<li>The downstream agents (Joke, Summary) process their respective tasks and send back A2A responses (containing the final Task object with results) to the Host Agent's client component.</li>
<li>The Host Agent logic receives the results for T1 and T2.</li>
<li>The Host Agent combines the results and sends the final response for the original Task T0 back to the user.</li>
</ol>
<p>The key is that the Host Agent speaks A2A <em>both</em> as a server (to the original user) and as a client (to the downstream agents).</p>
<p><b>Relevant Files:</b></p>
<ul>
<li><code>samples/python/hosts/multiagent/host_agent.py</code>: Implements the host agent logic, deciding which tools (remote agents) to call.</li>
<li><code>samples/python/hosts/multiagent/remote_agent_connection.py</code>: Wraps the <code>A2AClient</code> for easier use by the <code>HostAgent</code>. It handles sending the task via A2A (streaming or non-streaming).</li>
<li><code>demo/ui/service/server/adk_host_manager.py</code>: Manages the lifecycle and state of the host agent within the demo application framework (using Google ADK). It shows how task callbacks from <code>RemoteAgentConnection</code> update the overall state.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2048"></a>
Conclusion</h2>
<p>Multi-Agent Orchestration allows us to combine the strengths of specialized AI agents to tackle complex problems that a single agent might struggle with.</p>
<p>The <b>Host Agent</b> acts as the "project manager" in this system. It:</p>
<ul>
<li>Understands the overall goal.</li>
<li>Knows the capabilities of other available agents (via their <a class="el" href="../../d7/d4e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_201__agent__card.html">Agent Cards</a>).</li>
<li>Delegates sub-tasks to appropriate downstream agents by acting as an <a class="el" href="../../dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html">A2A Client</a>.</li>
<li>Coordinates the process and potentially combines the results.</li>
</ul>
<p>This pattern enables building sophisticated applications by composing modular, specialized agents that communicate using the standard A2A protocol.</p>
<p>Now that we've explored the core concepts and components of the A2A protocol, let's see how they all come together in a practical demonstration.</p>
<p><b>Next:</b> <a class="el" href="../../dc/dad/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_209__demo__ui__application______service.html">Chapter 9: Demo UI Application &amp; Service</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
