#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 02_node___basenode____node____asyncnode___</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dc/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_202__node______basenode________node________asyncnode______.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">02_node___basenode____node____asyncnode___</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2719"></a>
autotoc_md2719</h2>
<p>layout: default title: "Node (BaseNode, Node, AsyncNode)" parent: "PocketFlow" </p>
<h2><a class="anchor" id="autotoc_md2720"></a>
nav_order: 2</h2>
<h1><a class="anchor" id="autotoc_md2721"></a>
Chapter 2: Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>)</h1>
<p>In <a class="el" href="../../d1/d94/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_201__shared__state______shared____dictionary____.html">Chapter 1: Shared State (<code>shared</code> dictionary)</a>, we learned how different parts of a PocketFlow workflow can communicate using the <code>shared</code> dictionary. Now, let's meet the actual "workers" that perform the tasks and use this shared information: <b>Nodes</b>.</p>
<h2><a class="anchor" id="autotoc_md2722"></a>
What are Nodes and Why Do We Need Them?</h2>
<p>Imagine you're building an AI that helps you write a story. This process might involve several steps:</p><ol type="1">
<li>Generate a story idea.</li>
<li>Write an outline based on the idea.</li>
<li>Write the first draft of a chapter using the outline.</li>
<li>Review and edit the chapter.</li>
</ol>
<p>Each of these steps is a distinct task. In PocketFlow, each such task would be handled by a <b>Node</b>.</p>
<p>A <b>Node</b> is the fundamental building block in PocketFlow. It represents a single, atomic step in your workflow. Think of it as a highly specialized worker on an assembly line, responsible for one specific job. This job could be:</p><ul>
<li>Calling a Large Language Model (LLM) to generate text.</li>
<li>Searching the web for information.</li>
<li>Making a decision based on some data.</li>
<li>Reading user input.</li>
<li>Saving results to a file.</li>
</ul>
<p>By breaking down a complex process into a series of Nodes, we make our AI applications:</p><ul>
<li><b>Modular:</b> Each Node focuses on one thing, making it easier to develop, test, and understand.</li>
<li><b>Reusable:</b> A Node designed for web search can be used in many different AI applications.</li>
<li><b>Manageable:</b> It's easier to build and debug a sequence of simple steps than one giant, monolithic piece of code.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2723"></a>
The Anatomy of a Node: <code>prep</code>, <code>exec</code>, and <code>post</code></h2>
<p>Most Nodes in PocketFlow have a similar structure, typically involving three key methods:</p>
<ol type="1">
<li><b><code>prep(self, shared)</code> (Prepare):</b><ul>
<li><b>Purpose:</b> This method is called <em>before</em> the Node does its main work. Its job is to get any necessary input data from the <a class="el" href="../../d1/d94/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_201__shared__state______shared____dictionary____.html">shared dictionary</a>.</li>
<li><b>Analogy:</b> An assembly line worker picking up the necessary parts from a shared bin before starting their task.</li>
<li><b>Input:</b> It receives the <code>shared</code> dictionary.</li>
<li><b>Output:</b> It usually returns the specific data the Node needs for its core logic.</li>
</ul>
</li>
<li><b><code>exec(self, prep_res)</code> (Execute):</b><ul>
<li><b>Purpose:</b> This is where the Node performs its core task. This is the "brain" or "muscle" of the Node.</li>
<li><b>Analogy:</b> The assembly line worker actually assembling the parts or performing their specialized action.</li>
<li><b>Input:</b> It receives the result from the <code>prep</code> method (<code>prep_res</code>).</li>
<li><b>Output:</b> It returns the result of its execution (e.g., a summary, search results, a decision).</li>
</ul>
</li>
<li><b><code>post(self, shared, prep_res, exec_res)</code> (Post-process):</b><ul>
<li><b>Purpose:</b> This method is called <em>after</em> the Node has finished its main work. Its jobs are:<ul>
<li>To process the results from <code>exec</code>.</li>
<li>To update the <a class="el" href="../../d1/d94/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_201__shared__state______shared____dictionary____.html">shared dictionary</a> with these results or any other new information.</li>
<li>To decide what should happen next in the workflow (this is crucial for <a class="el" href="../../d8/d3f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_203__actions______transitions__.html">Actions / Transitions</a>, which we'll cover in the next chapter).</li>
</ul>
</li>
<li><b>Analogy:</b> The assembly line worker placing the finished component onto the conveyor belt (updating <code>shared</code>) and signaling if the item needs to go to a different station next (deciding the next action).</li>
<li><b>Input:</b> It receives the <code>shared</code> dictionary, the result from <code>prep</code> (<code>prep_res</code>), and the result from <code>exec</code> (<code>exec_res</code>).</li>
<li><b>Output:</b> It can return an "action" string that tells the Flow (<code>Flow</code>, <code>AsyncFlow</code>) which Node to execute next. If it returns nothing (or <code>None</code>), a default transition is usually followed.</li>
</ul>
</li>
</ol>
<p>Let's make this concrete with a simple example: a <code>SummarizeNode</code> whose job is to take some text and produce a short summary.</p>
<div class="fragment"><div class="line"><span class="comment"># This is a conceptual Node, actual implementation details might vary slightly</span></div>
<div class="line"><span class="keyword">from</span> pocketflow <span class="keyword">import</span> Node <span class="comment"># We&#39;ll import the base class</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SummarizeNode(Node):</div>
<div class="line">    <span class="keyword">def </span>prep(self, shared):</div>
<div class="line">        <span class="comment"># 1. Prepare: Get the text to summarize from &#39;shared&#39;</span></div>
<div class="line">        print(<span class="stringliteral">&quot;SummarizeNode: Preparing...&quot;</span>)</div>
<div class="line">        text_to_summarize = shared.get(<span class="stringliteral">&quot;document_text&quot;</span>, <span class="stringliteral">&quot;No text found.&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> text_to_summarize</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>exec(self, text_input):</div>
<div class="line">        <span class="comment"># 2. Execute: Perform the summarization (e.g., call an LLM)</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;SummarizeNode: Executing with text: &#39;{text_input[:30]}...&#39;&quot;</span>)</div>
<div class="line">        <span class="keywordflow">if</span> <span class="keywordflow">not</span> text_input <span class="keywordflow">or</span> text_input == <span class="stringliteral">&quot;No text found.&quot;</span>:</div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;Cannot summarize empty or missing text.&quot;</span></div>
<div class="line">        <span class="comment"># In a real scenario, this would call an LLM or a summarization library</span></div>
<div class="line">        summary = f<span class="stringliteral">&quot;This is a summary of: {text_input[:20]}...&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> summary</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>post(self, shared, prep_res, exec_res):</div>
<div class="line">        <span class="comment"># 3. Post-process: Store the summary in &#39;shared&#39;</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;SummarizeNode: Posting summary: &#39;{exec_res}&#39;&quot;</span>)</div>
<div class="line">        shared[<span class="stringliteral">&quot;summary_output&quot;</span>] = exec_res</div>
<div class="line">        <span class="comment"># We might decide the next step here, e.g., return &quot;summarization_done&quot;</span></div>
<div class="line">        <span class="comment"># For now, we&#39;ll just let it end by returning nothing (None)</span></div>
</div><!-- fragment --><p>Let's imagine how this <code>SummarizeNode</code> would work:</p>
<ol type="1">
<li><b>Initialization:</b> You'd start with some text in the <code>shared</code> dictionary. <code>python shared_data = {"document_text": "PocketFlow is a cool framework for building AI."} </code></li>
<li><b>Running the Node (simplified):</b><ul>
<li><b><code>prep(shared_data)</code> is called:</b> It looks into <code>shared_data</code> and finds <code>"PocketFlow is a cool framework for building AI."</code>. It returns this text.</li>
<li><b><code>exec("PocketFlow is a cool framework...")</code> is called:</b> It takes the text and (in our simplified example) creates a summary like <code>"This is a summary of: PocketFlow is a cool..."</code>. It returns this summary.</li>
<li><b><code>post(shared_data, text_from_prep, summary_from_exec)</code> is called:</b> It takes the <code>shared_data</code> and the <code>summary_from_exec</code>. It then adds a new entry: <code>shared_data["summary_output"] = "This is a summary of: PocketFlow is a cool..."</code>.</li>
</ul>
</li>
</ol>
<p>After the Node runs, <code>shared_data</code> would look like this: </p><div class="fragment"><div class="line">{</div>
<div class="line">    &quot;document_text&quot;: &quot;PocketFlow is a cool framework for building AI.&quot;,</div>
<div class="line">    &quot;summary_output&quot;: &quot;This is a summary of: PocketFlow is a cool...&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The summary is now available in the <code>shared</code> dictionary for other Nodes or for final output!</p>
<h2><a class="anchor" id="autotoc_md2724"></a>
Types of Nodes: <code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code></h2>
<p>PocketFlow provides a few variations of Nodes, built on top of each other:</p>
<ul>
<li><b><code>BaseNode</code>:</b><ul>
<li>This is the most fundamental type of Node. It provides the basic structure with <code>prep</code>, <code>exec</code>, and <code>post</code> methods.</li>
<li>It's like the basic blueprint for any worker.</li>
</ul>
</li>
<li><b><code>Node</code> (inherits from <code>BaseNode</code>):</b><ul>
<li>This is the standard synchronous Node you'll often use. "Synchronous" means it performs its task and waits for it to complete before anything else happens.</li>
<li>It adds helpful features on top of <code>BaseNode</code>, like automatic <b>retries</b> if the <code>exec</code> method fails (e.g., a network error when calling an LLM) and an <code>exec_fallback</code> method that can be called if all retries fail.</li>
<li>From <code>cookbook/pocketflow-node/flow.py</code>, our <code>Summarize</code> Node is an example of <code>Node</code>: ```python from pocketflow import Node </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2725"></a>
... other imports ...</h1>
<p>class Summarize(Node): # Inherits from Node </p>
<h1><a class="anchor" id="autotoc_md2726"></a>
... prep, exec, post methods ...</h1>
<p>def exec_fallback(self, shared, prep_res, exc): """Provide a simple fallback instead of crashing.""" return "There was an error processing your request." ``<code> This</code>Summarize<code>Node, if its</code>exec<code>method fails (e.g.,</code>call_llm<code>raises an error), will retry (default is 1 retry, but can be configured like</code>Summarize(max_retries=3)<code>). If all retries fail,</code>exec_fallback` is called.</p>
<ul>
<li><b><code>AsyncNode</code> (inherits from <code>Node</code>):</b><ul>
<li>This type of Node is for <b>asynchronous</b> tasks. Asynchronous tasks are those that might take some time to complete (like waiting for a web request or a user to type something) but don't need to block the entire program while they wait. They can "pause" and let other things run.</li>
<li><code>AsyncNode</code> uses <code>async</code> and <code>await</code> keywords from Python's <code>asyncio</code> library.</li>
<li>It has asynchronous versions of the core methods: <code>prep_async</code>, <code>exec_async</code>, and <code>post_async</code>.</li>
<li>We'll dive much deeper into asynchronous operations in <a class="el" href="../../d7/d6d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_205__asynchronous__processing___dbf1dc61cb3bcd98d46655d3ab8e2dd9.html">Chapter 5: Asynchronous Processing (<code>AsyncNode</code>, <code>AsyncFlow</code>)</a>. For now, just know it exists for tasks that involve waiting.</li>
<li>Example from <code>cookbook/pocketflow-async-basic/nodes.py</code>: ```python from pocketflow import AsyncNode </li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2727"></a>
... other imports ...</h1>
<p>class FetchRecipes(AsyncNode): # Inherits from AsyncNode async def prep_async(self, shared): </p>
<h1><a class="anchor" id="autotoc_md2728"></a>
... prepare input asynchronously ...</h1>
<p>ingredient = await get_user_input("Enter ingredient: ") # get_user_input is async return ingredient</p>
<p>async def exec_async(self, ingredient): </p>
<h1><a class="anchor" id="autotoc_md2729"></a>
... execute task asynchronously ...</h1>
<p>recipes = await fetch_recipes(ingredient) # fetch_recipes is async return recipes</p>
<p>async def post_async(self, shared, prep_res, recipes): </p>
<h1><a class="anchor" id="autotoc_md2730"></a>
... post-process asynchronously ...</h1>
<p>shared["recipes"] = recipes return "suggest" # Action for the next step ``<code> Notice the</code>async def<code>and</code>await<code>keywords. This</code>FetchRecipes` Node can wait for user input and web requests without freezing the application.</p>
<h2><a class="anchor" id="autotoc_md2731"></a>
How a Node Runs: Under the Hood (Simplified)</h2>
<p>When PocketFlow decides it's time for a particular Node to run (as part of a Flow (<code>Flow</code>, <code>AsyncFlow</code>)), it essentially orchestrates the calling of its <code>prep</code>, <code>exec</code>, and <code>post</code> methods in sequence.</p>
<p>Here's a simplified view of what happens when a synchronous <code>Node</code>'s internal <code>_run</code> method is invoked:</p>
<ol type="1">
<li><b>Call <code>prep</code>:</b> <code>prep_result = self.prep(shared)</code><ul>
<li>Your Node's <code>prep</code> method is called with the current <code>shared</code> dictionary.</li>
<li>Whatever <code>prep</code> returns is stored.</li>
</ul>
</li>
<li><b>Call <code>_exec</code> (which internally calls your <code>exec</code> with retries):</b> <code>exec_result = self._exec(prep_result)</code><ul>
<li>The Node's <code>_exec</code> method is called with the <code>prep_result</code>.</li>
<li>This <code>_exec</code> method in the <code>Node</code> class handles the retry logic. It will try to call your <code>exec(prep_result)</code> method.</li>
<li>If your <code>exec</code> succeeds, its result is stored.</li>
<li>If your <code>exec</code> raises an exception, <code>_exec</code> might wait and try again (up to <code>max_retries</code>).</li>
<li>If all retries fail, <code>exec_fallback(prep_result, exception)</code> is called, and its result is used as <code>exec_result</code>.</li>
</ul>
</li>
<li><b>Call <code>post</code>:</b> <code>action = self.post(shared, prep_result, exec_result)</code><ul>
<li>Your Node's <code>post</code> method is called with the <code>shared</code> dictionary, the <code>prep_result</code>, and the <code>exec_result</code>.</li>
<li><code>post</code> can modify <code>shared</code> and returns an action string (or <code>None</code>).</li>
</ul>
</li>
<li><b>Return Action:</b> The <code>action</code> returned by <code>post</code> is then used by the Flow (<code>Flow</code>, <code>AsyncFlow</code>) to determine the next Node to run.</li>
</ol>
<p>Let's visualize this with a sequence diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant FlowEngine as PocketFlow Engine</div>
<div class="line">    participant YourNode as Your Node Instance</div>
<div class="line">    participant SharedDict as Shared Dictionary</div>
<div class="line"> </div>
<div class="line">    FlowEngine-&gt;&gt;YourNode: _run(SharedDict)</div>
<div class="line">    YourNode-&gt;&gt;YourNode: prep(SharedDict)</div>
<div class="line">    Note right of YourNode: Reads from SharedDict</div>
<div class="line">    YourNode--&gt;&gt;SharedDict: Access data (e.g., shared[&#39;input&#39;])</div>
<div class="line">    YourNode-&gt;&gt;YourNode: _exec(prep_result)</div>
<div class="line">    Note right of YourNode: Calls your exec(), handles retries/fallback</div>
<div class="line">    YourNode-&gt;&gt;YourNode: post(SharedDict, prep_result, exec_result)</div>
<div class="line">    Note right of YourNode: Writes to SharedDict, decides next action</div>
<div class="line">    YourNode--&gt;&gt;SharedDict: Update data (e.g., shared[&#39;output&#39;] = ...)</div>
<div class="line">    YourNode--&gt;&gt;FlowEngine: Returns action string</div>
</div><!-- fragment --><p><b>Code Glimpse (from <code>pocketflow/__init__.py</code>):</b></p>
<p>The <code>BaseNode</code> class defines the fundamental execution flow in its <code>_run</code> method (this is a direct, slightly simplified version): </p><div class="fragment"><div class="line"><span class="comment"># Inside BaseNode class from pocketflow/__init__.py</span></div>
<div class="line"><span class="keyword">def </span>_run(self, shared):</div>
<div class="line">    prep_output = self.prep(shared)</div>
<div class="line">    exec_output = self._exec(prep_output) <span class="comment"># _exec calls self.exec</span></div>
<div class="line">    action = self.post(shared, prep_output, exec_output)</div>
<div class="line">    <span class="keywordflow">return</span> action</div>
</div><!-- fragment --><p> This is the core loop for a single Node's execution.</p>
<p>The <code>Node</code> class (which inherits from <code>BaseNode</code>) overrides <code>_exec</code> to add retry and fallback logic: </p><div class="fragment"><div class="line"><span class="comment"># Simplified concept from Node class in pocketflow/__init__.py</span></div>
<div class="line"><span class="keyword">def </span>_exec(self, prep_res):</div>
<div class="line">    <span class="keywordflow">for</span> self.cur_retry <span class="keywordflow">in</span> range(self.max_retries): <span class="comment"># Loop for retries</span></div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="keywordflow">return</span> self.exec(prep_res) <span class="comment"># Call your Node&#39;s exec method</span></div>
<div class="line">        <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">            <span class="keywordflow">if</span> self.cur_retry == self.max_retries - 1: <span class="comment"># If last retry</span></div>
<div class="line">                <span class="keywordflow">return</span> self.exec_fallback(prep_res, e) <span class="comment"># Call fallback</span></div>
<div class="line">            <span class="keywordflow">if</span> self.wait &gt; 0:</div>
<div class="line">                time.sleep(self.wait) <span class="comment"># Wait before retrying</span></div>
</div><!-- fragment --><p> This shows how <code>Node</code> makes your worker more robust by automatically handling temporary failures.</p>
<p>For <code>AsyncNode</code>, the methods are <code>prep_async</code>, <code>exec_async</code>, <code>post_async</code>, and they are <code>await</code>ed, allowing other tasks to run while waiting for I/O operations. This will be detailed in <a class="el" href="../../d7/d6d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_205__asynchronous__processing___dbf1dc61cb3bcd98d46655d3ab8e2dd9.html">Chapter 5</a>.</p>
<h2><a class="anchor" id="autotoc_md2732"></a>
Conclusion</h2>
<p>You've now been introduced to <b>Nodes</b>, the workhorses of PocketFlow!</p><ul>
<li>They represent <b>single, atomic steps</b> in your workflow.</li>
<li>They typically follow a <b><code>prep</code> -&gt; <code>exec</code> -&gt; <code>post</code></b> lifecycle.</li>
<li><code>prep</code> gets data from the <a class="el" href="../../d1/d94/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_201__shared__state______shared____dictionary____.html">shared dictionary</a>.</li>
<li><code>exec</code> performs the core logic.</li>
<li><code>post</code> updates the <code>shared</code> dictionary and can decide what happens next.</li>
<li><b><code>Node</code></b> provides synchronous execution with retries and fallbacks.</li>
<li><b><code>AsyncNode</code></b> provides asynchronous execution for I/O-bound tasks.</li>
</ul>
<p>Nodes are the building blocks you'll use to define the individual capabilities of your AI agents and applications. But how do these Nodes connect to form a sequence or a more complex workflow? And how does the <code>post</code> method's return value actually control the flow? That's where Actions / Transitions come in, which we'll explore in the next chapter!</p>
<p>Next up: Chapter 3: Actions / Transitions</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
