#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_custom_logic__decorators___annotated_helpers_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_204__custom__logic____decorators______annotated__helpers__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_custom_logic__decorators___annotated_helpers_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2842"></a>
autotoc_md2842</h2>
<p>layout: default title: "Custom Logic (Decorators &amp; Annotated Helpers)" parent: "Pydantic Core" </p>
<h2><a class="anchor" id="autotoc_md2843"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md2844"></a>
Chapter 4: Custom Logic (Decorators &amp; Annotated Helpers)</h1>
<p>In <a class="el" href="../../d0/d6f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_203__configuration____configdict______configwrapper__.html">Chapter 3: Configuration (ConfigDict / ConfigWrapper)</a>, we learned how to set global rules for our data blueprints using <code>model_config</code>. But what if we need more specific, custom rules or transformations that go beyond simple settings?</p>
<p>Imagine you need rules like:</p><ul>
<li>"This username must not contain any spaces."</li>
<li>"The `end_date` must always be later than the `start_date`."</li>
<li>"When sending this data as JSON, format this specific date field as `YYYY-MM-DD`."</li>
<li>"When validating, convert incoming usernames to lowercase automatically."</li>
</ul>
<p>These require custom code logic. Pydantic provides flexible ways to inject this custom logic directly into the validation and serialization processes.</p>
<h2><a class="anchor" id="autotoc_md2845"></a>
Why Custom Logic?</h2>
<p>Standard type hints (<code>str</code>, <code>int</code>), <a class="el" href="../../d9/df6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_202__fields____fieldinfo______field__function__.html">Fields</a> (<code>Field(gt=0)</code>), and <a class="el" href="../../d0/d6f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_203__configuration____configdict______configwrapper__.html">Configuration</a> (&lsquo;ConfigDict(extra='forbid&rsquo;)`) cover many common cases. However, sometimes the rules are more complex or specific to your application's needs.</p>
<p>For example, checking if a password meets complexity requirements (length, uppercase, numbers, symbols) or ensuring consistency between multiple fields (<code>start_date &lt; end_date</code>) requires writing your own Python functions.</p>
<p>Pydantic offers two main ways to add this custom logic:</p><ol type="1">
<li><b>Decorators:</b> Special markers (<code>@...</code>) you put above methods in your <code>BaseModel</code> class.</li>
<li><b><code>Annotated</code> Helpers:</b> Using Python's <code>typing.Annotated</code> along with special Pydantic classes to attach logic directly to a type hint.</li>
</ol>
<p><b>Analogy:</b> Think of these as adding custom steps to the construction (validation) and reporting (serialization) process for your data blueprint.</p><ul>
<li><b>Validators</b> are like adding extra <em>inspection checks</em> at different stages of construction (before basic checks, after basic checks, or wrapping the entire process).</li>
<li><b>Serializers</b> are like specifying custom <em>formatting rules</em> for the final report (converting your data back to simple types like dicts or JSON).</li>
</ul>
<p>Let's explore these mechanisms.</p>
<h2><a class="anchor" id="autotoc_md2846"></a>
Decorators: Adding Logic via Methods</h2>
<p>Decorators are a standard Python feature. They are functions that modify or enhance other functions or methods. Pydantic uses decorators to let you designate specific methods in your <code>BaseModel</code> as custom validators or serializers.</p>
<h3><a class="anchor" id="autotoc_md2847"></a>
<code>@field_validator</code>: Checking Individual Fields</h3>
<p>The <code>@field_validator</code> decorator lets you add custom validation logic for one or more specific fields <em>after</em> Pydantic has performed its initial type checks and coercion.</p>
<p><b>Use Case:</b> Let's ensure a <code>username</code> field doesn't contain spaces.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, field_validator, ValidationError</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>UserRegistration(BaseModel):</div>
<div class="line">    username: str</div>
<div class="line">    email: str</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># This method will be called automatically for the &#39;username&#39; field</span></div>
<div class="line">    <span class="comment"># AFTER Pydantic checks it&#39;s a string.</span></div>
<div class="line">    <span class="preprocessor">@field_validator(&#39;username&#39;)</span></div>
<div class="line">    <span class="preprocessor">@classmethod</span> <span class="comment"># Field validators should usually be class methods</span></div>
<div class="line">    <span class="keyword">def </span>check_username_spaces(cls, v: str) -&gt; str:</div>
<div class="line">        print(f<span class="stringliteral">&quot;Checking username: &#39;{v}&#39;&quot;</span>)</div>
<div class="line">        <span class="keywordflow">if</span> <span class="stringliteral">&#39; &#39;</span> <span class="keywordflow">in</span> v:</div>
<div class="line">            <span class="comment"># Raise a ValueError if the rule is broken</span></div>
<div class="line">            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Username cannot contain spaces&#39;</span>)</div>
<div class="line">        <span class="comment"># Return the valid value (can also modify it here if needed)</span></div>
<div class="line">        <span class="keywordflow">return</span> v</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Try it out ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Valid username</span></div>
<div class="line">user_ok = UserRegistration(username=<span class="stringliteral">&#39;cool_cat123&#39;</span>, email=<span class="stringliteral">&#39;cat@meow.com&#39;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Valid user created: {user_ok}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># Checking username: &#39;cool_cat123&#39;</span></div>
<div class="line"><span class="comment"># Valid user created: username=&#39;cool_cat123&#39; email=&#39;cat@meow.com&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Invalid username</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    UserRegistration(username=<span class="stringliteral">&#39;cool cat 123&#39;</span>, email=<span class="stringliteral">&#39;cat@meow.com&#39;</span>)</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;\nValidation Error:\n{e}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output (simplified):</span></div>
<div class="line">    <span class="comment"># Checking username: &#39;cool cat 123&#39;</span></div>
<div class="line">    <span class="comment"># Validation Error:</span></div>
<div class="line">    <span class="comment"># 1 validation error for UserRegistration</span></div>
<div class="line">    <span class="comment"># username</span></div>
<div class="line">    <span class="comment">#   Value error, Username cannot contain spaces [type=value_error, ...]</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ol type="1">
<li>We defined a <code>check_username_spaces</code> method inside our <code>UserRegistration</code> model.</li>
<li>We decorated it with &lsquo;@field_validator('username&rsquo;)<code>. This tells Pydantic: "After you validate&lt;/tt&gt;username&lt;tt&gt;as a&lt;/tt&gt;str&lt;tt&gt;, call this method with the value."</code></li>
<li><code> The</code>@classmethod<code>decorator is typically used so the method receives the class (</code>cls<code>) as the first argument instead of an instance (</code>self<code>).</code></li>
<li><code> Inside the method,</code>v<code>holds the value of the</code>username<code>field *after* Pydantic's basic</code>str<code>validation.</code></li>
<li><code> We check our custom rule (</code>' ' in v<code>).</code></li>
<li><code> If the rule is violated, we raise a</code>ValueError<code>(Pydantic catches this and wraps it in a</code>ValidationError<code>).</code></li>
<li><code> If the value is okay, we **must return it**. You could also transform the value here (e.g.,</code>return v.lower()`).</li>
</ol>
<p><code>@field_validator</code> has a <code>mode</code> argument (&lsquo;'before&rsquo;<code>or</code>'after'<code>, default is</code>'after'<code>).</code>'after'<code>(as shown) runs *after* Pydantic's internal validation for the field type.</code>'before'` runs <em>before</em>, giving you the raw input value.</p>
<h3><a class="anchor" id="autotoc_md2848"></a>
<code>@model_validator</code>: Checking the Whole Model</h3>
<p>Sometimes, validation depends on multiple fields interacting. The <code>@model_validator</code> decorator lets you run logic that involves the entire model's data.</p>
<p><b>Use Case:</b> Ensure <code>end_date</code> is after <code>start_date</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, model_validator, ValidationError</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Self <span class="comment"># Used for type hint in Python 3.11+</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Trip(BaseModel):</div>
<div class="line">    start_date: date</div>
<div class="line">    end_date: date</div>
<div class="line">    destination: str</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># This method runs AFTER the model fields are validated individually</span></div>
<div class="line">    <span class="preprocessor">@model_validator(mode=&#39;after&#39;)</span></div>
<div class="line">    <span class="keyword">def </span>check_dates(self) -&gt; Self: <span class="comment"># Use &#39;Self&#39; or &#39;Trip&#39; as return hint</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;Checking dates: start={self.start_date}, end={self.end_date}&quot;</span>)</div>
<div class="line">        <span class="keywordflow">if</span> self.start_date &gt;= self.end_date:</div>
<div class="line">            <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;End date must be after start date&#39;</span>)</div>
<div class="line">        <span class="comment"># Return the validated model instance</span></div>
<div class="line">        <span class="keywordflow">return</span> self</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Try it out ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Valid dates</span></div>
<div class="line">trip_ok = Trip(start_date=date(2024, 7, 1), end_date=date(2024, 7, 10), destination=<span class="stringliteral">&#39;Beach&#39;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Valid trip: {trip_ok}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># Checking dates: start=2024-07-01, end=2024-07-10</span></div>
<div class="line"><span class="comment"># Valid trip: start_date=datetime.date(2024, 7, 1) end_date=datetime.date(2024, 7, 10) destination=&#39;Beach&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Invalid dates</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    Trip(start_date=date(2024, 7, 10), end_date=date(2024, 7, 1), destination=<span class="stringliteral">&#39;Mountains&#39;</span>)</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;\nValidation Error:\n{e}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output (simplified):</span></div>
<div class="line">    <span class="comment"># Checking dates: start=2024-07-10, end=2024-07-01</span></div>
<div class="line">    <span class="comment"># Validation Error:</span></div>
<div class="line">    <span class="comment"># 1 validation error for Trip</span></div>
<div class="line">    <span class="comment">#   Value error, End date must be after start date [type=value_error, ...]</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ol type="1">
<li>We defined a <code>check_dates</code> method.</li>
<li>We decorated it with &lsquo;@model_validator(mode='after&rsquo;)<code>. This tells Pydantic: "After validating all individual fields and creating the model instance, call this method."</code></li>
<li><code> In</code>'after'<code>mode, the method receives</code>self&lt;tt&gt;(the model instance). We can access all fields like</li>
</ol>
<p>self.start_date<code>.</p><ol type="1">
<li>We perform our cross-field check.</li>
<li>If invalid, raise</li>
</ol>
<p></code>ValueError<code>.</p><ol type="1">
<li>If valid, **must return</li>
</ol>
<p></code>self`** (the model instance).</p>
<p><code>@model_validator</code> also supports &lsquo;mode='before&rsquo;<code>, where the method runs *before* individual field validation. In</code>'before'<code>mode, the method receives the class (</code>cls`) and the raw input data (usually a dictionary) and must return the (potentially modified) data dictionary to be used for further validation.</p>
<h3><a class="anchor" id="autotoc_md2849"></a>
<code>@field_serializer</code>: Customizing Field Output</h3>
<p>This decorator lets you control how a specific field is converted (serialized) when you call methods like <code>model_dump()</code> or <code>model_dump_json()</code>.</p>
<p><b>Use Case:</b> Serialize a <code>date</code> object as a simple <code>"YYYY-MM-DD"</code> string.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, field_serializer</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Event(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    event_date: date</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Customize serialization for the &#39;event_date&#39; field</span></div>
<div class="line">    <span class="preprocessor">@field_serializer(&#39;event_date&#39;)</span></div>
<div class="line">    <span class="keyword">def </span>serialize_date(self, dt: date) -&gt; str:</div>
<div class="line">        <span class="comment"># Return the custom formatted string</span></div>
<div class="line">        <span class="keywordflow">return</span> dt.strftime(<span class="stringliteral">&#39;%Y-%m-%d&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Try it out ---</span></div>
<div class="line">event = Event(name=<span class="stringliteral">&#39;Party&#39;</span>, event_date=date(2024, 12, 25))</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Default dump (dictionary)</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Model object: {event}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: Model object: name=&#39;Party&#39; event_date=datetime.date(2024, 12, 25)</span></div>
<div class="line"> </div>
<div class="line">dumped_dict = event.model_dump()</div>
<div class="line">print(f<span class="stringliteral">&quot;Dumped dict: {dumped_dict}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: Dumped dict: {&#39;name&#39;: &#39;Party&#39;, &#39;event_date&#39;: &#39;2024-12-25&#39;}</span></div>
<div class="line"> </div>
<div class="line">dumped_json = event.model_dump_json(indent=2)</div>
<div class="line">print(f<span class="stringliteral">&quot;Dumped JSON:\n{dumped_json}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># Dumped JSON:</span></div>
<div class="line"><span class="comment"># {</span></div>
<div class="line"><span class="comment">#   &quot;name&quot;: &quot;Party&quot;,</span></div>
<div class="line"><span class="comment">#   &quot;event_date&quot;: &quot;2024-12-25&quot;</span></div>
<div class="line"><span class="comment"># }</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ol type="1">
<li>We defined <code>serialize_date</code> and decorated it with &lsquo;@field_serializer('event_date&rsquo;)<code>.</code></li>
<li><code> The method receives</code>self&lt;tt&gt;(the instance) and</li>
</ol>
<p>dt<code>(the value of the</code>event_date<code>field). You can also add an optional</code>info: SerializationInfo<code>argument for more context.</p><ol type="1">
<li>It returns the desired serialized format (a string in this case).</li>
<li>When</li>
</ol>
<p></code>model_dump()<code>or</code>model_dump_json()<code>is called, Pydantic uses this method for the</code>event_date` field instead of its default date serialization.</p>
<h3><a class="anchor" id="autotoc_md2850"></a>
<code>@model_serializer</code>: Customizing Model Output</h3>
<p>This allows custom logic for serializing the entire model object.</p>
<p><b>Use Case:</b> Add a calculated <code>duration_days</code> field during serialization.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date, timedelta</div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, model_serializer</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Dict, Any</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Trip(BaseModel):</div>
<div class="line">    start_date: date</div>
<div class="line">    end_date: date</div>
<div class="line">    destination: str</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Customize the entire model&#39;s serialization</span></div>
<div class="line">    <span class="preprocessor">@model_serializer</span></div>
<div class="line">    <span class="keyword">def </span>serialize_with_duration(self) -&gt; Dict[str, Any]:</div>
<div class="line">        <span class="comment"># Start with the default field values</span></div>
<div class="line">        data = {<span class="stringliteral">&#39;start_date&#39;</span>: self.start_date, <span class="stringliteral">&#39;end_date&#39;</span>: self.end_date, <span class="stringliteral">&#39;destination&#39;</span>: self.destination}</div>
<div class="line">        <span class="comment"># Calculate and add the custom field</span></div>
<div class="line">        duration = self.end_date - self.start_date</div>
<div class="line">        data[<span class="stringliteral">&#39;duration_days&#39;</span>] = duration.days</div>
<div class="line">        <span class="keywordflow">return</span> data</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Try it out ---</span></div>
<div class="line">trip = Trip(start_date=date(2024, 8, 1), end_date=date(2024, 8, 5), destination=<span class="stringliteral">&#39;Lake&#39;</span>)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Model object: {trip}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: Model object: start_date=datetime.date(2024, 8, 1) end_date=datetime.date(2024, 8, 5) destination=&#39;Lake&#39;</span></div>
<div class="line"> </div>
<div class="line">dumped_dict = trip.model_dump()</div>
<div class="line">print(f<span class="stringliteral">&quot;Dumped dict: {dumped_dict}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: Dumped dict: {&#39;start_date&#39;: datetime.date(2024, 8, 1), &#39;end_date&#39;: datetime.date(2024, 8, 5), &#39;destination&#39;: &#39;Lake&#39;, &#39;duration_days&#39;: 4}</span></div>
<div class="line"> </div>
<div class="line">dumped_json = trip.model_dump_json(indent=2)</div>
<div class="line">print(f<span class="stringliteral">&quot;Dumped JSON:\n{dumped_json}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># Dumped JSON:</span></div>
<div class="line"><span class="comment"># {</span></div>
<div class="line"><span class="comment">#   &quot;start_date&quot;: &quot;2024-08-01&quot;,</span></div>
<div class="line"><span class="comment">#   &quot;end_date&quot;: &quot;2024-08-05&quot;,</span></div>
<div class="line"><span class="comment">#   &quot;destination&quot;: &quot;Lake&quot;,</span></div>
<div class="line"><span class="comment">#   &quot;duration_days&quot;: 4</span></div>
<div class="line"><span class="comment"># }</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ol type="1">
<li>We decorated <code>serialize_with_duration</code> with <code>@model_serializer</code>.</li>
<li>The default &lsquo;mode='plain&rsquo;<code>means this method *replaces* the standard model serialization. It receives</code>self<code>.</code></li>
<li><code> We manually construct the dictionary we want as output, adding our calculated</code>duration_days<code>.</code></li>
<li><code> This dictionary is used by</code>model_dump()<code>and</code>model_dump_json()`.</li>
</ol>
<p>There's also a &lsquo;mode='wrap&rsquo;<code>for</code>@model_serializer<code>(and</code>@field_serializer<code>) which is more advanced. It gives you a</code>handler` function to call the <em>next</em> serialization step (either Pydantic's default or another wrapper), allowing you to modify the result <em>around</em> the standard logic.</p>
<h2><a class="anchor" id="autotoc_md2851"></a>
<code>Annotated</code> Helpers: Attaching Logic to Type Hints</h2>
<p>Python's <code>typing.Annotated</code> allows adding extra metadata to type hints. Pydantic leverages this to let you attach validation and serialization logic directly inline with your field definitions.</p>
<p><b>Analogy:</b> Instead of separate instruction sheets (decorators), this is like putting specific instruction tags directly onto an item in the blueprint.</p>
<p>Common helpers include:</p><ul>
<li><b>Validators:</b> <code>BeforeValidator</code>, <code>AfterValidator</code>, <code>PlainValidator</code>, <code>WrapValidator</code></li>
<li><b>Serializers:</b> <code>PlainSerializer</code>, <code>WrapSerializer</code></li>
</ul>
<p>Let's see how <code>AfterValidator</code> compares to <code>@field_validator</code>.</p>
<p><b>Use Case:</b> Ensure <code>username</code> has no spaces, using <code>Annotated</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated</div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field, ValidationError</div>
<div class="line"><span class="comment"># Import the helper</span></div>
<div class="line"><span class="keyword">from</span> pydantic.functional_validators <span class="keyword">import</span> AfterValidator</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the validation function (can be outside the class)</span></div>
<div class="line"><span class="keyword">def </span>check_no_spaces(v: str) -&gt; str:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Checking username via Annotated: &#39;{v}&#39;&quot;</span>)</div>
<div class="line">    <span class="keywordflow">if</span> <span class="stringliteral">&#39; &#39;</span> <span class="keywordflow">in</span> v:</div>
<div class="line">        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&#39;Username cannot contain spaces&#39;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> v</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>UserRegistrationAnnotated(BaseModel):</div>
<div class="line">    <span class="comment"># Attach the validator function directly to the type hint</span></div>
<div class="line">    username: Annotated[str, AfterValidator(check_no_spaces)]</div>
<div class="line">    email: str</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Try it out ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Valid username</span></div>
<div class="line">user_ok = UserRegistrationAnnotated(username=<span class="stringliteral">&#39;another_cat&#39;</span>, email=<span class="stringliteral">&#39;cat@meow.com&#39;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Valid user: {user_ok}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># Checking username via Annotated: &#39;another_cat&#39;</span></div>
<div class="line"><span class="comment"># Valid user: username=&#39;another_cat&#39; email=&#39;cat@meow.com&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Invalid username</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    UserRegistrationAnnotated(username=<span class="stringliteral">&#39;another cat&#39;</span>, email=<span class="stringliteral">&#39;cat@meow.com&#39;</span>)</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;\nValidation Error:\n{e}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output (simplified):</span></div>
<div class="line">    <span class="comment"># Checking username via Annotated: &#39;another cat&#39;</span></div>
<div class="line">    <span class="comment"># Validation Error:</span></div>
<div class="line">    <span class="comment"># 1 validation error for UserRegistrationAnnotated</span></div>
<div class="line">    <span class="comment"># username</span></div>
<div class="line">    <span class="comment">#   Value error, Username cannot contain spaces [type=value_error, ...]</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ol type="1">
<li>We import <code>Annotated</code> from <code>typing</code> and <code>AfterValidator</code> from Pydantic.</li>
<li>We define a standalone function <code>check_no_spaces</code> (it doesn't need to be a method).</li>
<li>In the model, we define <code>username</code> as <code>Annotated[str, AfterValidator(check_no_spaces)]</code>. This tells Pydantic: "The type is `str`, and after validating it as a string, apply the `check_no_spaces` function."</li>
<li>The behavior is identical to the <code>@field_validator</code> example, but the logic is attached differently.</li>
</ol>
<p>Similarly, you can use <code>BeforeValidator</code> (runs before Pydantic's type validation) or <code>PlainSerializer</code> / <code>WrapSerializer</code> to attach serialization logic.</p>
<p><b>Use Case:</b> Serialize <code>date</code> as <code>"YYYY-MM-DD"</code> using <code>Annotated</code> and <code>PlainSerializer</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> date</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated</div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</div>
<div class="line"><span class="comment"># Import the helper</span></div>
<div class="line"><span class="keyword">from</span> pydantic.functional_serializers <span class="keyword">import</span> PlainSerializer</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the serializer function</span></div>
<div class="line"><span class="keyword">def </span>format_date_yyyymmdd(dt: date) -&gt; str:</div>
<div class="line">    <span class="keywordflow">return</span> dt.strftime(<span class="stringliteral">&#39;%Y-%m-%d&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EventAnnotated(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    <span class="comment"># Attach the serializer function directly to the type hint</span></div>
<div class="line">    event_date: Annotated[date, PlainSerializer(format_date_yyyymmdd)]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Try it out ---</span></div>
<div class="line">event = EventAnnotated(name=<span class="stringliteral">&#39;Conference&#39;</span>, event_date=date(2024, 10, 15))</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Model object: {event}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: Model object: name=&#39;Conference&#39; event_date=datetime.date(2024, 10, 15)</span></div>
<div class="line"> </div>
<div class="line">dumped_dict = event.model_dump()</div>
<div class="line">print(f<span class="stringliteral">&quot;Dumped dict: {dumped_dict}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: Dumped dict: {&#39;name&#39;: &#39;Conference&#39;, &#39;event_date&#39;: &#39;2024-10-15&#39;}</span></div>
<div class="line"> </div>
<div class="line">dumped_json = event.model_dump_json(indent=2)</div>
<div class="line">print(f<span class="stringliteral">&quot;Dumped JSON:\n{dumped_json}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># Dumped JSON:</span></div>
<div class="line"><span class="comment"># {</span></div>
<div class="line"><span class="comment">#   &quot;name&quot;: &quot;Conference&quot;,</span></div>
<div class="line"><span class="comment">#   &quot;event_date&quot;: &quot;2024-10-15&quot;</span></div>
<div class="line"><span class="comment"># }</span></div>
</div><!-- fragment --><p>This achieves the same result as the <code>@field_serializer</code> example, but by attaching the logic via <code>Annotated</code>.</p>
<p><b>Which to choose? Decorators vs. Annotated Helpers:</b></p><ul>
<li>**Decorators (<code>@field_validator</code>, etc.):** Keep logic tightly coupled with the model class definition. Good if the logic intrinsically belongs to the model or needs access to <code>cls</code> or <code>self</code>. Can feel more object-oriented.</li>
<li><b><code>Annotated</code> Helpers (<code>AfterValidator</code>, etc.):</b> Allow defining reusable validation/serialization functions outside the model. Good for applying the same logic across different models or fields. Can make type hints more verbose but keeps the model body cleaner.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2852"></a>
Under the Hood: Wiring Up the Logic</h2>
<p>How does Pydantic discover and apply this custom logic?</p>
<p><b>Decorators:</b></p><ol type="1">
<li><b>Class Creation:</b> When Python creates your <code>BaseModel</code> class (like <code>UserRegistration</code>), Pydantic's <code>ModelMetaclass</code> scans the class attributes.</li>
<li><b>Decorator Detection:</b> It finds methods decorated with Pydantic decorators (<code>@field_validator</code>, <code>@model_serializer</code>, etc.). It uses helper classes like <code>PydanticDescriptorProxy</code> (from <code>pydantic._internal._decorators</code>) to wrap these methods and store metadata about the decorator (like which fields it applies to, the mode, etc., using internal classes like <code>FieldValidatorDecoratorInfo</code>).</li>
<li><b>Info Storage:</b> Information about all found decorators is collected and stored internally, often associated with the class (e.g., in a hidden <code>__pydantic_decorators__</code> attribute holding a <code>DecoratorInfos</code> object).</li>
<li><b>Schema Integration:</b> When generating the <a class="el" href="../../d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html">Core Schema</a> for the model, Pydantic consults this stored decorator information. It translates the decorator rules (e.g., "run `check_username_spaces` after validating `username`") into corresponding schema components (like <code>after_validator_function</code>). The core validation/serialization engine then uses this schema.</li>
</ol>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Dev as Developer</div>
<div class="line">    participant Py as Python Interpreter</div>
<div class="line">    participant Meta as BaseModel Metaclass</div>
<div class="line">    participant DecInfo as DecoratorInfos</div>
<div class="line">    participant Core as Pydantic Core Engine</div>
<div class="line"> </div>
<div class="line">    Dev-&gt;&gt;Py: Define `class User(BaseModel): ... @field_validator(&#39;username&#39;) def check_spaces(cls, v): ...`</div>
<div class="line">    Py-&gt;&gt;Meta: Ask to create the `User` class</div>
<div class="line">    Meta-&gt;&gt;Meta: Scan class attributes, find `check_spaces` wrapped by PydanticDescriptorProxy</div>
<div class="line">    Meta-&gt;&gt;DecInfo: Store info: func=check_spaces, applies_to=&#39;username&#39;, mode=&#39;after&#39;</div>
<div class="line">    Meta-&gt;&gt;Core: Request Core Schema, providing field info AND DecoratorInfos</div>
<div class="line">    Core-&gt;&gt;Core: Build schema, incorporating an &#39;after_validator&#39; step for &#39;username&#39; linked to `check_spaces`</div>
<div class="line">    Core--&gt;&gt;Meta: Provide internal Core Schema for User</div>
<div class="line">    Meta-&gt;&gt;Core: Request validator/serializer functions from schema</div>
<div class="line">    Core--&gt;&gt;Meta: Provide optimized functions incorporating custom logic</div>
<div class="line">    Meta--&gt;&gt;Py: Return the fully prepared `User` class</div>
<div class="line">    Py--&gt;&gt;Dev: `User` class is ready</div>
</div><!-- fragment --><p><b><code>Annotated</code> Helpers:</b></p><ol type="1">
<li><b>Field Processing:</b> During class creation, when Pydantic processes a field like <code>username: Annotated[str, AfterValidator(check_no_spaces)]</code>, it analyzes the <code>Annotated</code> metadata.</li>
<li><b>Helper Recognition:</b> It recognizes Pydantic helper classes like <code>AfterValidator</code>. These helpers often implement a special method <code>__get_pydantic_core_schema__</code>.</li>
<li><b>Schema Generation:</b> Pydantic's schema generation logic (often involving <code>GetCoreSchemaHandler</code> from <code>pydantic.annotated_handlers</code>) calls <code>AfterValidator.__get_pydantic_core_schema__</code>. This method tells the handler how to integrate the custom logic (<code>check_no_spaces</code>) into the <a class="el" href="../../d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html">Core Schema</a> being built for the <code>username</code> field.</li>
<li><b>Schema Integration:</b> The handler modifies the schema-in-progress to include the custom logic (e.g., adding an <code>after_validator_function</code> component pointing to <code>check_no_spaces</code>). The final schema used by the core engine contains this logic directly associated with the field.</li>
</ol>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Dev as Developer</div>
<div class="line">    participant Py as Python Interpreter</div>
<div class="line">    participant Meta as BaseModel Metaclass</div>
<div class="line">    participant SchemaGen as Core Schema Generator</div>
<div class="line">    participant Helper as AfterValidator Instance</div>
<div class="line">    participant Core as Pydantic Core Engine</div>
<div class="line"> </div>
<div class="line">    Dev-&gt;&gt;Py: Define `class User(BaseModel): username: Annotated[str, AfterValidator(check_no_spaces)]`</div>
<div class="line">    Py-&gt;&gt;Meta: Ask to create the `User` class</div>
<div class="line">    Meta-&gt;&gt;SchemaGen: Start building schema for `User`</div>
<div class="line">    SchemaGen-&gt;&gt;SchemaGen: Process &#39;username&#39; field, see `Annotated[str, AfterValidator(...)]`</div>
<div class="line">    SchemaGen-&gt;&gt;Helper: Call `__get_pydantic_core_schema__` on `AfterValidator` instance</div>
<div class="line">    Helper-&gt;&gt;SchemaGen: Generate schema for base type (`str`)</div>
<div class="line">    SchemaGen--&gt;&gt;Helper: Return base `str` schema</div>
<div class="line">    Helper-&gt;&gt;Helper: Modify schema, adding &#39;after_validator&#39; pointing to `check_no_spaces`</div>
<div class="line">    Helper--&gt;&gt;SchemaGen: Return modified schema for &#39;username&#39;</div>
<div class="line">    SchemaGen-&gt;&gt;Core: Finalize schema for `User` model incorporating custom logic</div>
<div class="line">    Core--&gt;&gt;SchemaGen: Provide completed Core Schema</div>
<div class="line">    SchemaGen--&gt;&gt;Meta: Return Core Schema</div>
<div class="line">    Meta-&gt;&gt;Core: Request validator/serializer from final schema</div>
<div class="line">    Core--&gt;&gt;Meta: Provide optimized functions</div>
<div class="line">    Meta--&gt;&gt;Py: Return the fully prepared `User` class</div>
<div class="line">    Py--&gt;&gt;Dev: `User` class is ready</div>
</div><!-- fragment --><p><b>Code Location:</b></p><ul>
<li>Decorator logic (detection, storage, proxy): <code>pydantic._internal._decorators.py</code></li>
<li><code>Annotated</code> helper classes (<code>AfterValidator</code>, <code>PlainSerializer</code>, etc.): <code>pydantic.functional_validators.py</code>, <code>pydantic.functional_serializers.py</code></li>
<li>Schema generation integrating these: Primarily involves internal schema builders calling <code>__get_pydantic_core_schema__</code> on annotated types/metadata, often orchestrated via <code>pydantic._internal._generate_schema.GenerateSchema</code>. The <code>GetCoreSchemaHandler</code> from <code>pydantic.annotated_handlers.py</code> is passed around to facilitate this.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># Simplified concept from pydantic.functional_validators.py</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@dataclasses.dataclass(frozen=True)</span></div>
<div class="line"><span class="keyword">class </span>AfterValidator:</div>
<div class="line">    func: Callable <span class="comment"># The user&#39;s validation function</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># This method is called by Pydantic during schema building</span></div>
<div class="line">    <span class="keyword">def </span>__get_pydantic_core_schema__(</div>
<div class="line">        self,</div>
<div class="line">        source_type: Any, <span class="comment"># The base type (e.g., str)</span></div>
<div class="line">        handler: GetCoreSchemaHandler <span class="comment"># Helper to get schema for base type</span></div>
<div class="line">    ) -&gt; core_schema.CoreSchema:</div>
<div class="line">        <span class="comment"># 1. Get the schema for the base type (e.g., str_schema())</span></div>
<div class="line">        schema = handler(source_type)</div>
<div class="line">        <span class="comment"># 2. Wrap it with an &#39;after_validator&#39; step using self.func</span></div>
<div class="line">        info_arg = _inspect_validator(self.func, <span class="stringliteral">&#39;after&#39;</span>) <span class="comment"># Check signature</span></div>
<div class="line">        <span class="keywordflow">if</span> info_arg:</div>
<div class="line">            <span class="comment"># Use core_schema function for validators with info arg</span></div>
<div class="line">            <span class="keywordflow">return</span> core_schema.with_info_after_validator_function(</div>
<div class="line">                self.func, schema=schema</div>
<div class="line">            )</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            <span class="comment"># Use core_schema function for validators without info arg</span></div>
<div class="line">            <span class="keywordflow">return</span> core_schema.no_info_after_validator_function(</div>
<div class="line">                self.func, schema=schema</div>
<div class="line">            )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Simplified concept from pydantic._internal._decorators.py</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@dataclass</span></div>
<div class="line"><span class="keyword">class </span>FieldValidatorDecoratorInfo: <span class="comment"># Stores info about @field_validator</span></div>
<div class="line">    fields: tuple[str, ...]</div>
<div class="line">    mode: Literal[<span class="stringliteral">&#39;before&#39;</span>, <span class="stringliteral">&#39;after&#39;</span>, <span class="stringliteral">&#39;wrap&#39;</span>, <span class="stringliteral">&#39;plain&#39;</span>]</div>
<div class="line">    <span class="comment"># ... other options</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@dataclass</span></div>
<div class="line"><span class="keyword">class </span>PydanticDescriptorProxy: <span class="comment"># Wraps the decorated method</span></div>
<div class="line">    wrapped: Callable</div>
<div class="line">    decorator_info: FieldValidatorDecoratorInfo | ... <span class="comment"># Stores the info object</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Simplified concept from ModelMetaclass during class creation</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># ... scan class attributes ...</span></div>
<div class="line">decorators = DecoratorInfos() <span class="comment"># Object to hold all found decorators</span></div>
<div class="line"><span class="keywordflow">for</span> var_name, var_value <span class="keywordflow">in</span> vars(model_cls).items():</div>
<div class="line">    <span class="keywordflow">if</span> isinstance(var_value, PydanticDescriptorProxy):</div>
<div class="line">        info = var_value.decorator_info</div>
<div class="line">        <span class="comment"># Store the decorator info (function, fields, mode, etc.)</span></div>
<div class="line">        <span class="comment"># in the appropriate category within &#39;decorators&#39; object</span></div>
<div class="line">        <span class="keywordflow">if</span> isinstance(info, FieldValidatorDecoratorInfo):</div>
<div class="line">            decorators.field_validators[var_name] = Decorator(</div>
<div class="line">                func=var_value.wrapped, info=info <span class="comment"># Simplified</span></div>
<div class="line">            )</div>
<div class="line">        <span class="comment"># ... handle other decorator types ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># ... later, when building the core schema ...</span></div>
<div class="line"><span class="comment"># schema_generator uses the &#39;decorators&#39; object to add validation/serialization</span></div>
<div class="line"><span class="comment"># steps to the core schema based on the stored decorator info.</span></div>
</div><!-- fragment --><p>Both decorators and <code>Annotated</code> helpers ultimately achieve the same goal: embedding custom Python functions into the Pydantic validation and serialization pipeline by modifying the underlying <a class="el" href="../../d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html">Core Schema</a>.</p>
<h2><a class="anchor" id="autotoc_md2853"></a>
Conclusion</h2>
<p>You've learned two powerful ways to add custom logic to your Pydantic models:</p>
<ul>
<li><b>Decorators</b> (<code>@field_validator</code>, <code>@model_validator</code>, <code>@field_serializer</code>, <code>@model_serializer</code>) allow you to designate methods within your model class for custom validation or serialization tasks, applying logic to specific fields or the entire model.</li>
<li><b><code>Annotated</code> Helpers</b> (<code>BeforeValidator</code>, <code>AfterValidator</code>, <code>PlainSerializer</code>, etc.) let you attach validation or serialization functions directly to a field's type hint using <code>typing.Annotated</code>, often promoting reusable logic functions.</li>
</ul>
<p>These tools give you fine-grained control over how your data is processed, going beyond basic type checks and configuration. They are essential for handling real-world data validation and formatting complexities.</p>
<p>Understanding how these mechanisms work often involves looking at the internal representation Pydantic uses: the Core Schema. In the next chapter, we'll delve into what this schema looks like and how Pydantic uses it.</p>
<p>Next: <a class="el" href="../../d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html">Chapter 5: Core Schema &amp; Validation/Serialization</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
