#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_prompttemplates</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/d9e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_205__prompttemplates.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_prompttemplates</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md3116"></a>
autotoc_md3116</h2>
<p>layout: default title: "PromptTemplates" parent: "SmolaAgents" </p>
<h2><a class="anchor" id="autotoc_md3117"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md3118"></a>
Chapter 5: PromptTemplates - Crafting Your Agent's Script</h1>
<p>Welcome back! In <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">Chapter 4: AgentMemory</a>, we learned how our agent uses its "logbook" (<code>AgentMemory</code>) to remember the task, its past actions, and observations. This memory is crucial for deciding the next step.</p>
<p>But how exactly does the agent <em>use</em> this memory to talk to its LLM brain (<a class="el" href="../../dc/db5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_202__model__interface.html">Chapter 2: Model Interface</a>)? How does it tell the LLM:</p><ul>
<li>"Here's your overall job..."</li>
<li>"Here are the tools ([Chapter 3: Tool](03_tool.md)) you can use..."</li>
<li>"Here's the specific task..."</li>
<li>"Here's what happened so far..."</li>
<li>"Now, tell me what to do next!"</li>
</ul>
<p>Simply dumping the raw memory might confuse the LLM. We need a structured way to present this information â€“ like giving someone clear, consistent instructions. This is where <b>PromptTemplates</b> come in!</p>
<h2><a class="anchor" id="autotoc_md3119"></a>
The Problem: Giving Clear Instructions Every Time</h2>
<p>Imagine you have a very capable assistant, but you need to explain their role and the current task <em>every single time</em> you talk to them. You'd want a standard way to do this, right? You'd probably have a template:</p>
<ul>
<li>"Good morning! Remember, your main goal is [Overall Goal]."</li>
<li>"For this specific task, [Task Description], you have these resources available: [List of Resources]."</li>
<li>"So far, we've done [Summary of Progress]."</li>
<li>"What should we do next?"</li>
</ul>
<p>If you just improvised every time, your instructions might be inconsistent, confusing, or miss important details.</p>
<p>Our AI agent faces the same challenge. It needs to send instructions (prompts) to the LLM at various points (like the very beginning, before each step, maybe when planning). These instructions need to include:</p><ul>
<li>The agent's basic persona and rules.</li>
<li>Descriptions of the available <a class="el" href="../../d4/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_203__tool.html">Tools</a>.</li>
<li>The current <code>task</code>.</li>
<li>Relevant parts of the <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">AgentMemory</a>.</li>
</ul>
<p>How can we manage these instructions effectively and dynamically include the specific details for the current situation?</p>
<h2><a class="anchor" id="autotoc_md3120"></a>
The Solution: Mad Libs for Agents! (<code>PromptTemplates</code>)</h2>
<p>Remember Mad Libs? The game where you have a story template with blanks like <code>[NOUN]</code>, <code>[VERB]</code>, <code>[ADJECTIVE]</code>, and you fill them in to create a funny story?</p>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/e6/Mad_Libs_logo.svg/320px-Mad_Libs_logo.svg.png" alt="Mad Libs Example" class="inline"/></p>
<p><b>PromptTemplates</b> in <code>SmolaAgents</code> work a lot like that!</p>
<ul>
<li>They are a collection of <b>pre-written instruction templates</b>.</li>
<li>These templates have <b>placeholders</b> (like <code>{{ task }}</code> or <code>{{ tools }}</code>) for information that changes with each run or step.</li>
<li>They use a powerful templating engine called <b>Jinja2</b> (common in web development) to fill in these blanks.</li>
<li>The <code>MultiStepAgent</code> automatically picks the right template, fills in the blanks with current data (like the task description, tool list from <a class="el" href="../../d4/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_203__tool.html">Chapter 3: Tool</a>, or memory summary from <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">Chapter 4: AgentMemory</a>), and sends the final, complete prompt to the LLM.</li>
</ul>
<p>This ensures the LLM gets clear, consistent, and context-rich instructions every time.</p>
<h2><a class="anchor" id="autotoc_md3121"></a>
What's Inside the <code>PromptTemplates</code> Collection?</h2>
<p>The <code>PromptTemplates</code> object is essentially a structured dictionary holding different template strings for different situations. The main ones are:</p>
<ol type="1">
<li><b><code>system_prompt</code></b>: This is the <b>master instruction manual</b> given to the LLM at the very beginning of the conversation. It tells the LLM:<ul>
<li>Its overall role or personality (e.g., "You are a helpful assistant that uses tools...").</li>
<li>The rules it must follow (e.g., "Always think step-by-step," "Use the `final_answer` tool when done.").</li>
<li><b>Crucially, the descriptions of the available <code>{{ tools }}</code> and <code>{{ managed_agents }}</code> (if any).</b> This is how the LLM learns what capabilities the agent has!</li>
<li>The format it should use for its response (e.g., "Provide your reasoning in a 'Thought:' section and the action in a 'Code:' section").</li>
</ul>
</li>
<li><b><code>planning</code></b>: This group contains templates used only if the agent's planning feature is turned on (often for more complex tasks). It includes templates for:<ul>
<li>Generating an initial plan based on the <code>{{ task }}</code> and <code>{{ tools }}</code>.</li>
<li>Updating the plan based on progress stored in memory. <em>(Planning is a bit more advanced, so we won't focus heavily on these templates here).</em></li>
</ul>
</li>
<li><b><code>final_answer</code></b>: These templates are used in specific scenarios, like when the agent hits its maximum step limit (<code>max_steps</code>) and needs the LLM to try and generate a final answer based on the conversation history (<code>{{ task }}</code>, memory).</li>
<li><b><code>managed_agent</code></b>: If you build agents that can call <em>other</em> agents (like team members), these templates define how the calling agent instructs the "managed" agent (<code>{{ name }}</code>, <code>{{ task }}</code>) and how the result (<code>{{ final_answer }}</code>) is reported back.</li>
</ol>
<p>The most important one for understanding basic agent behavior is the <b><code>system_prompt</code></b>. It sets the stage for the entire interaction.</p>
<h2><a class="anchor" id="autotoc_md3122"></a>
How It Works: Filling in the Blanks with Jinja2</h2>
<p>Let's imagine a simplified <code>system_prompt</code> template:</p>
<div class="fragment"><div class="line">You are a helpful assistant.</div>
<div class="line">Your task is to achieve the goal described by the user.</div>
<div class="line">You have access to the following tools:</div>
<div class="line">{{ tools }}</div>
<div class="line"> </div>
<div class="line">Think step-by-step and then choose a tool to use or use the final_answer tool.</div>
</div><!-- fragment --><p>Now, let's say our agent is created with a <code>SearchTool</code> and our <code>GreetingTool</code> from <a class="el" href="../../d4/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_203__tool.html">Chapter 3: Tool</a>.</p>
<ol type="1">
<li><b>Agent Starts:</b> The <code>MultiStepAgent</code> needs to prepare the initial message for the LLM.</li>
<li><b>Get Template:</b> It retrieves the <code>system_prompt</code> template string.</li>
<li><b>Get Data:</b> It gets the list of actual tool instances (<code>[SearchTool(...), GreetingTool(...)]</code>). It formats their names and descriptions into a string. Let's say this formatted string is: <code><ul>
<li>web_search: Searches the web...</li>
<li>greet_person: Greets a person by name...</li>
<li>final_answer: Use this when you have the final answer... </li>
</ul>
</code></li>
<li><b>Fill Blanks (Render):</b> It uses the Jinja2 engine to replace <code>{{ tools }}</code> in the template with the formatted tool descriptions.</li>
<li><p class="startli"><b>Final Prompt:</b> The resulting prompt sent to the LLM would be:</p>
<p class="startli">```text You are a helpful assistant. Your task is to achieve the goal described by the user. You have access to the following tools:</p><ul>
<li>web_search: Searches the web...</li>
<li>greet_person: Greets a person by name...</li>
<li>final_answer: Use this when you have the final answer...</li>
</ul>
<p class="startli">Think step-by-step and then choose a tool to use or use the final_answer tool. ```</p>
</li>
</ol>
<p>This final, complete prompt gives the LLM all the context it needs to start working on the user's task.</p>
<p>Here's a diagram of the process:</p>
<div class="fragment"><div class="line">graph LR</div>
<div class="line">    A[&quot;Prompt Template String&lt;br/&gt;System Prompt with \{\{ tools \}\}&quot;] --&gt; C{Jinja2 Engine};</div>
<div class="line">    B[&quot;Agent Data&lt;br/&gt;(Formatted Tool Descriptions)&quot;] --&gt; C;</div>
<div class="line">    C --&gt; D[&quot;Final Prompt String&lt;br/&gt;(System Prompt with actual tools listed)&quot;];</div>
<div class="line">    D --&gt; E[&quot;LLM Brain&quot;];</div>
</div><!-- fragment --><p>The agent uses similar logic for other templates, inserting <code>{{ task }}</code>, snippets from <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">AgentMemory</a>, etc., as needed.</p>
<h2><a class="anchor" id="autotoc_md3123"></a>
Using <code>PromptTemplates</code> in <code>SmolaAgents</code></h2>
<p>The good news is that <code>SmolaAgents</code> handles most of this automatically!</p>
<ul>
<li><b>Defaults:</b> When you create an agent like <code>CodeAgent</code> or <code>ToolCallingAgent</code>, it comes pre-loaded with sophisticated default <code>PromptTemplates</code> tailored for that agent type. These defaults live in YAML files within the <code>SmolaAgents</code> library (e.g., <code>prompts/code_agent.yaml</code>, <code>prompts/toolcalling_agent.yaml</code>). These files define the <code>system_prompt</code>, <code>planning</code> prompts, etc., with all the necessary placeholders.</li>
<li><b>Automatic Loading:</b> The agent's <code>__init__</code> method loads these default templates unless you explicitly provide your own.</li>
</ul>
<p>Let's look at a simplified snippet from <code>agents.py</code> showing how a <code>CodeAgent</code> might initialize its system prompt:</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: agents.py (Simplified CodeAgent __init__ and initialize_system_prompt) ---</span></div>
<div class="line"><span class="keyword">import</span> yaml</div>
<div class="line"><span class="keyword">import</span> importlib.resources</div>
<div class="line"><span class="keyword">from</span> .tools <span class="keyword">import</span> Tool <span class="comment"># From Chapter 3</span></div>
<div class="line"><span class="keyword">from</span> .agents <span class="keyword">import</span> MultiStepAgent, populate_template, PromptTemplates <span class="comment"># Helper function</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CodeAgent(MultiStepAgent):</div>
<div class="line">    <span class="keyword">def </span>__init__(</div>
<div class="line">        self,</div>
<div class="line">        tools: list[Tool],</div>
<div class="line">        model: callable,</div>
<div class="line">        prompt_templates: PromptTemplates | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>, <span class="comment"># Allow custom templates</span></div>
<div class="line">        <span class="comment"># ... other parameters ...</span></div>
<div class="line">    ):</div>
<div class="line">        <span class="comment"># 1. Load default templates if none provided</span></div>
<div class="line">        <span class="keywordflow">if</span> prompt_templates <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line">            <span class="comment"># Find the default &#39;code_agent.yaml&#39; file</span></div>
<div class="line">            default_yaml_path = importlib.resources.files(<span class="stringliteral">&quot;smolagents.prompts&quot;</span>).joinpath(<span class="stringliteral">&quot;code_agent.yaml&quot;</span>)</div>
<div class="line">            <span class="comment"># Load the templates from the YAML file</span></div>
<div class="line">            prompt_templates = yaml.safe_load(default_yaml_path.read_text())</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 2. Call the parent class init, passing the templates along</span></div>
<div class="line">        super().__init__(</div>
<div class="line">            tools=tools,</div>
<div class="line">            model=model,</div>
<div class="line">            prompt_templates=prompt_templates, <span class="comment"># Use loaded or provided templates</span></div>
<div class="line">            <span class="comment"># ... other parameters ...</span></div>
<div class="line">        )</div>
<div class="line">        <span class="comment"># ... rest of CodeAgent setup ...</span></div>
<div class="line">        <span class="comment"># self.system_prompt is set later using initialize_system_prompt</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>initialize_system_prompt(self) -&gt; str:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Creates the final system prompt string by filling the template.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># 3. Get necessary data (tools, managed agents, authorized imports)</span></div>
<div class="line">        formatted_tools = <span class="comment"># ... format self.tools for the template ...</span></div>
<div class="line">        formatted_managed_agents = <span class="comment"># ... format self.managed_agents ...</span></div>
<div class="line">        authorized_imports = <span class="comment"># ... get list of allowed imports for CodeAgent ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 4. Use the populate_template helper to fill in the blanks</span></div>
<div class="line">        system_prompt_string = populate_template(</div>
<div class="line">            template=self.prompt_templates[<span class="stringliteral">&quot;system_prompt&quot;</span>], <span class="comment"># Get the template string</span></div>
<div class="line">            variables={ <span class="comment"># Provide the data for the placeholders</span></div>
<div class="line">                <span class="stringliteral">&quot;tools&quot;</span>: formatted_tools,</div>
<div class="line">                <span class="stringliteral">&quot;managed_agents&quot;</span>: formatted_managed_agents,</div>
<div class="line">                <span class="stringliteral">&quot;authorized_imports&quot;</span>: authorized_imports,</div>
<div class="line">                <span class="comment"># ... other potential variables ...</span></div>
<div class="line">            }</div>
<div class="line">        )</div>
<div class="line">        <span class="keywordflow">return</span> system_prompt_string</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... other CodeAgent methods ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Helper function used internally (Simplified from agents.py) ---</span></div>
<div class="line"><span class="keyword">from</span> jinja2 <span class="keyword">import</span> Template, StrictUndefined</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>populate_template(template: str, variables: dict) -&gt; str:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Renders a Jinja2 template string with given variables.&quot;&quot;&quot;</span></div>
<div class="line">    compiled_template = Template(template, undefined=StrictUndefined)</div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        <span class="comment"># This does the magic of replacing {{ placeholder }} with actual values</span></div>
<div class="line">        <span class="keywordflow">return</span> compiled_template.render(**variables)</div>
<div class="line">    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">        <span class="keywordflow">raise</span> Exception(f<span class="stringliteral">&quot;Error rendering Jinja template: {e}&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Load Defaults:</b> If the user doesn't provide custom <code>prompt_templates</code> when creating a <code>CodeAgent</code>, it loads the defaults from the <code>code_agent.yaml</code> file.</li>
<li><b>Store Templates:</b> The loaded templates (either default or custom) are stored within the agent instance (via the <code>super().__init__</code> call).</li>
<li><b>Get Data:</b> When the agent needs the final system prompt (e.g., during <code>run</code>), the <code>initialize_system_prompt</code> method gathers the current list of tools, managed agents, etc.</li>
<li><b>Render Template:</b> It calls the <code>populate_template</code> helper function. This function uses Jinja2's <code>Template(...).render(...)</code> to take the <code>system_prompt</code> template string and the collected <code>variables</code> (tools, etc.) and produces the final, ready-to-use prompt string.</li>
</ol>
<p><em>For beginners, you usually don't need to write your own templates. The defaults are designed to work well.</em> However, understanding that these templates exist and how they work helps you understand <em>why</em> the agent behaves the way it does and how it knows about its tools.</p>
<p>If you <em>do</em> want to see what these templates look like, you can inspect the <code>.yaml</code> files inside the <code>smolagents/prompts/</code> directory in the library's source code. For example, here's a small part of a typical <code>system_prompt</code> for a <code>CodeAgent</code>:</p>
<div class="fragment"><div class="line"># --- Snippet from prompts/code_agent.yaml ---</div>
<div class="line">system_prompt: |-</div>
<div class="line">  You are an expert assistant who can solve any task using code blobs.</div>
<div class="line">  # ... (lots of instructions and examples) ...</div>
<div class="line"> </div>
<div class="line">  You only have access to these tools:</div>
<div class="line">  {%- for tool in tools.values() %}</div>
<div class="line">  - {{ tool.name }}: {{ tool.description }}</div>
<div class="line">      Takes inputs: {{tool.inputs}}</div>
<div class="line">      Returns an output of type: {{tool.output_type}}</div>
<div class="line">  {%- endfor %}</div>
<div class="line"> </div>
<div class="line">  {%- if managed_agents and managed_agents.values() | list %}</div>
<div class="line">  You can also give tasks to team members.</div>
<div class="line">  # ... (instructions for managed agents) ...</div>
<div class="line">  {%- for agent in managed_agents.values() %}</div>
<div class="line">  - {{ agent.name }}: {{ agent.description }}</div>
<div class="line">  {%- endfor %}</div>
<div class="line">  {%- endif %}</div>
<div class="line"> </div>
<div class="line">  Here are the rules you should always follow:</div>
<div class="line">  # ... (more rules) ...</div>
<div class="line">  You can use imports in your code, but only from the following list of modules: {{authorized_imports}}</div>
<div class="line">  # ... (rest of the prompt) ...</div>
</div><!-- fragment --><p>{% raw %} You can see the <code>{{ tools }}</code>, <code>{{ managed_agents }}</code>, and <code>{{ authorized_imports }}</code> placeholders ready to be filled in. The <code>{%- for ... %}</code> syntax is Jinja2's way of looping through lists (like the list of tools). {% endraw %}</p>
<h2><a class="anchor" id="autotoc_md3124"></a>
Conclusion</h2>
<p><code>PromptTemplates</code> are the unsung heroes that shape the conversation between the agent and its LLM brain. They act like customizable scripts or Mad Libs templates, ensuring the LLM receives clear, consistent instructions filled with the specific details it needs (like the task, available tools, and memory context).</p>
<p>You've learned:</p>
<p>{% raw %}</p><ul>
<li>Why structured prompts are necessary for guiding LLMs effectively.</li>
<li>The "Mad Libs" analogy for <code>PromptTemplates</code>.</li>
<li>How Jinja2 is used to fill placeholders like <code>{{ task }}</code> and <code>{{ tools }}</code>.</li>
<li>The main types of prompts stored (<code>system_prompt</code>, <code>planning</code>, <code>final_answer</code>).</li>
<li>That <code>SmolaAgents</code> provides sensible default templates, especially the crucial <code>system_prompt</code>.</li>
<li>How the agent automatically renders these templates with current data before sending them to the LLM. {% endraw %}</li>
</ul>
<p>Understanding <code>PromptTemplates</code> helps you grasp how the agent frames its requests to the LLM. While you might stick to the defaults initially, knowing this mechanism exists opens the door to customizing agent behavior later on.</p>
<p>One of the most powerful tools often described in these prompts, especially for <code>CodeAgent</code>, is the ability to execute Python code. How is that done safely? Let's find out!</p>
<p><b>Next Chapter:</b> <a class="el" href="../../df/dec/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_206__pythonexecutor.html">Chapter 6: PythonExecutor</a> - Running Code Safely.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
