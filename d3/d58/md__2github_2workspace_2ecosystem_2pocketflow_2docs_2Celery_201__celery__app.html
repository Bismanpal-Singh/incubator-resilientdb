#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 01_celery_app</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/d58/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_201__celery__app.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">01_celery_app</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md955"></a>
autotoc_md955</h2>
<p>layout: default title: "Celery App" parent: "Celery" </p>
<h2><a class="anchor" id="autotoc_md956"></a>
nav_order: 1</h2>
<h1><a class="anchor" id="autotoc_md957"></a>
Chapter 1: The Celery App - Your Task Headquarters</h1>
<p>Welcome to the world of Celery! If you've ever thought, "I wish this slow part of my web request could run somewhere else later," or "How can I process this huge amount of data without freezing my main application?", then Celery is here to help.</p>
<p>Celery allows you to run code (we call these "tasks") separately from your main application, either in the background on the same machine or distributed across many different machines.</p>
<p>But how do you tell Celery <em>what</em> tasks to run and <em>how</em> to run them? That's where the <b>Celery App</b> comes in.</p>
<h2><a class="anchor" id="autotoc_md958"></a>
What Problem Does the Celery App Solve?</h2>
<p>Imagine you're building a website. When a user uploads a profile picture, you need to resize it into different formats (thumbnail, medium, large). Doing this immediately when the user clicks "upload" can make the request slow and keep the user waiting.</p>
<p>Ideally, you want to:</p><ol type="1">
<li>Quickly save the original image.</li>
<li>Tell the user "Okay, got it!"</li>
<li><em>Later</em>, in the background, resize the image.</li>
</ol>
<p>Celery helps with step 3. But you need a central place to define the "resize image" task and configure <em>how</em> it should be run (e.g., where to send the request to resize, where to store the result). The <b>Celery App</b> is that central place.</p>
<p>Think of it like the main application object in web frameworks like Flask or Django. It's the starting point, the brain, the headquarters for everything Celery-related in your project.</p>
<h2><a class="anchor" id="autotoc_md959"></a>
Creating Your First Celery App</h2>
<p>Getting started is simple. You just need to create an instance of the <code>Celery</code> class.</p>
<p>Let's create a file named <code>celery_app.py</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># celery_app.py</span></div>
<div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a Celery app instance</span></div>
<div class="line"><span class="comment"># &#39;tasks&#39; is just a name for this app instance, often the module name.</span></div>
<div class="line"><span class="comment"># &#39;broker&#39; tells Celery where to send task messages.</span></div>
<div class="line"><span class="comment"># We&#39;ll use Redis here for simplicity (you need Redis running).</span></div>
<div class="line">app = Celery(<span class="stringliteral">&#39;tasks&#39;</span>,</div>
<div class="line">             broker=<span class="stringliteral">&#39;redis://localhost:6379/0&#39;</span>,</div>
<div class="line">             backend=<span class="stringliteral">&#39;redis://localhost:6379/0&#39;</span>) <span class="comment"># Added backend for results</span></div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Celery app created: {app}&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>from celery import Celery</code>: We import the main <code>Celery</code> class.</li>
<li><code>app = Celery(...)</code>: We create an instance.<ul>
<li>&lsquo;'tasks&rsquo;<code>: This is the *name* of our Celery application. It's often good practice to use the name of the module where your app is defined. Celery uses this name to automatically name tasks if you don't provide one explicitly. *</code>broker='redis://localhost:6379/0'<code>: This is crucial! It tells Celery where to send the task messages. A "broker" is like a post office for tasks. We're using Redis here, but Celery supports others like RabbitMQ. We'll learn more about the [Broker Connection (AMQP)](<a class="el" href="../../d4/d7a/04__broker__connection____amqp___8md.html">04_broker_connection__amqp_.md</a>) in Chapter 4. (Note: AMQP is the protocol often used with brokers like RabbitMQ, but the concept applies even when using Redis). *</code>backend='redis://localhost:6379/0'<code>: This tells Celery where to store the results of your tasks. If your task returns a value (like</code>2+2<code>returns</code>4<code>), Celery can store this</code>4` in the backend. We'll cover the <a class="el" href="../../d3/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_206__result__backend.html">Result Backend</a> in Chapter 6.</li>
</ul>
</li>
</ul>
<p>That's it! You now have a <code>Celery</code> application instance named <code>app</code>. This <code>app</code> object is your main tool for working with Celery.</p>
<h2><a class="anchor" id="autotoc_md960"></a>
Defining a Task with the App</h2>
<p>Now that we have our <code>app</code>, how do we define a task? We use the <code>@app.task</code> decorator.</p>
<p>Let's modify <code>celery_app.py</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># celery_app.py</span></div>
<div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a Celery app instance</span></div>
<div class="line">app = Celery(<span class="stringliteral">&#39;tasks&#39;</span>,</div>
<div class="line">             broker=<span class="stringliteral">&#39;redis://localhost:6379/0&#39;</span>,</div>
<div class="line">             backend=<span class="stringliteral">&#39;redis://localhost:6379/0&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define a simple task using the app&#39;s decorator</span></div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>add(x, y):</div>
<div class="line">    print(f<span class="stringliteral">&quot;Task &#39;add&#39; started with args: ({x}, {y})&quot;</span>)</div>
<div class="line">    time.sleep(2) <span class="comment"># Simulate some work</span></div>
<div class="line">    result = x + y</div>
<div class="line">    print(f<span class="stringliteral">&quot;Task &#39;add&#39; finished with result: {result}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> result</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Task &#39;add&#39; is registered: {app.tasks.get(&#39;celery_app.add&#39;)}&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>@app.task</code>: This is the magic decorator. It takes our regular Python function <code>add(x, y)</code> and registers it as a Celery task within our <code>app</code>.</li>
<li>Now, <code>app</code> knows about a task called <code>celery_app.add</code> (Celery automatically generates the name based on the module <code>celery_app</code> and function <code>add</code>).</li>
<li>We'll learn all about <a class="el" href="../../d5/db8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_203__task.html">Task</a>s in Chapter 3.</li>
</ul>
<h2><a class="anchor" id="autotoc_md961"></a>
Sending a Task (Conceptual)</h2>
<p>How do we actually <em>run</em> this <code>add</code> task in the background? We use methods like <code>.delay()</code> or <code>.apply_async()</code> on the task object itself.</p>
<div class="fragment"><div class="line"><span class="comment"># In a separate Python script or interpreter, after importing &#39;add&#39; from celery_app.py</span></div>
<div class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> add</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Send the task to the broker configured in our &#39;app&#39;</span></div>
<div class="line">result_promise = add.delay(4, 5)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Task sent! It will run in the background.&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;We got back a promise object: {result_promise}&quot;</span>)</div>
<div class="line"><span class="comment"># We can later check the result using result_promise.get()</span></div>
<div class="line"><span class="comment"># (Requires a result backend and a worker running the task)</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>add.delay(4, 5)</code>: This doesn't run the <code>add</code> function <em>right now</em>. Instead, it:<ol type="1">
<li>Packages the task name (<code>celery_app.add</code>) and its arguments (<code>4</code>, <code>5</code>) into a message.</li>
<li>Sends this message to the <b>broker</b> (Redis, in our case) that was configured in our <code>Celery</code> app instance (<code>app</code>).</li>
</ol>
</li>
<li>It returns an <code>AsyncResult</code> object (our <code>result_promise</code>), which is like an IOU or a placeholder for the actual result. We can use this later to check if the task finished and what its result was (if we configured a <a class="el" href="../../d3/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_206__result__backend.html">Result Backend</a>).</li>
</ul>
<p>A separate program, called a Celery <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a>, needs to be running. This worker watches the broker for new task messages, executes the corresponding task function, and (optionally) stores the result in the backend. We'll learn how to run a worker in Chapter 5.</p>
<p>The key takeaway here is that the <b>Celery App</b> holds the configuration needed (<code>broker</code> and <code>backend</code> URLs) for <code>add.delay()</code> to know <em>where</em> to send the task message and potentially where the result will be stored.</p>
<h2><a class="anchor" id="autotoc_md962"></a>
How It Works Internally (High-Level)</h2>
<p>Let's visualize the process of creating the app and sending a task:</p>
<ol type="1">
<li><b>Initialization (<code>Celery(...)</code>)</b>: When you create <code>app = Celery(...)</code>, the app instance stores the <code>broker</code> and <code>backend</code> URLs and sets up internal components like the task registry.</li>
<li>**Task Definition (<code>@app.task</code>)**: The decorator tells the <code>app</code> instance: "Hey, remember this function `add`? It's a task." The app stores this information in its internal task registry (<code>app.tasks</code>).</li>
<li><b>Sending a Task (<code>add.delay(4, 5)</code>)</b>:<ul>
<li><code>add.delay()</code> looks up the <code>app</code> it belongs to.</li>
<li>It asks the <code>app</code> for the <code>broker</code> URL.</li>
<li>It creates a message containing the task name (<code>celery_app.add</code>), arguments (<code>4, 5</code>), and other details.</li>
<li>It uses the <code>broker</code> URL to connect to the broker (Redis) and sends the message.</li>
</ul>
</li>
</ol>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client as Your Python Code</div>
<div class="line">    participant CeleryApp as app = Celery(...)</div>
<div class="line">    participant AddTask as @app.task add()</div>
<div class="line">    participant Broker as Redis/RabbitMQ</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;CeleryApp: Create instance (broker=&#39;redis://...&#39;)</div>
<div class="line">    Client-&gt;&gt;AddTask: Define add() function with @app.task</div>
<div class="line">    Note over AddTask,CeleryApp: Decorator registers &#39;add&#39; with &#39;app&#39;</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;AddTask: Call add.delay(4, 5)</div>
<div class="line">    AddTask-&gt;&gt;CeleryApp: Get broker configuration</div>
<div class="line">    CeleryApp--&gt;&gt;AddTask: &#39;redis://...&#39;</div>
<div class="line">    AddTask-&gt;&gt;Broker: Send task message (&#39;add&#39;, 4, 5)</div>
<div class="line">    Broker--&gt;&gt;AddTask: Acknowledgment (message sent)</div>
<div class="line">    AddTask--&gt;&gt;Client: Return AsyncResult (promise)</div>
</div><!-- fragment --><p>This diagram shows how the <code>Celery App</code> acts as the central coordinator, holding configuration and enabling the task (<code>add</code>) to send its execution request to the Broker.</p>
<h2><a class="anchor" id="autotoc_md963"></a>
Code Dive: Inside the <code>Celery</code> Class</h2>
<p>Let's peek at some relevant code snippets (simplified for clarity).</p>
<p><b>Initialization (<code>app/base.py</code>)</b></p>
<p>When you call <code>Celery(...)</code>, the <code>__init__</code> method runs:</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified from celery/app/base.py</span></div>
<div class="line"><span class="keyword">from</span> .registry <span class="keyword">import</span> TaskRegistry</div>
<div class="line"><span class="keyword">from</span> .utils <span class="keyword">import</span> Settings</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Celery:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, main=None, broker=None, backend=None,</div>
<div class="line">                 include=None, config_source=None, task_cls=None,</div>
<div class="line">                 autofinalize=True, **kwargs):</div>
<div class="line"> </div>
<div class="line">        self.main = main <span class="comment"># Store the app name (&#39;tasks&#39; in our example)</span></div>
<div class="line">        self._tasks = TaskRegistry({}) <span class="comment"># Create an empty dictionary for tasks</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Store broker/backend/include settings temporarily</span></div>
<div class="line">        self._preconf = {}</div>
<div class="line">        self.__autoset(<span class="stringliteral">&#39;broker_url&#39;</span>, broker)</div>
<div class="line">        self.__autoset(<span class="stringliteral">&#39;result_backend&#39;</span>, backend)</div>
<div class="line">        self.__autoset(<span class="stringliteral">&#39;include&#39;</span>, include)</div>
<div class="line">        <span class="comment"># ... other kwargs ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Configuration object - initially pending, loaded later</span></div>
<div class="line">        self._conf = Settings(...)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># ... other setup ...</span></div>
<div class="line"> </div>
<div class="line">        _register_app(self) <span class="comment"># Register this app instance globally (sometimes useful)</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Helper to store initial settings before full configuration load</span></div>
<div class="line">    <span class="keyword">def </span>__autoset(self, key, value):</div>
<div class="line">        <span class="keywordflow">if</span> value <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line">            self._preconf[key] = value</div>
</div><!-- fragment --><p>This shows how the <code>Celery</code> object is initialized, storing the name, setting up a task registry, and holding onto initial configuration like the <code>broker</code> URL. The full configuration is often loaded later (see <a class="el" href="../../d7/df5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_202__configuration.html">Configuration</a>).</p>
<p><b>Task Decorator (<code>app/base.py</code>)</b></p>
<p>The <code>@app.task</code> decorator ultimately calls <code>_task_from_fun</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified from celery/app/base.py</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>task(self, *args, **opts):</div>
<div class="line">        <span class="comment"># ... logic to handle decorator arguments ...</span></div>
<div class="line">        <span class="keyword">def </span>_create_task_cls(fun):</div>
<div class="line">            <span class="comment"># If app isn&#39;t finalized, might return a proxy object first</span></div>
<div class="line">            <span class="comment"># Eventually calls _task_from_fun to create/register the task</span></div>
<div class="line">            ret = self._task_from_fun(fun, **opts)</div>
<div class="line">            <span class="keywordflow">return</span> ret</div>
<div class="line">        <span class="keywordflow">return</span> _create_task_cls</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>_task_from_fun(self, fun, name=None, base=None, bind=False, **options):</div>
<div class="line">        <span class="comment"># Generate task name if not provided (e.g., &#39;celery_app.add&#39;)</span></div>
<div class="line">        name = name <span class="keywordflow">or</span> self.gen_task_name(fun.__name__, fun.__module__)</div>
<div class="line">        base = base <span class="keywordflow">or</span> self.Task <span class="comment"># Default base Task class</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Check if task already registered</span></div>
<div class="line">        <span class="keywordflow">if</span> name <span class="keywordflow">not</span> <span class="keywordflow">in</span> self._tasks:</div>
<div class="line">            <span class="comment"># Create a Task class dynamically based on the function</span></div>
<div class="line">            task = type(fun.__name__, (base,), {</div>
<div class="line">                <span class="stringliteral">&#39;app&#39;</span>: self, <span class="comment"># Link task back to this app instance!</span></div>
<div class="line">                <span class="stringliteral">&#39;name&#39;</span>: name,</div>
<div class="line">                <span class="stringliteral">&#39;run&#39;</span>: staticmethod(fun), <span class="comment"># The actual function to run</span></div>
<div class="line">                <span class="comment"># ... other attributes and options ...</span></div>
<div class="line">            })() <span class="comment"># Instantiate the new task class</span></div>
<div class="line">            self._tasks[task.name] = task <span class="comment"># Add to app&#39;s task registry</span></div>
<div class="line">            task.bind(self) <span class="comment"># Perform any binding steps</span></div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            task = self._tasks[name] <span class="comment"># Task already exists</span></div>
<div class="line">        <span class="keywordflow">return</span> task</div>
</div><!-- fragment --><p>This shows how the decorator uses the <code>app</code> instance (<code>self</code>) to generate a name, create a <code>Task</code> object wrapping your function, associate the task with the app (&lsquo;'app&rsquo;: self<code>), and store it in the</code>app._tasks` registry.</p>
<p><b>Sending Tasks (<code>app/base.py</code>)</b></p>
<p>Calling <code>.delay()</code> or <code>.apply_async()</code> eventually uses <code>app.send_task</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified from celery/app/base.py</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>send_task(self, name, args=None, kwargs=None, task_id=None,</div>
<div class="line">                  producer=None, connection=None, router=None, **options):</div>
<div class="line">        <span class="comment"># ... lots of logic to prepare options, task_id, routing ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Get the routing info (exchange, routing_key, queue)</span></div>
<div class="line">        <span class="comment"># Uses app.conf for defaults if not specified</span></div>
<div class="line">        options = self.amqp.router.route(options, name, args, kwargs)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Create the message body</span></div>
<div class="line">        message = self.amqp.create_task_message(</div>
<div class="line">            task_id <span class="keywordflow">or</span> uuid(), <span class="comment"># Generate task ID if needed</span></div>
<div class="line">            name, args, kwargs, <span class="comment"># Task details</span></div>
<div class="line">            <span class="comment"># ... other arguments like countdown, eta, expires ...</span></div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Get a producer (handles connection/channel to broker)</span></div>
<div class="line">        <span class="comment"># Uses the app&#39;s producer pool (app.producer_pool)</span></div>
<div class="line">        <span class="keyword">with</span> self.producer_or_acquire(producer) <span class="keyword">as</span> P:</div>
<div class="line">            <span class="comment"># Tell the backend we&#39;re about to send (if tracking results)</span></div>
<div class="line">            <span class="keywordflow">if</span> <span class="keywordflow">not</span> options.get(<span class="stringliteral">&#39;ignore_result&#39;</span>, <span class="keyword">False</span>):</div>
<div class="line">                 self.backend.on_task_call(P, task_id)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># Actually send the message via the producer</span></div>
<div class="line">            self.amqp.send_task_message(P, name, message, **options)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Create the AsyncResult object to return to the caller</span></div>
<div class="line">        result = self.AsyncResult(task_id)</div>
<div class="line">        <span class="comment"># ... set result properties ...</span></div>
<div class="line">        <span class="keywordflow">return</span> result</div>
</div><!-- fragment --><p>This highlights how <code>send_task</code> relies on the <code>app</code> (via <code>self</code>) to:</p><ul>
<li>Access configuration (<code>self.conf</code>).</li>
<li>Use the AMQP utilities (<code>self.amqp</code>) for routing and message creation.</li>
<li>Access the result backend (<code>self.backend</code>).</li>
<li>Get a connection/producer from the pool (<code>self.producer_or_acquire</code>).</li>
<li>Create the <code>AsyncResult</code> using the app's result class (<code>self.AsyncResult</code>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md964"></a>
Conclusion</h2>
<p>You've learned that the <code>Celery App</code> is the essential starting point for any Celery project.</p>
<ul>
<li>It acts as the central <b>headquarters</b> or <b>brain</b>.</li>
<li>You create it using <code>app = Celery(...)</code>, providing at least a name and a <code>broker</code> URL.</li>
<li>It holds <b>configuration</b> (like broker/backend URLs).</li>
<li>It <b>registers tasks</b> defined using the <code>@app.task</code> decorator.</li>
<li>It enables tasks to be <b>sent</b> to the broker using methods like <code>.delay()</code>.</li>
</ul>
<p>The app ties everything together. But how do you manage all the different settings Celery offers, beyond just the <code>broker</code> and <code>backend</code>?</p>
<p>In the next chapter, we'll dive deeper into how to configure your Celery app effectively.</p>
<p><b>Next:</b> <a class="el" href="../../d7/df5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_202__configuration.html">Chapter 2: Configuration</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
