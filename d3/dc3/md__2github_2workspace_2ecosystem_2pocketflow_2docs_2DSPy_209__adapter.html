#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 09_adapter</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/dc3/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_209__adapter.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">09_adapter</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1698"></a>
autotoc_md1698</h2>
<p>layout: default title: "Adapter" parent: "DSPy" </p>
<h2><a class="anchor" id="autotoc_md1699"></a>
nav_order: 9</h2>
<h1><a class="anchor" id="autotoc_md1700"></a>
Chapter 9: Adapter - The Universal Translator</h1>
<p>Welcome to Chapter 9! In <a class="el" href="../../dc/d0a/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_208__teleprompter______optimizer.html">Chapter 8: Teleprompter / Optimizer</a>, we saw how DSPy can automatically optimize our programs by finding better prompts or few-shot examples. We ended up with a <code>compiled_program</code> that should perform better.</p>
<p>Now, this optimized program needs to communicate with a Language Model (<a class="el" href="../../d9/db7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_205__lm____language__model__client__.html">LM</a>) to actually do its work. But here's a potential challenge: different types of LMs expect different kinds of input!</p><ul>
<li>Older <b>Completion Models</b> (like GPT-3 <code>davinci</code>) expect a single, long text prompt.</li>
<li>Newer <b>Chat Models</b> (like GPT-4, Claude 3, Llama 3 Chat) expect a structured list of messages, each with a role (like "system", "user", or "assistant").</li>
</ul>
<p>Our DSPy program, using its <a class="el" href="../../d4/dfe/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_202__signature.html">Signature</a>, defines the task in an abstract way (inputs, outputs, instructions). How does this abstract definition get translated into the specific format required by the LM we're using, especially these modern chat models?</p>
<p>That's where the <b><code>Adapter</code></b> comes in! It acts like a universal translator.</p>
<p>Think of it like this:</p><ul>
<li>Your DSPy program (using a <code>Signature</code>) has a message it wants to send to the LM.</li>
<li>The LM speaks a specific language (e.g., "chat message list" language).</li>
<li>The <code>Adapter</code> translates your program's message into the LM's language, handles the conversation, and translates the LM's reply back into a format your DSPy program understands.</li>
</ul>
<p>In this chapter, you'll learn:</p>
<ul>
<li>What problem Adapters solve.</li>
<li>What an <code>Adapter</code> does (formatting and parsing).</li>
<li>How they allow your DSPy code to work with different LMs seamlessly.</li>
<li>How they work behind the scenes (mostly automatically!).</li>
</ul>
<p>Let's meet the translator!</p>
<h2><a class="anchor" id="autotoc_md1701"></a>
The Problem: Different LMs, Different Languages</h2>
<p>Imagine you have a DSPy Signature for summarizing text:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> dspy</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Summarize(dspy.Signature):</div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;Summarize the given text.&quot;&quot;&quot;</span></div>
<div class="line">  text = dspy.InputField(desc=<span class="stringliteral">&quot;The text to summarize.&quot;</span>)</div>
<div class="line">  summary = dspy.OutputField(desc=<span class="stringliteral">&quot;A concise summary.&quot;</span>)</div>
</div><!-- fragment --><p>And you use it in a <code>dspy.Predict</code> module:</p>
<div class="fragment"><div class="line"><span class="comment"># Assume LM is configured (Chapter 5)</span></div>
<div class="line">summarizer = dspy.Predict(Summarize)</div>
<div class="line">long_text = <span class="stringliteral">&quot;DSPy is a framework for programming foundation models...&quot;</span> <span class="comment"># (imagine longer text)</span></div>
<div class="line">result = summarizer(text=long_text)</div>
<div class="line"><span class="comment"># We expect result.summary to contain the summary</span></div>
</div><!-- fragment --><p>Now, if the configured LM is a <b>completion model</b>, the <code>summarizer</code> needs to create a single prompt like:</p>
<div class="fragment"><div class="line">Summarize the given text.</div>
<div class="line"> </div>
<div class="line">---</div>
<div class="line"> </div>
<div class="line">Follow the following format.</div>
<div class="line"> </div>
<div class="line">Text: ${text}</div>
<div class="line">Summary: ${summary}</div>
<div class="line"> </div>
<div class="line">---</div>
<div class="line"> </div>
<div class="line">Text: DSPy is a framework for programming foundation models...</div>
<div class="line">Summary: </div>
</div><!-- fragment --><p>But if the configured LM is a <b>chat model</b>, it needs a structured list of messages, perhaps like this:</p>
<div class="fragment"><div class="line">[</div>
<div class="line">  {<span class="stringliteral">&quot;role&quot;</span>: <span class="stringliteral">&quot;system&quot;</span>, <span class="stringliteral">&quot;content&quot;</span>: <span class="stringliteral">&quot;Summarize the given text.\n\nFollow the following format.\n\nText: ${text}\nSummary: ${summary}&quot;</span>},</div>
<div class="line">  {<span class="stringliteral">&quot;role&quot;</span>: <span class="stringliteral">&quot;user&quot;</span>, <span class="stringliteral">&quot;content&quot;</span>: <span class="stringliteral">&quot;Text: DSPy is a framework for programming foundation models...\nSummary:&quot;</span>}</div>
<div class="line">]</div>
</div><!-- fragment --><p> <em>(Simplified - actual chat formatting can be more complex)</em></p>
<p>How does <code>dspy.Predict</code> know which format to use? And how does it extract the <code>summary</code> from the potentially differently formatted responses? It doesn't! That's the job of the <b>Adapter</b>.</p>
<h2><a class="anchor" id="autotoc_md1702"></a>
What Does an Adapter Do?</h2>
<p>An <code>Adapter</code> is a component that sits between your DSPy module (like <code>dspy.Predict</code>) and the <a class="el" href="../../d9/db7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_205__lm____language__model__client__.html">LM Client</a>. Its main tasks are:</p>
<ol type="1">
<li><b>Formatting:</b> It takes the abstract information from DSPy – the <a class="el" href="../../d4/dfe/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_202__signature.html">Signature</a> (instructions, input/output fields), any few-shot <code>demos</code> (<a class="el" href="../../dc/db9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_203__example.html">Example</a>), and the current <code>inputs</code> – and <b>formats</b> it into the specific structure the target LM expects (either a single string or a list of chat messages).</li>
<li><b>Parsing:</b> After the LM generates its response (which is usually just raw text), the <code>Adapter</code> <b>parses</b> this text to extract the values for the output fields defined in the <code>Signature</code> (like extracting the generated <code>summary</code> text).</li>
</ol>
<p>The most common adapter is the <code>dspy.adapters.ChatAdapter</code>, which is specifically designed to translate between the DSPy format and the message list format expected by chat models.</p>
<h2><a class="anchor" id="autotoc_md1703"></a>
Why Use Adapters? Flexibility!</h2>
<p>The main benefit of using Adapters is <b>flexibility</b>.</p>
<ul>
<li><b>Write Once, Run Anywhere:</b> Your core DSPy program logic (your <code>Module</code>s, <code>Program</code>s, and <code>Signature</code>s) remains the same regardless of whether you're using a completion LM or a chat LM.</li>
<li><b>Easy Switching:</b> You can switch the underlying <a class="el" href="../../d9/db7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_205__lm____language__model__client__.html">LM Client</a> (e.g., from OpenAI GPT-3 to Anthropic Claude 3) in <code>dspy.settings</code>, and the appropriate Adapter (usually the default <code>ChatAdapter</code>) handles the communication differences automatically.</li>
<li><b>Standard Interface:</b> Adapters ensure that modules like <code>dspy.Predict</code> have a consistent way to interact with LMs, hiding the complexities of different API formats.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1704"></a>
How Adapters Work: Format and Parse</h2>
<p>Let's look conceptually at what the <code>ChatAdapter</code> does:</p>
<p><b>1. Formatting (<code>format</code> method):</b></p>
<p>Imagine calling our <code>summarizer</code> with one demo example:</p>
<div class="fragment"><div class="line"><span class="comment"># Demo example</span></div>
<div class="line">demo = dspy.Example(</div>
<div class="line">    text=<span class="stringliteral">&quot;Long article about cats.&quot;</span>,</div>
<div class="line">    summary=<span class="stringliteral">&quot;Cats are popular pets.&quot;</span></div>
<div class="line">).with_inputs(<span class="stringliteral">&quot;text&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Call the summarizer with the demo</span></div>
<div class="line">result = summarizer(text=long_text, demos=[demo])</div>
</div><!-- fragment --><p>The <code>ChatAdapter</code>'s <code>format</code> method might take the <code>Summarize</code> signature, the <code>demo</code>, and the <code>long_text</code> input and produce a list of messages like this:</p>
<div class="fragment"><div class="line"><span class="comment"># Conceptual Output of ChatAdapter.format()</span></div>
<div class="line">[</div>
<div class="line">  <span class="comment"># 1. System message from Signature instructions</span></div>
<div class="line">  {<span class="stringliteral">&quot;role&quot;</span>: <span class="stringliteral">&quot;system&quot;</span>, <span class="stringliteral">&quot;content&quot;</span>: <span class="stringliteral">&quot;Summarize the given text.\n\n---\n\nFollow the following format.\n\nText: ${text}\nSummary: ${summary}\n\n---\n\n&quot;</span>},</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># 2. User turn for the demo input</span></div>
<div class="line">  {<span class="stringliteral">&quot;role&quot;</span>: <span class="stringliteral">&quot;user&quot;</span>, <span class="stringliteral">&quot;content&quot;</span>: <span class="stringliteral">&quot;Text: Long article about cats.\nSummary:&quot;</span>},</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># 3. Assistant turn for the demo output</span></div>
<div class="line">  {<span class="stringliteral">&quot;role&quot;</span>: <span class="stringliteral">&quot;assistant&quot;</span>, <span class="stringliteral">&quot;content&quot;</span>: <span class="stringliteral">&quot;Summary: Cats are popular pets.&quot;</span>}, <span class="comment"># (Might use special markers like [[ ## Summary ## ]])</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment"># 4. User turn for the actual input</span></div>
<div class="line">  {<span class="stringliteral">&quot;role&quot;</span>: <span class="stringliteral">&quot;user&quot;</span>, <span class="stringliteral">&quot;content&quot;</span>: <span class="stringliteral">&quot;Text: DSPy is a framework for programming foundation models...\nSummary:&quot;</span>}</div>
<div class="line">]</div>
</div><!-- fragment --><p> <em>(Note: <code>ChatAdapter</code> uses specific markers like <code>[[ ## field_name ## ]]</code> to clearly separate fields in the content, making parsing easier)</em></p>
<p>This message list is then passed to the chat-based LM Client.</p>
<p><b>2. Parsing (<code>parse</code> method):</b></p>
<p>The chat LM responds, likely mimicking the format. Its response might be a string like:</p>
<div class="fragment"><div class="line">[[ ## summary ## ]]</div>
<div class="line">DSPy helps build and optimize language model pipelines.</div>
</div><!-- fragment --><p>The <code>ChatAdapter</code>'s <code>parse</code> method takes this string. It looks for the markers (<code>[[ ## summary ## ]]</code>) defined by the <code>Summarize</code> signature's output fields. It extracts the content associated with each marker and returns a dictionary:</p>
<div class="fragment"><div class="line"><span class="comment"># Conceptual Output of ChatAdapter.parse()</span></div>
<div class="line">{</div>
<div class="line">  <span class="stringliteral">&quot;summary&quot;</span>: <span class="stringliteral">&quot;DSPy helps build and optimize language model pipelines.&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p> This dictionary is then packaged into the <code>dspy.Prediction</code> object (as <code>result.summary</code>) that your <code>summarizer</code> module returns.</p>
<h2><a class="anchor" id="autotoc_md1705"></a>
Using Adapters (It's Often Automatic!)</h2>
<p>The good news is that you usually don't interact with Adapters directly. Modules like <code>dspy.Predict</code> are designed to use the currently configured adapter automatically.</p>
<p>DSPy sets a default adapter (usually <code>ChatAdapter</code>) in its global <code>dspy.settings</code>. When you configure your <a class="el" href="../../d9/db7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_205__lm____language__model__client__.html">LM Client</a> like this:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> dspy</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Configure LM (Chapter 5)</span></div>
<div class="line"><span class="comment"># turbo = dspy.LM(model=&#39;openai/gpt-3.5-turbo&#39;)</span></div>
<div class="line"><span class="comment"># dspy.settings.configure(lm=turbo)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Default Adapter (ChatAdapter) is usually active automatically!</span></div>
<div class="line"><span class="comment"># You typically DON&#39;T need to configure it unless you want a different one.</span></div>
<div class="line"><span class="comment"># dspy.settings.configure(adapter=dspy.adapters.ChatAdapter())</span></div>
</div><!-- fragment --><p>Now, when you use <code>dspy.Predict</code> or other modules that call LMs, they will internally use <code>dspy.settings.adapter</code> (the <code>ChatAdapter</code> in this case) to handle the formatting and parsing needed to talk to the configured <code>dspy.settings.lm</code> (<code>turbo</code>).</p>
<div class="fragment"><div class="line"><span class="comment"># The summarizer automatically uses the configured LM and Adapter</span></div>
<div class="line">summarizer = dspy.Predict(Summarize)</div>
<div class="line">result = summarizer(text=long_text) <span class="comment"># Adapter works its magic here!</span></div>
<div class="line">print(result.summary)</div>
</div><!-- fragment --><p>You write your DSPy code at a higher level of abstraction, and the Adapter handles the translation details for you.</p>
<h2><a class="anchor" id="autotoc_md1706"></a>
How It Works Under the Hood</h2>
<p>Let's trace the flow when <code>summarizer(text=long_text)</code> is called, assuming a chat LM and the <code>ChatAdapter</code> are configured:</p>
<ol type="1">
<li><b><code>Predict.__call__</code>:</b> The <code>summarizer</code> (<code>dspy.Predict</code>) instance is called.</li>
<li><b>Get Components:</b> It retrieves the <code>Signature</code> (<code>Summarize</code>), <code>demos</code>, <code>inputs</code> (<code>text</code>), the configured <code>LM</code> client, and the configured <code>Adapter</code> (e.g., <code>ChatAdapter</code>) from <code>dspy.settings</code>.</li>
<li><b><code>Adapter.__call__</code>:</b> <code>Predict</code> calls the <code>Adapter</code> instance, passing it the LM, signature, demos, and inputs.</li>
<li><b><code>Adapter.format</code>:</b> The <code>Adapter</code>'s <code>__call__</code> method first calls its own <code>format</code> method. <code>ChatAdapter.format</code> generates the list of chat messages (system prompt, demo turns, final user turn).</li>
<li><b><code>LM.__call__</code>:</b> The <code>Adapter</code>'s <code>__call__</code> method then passes the formatted messages to the <code>LM</code> client instance (e.g., <code>turbo(messages=...)</code>).</li>
<li><b>API Call:</b> The <code>LM</code> client sends the messages to the actual LM API (e.g., OpenAI API).</li>
<li><b>API Response:</b> The LM API returns the generated completion text (e.g., <code>[[ ## summary ## ]]\nDSPy helps...</code>).</li>
<li><b><code>LM.__call__</code> Returns:</b> The <code>LM</code> client returns the raw completion string(s) back to the <code>Adapter</code>.</li>
<li><b><code>Adapter.parse</code>:</b> The <code>Adapter</code>'s <code>__call__</code> method calls its own <code>parse</code> method with the completion string. <code>ChatAdapter.parse</code> extracts the content based on the <code>[[ ## ... ## ]]</code> markers and the <code>Signature</code>'s output fields.</li>
<li><b><code>Adapter.__call__</code> Returns:</b> The <code>Adapter</code> returns a list of dictionaries, each representing a parsed completion (e.g., &lsquo;[{'summary&rsquo;: 'DSPy helps...'}]<code>).</code></li>
<li><code>**</code>Predict.__call__<code>Returns:**</code>Predict<code>packages these parsed dictionaries into</code>dspy.Prediction` objects and returns the result.</li>
</ol>
<p>Here's a simplified sequence diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant PredictMod as dspy.Predict (summarizer)</div>
<div class="line">    participant Adapter as Adapter (e.g., ChatAdapter)</div>
<div class="line">    participant LMClient as LM Client (e.g., turbo)</div>
<div class="line">    participant LMApi as Actual LM API</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;PredictMod: Call summarizer(text=...)</div>
<div class="line">    PredictMod-&gt;&gt;Adapter: __call__(lm=LMClient, signature, demos, inputs)</div>
<div class="line">    Adapter-&gt;&gt;Adapter: format(signature, demos, inputs)</div>
<div class="line">    Adapter--&gt;&gt;Adapter: Return formatted_messages (list)</div>
<div class="line">    Adapter-&gt;&gt;LMClient: __call__(messages=formatted_messages)</div>
<div class="line">    LMClient-&gt;&gt;LMApi: Send API Request</div>
<div class="line">    LMApi--&gt;&gt;LMClient: Return raw_completion_text</div>
<div class="line">    LMClient--&gt;&gt;Adapter: Return raw_completion_text</div>
<div class="line">    Adapter-&gt;&gt;Adapter: parse(signature, raw_completion_text)</div>
<div class="line">    Adapter--&gt;&gt;Adapter: Return parsed_output (dict)</div>
<div class="line">    Adapter--&gt;&gt;PredictMod: Return list[parsed_output]</div>
<div class="line">    PredictMod-&gt;&gt;PredictMod: Create Prediction object(s)</div>
<div class="line">    PredictMod--&gt;&gt;User: Return Prediction object(s)</div>
</div><!-- fragment --><p><b>Relevant Code Files:</b></p>
<ul>
<li><code>dspy/adapters/base.py</code>: Defines the abstract <code>Adapter</code> class.<ul>
<li>Requires subclasses to implement <code>format</code> and <code>parse</code>.</li>
<li>The <code>__call__</code> method orchestrates the format -&gt; LM call -&gt; parse sequence.</li>
</ul>
</li>
<li><code>dspy/adapters/chat_adapter.py</code>: Defines <code>ChatAdapter</code>, the default implementation.<ul>
<li><code>format</code>: Implements logic to create the system/user/assistant message list, using <code>[[ ## ... ## ]]</code> markers. Includes helper functions like <code>format_turn</code> and <code>prepare_instructions</code>.</li>
<li><code>parse</code>: Implements logic to find the <code>[[ ## ... ## ]]</code> markers in the LM's output string and extract the corresponding values.</li>
</ul>
</li>
<li><code>dspy/predict/predict.py</code>: The <code>Predict</code> module's <code>forward</code> method retrieves the adapter from <code>dspy.settings</code> and calls it.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># Simplified view from dspy/adapters/base.py</span></div>
<div class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</div>
<div class="line"><span class="comment"># ... other imports ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Adapter(ABC):</div>
<div class="line">    <span class="comment"># ... init ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># The main orchestration method</span></div>
<div class="line">    <span class="keyword">def </span>__call__(</div>
<div class="line">        self,</div>
<div class="line">        lm: <span class="stringliteral">&quot;LM&quot;</span>,</div>
<div class="line">        lm_kwargs: dict[str, Any],</div>
<div class="line">        signature: Type[Signature],</div>
<div class="line">        demos: list[dict[str, Any]],</div>
<div class="line">        inputs: dict[str, Any],</div>
<div class="line">    ) -&gt; list[dict[str, Any]]:</div>
<div class="line">        <span class="comment"># 1. Format the inputs for the LM</span></div>
<div class="line">        <span class="comment">#    Returns either a string or list[dict] (for chat)</span></div>
<div class="line">        formatted_input = self.format(signature, demos, inputs)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Prepare arguments for the LM call</span></div>
<div class="line">        lm_call_args = dict(prompt=formatted_input) <span class="keywordflow">if</span> isinstance(formatted_input, str) <span class="keywordflow">else</span> dict(messages=formatted_input)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 2. Call the Language Model Client</span></div>
<div class="line">        outputs = lm(**lm_call_args, **lm_kwargs) <span class="comment"># Returns list of strings or dicts</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 3. Parse the LM outputs</span></div>
<div class="line">        parsed_values = []</div>
<div class="line">        <span class="keywordflow">for</span> output <span class="keywordflow">in</span> outputs:</div>
<div class="line">            <span class="comment"># Extract raw text (simplified)</span></div>
<div class="line">            raw_text = output <span class="keywordflow">if</span> isinstance(output, str) <span class="keywordflow">else</span> output[<span class="stringliteral">&quot;text&quot;</span>]</div>
<div class="line">            <span class="comment"># Parse the raw text based on the signature</span></div>
<div class="line">            value = self.parse(signature, raw_text)</div>
<div class="line">            <span class="comment"># Validate fields (simplified)</span></div>
<div class="line">            <span class="comment"># ...</span></div>
<div class="line">            parsed_values.append(value)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> parsed_values</div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@abstractmethod</span></div>
<div class="line">    <span class="keyword">def </span>format(self, signature, demos, inputs) -&gt; list[dict[str, Any]] | str:</div>
<div class="line">        <span class="comment"># Subclasses must implement this to format input for the LM</span></div>
<div class="line">        <span class="keywordflow">raise</span> NotImplementedError</div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@abstractmethod</span></div>
<div class="line">    <span class="keyword">def </span>parse(self, signature: Type[Signature], completion: str) -&gt; dict[str, Any]:</div>
<div class="line">        <span class="comment"># Subclasses must implement this to parse the LM&#39;s output string</span></div>
<div class="line">        <span class="keywordflow">raise</span> NotImplementedError</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... other helper methods (format_fields, format_turn, etc.) ...</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># Simplified view from dspy/adapters/chat_adapter.py</span></div>
<div class="line"><span class="comment"># ... imports ...</span></div>
<div class="line"><span class="keyword">import</span> re</div>
<div class="line"> </div>
<div class="line">field_header_pattern = re.compile(<span class="stringliteral">r&quot;\[\[ ## (\w+) ## \]\]&quot;</span>) <span class="comment"># Matches [[ ## field_name ## ]]</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ChatAdapter(Adapter):</div>
<div class="line">    <span class="comment"># ... init ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>format(self, signature, demos, inputs) -&gt; list[dict[str, Any]]:</div>
<div class="line">        messages = []</div>
<div class="line">        <span class="comment"># 1. Create system message from signature instructions</span></div>
<div class="line">        <span class="comment">#    (Uses helper `prepare_instructions`)</span></div>
<div class="line">        prepared_instructions = prepare_instructions(signature)</div>
<div class="line">        messages.append({<span class="stringliteral">&quot;role&quot;</span>: <span class="stringliteral">&quot;system&quot;</span>, <span class="stringliteral">&quot;content&quot;</span>: prepared_instructions})</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 2. Format demos into user/assistant turns</span></div>
<div class="line">        <span class="comment">#    (Uses helper `format_turn`)</span></div>
<div class="line">        <span class="keywordflow">for</span> demo <span class="keywordflow">in</span> demos:</div>
<div class="line">            messages.append(self.format_turn(signature, demo, role=<span class="stringliteral">&quot;user&quot;</span>))</div>
<div class="line">            messages.append(self.format_turn(signature, demo, role=<span class="stringliteral">&quot;assistant&quot;</span>))</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 3. Format final input into a user turn</span></div>
<div class="line">        <span class="comment">#    (Handles chat history if present, uses `format_turn`)</span></div>
<div class="line">        <span class="comment"># ... logic for chat history or simple input ...</span></div>
<div class="line">        messages.append(self.format_turn(signature, inputs, role=<span class="stringliteral">&quot;user&quot;</span>))</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Expand image tags if needed</span></div>
<div class="line">        messages = try_expand_image_tags(messages)</div>
<div class="line">        <span class="keywordflow">return</span> messages</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>parse(self, signature: Type[Signature], completion: str) -&gt; dict[str, Any]:</div>
<div class="line">        <span class="comment"># Logic to split completion string by [[ ## field_name ## ]] markers</span></div>
<div class="line">        <span class="comment"># Finds matches using `field_header_pattern`</span></div>
<div class="line">        sections = self._split_completion_by_markers(completion)</div>
<div class="line"> </div>
<div class="line">        fields = {}</div>
<div class="line">        <span class="keywordflow">for</span> field_name, field_content <span class="keywordflow">in</span> sections:</div>
<div class="line">            <span class="keywordflow">if</span> field_name <span class="keywordflow">in</span> signature.output_fields:</div>
<div class="line">                <span class="keywordflow">try</span>:</div>
<div class="line">                    <span class="comment"># Use helper `parse_value` to cast string to correct type</span></div>
<div class="line">                    fields[field_name] = parse_value(field_content, signature.output_fields[field_name].annotation)</div>
<div class="line">                <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">                    <span class="comment"># Handle parsing errors</span></div>
<div class="line">                    <span class="comment"># ...</span></div>
<div class="line">                    <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Check if all expected output fields were found</span></div>
<div class="line">        <span class="comment"># ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> fields</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... helper methods: format_turn, format_fields, _split_completion_by_markers ...</span></div>
</div><!-- fragment --><p>The key takeaway is that <code>Adapter</code> subclasses provide concrete implementations for <code>format</code> (DSPy -&gt; LM format) and <code>parse</code> (LM output -&gt; DSPy format), enabling smooth communication.</p>
<h2><a class="anchor" id="autotoc_md1707"></a>
Conclusion</h2>
<p>You've now met the <b><code>Adapter</code></b>, DSPy's universal translator!</p>
<ul>
<li>Adapters solve the problem of <b>different LMs expecting different input formats</b> (e.g., completion prompts vs. chat messages).</li>
<li>They act as a bridge, <b>formatting</b> DSPy's abstract <a class="el" href="../../d4/dfe/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_202__signature.html">Signature</a>, demos, and inputs into the LM-specific format, and <b>parsing</b> the LM's raw output back into structured DSPy data.</li>
<li>The primary benefit is <b>flexibility</b>, allowing you to use the same DSPy program with various LM types without changing your core logic.</li>
<li>Adapters like <code>ChatAdapter</code> usually work <b>automatically</b> behind the scenes, configured via <code>dspy.settings</code>.</li>
</ul>
<p>With Adapters handling the translation, LM Clients providing the connection, and RMs fetching knowledge, we have a powerful toolkit. But how do we manage all these configurations globally? That's the role of <code>dspy.settings</code>.</p>
<p><b>Next:</b> <a class="el" href="../../d6/ddc/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_210__settings.html">Chapter 10: Settings</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
