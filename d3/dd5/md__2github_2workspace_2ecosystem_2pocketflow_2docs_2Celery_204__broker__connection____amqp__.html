#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_broker_connection__amqp_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/dd5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_204__broker__connection____amqp__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_broker_connection__amqp_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1036"></a>
autotoc_md1036</h2>
<p>layout: default title: "Broker Connection (AMQP)" parent: "Celery" </p>
<h2><a class="anchor" id="autotoc_md1037"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md1038"></a>
Chapter 4: Broker Connection (AMQP) - Celery's Postal Service</h1>
<p>In <a class="el" href="../../d5/db8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_203__task.html">Chapter 3: Task</a>, we learned how to define "job descriptions" (Tasks) like <code>add(x, y)</code> and how to request them using <code>.delay()</code>. But when you call <code>add.delay(2, 2)</code>, how does that request actually <em>get</em> to a worker process that can perform the addition? It doesn't just magically appear!</p>
<p>This is where the <b>Broker Connection</b> comes in. Think of it as Celery's built-in postal service.</p>
<h2><a class="anchor" id="autotoc_md1039"></a>
What Problem Does the Broker Connection Solve?</h2>
<p>Imagine you want to send a letter (a task request) to a friend (a worker) who lives in another city. You can't just shout the message out your window and hope they hear it. You need:</p>
<ol type="1">
<li>A <b>Post Office</b> (the Message Broker, like RabbitMQ or Redis) that handles mail.</li>
<li>A way to <b>talk to the Post Office</b> (the Broker Connection) to drop off your letter or pick up mail addressed to you.</li>
</ol>
<p>The Broker Connection is that crucial link between your application (where you call <code>.delay()</code>) or your Celery worker and the message broker system. It manages sending messages <em>to</em> the broker and receiving messages <em>from</em> the broker reliably.</p>
<p>Without this connection, your task requests would never leave your application, and your workers would never know there's work waiting for them.</p>
<h2><a class="anchor" id="autotoc_md1040"></a>
Key Concepts: Post Office &amp; Rules</h2>
<p>Let's break down the pieces:</p>
<ol type="1">
<li><b>The Message Broker (The Post Office):</b> This is a separate piece of software that acts as a central hub for messages. Common choices are RabbitMQ and Redis. You tell Celery its address using the <code>broker_url</code> setting in your <a class="el" href="../../d7/df5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_202__configuration.html">Configuration</a>. <code>python @section autotoc_md1041 From Chapter 2 - celeryconfig.py broker_url = 'amqp://guest:guest@localhost:5672//' # Example for RabbitMQ @section autotoc_md1042 Or maybe: broker_url = 'redis://localhost:6379/0' # Example for Redis </code></li>
<li><b>The Connection (Talking to the Staff):</b> This is the active communication channel established between your Python code (either your main app or a worker) and the broker. It's like having an open phone line to the post office. Celery, using a library called <code>kombu</code>, handles creating and managing these connections based on the <code>broker_url</code>.</li>
<li><b>AMQP (The Postal Rules):</b> AMQP stands for <b>Advanced Message Queuing Protocol</b>. Think of it as a specific set of rules and procedures for how post offices should operate â€“ how letters should be addressed, sorted, delivered, and confirmed.<ul>
<li>RabbitMQ is a broker that speaks AMQP natively.</li>
<li>Other brokers, like Redis, use different protocols (their own set of rules).</li>
<li><b>Why mention AMQP?</b> It's a very common and powerful protocol for message queuing, and the principles behind it (exchanges, queues, routing) are fundamental to how Celery routes tasks, even when using other brokers. Celery's internal component for handling this communication is often referred to as <code>app.amqp</code> (found in <code>app/amqp.py</code>), even though the underlying library (<code>kombu</code>) supports multiple protocols. So, we focus on the <em>concept</em> of managing the broker connection, often using AMQP terminology as a reference point.</li>
</ul>
</li>
<li><b>Producer (Sending Mail):</b> When your application calls <code>add.delay(2, 2)</code>, it acts as a <em>producer</em>. It uses its broker connection to send a message ("Please run 'add' with arguments (2, 2)") to the broker.</li>
<li><b>Consumer (Receiving Mail):</b> A Celery <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a> acts as a <em>consumer</em>. It uses its <em>own</em> broker connection to constantly check a specific mailbox (queue) at the broker for new messages. When it finds one, it takes it, performs the task, and tells the broker it's done.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1043"></a>
How Sending a Task Uses the Connection</h2>
<p>Let's revisit sending a task from <a class="el" href="../../d5/db8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_203__task.html">Chapter 3: Task</a>:</p>
<div class="fragment"><div class="line"><span class="comment"># run_tasks.py (simplified)</span></div>
<div class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> add</div>
<div class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app <span class="comment"># Assume app is configured with a broker_url</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 1. You call .delay()</span></div>
<div class="line">print(<span class="stringliteral">&quot;Sending task...&quot;</span>)</div>
<div class="line">result_promise = add.delay(2, 2)</div>
<div class="line"><span class="comment"># Behind the scenes:</span></div>
<div class="line"><span class="comment"># a. Celery looks at the &#39;add&#39; task, finds its associated &#39;app&#39;.</span></div>
<div class="line"><span class="comment"># b. It asks &#39;app&#39; for the broker_url from its configuration.</span></div>
<div class="line"><span class="comment"># c. It uses the app.amqp component (powered by Kombu) to get a connection</span></div>
<div class="line"><span class="comment">#    to the broker specified by the URL (e.g., &#39;amqp://localhost...&#39;).</span></div>
<div class="line"><span class="comment"># d. It packages the task name &#39;tasks.add&#39; and args (2, 2) into a message.</span></div>
<div class="line"><span class="comment"># e. It uses the connection to &#39;publish&#39; (send) the message to the broker.</span></div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Task sent! ID: {result_promise.id}&quot;</span>)</div>
</div><!-- fragment --><p>The <code>add.delay(2, 2)</code> call triggers this whole process. It needs the configured <code>broker_url</code> to know <em>which</em> post office to connect to, and the broker connection handles the actual sending of the "letter" (task message).</p>
<p>Similarly, a running Celery <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a> establishes its own connection to the <em>same</em> broker. It uses this connection to <em>listen</em> for incoming messages on the queues it's assigned to.</p>
<h2><a class="anchor" id="autotoc_md1044"></a>
How It Works Internally (Simplified)</h2>
<p>Celery uses a powerful library called <b>Kombu</b> to handle the low-level details of connecting and talking to different types of brokers (RabbitMQ, Redis, etc.). The <code>app.amqp</code> object in Celery acts as a high-level interface to Kombu's features.</p>
<ol type="1">
<li><b>Configuration:</b> The <code>broker_url</code> tells Kombu where and how to connect.</li>
<li><b>Connection Pool:</b> To be efficient, Celery (via Kombu) often maintains a <em>pool</em> of connections. When you send a task, it might grab an existing, idle connection from the pool instead of creating a new one every time. This is faster. You can see this managed by <code>app.producer_pool</code> in <code>app/base.py</code>.</li>
<li><b>Producer:</b> When <code>task.delay()</code> is called, it ultimately uses a <code>kombu.Producer</code> object. This object represents the ability to <em>send</em> messages. It's tied to a specific connection and channel.</li>
<li><b>Publishing:</b> The producer's <code>publish()</code> method is called. This takes the task message (already serialized into a format like JSON), specifies the destination (exchange and routing key - think of these like the address and sorting code on an envelope), and sends it over the connection to the broker.</li>
<li><b>Consumer:</b> A Worker uses a <code>kombu.Consumer</code> object. This object is set up to listen on specific queues via its connection. When a message arrives in one of those queues, the broker pushes it to the consumer over the connection, and the consumer triggers the appropriate Celery task execution logic.</li>
</ol>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client as Your App Code</div>
<div class="line">    participant Task as add.delay()</div>
<div class="line">    participant App as Celery App</div>
<div class="line">    participant AppAMQP as app.amqp (Kombu Interface)</div>
<div class="line">    participant Broker as RabbitMQ / Redis</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;Task: Call add.delay(2, 2)</div>
<div class="line">    Task-&gt;&gt;App: Get broker config (broker_url)</div>
<div class="line">    App--&gt;&gt;Task: broker_url</div>
<div class="line">    Task-&gt;&gt;App: Ask to send task &#39;tasks.add&#39;</div>
<div class="line">    App-&gt;&gt;AppAMQP: Send task message(&#39;tasks.add&#39;, (2, 2), ...)</div>
<div class="line">    Note over AppAMQP: Gets connection/producer (maybe from pool)</div>
<div class="line">    AppAMQP-&gt;&gt;Broker: publish(message, routing_info) via Connection</div>
<div class="line">    Broker--&gt;&gt;AppAMQP: Acknowledge message received</div>
<div class="line">    AppAMQP--&gt;&gt;App: Message sent successfully</div>
<div class="line">    App--&gt;&gt;Task: Return AsyncResult</div>
<div class="line">    Task--&gt;&gt;Client: Return AsyncResult</div>
</div><!-- fragment --><p>This shows the flow: your code calls <code>.delay()</code>, Celery uses its configured connection details (<code>app.amqp</code> layer) to get a connection and producer, and then publishes the message to the broker.</p>
<h2><a class="anchor" id="autotoc_md1045"></a>
Code Dive: Sending a Message</h2>
<p>Let's peek inside <code>app/amqp.py</code> where the <code>AMQP</code> class orchestrates sending. The <code>send_task_message</code> method (simplified below) is key.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified from app/amqp.py within the AMQP class</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># This function is configured internally and gets called by app.send_task</span></div>
<div class="line"><span class="keyword">def </span>_create_task_sender(self):</div>
<div class="line">    <span class="comment"># ... (lots of setup: getting defaults from config, signals) ...</span></div>
<div class="line">    default_serializer = self.app.conf.task_serializer</div>
<div class="line">    default_compressor = self.app.conf.task_compression</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>send_task_message(producer, name, message,</div>
<div class="line">                          exchange=None, routing_key=None, queue=None,</div>
<div class="line">                          serializer=None, compression=None, declare=None,</div>
<div class="line">                          retry=None, retry_policy=None,</div>
<div class="line">                           **properties):</div>
<div class="line">        <span class="comment"># ... (Determine exchange, routing_key, queue based on config/options) ...</span></div>
<div class="line">        <span class="comment"># ... (Prepare headers, properties, handle retries) ...</span></div>
<div class="line"> </div>
<div class="line">        headers, properties, body, sent_event = message <span class="comment"># Unpack the prepared message tuple</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># The core action: Use the producer to publish the message!</span></div>
<div class="line">        ret = producer.publish(</div>
<div class="line">            body, <span class="comment"># The actual task payload (args, kwargs, etc.)</span></div>
<div class="line">            exchange=exchange,</div>
<div class="line">            routing_key=routing_key,</div>
<div class="line">            serializer=serializer <span class="keywordflow">or</span> default_serializer, <span class="comment"># e.g., &#39;json&#39;</span></div>
<div class="line">            compression=compression <span class="keywordflow">or</span> default_compressor,</div>
<div class="line">            retry=retry,</div>
<div class="line">            retry_policy=retry_policy,</div>
<div class="line">            declare=declare, <span class="comment"># Maybe declare queues/exchanges if needed</span></div>
<div class="line">            headers=headers,</div>
<div class="line">            **properties <span class="comment"># Other message properties (correlation_id, etc.)</span></div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># ... (Send signals like task_sent, publish events if configured) ...</span></div>
<div class="line">        <span class="keywordflow">return</span> ret</div>
<div class="line">    <span class="keywordflow">return</span> send_task_message</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>This function takes a <code>producer</code> object (which is linked to a broker connection via Kombu).</li>
<li>It figures out the final destination details (exchange, routing key).</li>
<li>It calls <code>producer.publish()</code>, passing the task body and all the necessary options (like serializer). This is the function that actually sends the data over the network connection to the broker.</li>
</ul>
<p>The <code>Connection</code> objects themselves are managed by Kombu (see <code>kombu/connection.py</code>). Celery uses these objects via its <code>app.connection_for_write()</code> or <code>app.connection_for_read()</code> methods, which often pull from the connection pool (<code>kombu.pools</code>).</p>
<h2><a class="anchor" id="autotoc_md1046"></a>
Conclusion</h2>
<p>The Broker Connection is Celery's vital communication link, its "postal service."</p>
<ul>
<li>It connects your application and workers to the <b>Message Broker</b> (like RabbitMQ or Redis).</li>
<li>It uses the <code>broker_url</code> from your <a class="el" href="../../d7/df5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_202__configuration.html">Configuration</a> to know where to connect.</li>
<li>Protocols like <b>AMQP</b> define the "rules" for communication, although Celery's underlying library (Kombu) handles various protocols.</li>
<li>Your app <b>produces</b> task messages and sends them over the connection.</li>
<li>Workers <b>consume</b> task messages received over their connection.</li>
<li>Celery manages connections efficiently, often using <b>pools</b>.</li>
</ul>
<p>Understanding the broker connection helps clarify how tasks move from where they're requested to where they run. Now that we know how tasks are defined and sent across the wire, let's look at the entity that actually picks them up and does the work.</p>
<p><b>Next:</b> <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Chapter 5: Worker</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
