#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 08___array_function___protocol___overrides___overrides__</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/d50/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_208______array__function______7b60f447b25b704c1d1f35f0473e9579.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">08___array_function___protocol___overrides___overrides__</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2596"></a>
autotoc_md2596</h2>
<p>layout: default title: "__array_function__ Protocol (overrides)" parent: "NumPy Core" </p>
<h2><a class="anchor" id="autotoc_md2597"></a>
nav_order: 8</h2>
<h1><a class="anchor" id="autotoc_md2598"></a>
Chapter 8: <b>array_function</b> Protocol / Overrides (<code>overrides</code>)</h1>
<p>Welcome to the final chapter of our NumPy Core exploration! In <a class="el" href="../../d0/db5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_207__umath__module.html">Chapter 7: umath Module</a>, we learned how NumPy implements its fast, element-wise mathematical functions (<code>ufuncs</code>) using optimized C code. We've seen the core components: the <code>ndarray</code> container, <code>dtype</code> descriptions, <code>ufunc</code> operations, numeric types, printing, and the C modules (<code>multiarray</code>, <code>umath</code>) that power them.</p>
<p>But NumPy doesn't exist in isolation. The Python scientific ecosystem is full of other libraries that also work with array-like data. Think of libraries like Dask (for parallel computing on large datasets that don't fit in memory) or CuPy (for running NumPy-like operations on GPUs). How can these <em>different</em> types of arrays work smoothly with standard NumPy functions like <code>np.sum</code>, <code>np.mean</code>, or <code>np.concatenate</code>?</p>
<h2><a class="anchor" id="autotoc_md2599"></a>
What Problem Does <code>__array_function__</code> Solve? Speaking NumPy's Language</h2>
<p>Imagine you have a special type of array, maybe one that lives on a GPU (like a CuPy array) or one that represents a computation spread across many machines (like a Dask array). You want to calculate the sum of its elements.</p>
<p>Ideally, you'd just write:</p>
<div class="fragment"><div class="line"><span class="comment"># Assume &#39;my_special_array&#39; is an instance of a custom array type</span></div>
<div class="line"><span class="comment"># (e.g., from CuPy or Dask)</span></div>
<div class="line">result = np.sum(my_special_array)</div>
</div><!-- fragment --><p>But wait, <code>np.sum</code> is a NumPy function, designed primarily for NumPy's <code>ndarray</code> (<a class="el" href="../../de/d16/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_201__ndarray____n__dimensional__array__.html">Chapter 1: ndarray (N-dimensional array)</a>). How can it possibly know how to sum elements on a GPU or coordinate a distributed calculation?</p>
<p>Before the <code>__array_function__</code> protocol, this was tricky. Either the library (like CuPy) had to provide its <em>own</em> complete set of functions (<code>cupy.sum</code>), or NumPy would have needed specific code to handle every possible external array type, which is impossible to maintain.</p>
<p>We need a way for NumPy functions to ask the input objects: "Hey, do *you* know how to handle this operation (`np.sum` in this case)?" If the object says yes, NumPy can step back and let the object take control.</p>
<p>This is exactly what the <code>__array_function__</code> protocol (defined in NEP-18) allows. It's like a common language or negotiation rule that lets different array libraries "override" or take over the execution of NumPy functions when their objects are involved.</p>
<p><b>Analogy:</b> Think of NumPy functions as a universal remote control. Initially, it only knows how to control NumPy-brand TVs (<code>ndarray</code>s). The <code>__array_function__</code> protocol is like adding a feature where the remote, when pointed at a different brand TV (like a CuPy array), asks the TV: "Do you understand this button (e.g., 'sum')?" If the TV responds, "Yes, here's how I do 'sum'," the remote lets the TV handle it.</p>
<h2><a class="anchor" id="autotoc_md2600"></a>
What is the <code>__array_function__</code> Protocol?</h2>
<p>The <code>__array_function__</code> protocol is a special method that array-like objects can implement. When a NumPy function is called with arguments that include one or more objects defining <code>__array_function__</code>, NumPy follows these steps:</p>
<ol type="1">
<li><b>Check Arguments:</b> NumPy looks at all the input arguments passed to the function (e.g., <code>np.sum(my_array, axis=0)</code>).</li>
<li><b>Find Overrides:</b> It identifies which arguments have an <code>__array_function__</code> method.</li>
<li><b>Prioritize:</b> It sorts these arguments based on a special attribute (<code>__array_priority__</code>) or by their position in the function call if priorities are equal. Subclasses are also considered.</li>
<li><b>Negotiate:</b> It calls the <code>__array_function__</code> method of the highest-priority object. It passes two key pieces of information to this method:<ul>
<li>The original NumPy function object itself (e.g., <code>np.sum</code>).</li>
<li>The arguments (<code>*args</code>) and keyword arguments (<code>**kwargs</code>) that were originally passed to the NumPy function.</li>
</ul>
</li>
<li><b>Delegate:</b> The object's <code>__array_function__</code> method now has control. It can:<ul>
<li>Handle the operation itself (e.g., perform a GPU sum if it's a CuPy array) and return the result.</li>
<li>Decide it <em>cannot</em> handle this specific function or combination of arguments and return a special value <code>NotImplemented</code>. In this case, NumPy tries the <code>__array_function__</code> method of the <em>next</em> highest-priority object.</li>
<li>Potentially call the original NumPy function on converted inputs if needed.</li>
</ul>
</li>
<li><b>Fallback:</b> If <em>no</em> object's <code>__array_function__</code> method handles the call (they all return <code>NotImplemented</code>), NumPy raises a <code>TypeError</code>. <em>Crucially, NumPy usually does NOT fall back to its own default implementation on the foreign objects unless explicitly told to by the override.</em></li>
</ol>
<h2><a class="anchor" id="autotoc_md2601"></a>
Using <code>__array_function__</code> (Implementing a Simple Override)</h2>
<p>Let's create a very basic array-like class that overrides <code>np.sum</code> but lets other functions pass through (by returning <code>NotImplemented</code>).</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MySimpleArray:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, data):</div>
<div class="line">        <span class="comment"># Store data internally, maybe as a NumPy array for simplicity here</span></div>
<div class="line">        self._data = np.asarray(data)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># This is the magic method!</span></div>
<div class="line">    <span class="keyword">def </span>__array_function__(self, func, types, args, kwargs):</div>
<div class="line">        print(f<span class="stringliteral">&quot;MySimpleArray.__array_function__ got called for {func.__name__}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> func <span class="keywordflow">is</span> np.sum:</div>
<div class="line">            <span class="comment"># Handle np.sum ourselves!</span></div>
<div class="line">            print(<span class="stringliteral">&quot;-&gt; Handling np.sum internally!&quot;</span>)</div>
<div class="line">            <span class="comment"># Convert args to NumPy arrays if they are MySimpleArray</span></div>
<div class="line">            np_args = [a._data <span class="keywordflow">if</span> isinstance(a, MySimpleArray) <span class="keywordflow">else</span> a <span class="keywordflow">for</span> a <span class="keywordflow">in</span> args]</div>
<div class="line">            np_kwargs = {k: v._data <span class="keywordflow">if</span> isinstance(v, MySimpleArray) <span class="keywordflow">else</span> v <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> kwargs.items()}</div>
<div class="line">            <span class="comment"># Perform the actual sum using NumPy on the internal data</span></div>
<div class="line">            <span class="keywordflow">return</span> np.sum(*np_args, **np_kwargs)</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            <span class="comment"># For any other function, say we don&#39;t handle it</span></div>
<div class="line">            print(f<span class="stringliteral">&quot;-&gt; Don&#39;t know how to handle {func.__name__}, returning NotImplemented.&quot;</span>)</div>
<div class="line">            <span class="keywordflow">return</span> NotImplemented</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Make it look a bit like an array for printing</span></div>
<div class="line">    <span class="keyword">def </span>__repr__(self):</div>
<div class="line">        <span class="keywordflow">return</span> f<span class="stringliteral">&quot;MySimpleArray({self._data})&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Try it out ---</span></div>
<div class="line">my_arr = MySimpleArray([1, 2, 3, 4])</div>
<div class="line">print(<span class="stringliteral">&quot;Array:&quot;</span>, my_arr)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Call np.sum</span></div>
<div class="line">print(<span class="stringliteral">&quot;\nCalling np.sum(my_arr):&quot;</span>)</div>
<div class="line">total = np.sum(my_arr)</div>
<div class="line">print(<span class="stringliteral">&quot;Result:&quot;</span>, total)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Call np.mean (which our class doesn&#39;t handle)</span></div>
<div class="line">print(<span class="stringliteral">&quot;\nCalling np.mean(my_arr):&quot;</span>)</div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    mean_val = np.mean(my_arr)</div>
<div class="line">    print(<span class="stringliteral">&quot;Result:&quot;</span>, mean_val)</div>
<div class="line"><span class="keywordflow">except</span> TypeError <span class="keyword">as</span> e:</div>
<div class="line">    print(<span class="stringliteral">&quot;Caught expected TypeError:&quot;</span>, e)</div>
</div><!-- fragment --><p><b>Output:</b></p>
<div class="fragment"><div class="line">Array: MySimpleArray([1 2 3 4])</div>
<div class="line"> </div>
<div class="line">Calling np.sum(my_arr):</div>
<div class="line">MySimpleArray.__array_function__ got called for sum</div>
<div class="line">-&gt; Handling np.sum internally!</div>
<div class="line">Result: 10</div>
<div class="line"> </div>
<div class="line">Calling np.mean(my_arr):</div>
<div class="line">MySimpleArray.__array_function__ got called for mean</div>
<div class="line">-&gt; Don&#39;t know how to handle mean, returning NotImplemented.</div>
<div class="line">Caught expected TypeError: no implementation found for &#39;numpy.mean&#39; on types that implement __array_function__: [&lt;class &#39;__main__.MySimpleArray&#39;&gt;]</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>We created <code>MySimpleArray</code> which holds some data (here, a standard NumPy array <code>_data</code>).</li>
<li>We implemented <code>__array_function__(self, func, types, args, kwargs)</code>.<ul>
<li><code>func</code>: The NumPy function being called (e.g., <code>np.sum</code>, <code>np.mean</code>).</li>
<li><code>types</code>: A tuple of unique types implementing <code>__array_function__</code> in the arguments.</li>
<li><code>args</code>, <code>kwargs</code>: The original arguments passed to <code>func</code>.</li>
</ul>
</li>
<li>Inside <code>__array_function__</code>, we check if <code>func</code> is <code>np.sum</code>.<ul>
<li>If yes, we print a message, extract the internal <code>_data</code> from any <code>MySimpleArray</code> arguments, call <code>np.sum</code> on that data, and return the result. NumPy uses this returned value directly.</li>
<li>If no (like for <code>np.mean</code>), we print a message and return <code>NotImplemented</code>.</li>
</ul>
</li>
<li>When we call <code>np.sum(my_arr)</code>, NumPy detects <code>__array_function__</code> on <code>my_arr</code>. It calls it. Our method handles <code>np.sum</code> and returns <code>10</code>.</li>
<li>When we call <code>np.mean(my_arr)</code>, NumPy again calls <code>__array_function__</code>. This time, our method returns <code>NotImplemented</code>. Since no other arguments handle it, NumPy raises a <code>TypeError</code> because it doesn't know how to calculate the mean of <code>MySimpleArray</code> by default.</li>
</ol>
<p>This example demonstrates how an external library object can selectively take control of NumPy functions. Libraries like CuPy or Dask implement <code>__array_function__</code> much more thoroughly, handling many NumPy functions to perform operations on their specific data representations (GPU arrays, distributed arrays).</p>
<h2><a class="anchor" id="autotoc_md2602"></a>
A Glimpse Under the Hood (<code>overrides.py</code>)</h2>
<p>How does NumPy actually manage this dispatching process? The logic lives primarily in the <code>numpy/core/overrides.py</code> module.</p>
<ol type="1">
<li><b>Decorator:</b> Many NumPy functions (especially those intended to be public and potentially overridden) are decorated with <code>@array_function_dispatch(...)</code> or a similar helper (<code>@array_function_from_dispatcher</code>). You can see this decorator used in files like <code>numpy/core/function_base.py</code> (for <code>linspace</code>, <code>logspace</code>, etc.) or <code>numpy/core/numeric.py</code> (for <code>sum</code>, <code>mean</code>, etc. indirectly via ufunc machinery). ```python </li>
</ol>
<h1><a class="anchor" id="autotoc_md2603"></a>
Example from numpy/core/function_base.py (simplified)</h1>
<p>from numpy._core import overrides</p>
<p>array_function_dispatch = functools.partial( overrides.array_function_dispatch, module='numpy')</p>
<p>def _linspace_dispatcher(start, stop, num=None, ...): </p>
<h1><a class="anchor" id="autotoc_md2604"></a>
This helper identifies arguments relevant for dispatch</h1>
<p>return (start, stop)</p>
<p>@array_function_dispatch(_linspace_dispatcher) # Decorator applied! def linspace(start, stop, num=50, ...): </p>
<h1><a class="anchor" id="autotoc_md2605"></a>
... Actual implementation for NumPy arrays ...</h1>
<p>pass ``<code></p><ol type="1">
<li>**Dispatcher Class:** The decorator wraps the original function (like</li>
</ol>
<p></code>linspace<code>) in a special callable object, often an instance of</code>_ArrayFunctionDispatcher<code>.</p><ol type="1">
<li>**Call Interception:** When you call the decorated NumPy function (e.g.,</li>
</ol>
<p></code>np.linspace(...)<code>), you're actually calling the</code>_ArrayFunctionDispatcher<code>object.</p><ol type="1">
<li>**Argument Check (</li>
</ol>
<p></code>_get_implementing_args<code>):** The dispatcher object first calls the little helper function provided to the decorator (like</code>_linspace_dispatcher<code>) to figure out which arguments are relevant for checking the</code>__array_function__<code>protocol. Then, it calls the C helper function</code>_get_implementing_args<code>(defined in</code>numpy/core/src/multiarray/overrides.c<code>) which efficiently inspects the relevant arguments, finds those with</code>__array_function__<code>, and sorts them according to priority and type relationships.</p><ol type="1">
<li>**Delegation Loop:** The dispatcher iterates through the implementing arguments found in step 4 (from highest priority to lowest). For each one, it calls its</li>
</ol>
<p></code>__array_function__<code>method.</p><ol type="1">
<li>**Handle Result:**<ul>
<li>If</li>
</ul>
</li>
</ol>
<p></code>__array_function__<code>returns a value other than</code>NotImplemented<code>, the dispatcher immediately returns that value to the original caller. The process stops.</p><ul>
<li>If</li>
</ul>
<p></code>__array_function__<code>returns</code>NotImplemented<code>, the dispatcher continues to the next implementing argument in the list.</p><ol type="1">
<li>**Error or Default:** If the loop finishes without any override handling the call, a</li>
</ol>
<p></code>TypeError` is raised.</p>
<p>Here's a simplified sequence diagram for <code>np.sum(my_arr)</code>:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant NumPyFunc as np.sum (Dispatcher Object)</div>
<div class="line">    participant Overrides as numpy.core.overrides</div>
<div class="line">    participant CustomArr as my_arr (MySimpleArray)</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;NumPyFunc: np.sum(my_arr)</div>
<div class="line">    NumPyFunc-&gt;&gt;Overrides: Get relevant args (my_arr)</div>
<div class="line">    Overrides-&gt;&gt;Overrides: _get_implementing_args([my_arr])</div>
<div class="line">    Overrides--&gt;&gt;NumPyFunc: Found [my_arr] implements __array_function__</div>
<div class="line">    NumPyFunc-&gt;&gt;CustomArr: call __array_function__(func=np.sum, ...)</div>
<div class="line">    CustomArr-&gt;&gt;CustomArr: Check if func is np.sum (Yes)</div>
<div class="line">    CustomArr-&gt;&gt;CustomArr: Perform custom sum logic</div>
<div class="line">    CustomArr--&gt;&gt;NumPyFunc: Return result (e.g., 10)</div>
<div class="line">    NumPyFunc--&gt;&gt;User: Return result (10)</div>
</div><!-- fragment --><p>The <code>numpy/core/overrides.py</code> file defines the Python-level infrastructure (<code>array_function_dispatch</code>, <code>_ArrayFunctionDispatcher</code>), while the core logic for efficiently finding and sorting implementing arguments (<code>_get_implementing_args</code>) is implemented in C for performance.</p>
<h2><a class="anchor" id="autotoc_md2606"></a>
Conclusion</h2>
<p>The <code>__array_function__</code> protocol is a powerful mechanism that makes NumPy far more extensible and integrated with the wider Python ecosystem. You've learned:</p>
<ul>
<li>It allows objects from <b>other libraries</b> (like Dask, CuPy) to <b>override</b> how NumPy functions behave when passed instances of those objects.</li>
<li>It works via a special method, <code>__array_function__</code>, that implementing objects define.</li>
<li>NumPy <b>negotiates</b> with arguments: it checks for the method and <b>delegates</b> the call if an argument handles it.</li>
<li>This enables writing code that looks like standard NumPy (<code>np.sum(my_obj)</code>) but can operate seamlessly on diverse array types (CPU, GPU, distributed).</li>
<li>The dispatch logic is managed primarily by decorators and helpers in <code>numpy/core/overrides.py</code>, relying on a C function (<code>_get_implementing_args</code>) for efficient argument checking.</li>
</ul>
<p>This protocol is a key part of why NumPy remains central to scientific computing in Python, allowing it to interact smoothly with specialized array libraries without requiring NumPy itself to know the specifics of each one.</p>
<p>This concludes our tour through the core concepts of NumPy! We hope this journey from the fundamental <code>ndarray</code> to the sophisticated <code>__array_function__</code> protocol has given you a deeper appreciation for how NumPy works under the hood.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
