#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 02_input_handling__textbuffer_editor_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/dac/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_202__input__handling____textbuffer__editor__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">02_input_handling__textbuffer_editor_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1289"></a>
autotoc_md1289</h2>
<p>layout: default title: "Input Handling (TextBuffer/Editor)" parent: "Codex" </p>
<h2><a class="anchor" id="autotoc_md1290"></a>
nav_order: 2</h2>
<h1><a class="anchor" id="autotoc_md1291"></a>
Chapter 2: Input Handling (TextBuffer/Editor)</h1>
<p>In the <a class="el" href="../../dd/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_201__terminal__ui____ink__components__.html">previous chapter</a>, we saw how Codex uses Ink and React to draw the chat interface in your terminal. We learned about components like <code>&lt;TerminalChatInput&gt;</code> and <code>&lt;MultilineTextEditor&gt;</code> that show an input box. But how does that input box <em>actually work</em>?</p>
<h2><a class="anchor" id="autotoc_md1292"></a>
Why a Fancy Input Box?</h2>
<p>Imagine you want Codex to write a small Python script. You might type something like this:</p>
<div class="fragment"><div class="line">Write a python function that:</div>
<div class="line">1. Takes a list of numbers.</div>
<div class="line">2. Returns a new list containing only the even numbers.</div>
<div class="line">Make sure it handles empty lists gracefully.</div>
</div><!-- fragment --><p>Or maybe you're reviewing a command Codex proposed and want to give detailed feedback. A simple, single-line input field like your shell's basic prompt would be really awkward for this! You'd want to:</p>
<ul>
<li>Write multiple lines easily.</li>
<li>Use arrow keys to move your cursor around to fix typos.</li>
<li>Maybe jump back a whole word (<code>Ctrl+LeftArrow</code>) or delete a word (<code>Ctrl+Backspace</code>).</li>
<li>Press <code>Up</code> or <code>Down</code> arrow to bring back previous messages you sent (history).</li>
<li>Perhaps even open the current text in your main code editor (like VS Code or Vim) for complex edits (<code>Ctrl+X</code>).</li>
</ul>
<p>This is where the <b>Input Handling</b> system comes in. It's like a mini text editor built right into the Codex chat interface, designed to make typing potentially complex prompts and messages much easier than a standard terminal input line.</p>
<h2><a class="anchor" id="autotoc_md1293"></a>
Key Idea: The <code>TextBuffer</code></h2>
<p>The heart of this system is a class called <code>TextBuffer</code> (found in <code>text-buffer.ts</code>). Think of <code>TextBuffer</code> like the hidden document model behind a simple text editor (like Notepad or TextEdit):</p>
<ul>
<li><b>It holds the text:</b> It stores all the lines of text you've typed into the input box in an internal list (an array of strings called <code>lines</code>).</li>
<li><b>It knows where the cursor is:</b> It keeps track of the cursor's position (which <code>row</code> and <code>column</code> it's on).</li>
<li><b>It handles edits:</b> When you press keys like letters, numbers, Backspace, Delete, or Enter, the <code>TextBuffer</code> modifies the text and updates the cursor position accordingly.</li>
<li><b>It manages scrolling:</b> If your text gets longer than the input box can display, the <code>TextBuffer</code> figures out which part of the text should be visible.</li>
</ul>
<p>The <code>MultilineTextEditor</code> React component we saw in Chapter 1 uses an instance of this <code>TextBuffer</code> internally to manage the state of the text being edited.</p>
<h2><a class="anchor" id="autotoc_md1294"></a>
How You Use It (Indirectly)</h2>
<p>You don't directly interact with <code>TextBuffer</code> yourself. You interact with the <code>&lt;MultilineTextEditor&gt;</code> component displayed by Ink. But understanding <code>TextBuffer</code> helps you see <em>how</em> the editor works.</p>
<p>Let's look at a simplified view of how the <code>&lt;TerminalChatNewInput&gt;</code> component uses <code>&lt;MultilineTextEditor&gt;</code>:</p>
<div class="fragment"><div class="line">// File: codex-cli/src/components/chat/terminal-chat-new-input.tsx (Simplified)</div>
<div class="line">import React, { useState, useCallback } from &quot;react&quot;;</div>
<div class="line">import { Box, Text, useInput } from &quot;ink&quot;;</div>
<div class="line">import MultilineTextEditor from &quot;./multiline-editor&quot;; // Our editor component</div>
<div class="line">// ... other imports</div>
<div class="line"> </div>
<div class="line">export default function TerminalChatInput({ submitInput, active, /* ... */ }) {</div>
<div class="line">  const [input, setInput] = useState(&quot;&quot;); // Holds the current text in the editor state</div>
<div class="line">  const [history, setHistory] = useState&lt;string[]&gt;([]); // Holds past submitted messages</div>
<div class="line">  const [historyIndex, setHistoryIndex] = useState&lt;number | null&gt;(null);</div>
<div class="line">  // Used to force re-render editor when history changes text</div>
<div class="line">  const [editorKey, setEditorKey] = useState(0);</div>
<div class="line">  const editorRef = React.useRef(/* ... */); // Handle to the editor</div>
<div class="line"> </div>
<div class="line">  // --- History Handling (Simplified) ---</div>
<div class="line">  useInput((_input, key) =&gt; {</div>
<div class="line">    // Check if Up/Down arrow pressed AND cursor is at top/bottom line</div>
<div class="line">    const isAtTop = editorRef.current?.isCursorAtFirstRow();</div>
<div class="line">    const isAtBottom = editorRef.current?.isCursorAtLastRow();</div>
<div class="line"> </div>
<div class="line">    if (key.upArrow &amp;&amp; isAtTop &amp;&amp; history.length &gt; 0) {</div>
<div class="line">      // Logic to go back in history</div>
<div class="line">      const newIndex = historyIndex === null ? history.length - 1 : Math.max(0, historyIndex - 1);</div>
<div class="line">      setHistoryIndex(newIndex);</div>
<div class="line">      setInput(history[newIndex] ?? &quot;&quot;); // Set the text to the historical item</div>
<div class="line">      setEditorKey(k =&gt; k + 1); // Force editor to re-mount with new text</div>
<div class="line">      // ... save draft if needed ...</div>
<div class="line">    } else if (key.downArrow &amp;&amp; isAtBottom &amp;&amp; historyIndex !== null) {</div>
<div class="line">      // Logic to go forward in history or restore draft</div>
<div class="line">      // ... similar logic using setInput, setHistoryIndex, setEditorKey ...</div>
<div class="line">    }</div>
<div class="line">    // Note: If not handling history, the key press falls through to MultilineTextEditor</div>
<div class="line">  }, { isActive: active });</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">  // --- Submission Handling ---</div>
<div class="line">  const onSubmit = useCallback((textFromEditor: string) =&gt; {</div>
<div class="line">    const trimmedText = textFromEditor.trim();</div>
<div class="line">    if (!trimmedText) return; // Ignore empty submissions</div>
<div class="line"> </div>
<div class="line">    // Add to history</div>
<div class="line">    setHistory(prev =&gt; [...prev, textFromEditor]);</div>
<div class="line">    setHistoryIndex(null); // Reset history navigation</div>
<div class="line"> </div>
<div class="line">    // Send the input to the Agent Loop!</div>
<div class="line">    submitInput(/* ... create input item from trimmedText ... */);</div>
<div class="line"> </div>
<div class="line">    // Clear the input for the next message</div>
<div class="line">    setInput(&quot;&quot;);</div>
<div class="line">    setEditorKey(k =&gt; k + 1); // Force editor reset</div>
<div class="line"> </div>
<div class="line">  }, [submitInput, setHistory /* ... */]);</div>
<div class="line"> </div>
<div class="line">  return (</div>
<div class="line">    &lt;Box flexDirection=&quot;column&quot; borderStyle=&quot;round&quot;&gt;</div>
<div class="line">      {/* The actual editor component */}</div>
<div class="line">      &lt;MultilineTextEditor</div>
<div class="line">        ref={editorRef} // Connect ref for cursor position checks</div>
<div class="line">        key={editorKey} // Force re-render on key change</div>
<div class="line">        initialText={input} // Tell editor what text to display initially</div>
<div class="line">        focus={active} // Tell editor whether to capture keys</div>
<div class="line">        onChange={(text) =&gt; setInput(text)} // Update React state when text changes internally</div>
<div class="line">        onSubmit={onSubmit} // Tell editor what to do on Enter</div>
<div class="line">        height={8} // Example height</div>
<div class="line">      /&gt;</div>
<div class="line">      &lt;Text dimColor&gt;ctrl+c exit | enter send | ↑↓ history | ctrl+x editor&lt;/Text&gt;</div>
<div class="line">    &lt;/Box&gt;</div>
<div class="line">  );</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b><code>initialText={input}</code>:</b> The <code>&lt;MultilineTextEditor&gt;</code> starts with the text held in the <code>input</code> state variable. This is how history navigation works – we change <code>input</code> and force a re-render.</li>
<li><b><code>onChange={(text) =&gt; setInput(text)}</code>:</b> Whenever the text <em>inside</em> the <code>MultilineTextEditor</code> (managed by its internal <code>TextBuffer</code>) changes, it calls this function. We update the <code>input</code> state variable in the parent component (<code>TerminalChatNewInput</code>) to keep track, though often the editor manages its own state primarily.</li>
<li><b><code>onSubmit={onSubmit}</code>:</b> When you press Enter (in a way that signifies submission, not just adding a newline), the <code>MultilineTextEditor</code> calls this <code>onSubmit</code> function, passing the final text content. This function then sends the message off to the <a class="el" href="../../d0/dbd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_203__agent__loop.html">Agent Loop</a> and clears the input.</li>
<li><b>History (<code>useInput</code>):</b> The parent component (<code>TerminalChatNewInput</code>) uses Ink's <code>useInput</code> hook to <em>intercept</em> the Up/Down arrow keys <em>before</em> they even reach the <code>MultilineTextEditor</code>. It checks if the cursor (using <code>editorRef.current?.isCursorAtFirstRow()</code>) is at the very top/bottom edge of the text. If so, it handles history navigation by changing the <code>input</code> state and forcing the editor to update using <code>setEditorKey</code>. If the cursor isn't at the edge, it lets the arrow key "fall through" to the <code>MultilineTextEditor</code>, which then just moves the cursor normally within the text via its internal <code>TextBuffer</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1295"></a>
Under the Hood: Keystroke to Display</h2>
<p>Let's trace what happens when you type a character, say 'h', into the input box:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant Terminal</div>
<div class="line">    participant InkUI as Ink/React (MultilineTextEditor)</div>
<div class="line">    participant TextBuffer</div>
<div class="line">    participant AgentLoop as Agent Loop (Not involved)</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;Terminal: Presses &#39;h&#39; key</div>
<div class="line">    Terminal-&gt;&gt;InkUI: Terminal sends key event to Ink</div>
<div class="line">    InkUI-&gt;&gt;InkUI: `useInput` hook captures &#39;h&#39;</div>
<div class="line">    InkUI-&gt;&gt;TextBuffer: Calls `handleInput(&#39;h&#39;, { ... }, viewport)`</div>
<div class="line">    TextBuffer-&gt;&gt;TextBuffer: Finds current line (&quot;&quot;) and cursor (0,0)</div>
<div class="line">    TextBuffer-&gt;&gt;TextBuffer: Calls `insert(&#39;h&#39;)`</div>
<div class="line">    TextBuffer-&gt;&gt;TextBuffer: Updates `lines` to `[&quot;h&quot;]`</div>
<div class="line">    TextBuffer-&gt;&gt;TextBuffer: Updates `cursorCol` to 1</div>
<div class="line">    TextBuffer-&gt;&gt;TextBuffer: Increments internal `version`</div>
<div class="line">    TextBuffer--&gt;&gt;InkUI: Returns `true` (buffer was modified)</div>
<div class="line">    InkUI-&gt;&gt;InkUI: Triggers a React re-render because internal state changed</div>
<div class="line">    InkUI-&gt;&gt;TextBuffer: Calls `getVisibleLines(viewport)` -&gt; returns `[&quot;h&quot;]`</div>
<div class="line">    InkUI-&gt;&gt;TextBuffer: Calls `getCursor()` -&gt; returns `[0, 1]`</div>
<div class="line">    InkUI-&gt;&gt;Terminal: Renders the updated text (&quot;h&quot;) with cursor highlight</div>
</div><!-- fragment --><ol type="1">
<li><b>Keystroke:</b> You press the 'h' key.</li>
<li><b>Capture:</b> Ink's <code>useInput</code> hook within <code>&lt;MultilineTextEditor&gt;</code> receives the key event.</li>
<li><b>Delegate:</b> <code>&lt;MultilineTextEditor&gt;</code> calls the <code>handleInput</code> method on its internal <code>TextBuffer</code> instance, passing the input character ('h'), key modifier flags (like Shift, Ctrl - none in this case), and the current visible area size (viewport).</li>
<li><b>Update State:</b> <code>TextBuffer.handleInput</code> determines it's a simple character insertion. It calls its internal <code>insert</code> method.</li>
<li><b><code>insert</code> Method:</b><ul>
<li>Gets the current line (e.g., <code>""</code>).</li>
<li>Splits the line at the cursor position (0).</li>
<li>Inserts the character: <code>""</code> + &lsquo;'h&rsquo;<code>+</code>""<code>-&gt;</code>"h"<code>.</code></li>
<li><code> Updates the</code>lines<code>array:</code>["h"]<code>.</code></li>
<li><code> Updates the cursor column:</code>0<code>-&gt;</code>1<code>.</code></li>
<li><code> Increments an internal version number to track changes.</code></li>
</ul>
</li>
<li><code> **Signal Change:**</code>handleInput<code>returns</code>true<code>because the buffer was modified.</code></li>
<li><code> **Re-render:** The</code>&lt;MultilineTextEditor&gt;<code>component detects the change (either via the return value or its internal state update) and triggers a React re-render.</code></li>
<li><code> **Get Display Data:** During the render,</code>&lt;MultilineTextEditor&gt;<code>calls methods on the</code>TextBuffer<code>like: *</code>getVisibleLines()<code>: Gets the lines of text that should currently be visible based on scrolling. *</code>getCursor()<code>: Gets the current row and column of the cursor.</code></li>
<li><code> **Draw:** The component uses this information to render the text (</code>h<code>) in the terminal. It uses the cursor position to draw the cursor, often by rendering the character *at* the cursor position with an inverted background color (like</code>chalk.inverse(char)`).</li>
</ol>
<p>This same loop happens for every key press: Backspace calls <code>TextBuffer.backspace()</code>, arrow keys call <code>TextBuffer.move()</code>, Enter calls <code>TextBuffer.newline()</code> (or triggers <code>onSubmit</code>), etc.</p>
<h2><a class="anchor" id="autotoc_md1296"></a>
Diving into <code>TextBuffer</code> Code (Simplified)</h2>
<p>Let's peek inside <code>text-buffer.ts</code>:</p>
<div class="fragment"><div class="line">// File: codex-cli/src/text-buffer.ts (Simplified)</div>
<div class="line"> </div>
<div class="line">// Helper to check if a character is part of a &quot;word&quot;</div>
<div class="line">function isWordChar(ch: string | undefined): boolean {</div>
<div class="line">  // Simplified: returns true if not whitespace or basic punctuation</div>
<div class="line">  return ch !== undefined &amp;&amp; !/[\s,.;!?]/.test(ch);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Helper to get the length respecting multi-byte characters (like emoji)</div>
<div class="line">function cpLen(str: string): number { return Array.from(str).length; }</div>
<div class="line">// Helper to slice respecting multi-byte characters</div>
<div class="line">function cpSlice(str: string, start: number, end?: number): string {</div>
<div class="line">  return Array.from(str).slice(start, end).join(&#39;&#39;);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">export default class TextBuffer {</div>
<div class="line">  // --- Core State ---</div>
<div class="line">  private lines: string[] = [&quot;&quot;]; // The text, line by line</div>
<div class="line">  private cursorRow = 0;          // Cursor&#39;s current line number</div>
<div class="line">  private cursorCol = 0;          // Cursor&#39;s column (character index) on the line</div>
<div class="line">  // ... scrollRow, scrollCol for viewport management ...</div>
<div class="line">  private version = 0;            // Increments on each change</div>
<div class="line"> </div>
<div class="line">  constructor(text = &quot;&quot;) {</div>
<div class="line">    this.lines = text.split(&quot;\n&quot;);</div>
<div class="line">    if (this.lines.length === 0) this.lines = [&quot;&quot;];</div>
<div class="line">    // Start cursor at the end</div>
<div class="line">    this.cursorRow = this.lines.length - 1;</div>
<div class="line">    this.cursorCol = this.lineLen(this.cursorRow);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // --- Internal Helpers ---</div>
<div class="line">  private line(r: number): string { return this.lines[r] ?? &quot;&quot;; }</div>
<div class="line">  private lineLen(r: number): number { return cpLen(this.line(r)); }</div>
<div class="line">  private ensureCursorInRange(): void { /* Makes sure row/col are valid */ }</div>
<div class="line"> </div>
<div class="line">  // --- Public Accessors ---</div>
<div class="line">  getCursor(): [number, number] { return [this.cursorRow, this.cursorCol]; }</div>
<div class="line">  getText(): string { return this.lines.join(&quot;\n&quot;); }</div>
<div class="line">  getVisibleLines(/* viewport */): string[] {</div>
<div class="line">    // ... calculate visible lines based on scrollRow/Col ...</div>
<div class="line">    return this.lines; // Simplified: return all lines</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // --- Editing Operations ---</div>
<div class="line">  insert(ch: string): void {</div>
<div class="line">    // ... handle potential newlines by calling insertStr ...</div>
<div class="line">    const line = this.line(this.cursorRow);</div>
<div class="line">    // Use cpSlice for multi-byte character safety</div>
<div class="line">    this.lines[this.cursorRow] =</div>
<div class="line">      cpSlice(line, 0, this.cursorCol) + ch + cpSlice(line, this.cursorCol);</div>
<div class="line">    this.cursorCol += cpLen(ch); // Use cpLen</div>
<div class="line">    this.version++;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  newline(): void {</div>
<div class="line">    const line = this.line(this.cursorRow);</div>
<div class="line">    const before = cpSlice(line, 0, this.cursorCol);</div>
<div class="line">    const after = cpSlice(line, this.cursorCol);</div>
<div class="line"> </div>
<div class="line">    this.lines[this.cursorRow] = before; // Keep text before cursor on current line</div>
<div class="line">    this.lines.splice(this.cursorRow + 1, 0, after); // Insert text after cursor as new line</div>
<div class="line"> </div>
<div class="line">    this.cursorRow++; // Move cursor down</div>
<div class="line">    this.cursorCol = 0;  // Move cursor to start of new line</div>
<div class="line">    this.version++;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  backspace(): void {</div>
<div class="line">    if (this.cursorCol &gt; 0) { // If not at start of line</div>
<div class="line">      const line = this.line(this.cursorRow);</div>
<div class="line">      this.lines[this.cursorRow] =</div>
<div class="line">        cpSlice(line, 0, this.cursorCol - 1) + cpSlice(line, this.cursorCol);</div>
<div class="line">      this.cursorCol--;</div>
<div class="line">      this.version++;</div>
<div class="line">    } else if (this.cursorRow &gt; 0) { // If at start of line (but not first line)</div>
<div class="line">      // Merge with previous line</div>
<div class="line">      const prevLine = this.line(this.cursorRow - 1);</div>
<div class="line">      const currentLine = this.line(this.cursorRow);</div>
<div class="line">      const newCol = this.lineLen(this.cursorRow - 1); // Cursor goes to end of merged line</div>
<div class="line"> </div>
<div class="line">      this.lines[this.cursorRow - 1] = prevLine + currentLine; // Combine lines</div>
<div class="line">      this.lines.splice(this.cursorRow, 1); // Remove the now-empty current line</div>
<div class="line"> </div>
<div class="line">      this.cursorRow--;</div>
<div class="line">      this.cursorCol = newCol;</div>
<div class="line">      this.version++;</div>
<div class="line">    }</div>
<div class="line">    // Do nothing if at row 0, col 0</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  move(dir: &#39;left&#39; | &#39;right&#39; | &#39;up&#39; | &#39;down&#39; | &#39;wordLeft&#39; | &#39;wordRight&#39; | &#39;home&#39; | &#39;end&#39;): void {</div>
<div class="line">    switch (dir) {</div>
<div class="line">      case &#39;left&#39;:</div>
<div class="line">        if (this.cursorCol &gt; 0) this.cursorCol--;</div>
<div class="line">        else if (this.cursorRow &gt; 0) { /* Move to end of prev line */ }</div>
<div class="line">        break;</div>
<div class="line">      case &#39;right&#39;:</div>
<div class="line">        if (this.cursorCol &lt; this.lineLen(this.cursorRow)) this.cursorCol++;</div>
<div class="line">        else if (this.cursorRow &lt; this.lines.length - 1) { /* Move to start of next line */ }</div>
<div class="line">        break;</div>
<div class="line">      case &#39;up&#39;:</div>
<div class="line">        if (this.cursorRow &gt; 0) {</div>
<div class="line">          this.cursorRow--;</div>
<div class="line">          // Try to maintain horizontal position (handle preferredCol logic)</div>
<div class="line">          this.cursorCol = Math.min(this.cursorCol, this.lineLen(this.cursorRow));</div>
<div class="line">        }</div>
<div class="line">        break;</div>
<div class="line">      // ... other cases (down, home, end) ...</div>
<div class="line">      case &#39;wordLeft&#39;: {</div>
<div class="line">        // Scan backwards from cursorCol, skip whitespace, then skip word chars</div>
<div class="line">        // Update this.cursorCol to the start of the word/whitespace run</div>
<div class="line">        // ... implementation details ...</div>
<div class="line">        break;</div>
<div class="line">      }</div>
<div class="line">      // ... wordRight ...</div>
<div class="line">    }</div>
<div class="line">    this.ensureCursorInRange();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // --- High-Level Input Handler ---</div>
<div class="line">  handleInput(input: string | undefined, key: Record&lt;string, boolean&gt;, /* viewport */): boolean {</div>
<div class="line">    const beforeVersion = this.version;</div>
<div class="line">    // Check key flags (key.leftArrow, key.backspace, key.ctrl, etc.)</div>
<div class="line">    // and the `input` character itself.</div>
<div class="line">    if (key.leftArrow &amp;&amp; !key.ctrl &amp;&amp; !key.meta) this.move(&#39;left&#39;);</div>
<div class="line">    else if (key.rightArrow &amp;&amp; !key.ctrl &amp;&amp; !key.meta) this.move(&#39;right&#39;);</div>
<div class="line">    else if (key.upArrow) this.move(&#39;up&#39;);</div>
<div class="line">    else if (key.downArrow) this.move(&#39;down&#39;);</div>
<div class="line">    else if ((key.ctrl || key.meta) &amp;&amp; key.leftArrow) this.move(&#39;wordLeft&#39;);</div>
<div class="line">    // ... handle wordRight, home, end ...</div>
<div class="line">    else if (key.backspace || input === &#39;\x7f&#39; /* DEL char */) this.backspace();</div>
<div class="line">    // ... handle delete, newline (Enter) ...</div>
<div class="line">    else if (input &amp;&amp; !key.ctrl &amp;&amp; !key.meta) {</div>
<div class="line">      // If it&#39;s a printable character (and not a special key combo)</div>
<div class="line">      this.insert(input);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    // ... ensure cursor visible based on viewport ...</div>
<div class="line">    return this.version !== beforeVersion; // Return true if text changed</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // --- External Editor ---</div>
<div class="line">  async openInExternalEditor(): Promise&lt;void&gt; {</div>
<div class="line">    // 1. Get editor from $VISUAL or $EDITOR env var (fallback to vi/notepad)</div>
<div class="line">    // 2. Write this.getText() to a temporary file</div>
<div class="line">    // 3. Use Node&#39;s `spawnSync` to run the editor command with the temp file path</div>
<div class="line">    //    (This blocks until the editor is closed)</div>
<div class="line">    // 4. Read the content back from the temp file</div>
<div class="line">    // 5. Update this.lines, this.cursorRow, this.cursorCol</div>
<div class="line">    // 6. Clean up the temp file</div>
<div class="line">    this.version++;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>The <code>lines</code> array holds the actual text content.</li>
<li><code>cursorRow</code> and <code>cursorCol</code> track the insertion point.</li>
<li>Methods like <code>insert</code>, <code>backspace</code>, <code>newline</code>, and <code>move</code> directly manipulate <code>lines</code>, <code>cursorRow</code>, and <code>cursorCol</code>. They use helpers like <code>cpLen</code> and <code>cpSlice</code> to correctly handle characters that might take up more than one byte (like emojis).</li>
<li><code>handleInput</code> acts as the main entry point, deciding which specific editing operation to perform based on the key pressed.</li>
<li><code>openInExternalEditor</code> handles the <code>Ctrl+X</code> magic by saving to a temp file, running your system's default editor, and reloading the content.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1297"></a>
Conclusion</h2>
<p>You've now seen how Codex provides a surprisingly powerful text editing experience right within your terminal. It goes far beyond a simple input line by using the <code>&lt;MultilineTextEditor&gt;</code> component, which relies heavily on the internal <code>TextBuffer</code> class. This class manages the text content, cursor position, and editing operations like insertion, deletion, multi-line handling, cursor navigation (including word jumps), and even integration with external editors. This allows you to compose complex prompts or provide detailed feedback without leaving the terminal interface.</p>
<p>With the UI drawn and user input handled, what happens next? How does Codex take your input, think about it, and generate a response or decide to run a command? That's the job of the core logic loop.</p>
<p>Next up: <a class="el" href="../../d0/dbd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_203__agent__loop.html">Agent Loop</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
