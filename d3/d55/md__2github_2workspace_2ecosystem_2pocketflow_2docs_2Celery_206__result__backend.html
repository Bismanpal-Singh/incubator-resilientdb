#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_result_backend</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d3/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_206__result__backend.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_result_backend</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1034"></a>
autotoc_md1034</h2>
<p>layout: default title: "Result Backend" parent: "Celery" </p>
<h2><a class="anchor" id="autotoc_md1035"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md1036"></a>
Chapter 6: Result Backend - Checking Your Task's Homework</h1>
<p>In <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Chapter 5: Worker</a>, we met the Celery Worker, the diligent entity that picks up task messages from the <a class="el" href="../../d3/dd5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_204__broker__connection____amqp__.html">Broker Connection (AMQP)</a> and executes the code defined in our <a class="el" href="../../d5/db8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_203__task.html">Task</a>.</p>
<p>But what happens after the worker finishes a task? What if the task was supposed to calculate something, like <code>add(2, 2)</code>? How do we, back in our main application, find out the answer (<code>4</code>)? Or even just know if the task finished successfully or failed?</p>
<p>This is where the <b>Result Backend</b> comes in. It's like a dedicated place to check the status and results of the homework assigned to the workers.</p>
<h2><a class="anchor" id="autotoc_md1037"></a>
What Problem Does the Result Backend Solve?</h2>
<p>Imagine you give your Celery worker a math problem: "What is 123 + 456?". The worker goes away, calculates the answer (579), and... then what?</p>
<p>If you don't tell the worker <em>where</em> to put the answer, it just disappears! You, back in your main program, have no idea if the worker finished, if it got the right answer, or if it encountered an error.</p>
<p>The <b>Result Backend</b> solves this by providing a storage location (like a database, a cache like Redis, or even via the message broker itself) where the worker can:</p>
<ol type="1">
<li>Record the final <b>state</b> of the task (e.g., <code>SUCCESS</code>, <code>FAILURE</code>).</li>
<li>Store the task's <b>return value</b> (e.g., <code>579</code>) if it succeeded.</li>
<li>Store the <b>error</b> information (e.g., <code>TypeError: unsupported operand type(s)...</code>) if it failed.</li>
</ol>
<p>Later, your main application can query this Result Backend using the task's unique ID to retrieve this information.</p>
<p>Think of it as a shared filing cabinet:</p><ul>
<li>The <b>Worker</b> puts the completed homework (result and status) into a specific folder (identified by the task ID).</li>
<li>Your <b>Application</b> can later look inside that folder (using the task ID) to see the results.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1038"></a>
Key Concepts</h2>
<ol type="1">
<li><b>Storage:</b> It's a place to store task results and states. This could be Redis, a relational database (like PostgreSQL or MySQL), MongoDB, RabbitMQ (using RPC), and others.</li>
<li><b>Task ID:</b> Each task execution gets a unique ID (remember the <code>result_promise_add.id</code> from Chapter 3?). This ID is the key used to store and retrieve the result from the backend.</li>
<li><b>State:</b> Besides the return value, the backend stores the task's current state (e.g., <code>PENDING</code>, <code>STARTED</code>, <code>SUCCESS</code>, <code>FAILURE</code>, <code>RETRY</code>, <code>REVOKED</code>).</li>
<li><b>Return Value / Exception:</b> If the task finishes successfully (<code>SUCCESS</code>), the backend stores the value the task function returned. If it fails (<code>FAILURE</code>), it stores details about the exception that occurred.</li>
<li><b><code>AsyncResult</code> Object:</b> When you call <code>task.delay()</code> or <code>task.apply_async()</code>, Celery gives you back an <code>AsyncResult</code> object. This object holds the task's ID and provides methods to interact with the result backend (check status, get the result, etc.).</li>
</ol>
<h2><a class="anchor" id="autotoc_md1039"></a>
How to Use a Result Backend</h2>
<p><b>1. Configure It!</b></p>
<p>First, you need to tell your Celery app <em>where</em> the result backend is located. You do this using the <code>result_backend</code> configuration setting, just like you set the <code>broker_url</code> in <a class="el" href="../../d7/df5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_202__configuration.html">Chapter 2: Configuration</a>.</p>
<p>Let's configure our app to use Redis (make sure you have Redis running!) as the result backend. We'll use database number <code>1</code> for results to keep it separate from the broker which might be using database <code>0</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># celery_app.py</span></div>
<div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Configure BOTH broker and result backend</span></div>
<div class="line">app = Celery(<span class="stringliteral">&#39;tasks&#39;</span>,</div>
<div class="line">             broker=<span class="stringliteral">&#39;redis://localhost:6379/0&#39;</span>,</div>
<div class="line">             backend=<span class="stringliteral">&#39;redis://localhost:6379/1&#39;</span>) <span class="comment"># &lt;-- Result Backend URL</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># You could also use app.config_from_object(&#39;celeryconfig&#39;)</span></div>
<div class="line"><span class="comment"># if result_backend = &#39;redis://localhost:6379/1&#39; is in celeryconfig.py</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># ... your task definitions (@app.task) would go here or be imported ...</span></div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>add(x, y):</div>
<div class="line">    <span class="keyword">import</span> time</div>
<div class="line">    time.sleep(3) <span class="comment"># Simulate work</span></div>
<div class="line">    <span class="keywordflow">return</span> x + y</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>fail_sometimes(x):</div>
<div class="line">    <span class="keyword">import</span> random</div>
<div class="line">    <span class="keywordflow">if</span> random.random() &lt; 0.5:</div>
<div class="line">        <span class="keywordflow">raise</span> ValueError(<span class="stringliteral">&quot;Something went wrong!&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> f<span class="stringliteral">&quot;Processed {x}&quot;</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>&lsquo;backend='redis://localhost:6379/1&rsquo;<code>: We provide a URL telling Celery to use the Redis server running on</code>localhost<code>, port</code>6379<code>, and specifically database</code>1<code>for storing results. (The</code>backend<code>argument is an alias for</code>result_backend`).</li>
</ul>
<p><b>2. Send a Task and Get the <code>AsyncResult</code></b></p>
<p>When you send a task, the returned object is your key to the result.</p>
<div class="fragment"><div class="line"><span class="comment"># run_tasks.py</span></div>
<div class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> add, fail_sometimes</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Send the add task</span></div>
<div class="line">result_add = add.delay(10, 20)</div>
<div class="line">print(f<span class="stringliteral">&quot;Sent task add(10, 20). Task ID: {result_add.id}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Send the task that might fail</span></div>
<div class="line">result_fail = fail_sometimes.delay(<span class="stringliteral">&quot;my data&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Sent task fail_sometimes(&#39;my data&#39;). Task ID: {result_fail.id}&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>result_add</code> and <code>result_fail</code> are <code>AsyncResult</code> objects. They contain the <code>.id</code> attribute, which is the unique identifier for <em>this specific execution</em> of the task.</li>
</ul>
<p><b>3. Check the Status and Get the Result</b></p>
<p>Now, you can use the <code>AsyncResult</code> object to interact with the result backend.</p>
<p><b>(Run a worker in another terminal first: <code>celery -A celery_app worker --loglevel=info</code>)</b></p>
<div class="fragment"><div class="line"><span class="comment"># continue in run_tasks.py or a new Python session</span></div>
<div class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app <span class="comment"># Need app for AsyncResult if creating from ID</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Use the AsyncResult objects we got earlier</span></div>
<div class="line"><span class="comment"># Or, if you only have the ID, you can recreate the AsyncResult:</span></div>
<div class="line"><span class="comment"># result_add = app.AsyncResult(&#39;the-task-id-you-saved-earlier&#39;)</span></div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;\nChecking results for add task ({result_add.id})...&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Check if the task is finished (returns True/False immediately)</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Is add ready? {result_add.ready()}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Check the state (returns &#39;PENDING&#39;, &#39;STARTED&#39;, &#39;SUCCESS&#39;, &#39;FAILURE&#39;, etc.)</span></div>
<div class="line">print(f<span class="stringliteral">&quot;State of add: {result_add.state}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Get the result. IMPORTANT: This call will BLOCK until the task is finished!</span></div>
<div class="line"><span class="comment"># If the task failed, this will raise the exception that occurred in the worker.</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    <span class="comment"># Set a timeout (in seconds) to avoid waiting forever</span></div>
<div class="line">    final_result = result_add.get(timeout=10)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Result of add: {final_result}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Did add succeed? {result_add.successful()}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Final state of add: {result_add.state}&quot;</span>)</div>
<div class="line"><span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Could not get result for add: {type(e).__name__} - {e}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Final state of add: {result_add.state}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Did add fail? {result_add.failed()}&quot;</span>)</div>
<div class="line">    <span class="comment"># Get the traceback if it failed</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Traceback: {result_add.traceback}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;\nChecking results for fail_sometimes task ({result_fail.id})...&quot;</span>)</div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    <span class="comment"># Wait up to 10 seconds for this task</span></div>
<div class="line">    fail_result = result_fail.get(timeout=10)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Result of fail_sometimes: {fail_result}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Did fail_sometimes succeed? {result_fail.successful()}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Final state of fail_sometimes: {result_fail.state}&quot;</span>)</div>
<div class="line"><span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Could not get result for fail_sometimes: {type(e).__name__} - {e}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Final state of fail_sometimes: {result_fail.state}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Did fail_sometimes fail? {result_fail.failed()}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Traceback:\n{result_fail.traceback}&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation &amp; Potential Output:</b></p>
<ul>
<li><code>result.ready()</code>: Checks if the task has finished (reached a <code>SUCCESS</code>, <code>FAILURE</code>, or other final state). Non-blocking.</li>
<li><code>result.state</code>: Gets the current state string. Non-blocking.</li>
<li><code>result.successful()</code>: Returns <code>True</code> if the state is <code>SUCCESS</code>. Non-blocking.</li>
<li><code>result.failed()</code>: Returns <code>True</code> if the state is <code>FAILURE</code> or another exception state. Non-blocking.</li>
<li><code>result.get(timeout=...)</code>: This is the most common way to get the actual return value.<ul>
<li><b>It blocks</b> (waits) until the task completes <em>or</em> the timeout expires.</li>
<li>If the task state becomes <code>SUCCESS</code>, it returns the value the task function returned (e.g., <code>30</code>).</li>
<li>If the task state becomes <code>FAILURE</code>, it <b>raises</b> the exception that occurred in the worker (e.g., <code>ValueError: Something went wrong!</code>).</li>
<li>If the timeout is reached before the task finishes, it raises a <code>celery.exceptions.TimeoutError</code>.</li>
</ul>
</li>
<li><code>result.traceback</code>: If the task failed, this contains the error traceback string from the worker.</li>
</ul>
<p><b>(Example Output - might vary for <code>fail_sometimes</code> due to randomness)</b></p>
<div class="fragment"><div class="line">Sent task add(10, 20). Task ID: f5e8a3f6-c7b1-4a9e-8f0a-1b2c3d4e5f6a</div>
<div class="line">Sent task fail_sometimes(&#39;my data&#39;). Task ID: 9b1d8c7e-a6f5-4b3a-9c8d-7e6f5a4b3c2d</div>
<div class="line"> </div>
<div class="line">Checking results for add task (f5e8a3f6-c7b1-4a9e-8f0a-1b2c3d4e5f6a)...</div>
<div class="line">Is add ready? False</div>
<div class="line">State of add: PENDING  # Or STARTED if checked quickly after worker picks it up</div>
<div class="line">Result of add: 30</div>
<div class="line">Did add succeed? True</div>
<div class="line">Final state of add: SUCCESS</div>
<div class="line"> </div>
<div class="line">Checking results for fail_sometimes task (9b1d8c7e-a6f5-4b3a-9c8d-7e6f5a4b3c2d)...</div>
<div class="line">Could not get result for fail_sometimes: ValueError - Something went wrong!</div>
<div class="line">Final state of fail_sometimes: FAILURE</div>
<div class="line">Did fail_sometimes fail? True</div>
<div class="line">Traceback:</div>
<div class="line">Traceback (most recent call last):</div>
<div class="line">  File &quot;/path/to/celery/app/trace.py&quot;, line ..., in trace_task</div>
<div class="line">    R = retval = fun(*args, **kwargs)</div>
<div class="line">  File &quot;/path/to/celery/app/trace.py&quot;, line ..., in __protected_call__</div>
<div class="line">    return self.run(*args, **kwargs)</div>
<div class="line">  File &quot;/path/to/your/project/celery_app.py&quot;, line ..., in fail_sometimes</div>
<div class="line">    raise ValueError(&quot;Something went wrong!&quot;)</div>
<div class="line">ValueError: Something went wrong!</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1040"></a>
How It Works Internally</h2>
<ol type="1">
<li><b>Task Sent:</b> Your application calls <code>add.delay(10, 20)</code>. It sends a message to the <b>Broker</b> and gets back an <code>AsyncResult</code> object containing the unique <code>task_id</code>.</li>
<li><b>Worker Executes:</b> A <b>Worker</b> picks up the task message from the Broker. It finds the <code>add</code> function and executes <code>add(10, 20)</code>. The function returns <code>30</code>.</li>
<li><b>Worker Stores Result:</b> Because a <code>result_backend</code> is configured (<code>redis://.../1</code>), the Worker:<ul>
<li>Connects to the Result Backend (Redis DB 1).</li>
<li>Prepares the result data (e.g., &lsquo;{'status&rsquo;: 'SUCCESS', 'result': 30, 'task_id': 'f5e8...', ...}<code>).</code></li>
<li><code> Stores this data in the backend, using the</code>task_id<code>as the key (e.g., in Redis, it might set a key like</code>celery-task-meta-f5e8a3f6-c7b1-4a9e-8f0a-1b2c3d4e5f6a<code>to the JSON representation of the result data).</code></li>
<li><code> It might also set an expiry time on the result if configured (</code>result_expires<code>).</code></li>
</ul>
</li>
<li><code> **Client Checks Result:** Your application calls</code>result_add.get(timeout=10)<code>on the</code>AsyncResult<code>object.</code></li>
<li><code> **Client Queries Backend:** The</code>AsyncResult<code>object uses the</code>task_id<code>(</code>f5e8...<code>) and the configured</code>result_backend<code>URL:<ul>
<li>It connects to the Result Backend (Redis DB 1).</li>
<li>It repeatedly fetches the data associated with the</li>
</ul>
</code>task_id<code>key (e.g.,</code>GET celery-task-meta-f5e8...<code>in Redis).<ul>
<li>It checks the</li>
</ul>
</code>status<code>field in the retrieved data.<ul>
<li>If the status is</li>
</ul>
</code>PENDING<code>or</code>STARTED<code>, it waits a short interval and tries again, until the timeout is reached.<ul>
<li>If the status is</li>
</ul>
</code>SUCCESS<code>, it extracts the</code>result<code>field (</code>30<code>) and returns it.<ul>
<li>If the status is</li>
</ul>
</code>FAILURE<code>, it extracts the</code>result` field (which contains exception info), reconstructs the exception, and raises it.</li>
</ol>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client as Your Application</div>
<div class="line">    participant Task as add.delay(10, 20)</div>
<div class="line">    participant Broker as Message Broker (Redis DB 0)</div>
<div class="line">    participant Worker as Celery Worker</div>
<div class="line">    participant ResultBackend as Result Backend (Redis DB 1)</div>
<div class="line">    participant AsyncResult as result_add = AsyncResult(...)</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;Task: Call add.delay(10, 20)</div>
<div class="line">    Task-&gt;&gt;Broker: Send task message (task_id: &#39;t1&#39;)</div>
<div class="line">    Task--&gt;&gt;Client: Return AsyncResult (id=&#39;t1&#39;)</div>
<div class="line"> </div>
<div class="line">    Worker-&gt;&gt;Broker: Fetch message (task_id: &#39;t1&#39;)</div>
<div class="line">    Worker-&gt;&gt;Worker: Execute add(10, 20) -&gt; returns 30</div>
<div class="line">    Worker-&gt;&gt;ResultBackend: Store result (key=&#39;t1&#39;, value={&#39;status&#39;: &#39;SUCCESS&#39;, &#39;result&#39;: 30, ...})</div>
<div class="line">    ResultBackend--&gt;&gt;Worker: Ack (Result stored)</div>
<div class="line">    Worker-&gt;&gt;Broker: Ack message complete</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;AsyncResult: Call result_add.get(timeout=10)</div>
<div class="line">    loop Check Backend Until Ready or Timeout</div>
<div class="line">        AsyncResult-&gt;&gt;ResultBackend: Get result for key=&#39;t1&#39;</div>
<div class="line">        ResultBackend--&gt;&gt;AsyncResult: Return {&#39;status&#39;: &#39;SUCCESS&#39;, &#39;result&#39;: 30, ...}</div>
<div class="line">    end</div>
<div class="line">    AsyncResult--&gt;&gt;Client: Return 30</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1041"></a>
Code Dive: Storing and Retrieving Results</h2>
<ul>
<li><b>Backend Loading (<code>celery/app/backends.py</code>):</b> When Celery starts, it uses the <code>result_backend</code> URL to look up the correct backend class (e.g., <code>RedisBackend</code>, <code>DatabaseBackend</code>, <code>RPCBackend</code>) using functions like <code>by_url</code> and <code>by_name</code>. These map URL schemes (<code>redis://</code>, <code>db+postgresql://</code>, <code>rpc://</code>) or aliases ('redis', 'db', 'rpc') to the actual Python classes. The mapping is defined in <code>BACKEND_ALIASES</code>.</li>
<li><b>Base Classes (<code>celery/backends/base.py</code>):</b> All result backends inherit from <code>BaseBackend</code>. Many common backends (like Redis, Memcached) inherit from <code>BaseKeyValueStoreBackend</code>, which provides common logic for storing results using keys.</li>
<li><p class="startli"><b>Storing Result (<code>BaseKeyValueStoreBackend._store_result</code> in <code>celery/backends/base.py</code>):</b> This method (called by the worker) is responsible for actually saving the result.</p>
<p class="startli">``&lsquo;python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1042"></a>
Simplified from backends/base.py (inside BaseKeyValueStoreBackend)</h1>
<p>def _store_result(self, task_id, result, state, traceback=None, request=None, **kwargs): </p>
<h1><a class="anchor" id="autotoc_md1043"></a>
1. Prepare the metadata dictionary</h1>
<p>meta = self._get_result_meta(result=result, state=state, traceback=traceback, request=request) meta['task_id&rsquo;] = bytes_to_str(task_id) # Ensure task_id is str</p>
<h1><a class="anchor" id="autotoc_md1044"></a>
(Check if already successfully stored to prevent overwrites - omitted for brevity)</h1>
<h1><a class="anchor" id="autotoc_md1045"></a>
2. Encode the metadata (e.g., to JSON or pickle)</h1>
<p>encoded_meta = self.encode(meta)</p>
<h1><a class="anchor" id="autotoc_md1046"></a>
3. Get the specific key for this task</h1>
<p>key = self.get_key_for_task(task_id) # e.g., b'celery-task-meta-&lt;task_id&gt;'</p>
<h1><a class="anchor" id="autotoc_md1047"></a>
4. Call the specific backend's 'set' method (implemented by RedisBackend etc.)</h1>
<h1><a class="anchor" id="autotoc_md1048"></a>
It might also set an expiry time (self.expires)</h1>
<p>try: self._set_with_state(key, encoded_meta, state) # Calls self.set(key, encoded_meta) except Exception as exc: </p>
<h1><a class="anchor" id="autotoc_md1049"></a>
Handle potential storage errors, maybe retry</h1>
<p>raise BackendStoreError(...) from exc</p>
<p>return result # Returns the original (unencoded) result ``<code> The</code>self.set()<code>method is implemented by the concrete backend (e.g.,</code>RedisBackend.set<code>uses</code>redis-py<code>client's</code>setex<code>or</code>set` command).</p>
<ul>
<li><p class="startli"><b>Retrieving Result (<code>BaseBackend.wait_for</code> or <code>BaseKeyValueStoreBackend.get_many</code> in <code>celery/backends/base.py</code>):</b> When you call <code>AsyncResult.get()</code>, it often ends up calling <code>wait_for</code> or similar methods that poll the backend.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1050"></a>
Simplified from backends/base.py (inside SyncBackendMixin)</h1>
<p>def wait_for(self, task_id, timeout=None, interval=0.5, no_ack=True, on_interval=None): """Wait for task and return its result meta.""" self._ensure_not_eager() # Check if running in eager mode</p>
<p>time_elapsed = 0.0</p>
<p>while True: </p>
<h1><a class="anchor" id="autotoc_md1051"></a>
1. Get metadata from backend (calls self._get_task_meta_for)</h1>
<p>meta = self.get_task_meta(task_id)</p>
<h1><a class="anchor" id="autotoc_md1052"></a>
2. Check if the task is in a final state</h1>
<p>if meta['status'] in states.READY_STATES: return meta # Return the full metadata dict</p>
<h1><a class="anchor" id="autotoc_md1053"></a>
3. Call interval callback if provided</h1>
<p>if on_interval: on_interval()</p>
<h1><a class="anchor" id="autotoc_md1054"></a>
4. Sleep to avoid busy-waiting</h1>
<p>time.sleep(interval) time_elapsed += interval</p>
<h1><a class="anchor" id="autotoc_md1055"></a>
5. Check for timeout</h1>
<p>if timeout and time_elapsed &gt;= timeout: raise TimeoutError('The operation timed out.') ``<code> The</code>self.get_task_meta(task_id)<code>eventually calls</code>self._get_task_meta_for(task_id)<code>, which in</code>BaseKeyValueStoreBackend<code>uses</code>self.get(key)<code>(e.g.,</code>RedisBackend.get<code>uses</code>redis-py<code>client's</code>GET<code>command) and then decodes the result using</code>self.decode_result`.</p>
<h2><a class="anchor" id="autotoc_md1056"></a>
Conclusion</h2>
<p>You've learned about the crucial <b>Result Backend</b>:</p>
<ul>
<li>It acts as a <b>storage place</b> (like a filing cabinet or database) for task results and states.</li>
<li>It's configured using the <code>result_backend</code> setting in your <a class="el" href="../../d3/d58/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_201__celery__app.html">Celery App</a>.</li>
<li>The <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a> stores the outcome (success value or failure exception) in the backend after executing a <a class="el" href="../../d5/db8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_203__task.html">Task</a>.</li>
<li>You use the <code>AsyncResult</code> object (returned by <code>.delay()</code> or <code>.apply_async()</code>) and its methods (<code>.<a class="el" href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get()</a></code>, <code>.state</code>, <code>.ready()</code>) to query the backend using the task's unique ID.</li>
<li>Various backend types exist (Redis, Database, RPC, etc.), each with different characteristics.</li>
</ul>
<p>Result backends allow your application to track the progress and outcome of background work. But what if you want tasks to run automatically at specific times or on a regular schedule, like sending a report every morning? That's where Celery's scheduler comes in.</p>
<p><b>Next:</b> <a class="el" href="../../dd/d67/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_207__beat____scheduler__.html">Chapter 7: Beat (Scheduler)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
