#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 02_memtable</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">02_memtable</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2258"></a>
autotoc_md2258</h2>
<p>layout: default title: "MemTable" parent: "LevelDB" </p>
<h2><a class="anchor" id="autotoc_md2259"></a>
nav_order: 2</h2>
<h1><a class="anchor" id="autotoc_md2260"></a>
Chapter 2: MemTable</h1>
<p>In <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">Chapter 1: Table / SSTable &amp; TableCache</a>, we learned how LevelDB stores the bulk of its data permanently on disk in sorted, immutable files called SSTables. We also saw how the <code>TableCache</code> helps access these files efficiently.</p>
<p>But imagine you're updating your data frequently – adding new users, changing scores, deleting temporary items. Writing every tiny change directly to a new SSTable file on disk would be incredibly slow, like carving every single note onto a stone tablet! We need a faster way to handle recent changes.</p>
<h2><a class="anchor" id="autotoc_md2261"></a>
What's the Problem? Slow Disk Writes for Every Change</h2>
<p>Disk drives (even fast SSDs) are much slower than your computer's main memory (RAM). If LevelDB wrote every <code>Put</code> or <code>Delete</code> operation straight to an SSTable file, your application would constantly be waiting for the disk, making it feel sluggish.</p>
<p>How can we accept new writes quickly but still eventually store them permanently on disk?</p>
<h2><a class="anchor" id="autotoc_md2262"></a>
MemTable: The Fast In-Memory Notepad</h2>
<p>LevelDB's solution is the <b>MemTable</b>. Think of it as a <b>temporary notepad</b> or a <b>scratchpad</b> that lives entirely in your computer's fast RAM.</p>
<ol type="1">
<li><b>In-Memory:</b> It's stored in RAM, making reads and writes extremely fast.</li>
<li><b>Holds Recent Writes:</b> When you <code>Put</code> a new key-value pair or <code>Delete</code> a key, the change goes into the MemTable first.</li>
<li><b>Sorted:</b> Just like SSTables, the data inside the MemTable is kept sorted by key. This is important for efficiency later.</li>
<li><b>Temporary:</b> It's only a temporary holding area. Eventually, its contents get written out to a permanent SSTable file on disk.</li>
</ol>
<p>So, when you write data:</p>
<p><em>Your Application</em> -&gt; <code>Put("user123", "data")</code> -&gt; <b>MemTable</b> (Fast RAM write!)</p>
<p>This makes write operations feel almost instantaneous to your application.</p>
<h2><a class="anchor" id="autotoc_md2263"></a>
How Reads Use the MemTable</h2>
<p>When you try to read data using <code>Get(key)</code>, LevelDB is smart. It knows the most recent data might still be on the "notepad" (MemTable). So, it checks there <em>first</em>:</p>
<ol type="1">
<li><b>Check MemTable:</b> Look for the key in the current MemTable.<ul>
<li>If the key is found, return the value immediately (super fast!).</li>
<li>If a "deletion marker" for the key is found, stop and report "Not Found" (the key was recently deleted).</li>
</ul>
</li>
<li><b>Check Older MemTable (Immutable):</b> If there's an older MemTable being flushed (we'll cover this next), check that too.</li>
<li><b>Check SSTables:</b> If the key wasn't found in memory (or wasn't deleted there), <em>then</em> LevelDB looks for it in the SSTable files on disk, using the <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">Table / SSTable &amp; TableCache</a> we learned about in Chapter 1.</li>
</ol>
<p>This "check memory first" strategy ensures that you always read the most up-to-date value, even if it hasn't hit the disk yet.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client as App Read (Get)</div>
<div class="line">    participant LevelDB</div>
<div class="line">    participant MemTable as Active MemTable (RAM)</div>
<div class="line">    participant ImMemTable as Immutable MemTable (RAM, if exists)</div>
<div class="line">    participant TableCache as SSTable Cache (Disk/RAM)</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;LevelDB: Get(&quot;some_key&quot;)</div>
<div class="line">    LevelDB-&gt;&gt;MemTable: Have &quot;some_key&quot;?</div>
<div class="line">    alt Key found in Active MemTable</div>
<div class="line">        MemTable--&gt;&gt;LevelDB: Yes, value is &quot;xyz&quot;</div>
<div class="line">        LevelDB--&gt;&gt;Client: Return &quot;xyz&quot;</div>
<div class="line">    else Key Deleted in Active MemTable</div>
<div class="line">        MemTable--&gt;&gt;LevelDB: Yes, it&#39;s deleted</div>
<div class="line">        LevelDB--&gt;&gt;Client: Return NotFound</div>
<div class="line">    else Not in Active MemTable</div>
<div class="line">        MemTable--&gt;&gt;LevelDB: No</div>
<div class="line">        LevelDB-&gt;&gt;ImMemTable: Have &quot;some_key&quot;?</div>
<div class="line">        alt Key found in Immutable MemTable</div>
<div class="line">             ImMemTable--&gt;&gt;LevelDB: Yes, value is &quot;abc&quot;</div>
<div class="line">             LevelDB--&gt;&gt;Client: Return &quot;abc&quot;</div>
<div class="line">        else Key Deleted in Immutable MemTable</div>
<div class="line">             ImMemTable--&gt;&gt;LevelDB: Yes, it&#39;s deleted</div>
<div class="line">             LevelDB--&gt;&gt;Client: Return NotFound</div>
<div class="line">        else Not in Immutable MemTable</div>
<div class="line">            ImMemTable--&gt;&gt;LevelDB: No</div>
<div class="line">            LevelDB-&gt;&gt;TableCache: Get(&quot;some_key&quot;) from SSTables</div>
<div class="line">            TableCache--&gt;&gt;LevelDB: Found &quot;old_value&quot; / NotFound</div>
<div class="line">            LevelDB--&gt;&gt;Client: Return &quot;old_value&quot; / NotFound</div>
<div class="line">        end</div>
<div class="line">    end</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2264"></a>
What Happens When the Notepad Fills Up?</h2>
<p>The MemTable lives in RAM, which is limited. We can't just keep adding data to it forever. LevelDB has a configured size limit for the MemTable ( <code>options.write_buffer_size</code>, often a few megabytes).</p>
<p>When the MemTable gets close to this size:</p>
<ol type="1">
<li><b>Freeze!</b> LevelDB declares the current MemTable "immutable" (meaning read-only). No new writes go into this specific MemTable anymore. Let's call it <code>imm_</code> (Immutable MemTable).</li>
<li><b>New Notepad:</b> LevelDB immediately creates a <em>new</em>, empty MemTable (<code>mem_</code>) to accept incoming writes. Your application doesn't pause; new writes just start going to the fresh MemTable.</li>
<li><b>Flush to Disk:</b> A background task starts working on the frozen <code>imm_</code>. It reads all the sorted key-value pairs from <code>imm_</code> and uses the <code>BuildTable</code> process (from <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">Chapter 1</a>) to write them into a brand new SSTable file on disk. This new file becomes part of "Level-0" (we'll learn more about levels in <a class="el" href="../../df/d5d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_208__compaction.html">Chapter 8: Compaction</a>).</li>
<li><b>Discard:</b> Once the <code>imm_</code> is successfully written to the SSTable file, the in-memory <code>imm_</code> is discarded, freeing up RAM.</li>
</ol>
<p>This process ensures that writes are always fast (going to the <em>new</em> <code>mem_</code>) while the <em>old</em> data is efficiently flushed to disk in the background.</p>
<div class="fragment"><div class="line">graph TD</div>
<div class="line">    subgraph Writes</div>
<div class="line">        A[Incoming Writes: Put/Delete] --&gt; B(Active MemTable mem_);</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    subgraph MemTable Full</div>
<div class="line">        B -- Reaches Size Limit --&gt; C{Freeze mem_ -&gt; becomes imm_};</div>
<div class="line">        C --&gt; D(Create New Empty mem_);</div>
<div class="line">        A --&gt; D;</div>
<div class="line">        C --&gt; E{Background Flush};</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    subgraph Background Flush</div>
<div class="line">        E -- Reads Data --&gt; F(Immutable MemTable imm_);</div>
<div class="line">        F -- Uses BuildTable --&gt; G([Level-0 SSTable on Disk]);</div>
<div class="line">        G -- Flush Complete --&gt; H{Discard imm_};</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    style G fill:#f9f,stroke:#333,stroke-width:2px</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2265"></a>
Under the Hood: Keeping it Sorted with a SkipList</h2>
<p>We mentioned that the MemTable keeps keys sorted. Why?</p>
<ol type="1">
<li><b>Efficient Flushing:</b> When flushing the MemTable to an SSTable, the data needs to be written in sorted order. If the MemTable is already sorted, this is very efficient – we just read through it sequentially.</li>
<li><b>Efficient Reads:</b> Keeping it sorted allows for faster lookups within the MemTable itself.</li>
</ol>
<p>How does LevelDB keep the MemTable sorted while allowing fast inserts? It uses a clever data structure called a <b>SkipList</b>.</p>
<p>Imagine a sorted linked list. To find an element, you might have to traverse many nodes. Now, imagine adding some "express lanes" (higher-level links) that skip over several nodes at a time. You can use these express lanes to quickly get close to your target, then drop down to the detailed level (the base list) to find the exact spot. This is the core idea of a SkipList!</p>
<ul>
<li><b>Fast Inserts:</b> Adding a new item is generally fast.</li>
<li><b>Fast Lookups:</b> Finding an item is much faster than a simple linked list, often close to the speed of more complex balanced trees.</li>
<li><b>Efficient Iteration:</b> Reading all items in sorted order (needed for flushing) is straightforward.</li>
</ul>
<p>The MemTable essentially wraps a SkipList provided by <code>skiplist.h</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/memtable.h ---</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;db/skiplist.h&quot;</span> <span class="comment">// The SkipList data structure</span></div>
<div class="line"><span class="preprocessor">#include &quot;util/arena.h&quot;</span>   <span class="comment">// Memory allocator</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MemTable {</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// The core data structure: a SkipList.</span></div>
<div class="line">  <span class="comment">// The Key is &#39;const char*&#39; pointing into the Arena.</span></div>
<div class="line">  <span class="comment">// KeyComparator helps compare keys correctly (we&#39;ll see this later).</span></div>
<div class="line">  <span class="keyword">typedef</span> SkipList&lt;const char*, KeyComparator&gt; Table;</div>
<div class="line"> </div>
<div class="line">  Arena arena_;   <span class="comment">// Allocates memory for nodes efficiently</span></div>
<div class="line">  Table table_;   <span class="comment">// The actual SkipList instance</span></div>
<div class="line">  <span class="keywordtype">int</span> refs_;      <span class="comment">// Reference count for managing lifetime</span></div>
<div class="line">  <span class="comment">// ... other members like KeyComparator ...</span></div>
<div class="line"> </div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Add an entry (Put or Delete marker)</span></div>
<div class="line">  <span class="keywordtype">void</span> Add(SequenceNumber seq, ValueType type, <span class="keyword">const</span> Slice&amp; key,</div>
<div class="line">           <span class="keyword">const</span> Slice&amp; value);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Look up a key</span></div>
<div class="line">  <span class="keywordtype">bool</span> Get(<span class="keyword">const</span> LookupKey&amp; key, std::string* value, Status* s);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create an iterator to scan the MemTable&#39;s contents</span></div>
<div class="line">  Iterator* NewIterator();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Estimate memory usage</span></div>
<div class="line">  <span class="keywordtype">size_t</span> ApproximateMemoryUsage();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constructor, Ref/Unref omitted for brevity...</span></div>
<div class="line">};</div>
</div><!-- fragment --><p>This header shows the <code>MemTable</code> class uses an <code>Arena</code> for memory management and a <code>Table</code> (which is a <code>SkipList</code>) to store the data.</p>
<h2><a class="anchor" id="autotoc_md2266"></a>
Adding and Getting Data (Code View)</h2>
<p>Let's look at simplified versions of <code>Add</code> and <code>Get</code>.</p>
<p><b>Adding an Entry:</b></p>
<p>When you call <code>db-&gt;Put(key, value)</code> or <code>db-&gt;Delete(key)</code>, it eventually calls <code>MemTable::Add</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/memtable.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MemTable::Add(SequenceNumber s, ValueType type, <span class="keyword">const</span> Slice&amp; key,</div>
<div class="line">                   <span class="keyword">const</span> Slice&amp; value) {</div>
<div class="line">  <span class="comment">// Calculate size needed for the entry in the skiplist.</span></div>
<div class="line">  <span class="comment">// Format includes key size, key, sequence number + type tag, value size, value.</span></div>
<div class="line">  <span class="keywordtype">size_t</span> key_size = key.size();</div>
<div class="line">  <span class="keywordtype">size_t</span> val_size = value.size();</div>
<div class="line">  <span class="keywordtype">size_t</span> internal_key_size = key_size + 8; <span class="comment">// 8 bytes for seq + type</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> encoded_len = VarintLength(internal_key_size) +</div>
<div class="line">                             internal_key_size + VarintLength(val_size) +</div>
<div class="line">                             val_size;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Allocate memory from the Arena</span></div>
<div class="line">  <span class="keywordtype">char</span>* buf = arena_.Allocate(encoded_len);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Encode the entry into the buffer &#39;buf&#39; (details omitted)</span></div>
<div class="line">  <span class="comment">// Format: [key_len][key_bytes][seq_num|type][value_len][value_bytes]</span></div>
<div class="line">  <span class="comment">// ... encoding logic ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Insert the buffer pointer into the SkipList. The SkipList uses the</span></div>
<div class="line">  <span class="comment">// KeyComparator to know how to sort based on the encoded format.</span></div>
<div class="line">  table_.Insert(buf);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Calculate Size:</b> Determines how much memory is needed to store the key, value, sequence number, and type. (We'll cover sequence numbers and internal keys in <a class="el" href="../../d6/d38/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_209__internalkey______dbformat.html">Chapter 9</a>).</li>
<li><b>Allocate:</b> Gets a chunk of memory from the <code>Arena</code>. Arenas are efficient allocators for many small objects with similar lifetimes.</li>
<li><b>Encode:</b> Copies the key, value, and metadata into the allocated buffer (<code>buf</code>).</li>
<li><b>Insert:</b> Calls <code>table_.Insert(buf)</code>, where <code>table_</code> is the SkipList. The SkipList takes care of finding the correct sorted position and linking the new entry.</li>
</ol>
<p><b>Getting an Entry:</b></p>
<p>When you call <code>db-&gt;Get(key)</code>, it checks the MemTable first using <code>MemTable::Get</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/memtable.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">bool</span> MemTable::Get(<span class="keyword">const</span> LookupKey&amp; lkey, std::string* value, Status* s) {</div>
<div class="line">  <span class="comment">// Get the specially formatted key to search for in the MemTable.</span></div>
<div class="line">  Slice memkey = lkey.memtable_key();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create an iterator for the SkipList.</span></div>
<div class="line">  Table::Iterator iter(&amp;table_);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Seek to the first entry &gt;= the key we are looking for.</span></div>
<div class="line">  iter.Seek(memkey.data());</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (iter.Valid()) { <span class="comment">// Did we find something at or after our key?</span></div>
<div class="line">    <span class="comment">// Decode the key found in the SkipList</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">char</span>* entry = iter.key();</div>
<div class="line">    <span class="comment">// ... decode logic to get user_key, sequence, type ...</span></div>
<div class="line">    Slice found_user_key = <span class="comment">/* decoded user key */</span>;</div>
<div class="line">    ValueType found_type = <span class="comment">/* decoded type */</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Check if the user key matches exactly</span></div>
<div class="line">    <span class="keywordflow">if</span> (comparator_.comparator.user_comparator()-&gt;Compare(</div>
<div class="line">            found_user_key, lkey.user_key()) == 0) {</div>
<div class="line">      <span class="comment">// It&#39;s the right key! Check the type.</span></div>
<div class="line">      <span class="keywordflow">if</span> (found_type == kTypeValue) { <span class="comment">// Is it a Put record?</span></div>
<div class="line">        <span class="comment">// Decode the value and return it</span></div>
<div class="line">        Slice v = <span class="comment">/* decoded value */</span>;</div>
<div class="line">        value-&gt;assign(v.data(), v.size());</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// Found the value!</span></div>
<div class="line">      } <span class="keywordflow">else</span> { <span class="comment">// Must be kTypeDeletion</span></div>
<div class="line">        <span class="comment">// Found a deletion marker for this key. Report &quot;NotFound&quot;.</span></div>
<div class="line">        *s = Status::NotFound(Slice());</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>; <span class="comment">// Found a deletion!</span></div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Key not found in this MemTable</span></div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Get Search Key:</b> Prepares the key in the format used internally by the MemTable (<code>LookupKey</code>).</li>
<li><b>Create Iterator:</b> Gets a <code>SkipList::Iterator</code>.</li>
<li><b>Seek:</b> Uses the iterator's <code>Seek</code> method to efficiently find the first entry in the SkipList whose key is greater than or equal to the search key.</li>
<li><b>Check Found Entry:</b> If <code>Seek</code> finds an entry (<code>iter.Valid()</code>):<ul>
<li>It decodes the entry found in the SkipList.</li>
<li>It compares the <em>user</em> part of the key to ensure it's an exact match (not just the next key in sorted order).</li>
<li>If the keys match, it checks the <code>type</code>:<ul>
<li>If it's <code>kTypeValue</code>, it decodes the value and returns <code>true</code>.</li>
<li>If it's <code>kTypeDeletion</code>, it sets the status to <code>NotFound</code> and returns <code>true</code> (indicating we found definitive information about the key – it's deleted).</li>
</ul>
</li>
</ul>
</li>
<li><b>Not Found:</b> If no matching key is found, it returns <code>false</code>.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2267"></a>
Conclusion</h2>
<p>The <b>MemTable</b> is LevelDB's crucial in-memory cache for recent writes. It acts like a fast notepad:</p>
<ul>
<li>Accepts new <code>Put</code> and <code>Delete</code> operations quickly in RAM.</li>
<li>Keeps entries sorted using an efficient <b>SkipList</b>.</li>
<li>Allows recent data to be read quickly without touching the disk.</li>
<li>When full, it's frozen, flushed to a new Level-0 <b>SSTable</b> file on disk in the background, and then discarded.</li>
</ul>
<p>This design allows LevelDB to provide very fast write performance while still ensuring data is eventually persisted safely to disk.</p>
<p>However, what happens if the power goes out <em>after</em> data is written to the MemTable but <em>before</em> it's flushed to an SSTable? Isn't the data in RAM lost? To solve this, LevelDB uses another component alongside the MemTable: the Write-Ahead Log (WAL).</p>
<p>Next up: <a class="el" href="../../df/d85/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_203__write__ahead__log____wal________logwriter__logreader.html">Chapter 3: Write-Ahead Log (WAL) &amp; LogWriter/LogReader</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
