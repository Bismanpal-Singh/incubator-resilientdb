#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_tool</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_203__tool.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_tool</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md3059"></a>
autotoc_md3059</h2>
<p>layout: default title: "Tool" parent: "SmolaAgents" </p>
<h2><a class="anchor" id="autotoc_md3060"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md3061"></a>
Chapter 3: Tool - Giving Your Agent Superpowers</h1>
<p>Welcome back! In <a class="el" href="../../dc/db5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_202__model__interface.html">Chapter 2: Model Interface</a>, we learned how our <code>MultiStepAgent</code> uses a "universal remote" (the Model Interface) to talk to its LLM "brain". The LLM thinks and suggests what the agent should do next.</p>
<p>But how does the agent actually <em>do</em> things? If the LLM suggests "Search the web for the capital of France," how does the agent perform the search? It can't just magically type into Google!</p>
<p>This is where <b>Tools</b> come in. They are the agent's hands and specialized equipment, allowing it to interact with the world beyond just generating text.</p>
<h2><a class="anchor" id="autotoc_md3062"></a>
The Problem: An Agent Trapped in its Mind</h2>
<p>Imagine a brilliant chef who only knows recipes but is locked in an empty room. They can tell you exactly how to make a perfect souffl√©, step-by-step, but they can't actually <em>do</em> any of it. They have no ingredients, no oven, no whisk, no bowls. They're stuck!</p>
<p><img src="https://img.icons8.com/ios/50/000000/cook-male--v1.png" alt="Chef Thinking" class="inline"/> ü§î -&gt; üìù Recipe (Think)</p>
<p>An agent without tools is like that chef. The LLM brain can reason and plan ("I need to search the web"), but the agent itself has no way to execute that plan ("How do I *actually* search?").</p>
<h2><a class="anchor" id="autotoc_md3063"></a>
The Solution: The Agent's Toolbox</h2>
<p>Tools are specific capabilities we give to our agent. Think of them like the utensils and appliances in a kitchen drawer:</p>
<ul>
<li><b>Peeler:</b> Used for peeling vegetables.</li>
<li><b>Whisk:</b> Used for mixing ingredients.</li>
<li><b>Oven:</b> Used for baking.</li>
<li><b>Search Engine Tool:</b> Used for searching the web.</li>
<li><b>Calculator Tool:</b> Used for performing calculations.</li>
<li><b>Code Execution Tool:</b> Used for running computer code.</li>
</ul>
<p><img src="https://img.icons8.com/plasticine/100/toolbox.png" alt="Toolbox" class="inline"/> -&gt; üîé Search, üíª Code Runner, ‚òÅÔ∏è Weather API</p>
<p>Each tool is a reusable function that the agent can call upon to perform a specific action. The agent acts like the chef, looking at the next step in the recipe (the LLM's suggestion) and picking the right tool from its toolbox.</p>
<h2><a class="anchor" id="autotoc_md3064"></a>
What Makes a Tool?</h2>
<p>Every tool in <code>SmolaAgents</code> needs a few key pieces of information so the agent (and the LLM helping it) can understand it:</p>
<ol type="1">
<li><b><code>name</code></b>: A short, descriptive name for the tool (e.g., <code>web_search</code>, <code>calculator</code>). This is how the agent identifies which tool to use.</li>
<li><b><code>description</code></b>: A clear explanation of what the tool does, what it's good for, and what information it needs. This helps the LLM decide <em>when</em> to suggest using this tool. Example: <em>"Performs a web search using DuckDuckGo and returns the top results."</em></li>
<li><b><code>inputs</code></b>: Defines what information the tool needs to do its job. This is like specifying that a peeler needs a vegetable, or a calculator needs numbers and an operation. It's defined as a dictionary where keys are argument names and values describe the type and purpose. Example: <code>{"query": {"type": "string", "description": "The search query"}}</code>.</li>
<li><b><code>output_type</code></b>: Describes the type of result the tool will return (e.g., <code>string</code>, <code>number</code>, <code>image</code>).</li>
<li><b><code>forward</code> method</b>: This is the actual Python code that gets executed when the tool is used. It takes the defined <code>inputs</code> as arguments and performs the tool's action, returning the result.</li>
</ol>
<h2><a class="anchor" id="autotoc_md3065"></a>
Creating Your First Tool: The <code>GreetingTool</code></h2>
<p>Let's build a very simple tool. Imagine we want our agent to be able to greet someone by name.</p>
<p>We'll create a <code>GreetingTool</code> by inheriting from the base <code>Tool</code> class provided by <code>SmolaAgents</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: simple_tools.py ---</span></div>
<div class="line"><span class="keyword">from</span> smolagents <span class="keyword">import</span> Tool <span class="comment"># Import the base class</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>GreetingTool(Tool):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;A simple tool that generates a greeting.&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># 1. Give it a unique name</span></div>
<div class="line">    name: str = <span class="stringliteral">&quot;greet_person&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># 2. Describe what it does clearly</span></div>
<div class="line">    description: str = <span class="stringliteral">&quot;Greets a person by their name.&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># 3. Define the inputs it needs</span></div>
<div class="line">    <span class="comment"># It needs one input: the &#39;name&#39; of the person, which should be a string.</span></div>
<div class="line">    inputs: dict = {</div>
<div class="line">        <span class="stringliteral">&quot;name&quot;</span>: {</div>
<div class="line">            <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;string&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;The name of the person to greet.&quot;</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># 4. Specify the type of the output</span></div>
<div class="line">    <span class="comment"># It will return the greeting as a string.</span></div>
<div class="line">    output_type: str = <span class="stringliteral">&quot;string&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># 5. Implement the action in the &#39;forward&#39; method</span></div>
<div class="line">    <span class="keyword">def </span>forward(self, name: str) -&gt; str:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;The actual code that runs when the tool is called.&quot;&quot;&quot;</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;--- GreetingTool activated with name: {name} ---&quot;</span>)</div>
<div class="line">        greeting = f<span class="stringliteral">&quot;Hello, {name}! Nice to meet you.&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> greeting</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Let&#39;s test it quickly (outside the agent context)</span></div>
<div class="line">greeter = GreetingTool()</div>
<div class="line">result = greeter(name=<span class="stringliteral">&quot;Alice&quot;</span>) <span class="comment"># Calling the tool instance</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Tool returned: &#39;{result}&#39;&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># --- GreetingTool activated with name: Alice ---</span></div>
<div class="line"><span class="comment"># Tool returned: &#39;Hello, Alice! Nice to meet you.&#39;</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Import:</b> We import the base <code>Tool</code> class.</li>
<li><b>Class Definition:</b> We define <code>GreetingTool</code> inheriting from <code>Tool</code>.</li>
<li><b>Attributes:</b> We set the required class attributes: <code>name</code>, <code>description</code>, <code>inputs</code>, and <code>output_type</code>. These tell the agent everything it needs to know <em>about</em> the tool without running it.</li>
<li><b><code>forward</code> Method:</b> This method contains the core logic. It takes the <code>name</code> (defined in <code>inputs</code>) as an argument and returns the greeting string. We added a <code>print</code> statement just to see when it runs.</li>
<li><b>Testing:</b> We create an instance <code>greeter</code> and call it like a function, passing the required argument <code>name="Alice"</code>. It executes the <code>forward</code> method and returns the result.</li>
</ol>
<p>This <code>GreetingTool</code> is now ready to be added to an agent's toolbox!</p>
<h2><a class="anchor" id="autotoc_md3066"></a>
Adding the Tool to Your Agent</h2>
<p>Remember how we created our <code>MultiStepAgent</code> in <a class="el" href="../../dc/d92/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_201__multistepagent.html">Chapter 1</a>? We gave it a model and a list of tools. Let's add our new <code>GreetingTool</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: agent_with_greeting.py ---</span></div>
<div class="line"><span class="comment"># (Assuming GreetingTool is defined as above or imported)</span></div>
<div class="line"><span class="comment"># from simple_tools import GreetingTool</span></div>
<div class="line"><span class="keyword">from</span> smolagents <span class="keyword">import</span> MultiStepAgent</div>
<div class="line"><span class="keyword">from</span> smolagents.models <span class="keyword">import</span> LiteLLMModel <span class="comment"># From Chapter 2</span></div>
<div class="line"><span class="comment"># Potentially other tools like SearchTool etc.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 1. Create an instance of our new tool</span></div>
<div class="line">greeting_tool = GreetingTool()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 2. Create instances of any other tools the agent might need</span></div>
<div class="line"><span class="comment"># search_tool = SearchTool() # Example from Chapter 1</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 3. Choose a language model (the &quot;brain&quot;)</span></div>
<div class="line">llm = LiteLLMModel(model_id=<span class="stringliteral">&quot;gpt-3.5-turbo&quot;</span>) <span class="comment"># Needs API key setup</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 4. Create the MultiStepAgent, passing the tool(s) in a list</span></div>
<div class="line">agent = MultiStepAgent(</div>
<div class="line">    model=llm,</div>
<div class="line">    tools=[greeting_tool] <span class="comment"># Add our tool here! Maybe add search_tool too?</span></div>
<div class="line">    <span class="comment"># tools=[greeting_tool, search_tool]</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;Agent created with GreetingTool!&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 5. Give the agent a task that might use the tool</span></div>
<div class="line">task = <span class="stringliteral">&quot;Greet the user named Bob.&quot;</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Running agent with task: &#39;{task}&#39;&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># The agent will now start its Think-Act-Observe cycle...</span></div>
<div class="line">final_answer = agent.run(task)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;-&quot;</span> * 20)</div>
<div class="line">print(f<span class="stringliteral">&quot;Final Answer received: {final_answer}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Expected Interaction (Simplified) ---</span></div>
<div class="line"><span class="comment"># Agent (thinks): The task is to greet Bob. I have a &#39;greet_person&#39; tool.</span></div>
<div class="line"><span class="comment"># Agent (acts): Use tool &#39;greet_person&#39; with input name=&quot;Bob&quot;.</span></div>
<div class="line"><span class="comment"># --- GreetingTool activated with name: Bob --- (Our print statement)</span></div>
<div class="line"><span class="comment"># Agent (observes): Tool returned &quot;Hello, Bob! Nice to meet you.&quot;</span></div>
<div class="line"><span class="comment"># Agent (thinks): I have the greeting. That completes the task.</span></div>
<div class="line"><span class="comment"># Agent (acts): Use &#39;final_answer&#39; tool with &quot;Hello, Bob! Nice to meet you.&quot;</span></div>
<div class="line"><span class="comment"># --------------------</span></div>
<div class="line"><span class="comment"># Final Answer received: Hello, Bob! Nice to meet you.</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>We create an instance of <code>GreetingTool</code>.</li>
<li>We put this instance into the <code>tools</code> list when initializing <code>MultiStepAgent</code>.</li>
<li>The agent now "knows" about the <code>greet_person</code> tool, its description, and how to use it (via its <code>name</code> and <code>inputs</code>).</li>
<li>When we run the <code>agent</code> with the task "Greet the user named Bob," the LLM (using the tool descriptions provided in the prompt) will likely recognize that the <code>greet_person</code> tool is perfect for this.</li>
<li>The agent will then execute the <code>greeting_tool.forward(name="Bob")</code> method during its "Act" phase.</li>
</ol>
<h2><a class="anchor" id="autotoc_md3067"></a>
How the Agent Uses Tools: Under the Hood</h2>
<p>Let's revisit the <b>Think -&gt; Act -&gt; Observe</b> cycle from <a class="el" href="../../dc/d92/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_201__multistepagent.html">Chapter 1</a> and see exactly where tools fit in.</p>
<ol type="1">
<li><b>Think:</b> The agent gathers its history (<a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">AgentMemory</a>) and the available tool descriptions. It sends this to the LLM via the <a class="el" href="../../dc/db5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_202__model__interface.html">Model Interface</a> asking, "What should I do next to accomplish the task 'Greet Bob'?" The LLM, seeing the <code>greet_person</code> tool description, might respond with something like: <code>json { "thought": "The user wants me to greet Bob. I should use the 'greet_person' tool.", "action": "greet_person", "action_input": {"name": "Bob"} } </code> <em>(Note: The exact format depends on the agent type and model. Some models use explicit tool-calling formats like the one shown in Chapter 2's <code>ToolCallingAgent</code> example output).</em></li>
<li><b>Act:</b> The <code>MultiStepAgent</code> receives this response.<ul>
<li>It parses the response to identify the intended <code>action</code> (<code>greet_person</code>) and the <code>action_input</code> (<code>{"name": "Bob"}</code>).</li>
<li>It looks up the tool named <code>greet_person</code> in its <code>self.tools</code> dictionary.</li>
<li>It calls the <code>forward</code> method of that tool instance, passing the arguments from <code>action_input</code>. In our case: <code>greeting_tool.forward(name="Bob")</code>.</li>
<li>This executes our Python code inside the <code>forward</code> method.</li>
</ul>
</li>
<li><b>Observe:</b> The agent captures the return value from the <code>forward</code> method (e.g., <code>"Hello, Bob! Nice to meet you."</code>). This becomes the "observation" for this step.<ul>
<li>This observation is stored in the <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">AgentMemory</a>.</li>
<li>The cycle repeats: The agent thinks again, now considering the result of the greeting tool. It likely decides the task is complete and uses the built-in <code>final_answer</code> tool.</li>
</ul>
</li>
</ol>
<p>Here's a simplified diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Agent as MultiStepAgent</div>
<div class="line">    participant LLM as LLM Brain</div>
<div class="line">    participant GreetTool as GreetingTool</div>
<div class="line"> </div>
<div class="line">    Agent-&gt;&gt;LLM: Task: Greet Bob. Tools: [greet_person]. What next?</div>
<div class="line">    LLM--&gt;&gt;Agent: Use tool &#39;greet_person&#39; with name=&#39;Bob&#39;</div>
<div class="line">    Agent-&gt;&gt;GreetTool: forward(name=&quot;Bob&quot;)</div>
<div class="line">    GreetTool--&gt;&gt;Agent: &quot;Hello, Bob! Nice to meet you.&quot; (Observation)</div>
<div class="line">    Agent-&gt;&gt;LLM: Observation: &quot;Hello, Bob!...&quot; Task done?</div>
<div class="line">    LLM--&gt;&gt;Agent: Use tool &#39;final_answer&#39; with &quot;Hello, Bob!...&quot;</div>
<div class="line">    Agent--&gt;&gt;User: &quot;Hello, Bob! Nice to meet you.&quot;</div>
</div><!-- fragment --><p><b>Code Glimpse (Simplified <code>execute_tool_call</code>):</b></p>
<p>Inside the <code>agents.py</code> file (specifically within agent types like <code>ToolCallingAgent</code>), there's logic similar to this (heavily simplified):</p>
<div class="fragment"><div class="line"><span class="comment"># --- Simplified concept from agents.py ---</span></div>
<div class="line"><span class="keyword">class </span>SomeAgentType(MultiStepAgent):</div>
<div class="line">    <span class="comment"># ... other methods ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>execute_tool_call(self, tool_name: str, arguments: dict) -&gt; Any:</div>
<div class="line">        <span class="comment"># Find the tool in the agent&#39;s toolbox</span></div>
<div class="line">        <span class="keywordflow">if</span> tool_name <span class="keywordflow">in</span> self.tools:</div>
<div class="line">            tool_instance = self.tools[tool_name]</div>
<div class="line">            <span class="keywordflow">try</span>:</div>
<div class="line">                <span class="comment"># Call the tool&#39;s forward method with the arguments!</span></div>
<div class="line">                <span class="comment"># This is where GreetingTool.forward(name=&quot;Bob&quot;) happens.</span></div>
<div class="line">                result = tool_instance(**arguments) <span class="comment"># Uses ** to unpack the dict</span></div>
<div class="line">                <span class="keywordflow">return</span> result</div>
<div class="line">            <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">                <span class="comment"># Handle errors if the tool fails</span></div>
<div class="line">                print(f<span class="stringliteral">&quot;Error executing tool {tool_name}: {e}&quot;</span>)</div>
<div class="line">                <span class="keywordflow">return</span> f<span class="stringliteral">&quot;Error: Tool {tool_name} failed.&quot;</span></div>
<div class="line">        <span class="comment"># ... handle case where tool_name is not found ...</span></div>
<div class="line">        <span class="keywordflow">elif</span> tool_name == <span class="stringliteral">&quot;final_answer&quot;</span>:</div>
<div class="line">             <span class="comment"># Special handling for the final answer</span></div>
<div class="line">             <span class="keywordflow">return</span> arguments.get(<span class="stringliteral">&quot;answer&quot;</span>, arguments) <span class="comment"># Return the final answer content</span></div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            <span class="keywordflow">return</span> f<span class="stringliteral">&quot;Error: Unknown tool {tool_name}.&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>step(self, memory_step: ActionStep):</div>
<div class="line">        <span class="comment"># ... (Agent thinks and gets LLM response) ...</span></div>
<div class="line">        llm_response = <span class="comment"># ... result from self.model(...) ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> llm_response suggests a tool call:</div>
<div class="line">             tool_name = <span class="comment"># ... parse tool name from response ...</span></div>
<div class="line">             arguments = <span class="comment"># ... parse arguments from response ...</span></div>
<div class="line"> </div>
<div class="line">             <span class="comment"># === ACT ===</span></div>
<div class="line">             observation = self.execute_tool_call(tool_name, arguments)</div>
<div class="line">             memory_step.observations = str(observation) <span class="comment"># Store observation</span></div>
<div class="line"> </div>
<div class="line">             <span class="keywordflow">if</span> tool_name == <span class="stringliteral">&quot;final_answer&quot;</span>:</div>
<div class="line">                 <span class="keywordflow">return</span> observation <span class="comment"># Signal that this is the final answer</span></div>
<div class="line">        <span class="comment"># ... (handle cases where LLM gives text instead of tool call) ...</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keywordtype">None</span> <span class="comment"># Not the final answer yet</span></div>
</div><!-- fragment --><p>This shows the core idea: the agent gets the <code>tool_name</code> and <code>arguments</code> from the LLM, finds the corresponding <code>Tool</code> object, and calls its <code>forward</code> method using the arguments.</p>
<h2><a class="anchor" id="autotoc_md3068"></a>
Common Built-in Tools</h2>
<p><code>SmolaAgents</code> comes with several useful tools ready to use (found in <code>default_tools.py</code>):</p>
<ul>
<li><b><code>DuckDuckGoSearchTool</code> (<code>web_search</code>)</b>: Searches the web using DuckDuckGo.</li>
<li><b><code>PythonInterpreterTool</code> (<code>python_interpreter</code>)</b>: Executes Python code snippets safely. Very powerful for calculations, data manipulation, etc. (Used primarily by <code>CodeAgent</code>, see <a class="el" href="../../df/dec/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_206__pythonexecutor.html">Chapter 6: PythonExecutor</a>).</li>
<li><b><code>VisitWebpageTool</code> (<code>visit_webpage</code>)</b>: Fetches the content of a webpage URL.</li>
<li><b><code>FinalAnswerTool</code> (<code>final_answer</code>)</b>: A special, essential tool. The agent uses this <em>only</em> when it believes it has completed the task and has the final result. Calling this tool usually ends the agent's run. It's automatically added to every agent.</li>
</ul>
<p>You can import and use these just like we used our <code>GreetingTool</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> smolagents.tools <span class="keyword">import</span> DuckDuckGoSearchTool, FinalAnswerTool <span class="comment"># FinalAnswerTool is usually added automatically</span></div>
<div class="line"> </div>
<div class="line">search_tool = DuckDuckGoSearchTool()</div>
<div class="line"><span class="comment"># calculator_tool = PythonInterpreterTool() # Often used internally by CodeAgent</span></div>
<div class="line"> </div>
<div class="line">agent = MultiStepAgent(</div>
<div class="line">    model=llm,</div>
<div class="line">    tools=[search_tool] <span class="comment"># Agent can now search!</span></div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3069"></a>
Conclusion</h2>
<p>Tools are the bridge between an agent's reasoning and the real world (or specific functionalities like code execution). They are reusable capabilities defined by their <code>name</code>, <code>description</code>, <code>inputs</code>, <code>output_type</code>, and the core logic in their <code>forward</code> method.</p>
<p>You've learned:</p>
<ul>
<li>Why agents need tools (like a chef needs utensils).</li>
<li>The essential components of a <code>Tool</code> in <code>SmolaAgents</code>.</li>
<li>How to create a simple custom tool (<code>GreetingTool</code>).</li>
<li>How to give tools to your <code>MultiStepAgent</code>.</li>
<li>How the agent uses the LLM's suggestions to select and execute the correct tool during the "Act" phase.</li>
<li>About some common built-in tools.</li>
</ul>
<p>By equipping your agent with the right set of tools, you dramatically expand the range of tasks it can accomplish! But as the agent takes multiple steps, using tools and getting results, how does it keep track of everything that has happened? That's where memory comes in.</p>
<p><b>Next Chapter:</b> <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">Chapter 4: AgentMemory</a> - The Agent's Notepad.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
