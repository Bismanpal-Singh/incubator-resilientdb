#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 09_events</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d4/daa/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_209__events.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">09_events</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1125"></a>
autotoc_md1125</h2>
<p>layout: default title: "Events" parent: "Celery" </p>
<h2><a class="anchor" id="autotoc_md1126"></a>
nav_order: 9</h2>
<h1><a class="anchor" id="autotoc_md1127"></a>
Chapter 9: Events - Listening to Celery's Heartbeat</h1>
<p>In <a class="el" href="../../dc/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_208__canvas____signatures______primitives__.html">Chapter 8: Canvas (Signatures &amp; Primitives)</a>, we saw how to build complex workflows by chaining tasks together or running them in parallel. But as your Celery system gets busier, you might wonder: "What are my workers doing *right now*? Which tasks have started? Which ones finished successfully or failed?"</p>
<p>Imagine you're running an important data processing job involving many tasks. Wouldn't it be great to have a live dashboard showing the progress, or get immediate notifications if something goes wrong? This is where <b>Celery Events</b> come in.</p>
<h2><a class="anchor" id="autotoc_md1128"></a>
What Problem Do Events Solve?</h2>
<p>Celery Events provide a <b>real-time monitoring system</b> for your tasks and workers. Think of it like a live activity log or a notification system built into Celery.</p>
<p>Without events, finding out what happened requires checking logs or querying the <a class="el" href="../../d3/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_206__result__backend.html">Result Backend</a> for each task individually. This isn't ideal for getting a live overview of the entire cluster.</p>
<p>Events solve this by having workers broadcast messages (events) about important actions they take, such as:</p><ul>
<li>A worker coming online or going offline.</li>
<li>A worker receiving a task.</li>
<li>A worker starting to execute a task.</li>
<li>A task succeeding or failing.</li>
<li>A worker sending out a heartbeat signal.</li>
</ul>
<p>Other programs can then listen to this stream of event messages to monitor the health and activity of the Celery cluster in real-time, build dashboards (like the popular tool Flower), or trigger custom alerts.</p>
<h2><a class="anchor" id="autotoc_md1129"></a>
Key Concepts</h2>
<ol type="1">
<li><b>Events:</b> Special messages sent by workers (and sometimes clients) describing an action. Each event has a <code>type</code> (e.g., <code>task-received</code>, <code>worker-online</code>) and contains details relevant to that action (like the task ID, worker hostname, timestamp).</li>
<li><b>Event Exchange:</b> Events aren't sent to the regular task queues. They are published to a dedicated, named exchange on the <a class="el" href="../../d3/dd5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_204__broker__connection____amqp__.html">Broker Connection (AMQP)</a>. Think of it as a separate broadcast channel just for monitoring messages.</li>
<li><b>Event Sender (<code>EventDispatcher</code>):</b> A component within the <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a> responsible for creating and sending event messages to the broker's event exchange. This is usually disabled by default for performance reasons.</li>
<li><b>Event Listener (<code>EventReceiver</code>):</b> Any program that connects to the event exchange on the broker and consumes the stream of event messages. This could be the <code>celery events</code> command-line tool, Flower, or your own custom monitoring script.</li>
<li><b>Event Types:</b> Celery defines many event types. Some common ones include:<ul>
<li><code>worker-online</code>, <code>worker-offline</code>, <code>worker-heartbeat</code>: Worker status updates.</li>
<li><code>task-sent</code>: Client sent a task request (requires <code>task_send_sent_event</code> setting).</li>
<li><code>task-received</code>: Worker received the task message.</li>
<li><code>task-started</code>: Worker started executing the task code.</li>
<li><code>task-succeeded</code>: Task finished successfully.</li>
<li><code>task-failed</code>: Task failed with an error.</li>
<li><code>task-retried</code>: Task is being retried.</li>
<li><code>task-revoked</code>: Task was cancelled/revoked.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md1130"></a>
How to Use Events: Simple Monitoring</h2>
<p>Let's see how to enable events and watch the live stream using Celery's built-in tool.</p>
<p><b>1. Enable Events in the Worker</b></p>
<p>By default, workers don't send events to save resources. You need to explicitly tell them to start sending. You can do this in two main ways:</p>
<ul>
<li><p class="startli"><b>Command-line flag (<code>-E</code>):</b> When starting your worker, add the <code>-E</code> flag.</p>
<p class="startli"><code>bash @section autotoc_md1131 Start a worker AND enable sending events celery -A celery_app worker --loglevel=info -E </code></p>
</li>
<li><p class="startli"><b>Configuration Setting:</b> Set <code>worker_send_task_events = True</code> in your Celery configuration (<a class="el" href="../../d7/df5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_202__configuration.html">Chapter 2: Configuration</a>). This is useful if you always want events enabled for workers using that configuration. You can also enable worker-specific events (<code>worker-online</code>, <code>worker-heartbeat</code>) with <code>worker_send_worker_events = True</code> (which defaults to True).</p>
<p class="startli">``&lsquo;python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1132"></a>
celeryconfig.py (example)</h1>
<p>broker_url = 'redis://localhost:6379/0&rsquo; result_backend = 'redis://localhost:6379/1' imports = ('tasks',)</p>
<h1><a class="anchor" id="autotoc_md1133"></a>
Enable sending task-related events</h1>
<p>task_send_sent_event = False # Optional: If you want task-sent events too worker_send_task_events = True worker_send_worker_events = True # Usually True by default ```</p>
<p>Now, any worker started with this configuration (or the <code>-E</code> flag) will publish events to the broker.</p>
<p><b>2. Watch the Event Stream</b></p>
<p>Celery provides a command-line tool called <code>celery events</code> that acts as a simple event listener and prints the events it receives to your console.</p>
<p>Open <b>another terminal</b> (while your worker with events enabled is running) and run:</p>
<div class="fragment"><div class="line"># Watch for events associated with your app</div>
<div class="line">celery -A celery_app events</div>
</div><!-- fragment --><p>Alternatively, you can use the more descriptive (but older) command <code>celery control enable_events</code> to tell already running workers to start sending events, and <code>celery control disable_events</code> to stop them.</p>
<p><b>What You'll See:</b></p>
<p>Initially, <code>celery events</code> might show nothing. Now, try sending a task from another script or shell (like the <code>run_tasks.py</code> from <a class="el" href="../../d5/db8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_203__task.html">Chapter 3: Task</a>):</p>
<div class="fragment"><div class="line"><span class="comment"># In a third terminal/shell</span></div>
<div class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> add</div>
<div class="line">result = add.delay(5, 10)</div>
<div class="line">print(f<span class="stringliteral">&quot;Sent task {result.id}&quot;</span>)</div>
</div><!-- fragment --><p>Switch back to the terminal running <code>celery events</code>. You should see output similar to this (details and timestamps will vary):</p>
<div class="fragment"><div class="line">-&gt; celery events v5.x.x</div>
<div class="line">-&gt; connected to redis://localhost:6379/0</div>
<div class="line"> </div>
<div class="line">-------------- task-received celery@myhostname [2023-10-27 12:00:01.100]</div>
<div class="line">    uuid:a1b2c3d4-e5f6-7890-1234-567890abcdef</div>
<div class="line">    name:tasks.add</div>
<div class="line">    args:[5, 10]</div>
<div class="line">    kwargs:{}</div>
<div class="line">    retries:0</div>
<div class="line">    eta:null</div>
<div class="line">    hostname:celery@myhostname</div>
<div class="line">    timestamp:1666872001.1</div>
<div class="line">    pid:12345</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">-------------- task-started celery@myhostname [2023-10-27 12:00:01.150]</div>
<div class="line">    uuid:a1b2c3d4-e5f6-7890-1234-567890abcdef</div>
<div class="line">    hostname:celery@myhostname</div>
<div class="line">    timestamp:1666872001.15</div>
<div class="line">    pid:12345</div>
<div class="line">    ...</div>
<div class="line"> </div>
<div class="line">-------------- task-succeeded celery@myhostname [2023-10-27 12:00:04.200]</div>
<div class="line">    uuid:a1b2c3d4-e5f6-7890-1234-567890abcdef</div>
<div class="line">    result:&#39;15&#39;</div>
<div class="line">    runtime:3.05</div>
<div class="line">    hostname:celery@myhostname</div>
<div class="line">    timestamp:1666872004.2</div>
<div class="line">    pid:12345</div>
<div class="line">    ...</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>celery events</code> connects to the broker defined in <code>celery_app</code>.</li>
<li>It listens for messages on the event exchange.</li>
<li>As the worker processes the <code>add(5, 10)</code> task, it sends <code>task-received</code>, <code>task-started</code>, and <code>task-succeeded</code> events.</li>
<li><code>celery events</code> receives these messages and prints their details.</li>
</ul>
<p>This gives you a raw, real-time feed of what's happening in your Celery cluster!</p>
<p><b>Flower: A Visual Monitor</b></p>
<p>While <code>celery events</code> is useful, it's quite basic. A very popular tool called <b>Flower</b> uses the same event stream to provide a web-based dashboard for monitoring your Celery cluster. It shows running tasks, completed tasks, worker status, task details, and more, all updated in real-time thanks to Celery Events. You can typically install it (<code>pip install flower</code>) and run it (<code>celery -A celery_app flower</code>).</p>
<h2><a class="anchor" id="autotoc_md1134"></a>
How It Works Internally (Simplified)</h2>
<ol type="1">
<li><b>Worker Action:</b> A worker performs an action (e.g., starts executing task <code>T1</code>).</li>
<li><b>Event Dispatch:</b> If events are enabled, the worker's internal <code>EventDispatcher</code> component is notified.</li>
<li><b>Create Event Message:</b> The <code>EventDispatcher</code> creates a dictionary representing the event (e.g., &lsquo;{'type&rsquo;: 'task-started', 'uuid': 'T1', 'hostname': 'worker1', ...}<code>).</code></li>
<li><code> **Publish to Broker:** The</code>EventDispatcher<code>uses its connection to the [Broker Connection (AMQP)](<a class="el" href="../../d4/d7a/04__broker__connection____amqp___8md.html">04_broker_connection__amqp_.md</a>) to publish this event message to a specific **event exchange** (usually named</code>celeryev<code>). It uses a routing key based on the event type (e.g.,</code>task.started<code>).</code></li>
<li><code> **Listener Connects:** A monitoring tool (like</code>celery events<code>or Flower) starts up. It creates an</code>EventReceiver<code>.</code></li>
<li><code> **Declare Queue:** The</code>EventReceiver<code>connects to the same broker and declares a temporary, unique queue bound to the event exchange (</code>celeryev<code>), often configured to receive all event types (</code>#<code>routing key).</code></li>
<li><code> **Consume Events:** The</code>EventReceiver<code>starts consuming messages from its dedicated queue.</code></li>
<li><code> **Process Event:** When an event message (like the</code>task-started<code>message for</code>T1<code>) arrives from the broker, the</code>EventReceiver<code>decodes it and passes it to a handler (e.g.,</code>celery events` prints it, Flower updates its web UI).</li>
</ol>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Worker</div>
<div class="line">    participant Dispatcher as EventDispatcher (in Worker)</div>
<div class="line">    participant Broker as Message Broker</div>
<div class="line">    participant Receiver as EventReceiver (e.g., celery events tool)</div>
<div class="line">    participant Display as Console/UI</div>
<div class="line"> </div>
<div class="line">    Worker-&gt;&gt;Worker: Starts executing Task T1</div>
<div class="line">    Worker-&gt;&gt;Dispatcher: Notify: Task T1 started</div>
<div class="line">    Dispatcher-&gt;&gt;Dispatcher: Create event message {&#39;type&#39;: &#39;task-started&#39;, ...}</div>
<div class="line">    Dispatcher-&gt;&gt;Broker: Publish event msg to &#39;celeryev&#39; exchange (routing_key=&#39;task.started&#39;)</div>
<div class="line">    Broker--&gt;&gt;Dispatcher: Ack (Message Sent)</div>
<div class="line"> </div>
<div class="line">    Receiver-&gt;&gt;Broker: Connect and declare unique queue bound to &#39;celeryev&#39; exchange</div>
<div class="line">    Broker--&gt;&gt;Receiver: Queue ready</div>
<div class="line"> </div>
<div class="line">    Broker-&gt;&gt;Receiver: Deliver event message {&#39;type&#39;: &#39;task-started&#39;, ...}</div>
<div class="line">    Receiver-&gt;&gt;Receiver: Decode message</div>
<div class="line">    Receiver-&gt;&gt;Display: Process event (e.g., print to console)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1135"></a>
Code Dive: Sending and Receiving Events</h2>
<ul>
<li><p class="startli"><b>Enabling Events (<code>celery/worker/consumer/events.py</code>):</b> The <code>Events</code> bootstep in the worker process is responsible for initializing the <code>EventDispatcher</code>. The <code>-E</code> flag or configuration settings control whether this bootstep actually enables the dispatcher.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1136"></a>
Simplified from worker/consumer/events.py</h1>
<p>class Events(bootsteps.StartStopStep): requires = (Connection,)</p>
<p>def <b>init</b>(self, c, task_events=True, # Controlled by config/flags </p>
<h1><a class="anchor" id="autotoc_md1137"></a>
... other flags ...</h1>
<p>**kwargs): self.send_events = task_events # or other flags self.enabled = self.send_events </p>
<h1><a class="anchor" id="autotoc_md1138"></a>
...</h1>
<p>super().__init__(c, **kwargs)</p>
<p>def start(self, c): </p>
<h1><a class="anchor" id="autotoc_md1139"></a>
... gets connection ...</h1>
<h1><a class="anchor" id="autotoc_md1140"></a>
Creates the actual dispatcher instance</h1>
<p>dis = c.event_dispatcher = c.app.events.Dispatcher( c.connection_for_write(), hostname=c.hostname, enabled=self.send_events, # Only sends if enabled </p>
<h1><a class="anchor" id="autotoc_md1141"></a>
... other options ...</h1>
<p>) </p>
<h1><a class="anchor" id="autotoc_md1142"></a>
... flush buffer ...</h1>
<p>```</p>
<ul>
<li><p class="startli"><b>Sending Events (<code>celery/events/dispatcher.py</code>):</b> The <code>EventDispatcher</code> class has the <code>send</code> method, which creates the event dictionary and calls <code>publish</code>.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1143"></a>
Simplified from events/dispatcher.py</h1>
<p>class EventDispatcher: </p>
<h1><a class="anchor" id="autotoc_md1144"></a>
... <b>init</b> setup ...</h1>
<p>def send(self, type, blind=False, ..., **fields): if self.enabled: groups, group = self.groups, group_from(type) if groups and group not in groups: return # Don't send if this group isn't enabled</p>
<h1><a class="anchor" id="autotoc_md1145"></a>
... potential buffering logic (omitted) ...</h1>
<h1><a class="anchor" id="autotoc_md1146"></a>
Call publish to actually send</h1>
<p>return self.publish(type, fields, self.producer, blind=blind, Event=Event, ...)</p>
<p>def publish(self, type, fields, producer, blind=False, Event=Event, **kwargs): </p>
<h1><a class="anchor" id="autotoc_md1147"></a>
Create the event dictionary</h1>
<p>clock = None if blind else self.clock.forward() event = Event(type, hostname=self.hostname, utcoffset=utcoffset(), pid=self.pid, clock=clock, **fields)</p>
<h1><a class="anchor" id="autotoc_md1148"></a>
Publish using the underlying Kombu producer</h1>
<p>with self.mutex: return self._publish(event, producer, routing_key=type.replace('-', '.'), **kwargs)</p>
<p>def _publish(self, event, producer, routing_key, **kwargs): exchange = self.exchange # The dedicated event exchange try: </p>
<h1><a class="anchor" id="autotoc_md1149"></a>
Kombu's publish method sends the message</h1>
<p>producer.publish( event, # The dictionary payload routing_key=routing_key, exchange=exchange.name, declare=[exchange], # Ensure exchange exists serializer=self.serializer, # e.g., 'json' headers=self.headers, delivery_mode=self.delivery_mode, # e.g., transient **kwargs ) except Exception as exc: </p>
<h1><a class="anchor" id="autotoc_md1150"></a>
... error handling / buffering ...</h1>
<p>raise ```</p>
<ul>
<li><p class="startli"><b>Receiving Events (<code>celery/events/receiver.py</code>):</b> The <code>EventReceiver</code> class (used by tools like <code>celery events</code>) sets up a consumer to listen for messages on the event exchange.</p>
<p class="startli">``&lsquo;python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1151"></a>
Simplified from events/receiver.py</h1>
<p>class EventReceiver(ConsumerMixin): # Uses Kombu's ConsumerMixin </p><pre class="fragment">def __init__(self, channel, handlers=None, routing_key=&amp;rsquo;#', ...):
    # ... setup app, channel, handlers ...
    self.exchange = get_exchange(..., name=self.app.conf.event_exchange)
    self.queue = Queue( # Create a unique, auto-deleting queue
        '.'.join([self.queue_prefix, self.node_id]),
        exchange=self.exchange,
        routing_key=routing_key, # Often '#' to get all events
        auto_delete=True, durable=False,
        # ... other queue options ...
    )
    # ...

def get_consumers(self, Consumer, channel):
    # Tell ConsumerMixin to consume from our event queue
    return [Consumer(queues=[self.queue],
                     callbacks=[self._receive], # Method to call on message
                     no_ack=True, # Events usually don't need explicit ack
                     accept=self.accept)]

# This method is registered as the callback for new messages
def _receive(self, body, message):
    # Decode message body (can be single event or list in newer Celery)
    if isinstance(body, list):
        process, from_message = self.process, self.event_from_message
        [process(*from_message(event)) for event in body]
    else:
        self.process(*self.event_from_message(body))

# process() calls the appropriate handler from self.handlers
def process(self, type, event):
    """Process event by dispatching to configured handler."""
    handler = self.handlers.get(type) or self.handlers.get('*')
    handler and handler(event) # Call the handler function
</pre><p> ```</p>
<h2><a class="anchor" id="autotoc_md1152"></a>
Conclusion</h2>
<p>Celery Events provide a powerful mechanism for <b>real-time monitoring</b> of your distributed task system.</p>
<ul>
<li>Workers (when enabled via <code>-E</code> or configuration) send <b>event messages</b> describing their actions (like task start/finish, worker online).</li>
<li>These messages go to a dedicated <b>event exchange</b> on the broker.</li>
<li>Tools like <code>celery events</code> or Flower act as <b>listeners</b> (<code>EventReceiver</code>), consuming this stream to provide insights into the cluster's activity.</li>
<li>Events are the foundation for building dashboards, custom monitoring, and diagnostic tools.</li>
</ul>
<p>Understanding events helps you observe and manage your Celery application more effectively.</p>
<p>So far, we've explored the major components and concepts of Celery. But how does a worker actually start up? How does it initialize all these different parts like the connection, the consumer, the event dispatcher, and the execution pool in the right order? That's orchestrated by a system called Bootsteps.</p>
<p><b>Next:</b> <a class="el" href="../../dc/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_210__bootsteps.html">Chapter 10: Bootsteps</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
