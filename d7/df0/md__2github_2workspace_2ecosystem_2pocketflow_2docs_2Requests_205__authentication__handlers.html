#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_authentication_handlers</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d7/df0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_205__authentication__handlers.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_authentication_handlers</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2951"></a>
autotoc_md2951</h2>
<p>layout: default title: "Authentication Handlers" parent: "Requests" </p>
<h2><a class="anchor" id="autotoc_md2952"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md2953"></a>
Chapter 5: Authentication Handlers - Showing Your ID Card</h1>
<p>In <a class="el" href="../../d1/df9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_204__cookie__jar.html">Chapter 4: The Cookie Jar</a>, we learned how <code>requests</code> uses <code>Session</code> objects and cookie jars to automatically remember things like login cookies. This is great for websites that use cookies to manage sessions after you log in.</p>
<p>But what about websites or APIs that require you to prove who you are <em>every time</em> you make a request, or use different methods than cookies? For example, some services need a username and password sent directly with the request, not just a cookie.</p>
<h2><a class="anchor" id="autotoc_md2954"></a>
The Problem: Accessing Protected Resources</h2>
<p>Imagine a website has a special members-only area. To access pages in this area, the server needs to know you're a valid member <em>right when you ask for the page</em>. It won't just let anyone in. It needs some form of identification, like a username and password.</p>
<p>How do we tell <code>requests</code> to include this identification with our request?</p>
<p>This is where <b>Authentication Handlers</b> come in.</p>
<h2><a class="anchor" id="autotoc_md2955"></a>
What are Authentication Handlers?</h2>
<p>Think of authentication handlers as different types of <b>ID badges</b> you can attach to your web requests. Just like you might need a specific badge to get into different parts of a building, different web services might require different types of authentication.</p>
<p><code>Requests</code> has built-in support for common types (schemes) of HTTP authentication, and you can even create your own custom badges.</p>
<p><b>Common ID Badges (Authentication Schemes):</b></p>
<ol type="1">
<li><b>HTTP Basic Auth:</b> This is the simplest type. It's like a badge with your username and password written directly on it (encoded, but easily decoded). It's common but not very secure over plain HTTP (HTTPS makes it safer).<ul>
<li><code>Requests</code> provides: A simple <code>(username, password)</code> tuple or the <code>HTTPBasicAuth</code> class.</li>
</ul>
</li>
<li><b>HTTP Digest Auth:</b> This is a bit more secure than Basic. Instead of sending your password directly, it involves a challenge-response process, like the server asking a secret question based on your password, and your request providing the answer. It's more complex but avoids sending the password openly.<ul>
<li><code>Requests</code> provides: The <code>HTTPDigestAuth</code> class.</li>
</ul>
</li>
<li><b>Custom Auth:</b> Some services use unique authentication methods (like OAuth1, OAuth2, custom API keys).<ul>
<li><code>Requests</code> allows you to create your own auth handlers by subclassing <code>AuthBase</code>. Many other libraries provide handlers for common schemes like OAuth.</li>
</ul>
</li>
</ol>
<p>When you provide authentication details to <code>requests</code>, it automatically figures out how to create and attach the correct <code>Authorization</code> header (or sometimes <code>Proxy-Authorization</code> for proxies) to your request. It's like pinning the right ID badge onto your request before sending it off.</p>
<h2><a class="anchor" id="autotoc_md2956"></a>
Using Authentication Handlers</h2>
<p>The easiest way to add authentication is by using the <code>auth</code> parameter when making a request, either with the functional API or with a <a class="el" href="../../dd/d2f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_203__session.html">Session</a> object.</p>
<h3><a class="anchor" id="autotoc_md2957"></a>
HTTP Basic Auth (The Easiest Way)</h3>
<p>For Basic Auth, you can simply pass a tuple <code>(username, password)</code> to the <code>auth</code> argument.</p>
<p>Let's try accessing a test endpoint from <code>httpbin.org</code> that's protected with Basic Auth. The username is <code>testuser</code> and the password is <code>testpass</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> requests</div>
<div class="line"> </div>
<div class="line"><span class="comment"># This URL requires Basic Auth with user=&#39;testuser&#39;, pass=&#39;testpass&#39;</span></div>
<div class="line">url = <span class="stringliteral">&#39;https://httpbin.org/basic-auth/testuser/testpass&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Try without authentication first (should fail with 401 Unauthorized)</span></div>
<div class="line">print(<span class="stringliteral">&quot;Attempting without authentication...&quot;</span>)</div>
<div class="line">response_fail = requests.get(url)</div>
<div class="line">print(f<span class="stringliteral">&quot;Status Code (fail): {response_fail.status_code}&quot;</span>) <span class="comment"># Expect 401</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Now, provide the username and password tuple to the &#39;auth&#39; parameter</span></div>
<div class="line">print(<span class="stringliteral">&quot;\nAttempting with Basic Auth tuple...&quot;</span>)</div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    response_ok = requests.get(url, auth=(<span class="stringliteral">&#39;testuser&#39;</span>, <span class="stringliteral">&#39;testpass&#39;</span>))</div>
<div class="line">    print(f<span class="stringliteral">&quot;Status Code (ok): {response_ok.status_code}&quot;</span>) <span class="comment"># Expect 200</span></div>
<div class="line">    <span class="comment"># Check the response content (httpbin echoes auth info)</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Response JSON:&quot;</span>)</div>
<div class="line">    print(response_ok.json())</div>
<div class="line"><span class="keywordflow">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;An error occurred: {e}&quot;</span>)</div>
</div><!-- fragment --><p><b>Output:</b></p>
<div class="fragment"><div class="line">Attempting without authentication...</div>
<div class="line">Status Code (fail): 401</div>
<div class="line"> </div>
<div class="line">Attempting with Basic Auth tuple...</div>
<div class="line">Status Code (ok): 200</div>
<div class="line">Response JSON:</div>
<div class="line">{&#39;authenticated&#39;: True, &#39;user&#39;: &#39;testuser&#39;}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>The first request failed with <code>401 Unauthorized</code> because we didn't provide credentials.</li>
<li>In the second request, we added &lsquo;auth=('testuser&rsquo;, 'testpass')<code>. 3.</code>Requests<code>automatically recognized this tuple, created the necessary</code>Authorization: Basic dGVzdHVzZXI6dGVzdHBhc3M=<code>header (where</code>dGVzdHVzZXI6dGVzdHBhc3M=<code>is the Base64 encoding of</code>testuser:testpass<code>), and added it to the request.</code></li>
<li><code> The server validated the credentials and granted access, returning a</code>200 OK<code>status. The response body confirms we were authenticated as</code>testuser`.</li>
</ol>
<h3><a class="anchor" id="autotoc_md2958"></a>
Using the <code>HTTPBasicAuth</code> Class</h3>
<p>Passing a tuple is a shortcut specifically for Basic Auth. For clarity, or if you want to reuse the authentication details, you can use the <code>HTTPBasicAuth</code> class explicitly. It does exactly the same thing internally.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> requests</div>
<div class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth <span class="comment"># Import the class</span></div>
<div class="line"> </div>
<div class="line">url = <span class="stringliteral">&#39;https://httpbin.org/basic-auth/testuser/testpass&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create an HTTPBasicAuth object</span></div>
<div class="line">basic_auth = HTTPBasicAuth(<span class="stringliteral">&#39;testuser&#39;</span>, <span class="stringliteral">&#39;testpass&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Pass the auth object to the &#39;auth&#39; parameter</span></div>
<div class="line">print(<span class="stringliteral">&quot;Attempting with HTTPBasicAuth object...&quot;</span>)</div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    response = requests.get(url, auth=basic_auth)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Status Code: {response.status_code}&quot;</span>) <span class="comment"># Expect 200</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Response JSON:&quot;</span>)</div>
<div class="line">    print(response.json())</div>
<div class="line"><span class="keywordflow">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;An error occurred: {e}&quot;</span>)</div>
</div><!-- fragment --><p><b>Output:</b></p>
<div class="fragment"><div class="line">Attempting with HTTPBasicAuth object...</div>
<div class="line">Status Code: 200</div>
<div class="line">Response JSON:</div>
<div class="line">{&#39;authenticated&#39;: True, &#39;user&#39;: &#39;testuser&#39;}</div>
</div><!-- fragment --><p>This achieves the same result as the tuple, but <code>HTTPBasicAuth(user, pass)</code> is more explicit about the type of authentication being used.</p>
<h3><a class="anchor" id="autotoc_md2959"></a>
HTTP Digest Auth</h3>
<p>Digest Auth is more complex, involving a challenge from the server. <code>Requests</code> handles this complexity for you with the <code>HTTPDigestAuth</code> class. You use it similarly to <code>HTTPBasicAuth</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> requests</div>
<div class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPDigestAuth <span class="comment"># Import the class</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># httpbin has a digest auth endpoint</span></div>
<div class="line"><span class="comment"># user=&#39;testuser&#39;, pass=&#39;testpass&#39;</span></div>
<div class="line">url = <span class="stringliteral">&#39;https://httpbin.org/digest-auth/auth/testuser/testpass&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create an HTTPDigestAuth object</span></div>
<div class="line">digest_auth = HTTPDigestAuth(<span class="stringliteral">&#39;testuser&#39;</span>, <span class="stringliteral">&#39;testpass&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Pass the auth object to the &#39;auth&#39; parameter</span></div>
<div class="line">print(<span class="stringliteral">&quot;Attempting with HTTPDigestAuth object...&quot;</span>)</div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    response = requests.get(url, auth=digest_auth)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Status Code: {response.status_code}&quot;</span>) <span class="comment"># Expect 200</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Response JSON:&quot;</span>)</div>
<div class="line">    print(response.json())</div>
<div class="line">    <span class="comment"># Note: It might take two requests internally for Digest Auth</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Request History (if any): {response.history}&quot;</span>)</div>
<div class="line"><span class="keywordflow">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;An error occurred: {e}&quot;</span>)</div>
</div><!-- fragment --><p><b>Output:</b></p>
<div class="fragment"><div class="line">Attempting with HTTPDigestAuth object...</div>
<div class="line">Status Code: 200</div>
<div class="line">Response JSON:</div>
<div class="line">{&#39;authenticated&#39;: True, &#39;user&#39;: &#39;testuser&#39;}</div>
<div class="line">Request History (if any): [&lt;Response [401]&gt;]</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>We used <code>HTTPDigestAuth</code> this time.</li>
<li>When <code>requests</code> first tries to access the URL, the server challenges it with a <code>401 Unauthorized</code> response containing details needed for Digest Auth (like a <code>nonce</code> and <code>realm</code>). You can see this <code>401</code> response in <code>response.history</code>.</li>
<li>The <code>HTTPDigestAuth</code> handler catches this <code>401</code>, uses the challenge information and your password to calculate the correct response, and automatically sends a <em>second</em> request with the proper <code>Authorization: Digest ...</code> header.</li>
<li>This second request succeeds, and you get the final <code>200 OK</code> response.</li>
</ol>
<p><code>Requests</code> handles the two-step process automatically when you use <code>HTTPDigestAuth</code>.</p>
<h3><a class="anchor" id="autotoc_md2960"></a>
Persistent Authentication with Sessions</h3>
<p>If you need to make multiple requests to the same server using the same authentication, it's much more efficient to set the authentication on a <a class="el" href="../../dd/d2f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_203__session.html">Session</a> object. The session will then automatically apply the authentication to <em>all</em> requests made through it.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> requests</div>
<div class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> HTTPBasicAuth</div>
<div class="line"> </div>
<div class="line">basic_auth_url = <span class="stringliteral">&#39;https://httpbin.org/basic-auth/testuser/testpass&#39;</span></div>
<div class="line">headers_url = <span class="stringliteral">&#39;https://httpbin.org/headers&#39;</span> <span class="comment"># Just to see headers sent</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a session</span></div>
<div class="line"><span class="keyword">with</span> requests.Session() <span class="keyword">as</span> s:</div>
<div class="line">    <span class="comment"># Set the authentication ONCE on the session</span></div>
<div class="line">    s.auth = HTTPBasicAuth(<span class="stringliteral">&#39;testuser&#39;</span>, <span class="stringliteral">&#39;testpass&#39;</span>)</div>
<div class="line">    <span class="comment"># Or: s.auth = (&#39;testuser&#39;, &#39;testpass&#39;)</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Make the first request (auth will be added automatically)</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Making first request using session auth...&quot;</span>)</div>
<div class="line">    response1 = s.get(basic_auth_url)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Status Code 1: {response1.status_code}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Make a second request to a different endpoint (auth will also be added)</span></div>
<div class="line">    <span class="comment"># We use /headers to see the Authorization header being sent</span></div>
<div class="line">    print(<span class="stringliteral">&quot;\nMaking second request using session auth...&quot;</span>)</div>
<div class="line">    response2 = s.get(headers_url)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Status Code 2: {response2.status_code}&quot;</span>)</div>
<div class="line">    print(<span class="stringliteral">&quot;Headers sent in second request:&quot;</span>)</div>
<div class="line">    <span class="comment"># Look for the &#39;Authorization&#39; header in the output</span></div>
<div class="line">    print(response2.json()[<span class="stringliteral">&#39;headers&#39;</span>])</div>
</div><!-- fragment --><p><b>Output:</b></p>
<div class="fragment"><div class="line">Making first request using session auth...</div>
<div class="line">Status Code 1: 200</div>
<div class="line"> </div>
<div class="line">Making second request using session auth...</div>
<div class="line">Status Code 2: 200</div>
<div class="line">Headers sent in second request:</div>
<div class="line">{</div>
<div class="line">  &quot;Accept&quot;: &quot;*/*&quot;,</div>
<div class="line">  &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</div>
<div class="line">  &quot;Authorization&quot;: &quot;Basic dGVzdHVzZXI6dGVzdHBhc3M=&quot;, // &lt;-- Auth header added automatically!</div>
<div class="line">  &quot;Host&quot;: &quot;httpbin.org&quot;,</div>
<div class="line">  &quot;User-Agent&quot;: &quot;python-requests/2.x.y&quot;,</div>
<div class="line">  &quot;X-Amzn-Trace-Id&quot;: &quot;Root=...&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>By setting <code>s.auth = ...</code>, we ensured that <em>both</em> requests sent the <code>Authorization</code> header without needing to specify it in each <code>s.get()</code> call.</p>
<h3><a class="anchor" id="autotoc_md2961"></a>
Custom Authentication</h3>
<p>What if a service uses a completely different way to authenticate? <code>Requests</code> allows you to create your own authentication handler by writing a class that inherits from <code>requests.auth.AuthBase</code> and implements the <code>__call__</code> method. This method receives the <code>PreparedRequest</code> object and should modify it (usually by adding headers) as needed.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> requests.auth <span class="keyword">import</span> AuthBase</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyCustomApiKeyAuth(AuthBase):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Attaches a custom API Key header to the request.&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">def </span>__init__(self, api_key):</div>
<div class="line">        self.api_key = api_key</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__call__(self, r):</div>
<div class="line">        <span class="comment"># &#39;r&#39; is the PreparedRequest object</span></div>
<div class="line">        <span class="comment"># Modify the request &#39;r&#39; here. We&#39;ll add a header.</span></div>
<div class="line">        r.headers[<span class="stringliteral">&#39;X-API-Key&#39;</span>] = self.api_key</div>
<div class="line">        <span class="comment"># We MUST return the modified request object</span></div>
<div class="line">        <span class="keywordflow">return</span> r</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Usage:</span></div>
<div class="line"><span class="comment"># api_key = &quot;YOUR_SECRET_API_KEY&quot;</span></div>
<div class="line"><span class="comment"># response = requests.get(some_url, auth=MyCustomApiKeyAuth(api_key))</span></div>
</div><!-- fragment --><p>This is more advanced, but it shows the flexibility of the <code>requests</code> auth system. Many third-party libraries use this pattern to provide auth helpers for specific services (like OAuth).</p>
<h2><a class="anchor" id="autotoc_md2962"></a>
How It Works Internally</h2>
<p>How does <code>requests</code> take the <code>auth</code> parameter and turn it into the correct <code>Authorization</code> header?</p>
<ol type="1">
<li><b>Preparation Step:</b> When you make a request (e.g., <code>requests.get(url, auth=...)</code> or <code>s.request(...)</code>), the <code>Request</code> object is turned into a <code>PreparedRequest</code> as we saw in <a class="el" href="../../dd/d7e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_202__request______response__models.html">Chapter 2: Request &amp; Response Models</a>. Part of this preparation involves the <code>prepare_auth</code> method.</li>
<li><b>Check Auth Type:</b> Inside <code>prepare_auth</code>, <code>requests</code> checks the <code>auth</code> parameter.<ul>
<li>If <code>auth</code> is a tuple <code>(user, pass)</code>, it automatically wraps it in an <code>HTTPBasicAuth(user, pass)</code> object.</li>
<li>If <code>auth</code> is already an object (like <code>HTTPBasicAuth</code>, <code>HTTPDigestAuth</code>, or a custom one inheriting from <code>AuthBase</code>), it uses that object directly.</li>
</ul>
</li>
<li><b>Call the Auth Object:</b> All authentication handler objects (including the built-in ones) are <b>callable</b>. This means they have a <code>__call__</code> method. The <code>prepare_auth</code> step <em>calls</em> the auth object, passing the <code>PreparedRequest</code> object (<code>p</code>) to it: <code>auth(p)</code>.</li>
<li><b>Modify the Request:</b> The <code>__call__</code> method of the auth object does the actual work.<ul>
<li>For <code>HTTPBasicAuth</code>, the <code>__call__</code> method calculates the <code>Basic base64(user:pass)</code> string and sets &lsquo;p.headers['Authorization&rsquo;] = ...<code>.</code></li>
<li><code> For</code>HTTPDigestAuth<code>, the</code>__call__<code>method might initially set up hooks to handle the</code>401<code>challenge, or if it already has the necessary info (like a</code>nonce<code>), it calculates the</code>Digest ...<code>header and sets</code>p.headers['Authorization']<code>.</code></li>
<li><code> For a custom auth object, its</code>__call__<code>method performs whatever modifications are needed (e.g., adding an</code>X-API-Key<code>header).</code></li>
</ul>
</li>
<li><code> **Return Modified Request:** The</code>__call__<code>method *must* return the modified</code>PreparedRequest<code>object.</code></li>
<li><code> **Send Request:** The</code>PreparedRequest<code>, now potentially including an</code>Authorization` header, is sent to the server.</li>
</ol>
<p>Here's a simplified sequence diagram for Basic Auth:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant UserCode as Your Code</div>
<div class="line">    participant ReqFunc as requests.get / Session.request</div>
<div class="line">    participant PrepReq as PreparedRequest</div>
<div class="line">    participant AuthObj as HTTPBasicAuth Instance</div>
<div class="line">    participant Server</div>
<div class="line"> </div>
<div class="line">    UserCode-&gt;&gt;ReqFunc: Call get(url, auth=(&#39;user&#39;, &#39;pass&#39;))</div>
<div class="line">    ReqFunc-&gt;&gt;PrepReq: Create PreparedRequest (p)</div>
<div class="line">    ReqFunc-&gt;&gt;PrepReq: Call p.prepare_auth(auth=...)</div>
<div class="line">    Note over PrepReq: Detects tuple, creates HTTPBasicAuth(&#39;user&#39;, &#39;pass&#39;)</div>
<div class="line">    PrepReq-&gt;&gt;AuthObj: Call auth_obj(p)</div>
<div class="line">    activate AuthObj</div>
<div class="line">    AuthObj-&gt;&gt;AuthObj: Calculate &#39;Basic ...&#39; string</div>
<div class="line">    AuthObj-&gt;&gt;PrepReq: Set p.headers[&#39;Authorization&#39;] = &#39;Basic ...&#39;</div>
<div class="line">    AuthObj--&gt;&gt;PrepReq: Return modified p</div>
<div class="line">    deactivate AuthObj</div>
<div class="line">    PrepReq--&gt;&gt;ReqFunc: Return prepared request p</div>
<div class="line">    ReqFunc-&gt;&gt;Server: Send HTTP Request (with Authorization header)</div>
<div class="line">    Server--&gt;&gt;ReqFunc: Send HTTP Response</div>
<div class="line">    ReqFunc--&gt;&gt;UserCode: Return Response</div>
</div><!-- fragment --><p>Let's look at the simplified code in <code>requests/auth.py</code> for <code>HTTPBasicAuth</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># File: requests/auth.py (Simplified)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64encode</div>
<div class="line"><span class="keyword">from</span> ._internal_utils <span class="keyword">import</span> to_native_string</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>_basic_auth_str(username, password):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Returns a Basic Auth string.&quot;&quot;&quot;</span></div>
<div class="line">    <span class="comment"># ... (handle encoding username/password to bytes) ...</span></div>
<div class="line">    auth_bytes = b<span class="stringliteral">&quot;:&quot;</span>.join((username_bytes, password_bytes))</div>
<div class="line">    auth_b64 = b64encode(auth_bytes).strip()</div>
<div class="line">    <span class="comment"># Return native string (str in Py3) e.g., &quot;Basic dXNlcjpwYXNz&quot;</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;Basic &quot;</span> + to_native_string(auth_b64)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>AuthBase:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Base class that all auth implementations derive from&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">def </span>__call__(self, r):</div>
<div class="line">        <span class="comment"># This method MUST be overridden by subclasses</span></div>
<div class="line">        <span class="keywordflow">raise</span> NotImplementedError(<span class="stringliteral">&quot;Auth hooks must be callable.&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>HTTPBasicAuth(AuthBase):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Attaches HTTP Basic Authentication to the given Request object.&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">def </span>__init__(self, username, password):</div>
<div class="line">        self.username = username</div>
<div class="line">        self.password = password</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__call__(self, r):</div>
<div class="line">        <span class="comment"># &#39;r&#39; is the PreparedRequest object passed in by requests</span></div>
<div class="line">        <span class="comment"># Calculate the Basic auth string</span></div>
<div class="line">        auth_header_value = _basic_auth_str(self.username, self.password)</div>
<div class="line">        <span class="comment"># Modify the request&#39;s headers</span></div>
<div class="line">        r.headers[<span class="stringliteral">&#39;Authorization&#39;</span>] = auth_header_value</div>
<div class="line">        <span class="comment"># Return the modified request</span></div>
<div class="line">        <span class="keywordflow">return</span> r</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>HTTPProxyAuth(HTTPBasicAuth):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Attaches HTTP Proxy Authentication to a given Request object.&quot;&quot;&quot;</span></div>
<div class="line">    <span class="keyword">def </span>__call__(self, r):</div>
<div class="line">        <span class="comment"># Same as Basic Auth, but sets the Proxy-Authorization header</span></div>
<div class="line">        r.headers[<span class="stringliteral">&#39;Proxy-Authorization&#39;</span>] = _basic_auth_str(self.username, self.password)</div>
<div class="line">        <span class="keywordflow">return</span> r</div>
<div class="line"> </div>
<div class="line"><span class="comment"># HTTPDigestAuth is more complex, involving state and hooks for the 401 challenge</span></div>
<div class="line"><span class="keyword">class </span>HTTPDigestAuth(AuthBase):</div>
<div class="line">    <span class="keyword">def </span>__init__(self, username, password):</div>
<div class="line">        <span class="comment"># ... store username/password ...</span></div>
<div class="line">        <span class="comment"># ... initialize state (nonce, etc.) ...</span></div>
<div class="line">        <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>build_digest_header(self, method, url):</div>
<div class="line">        <span class="comment"># ... complex calculation based on nonce, realm, qop, etc. ...</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;Digest ...&quot;</span> <span class="comment"># Calculated digest header</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>handle_401(self, r, **kwargs):</div>
<div class="line">        <span class="comment"># Hook called when a 401 response is received</span></div>
<div class="line">        <span class="comment"># 1. Parse challenge (&#39;WWW-Authenticate&#39; header)</span></div>
<div class="line">        <span class="comment"># 2. Store nonce, realm etc.</span></div>
<div class="line">        <span class="comment"># 3. Prepare a *new* request with the calculated digest header</span></div>
<div class="line">        <span class="comment"># 4. Send the new request</span></div>
<div class="line">        <span class="comment"># 5. Return the response to the *new* request</span></div>
<div class="line">        <span class="keywordflow">pass</span> <span class="comment"># Simplified</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__call__(self, r):</div>
<div class="line">        <span class="comment"># &#39;r&#39; is the PreparedRequest</span></div>
<div class="line">        <span class="comment"># If we already have a nonce, add the Authorization header directly</span></div>
<div class="line">        <span class="keywordflow">if</span> self.has_nonce():</div>
<div class="line">            r.headers[<span class="stringliteral">&#39;Authorization&#39;</span>] = self.build_digest_header(r.method, r.url)</div>
<div class="line">        <span class="comment"># Register the handle_401 hook to handle the server challenge if needed</span></div>
<div class="line">        r.register_hook(<span class="stringliteral">&#39;response&#39;</span>, self.handle_401)</div>
<div class="line">        <span class="keywordflow">return</span> r</div>
</div><!-- fragment --><p>And in <code>requests/models.py</code>, the <code>PreparedRequest</code> calls the auth object:</p>
<div class="fragment"><div class="line"><span class="comment"># File: requests/models.py (Simplified View)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> .auth <span class="keyword">import</span> HTTPBasicAuth</div>
<div class="line"><span class="keyword">from</span> .utils <span class="keyword">import</span> get_auth_from_url</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PreparedRequest(RequestEncodingMixin, RequestHooksMixin):</div>
<div class="line">    <span class="comment"># ... (other prepare methods like prepare_url, prepare_headers) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>prepare_auth(self, auth, url=&quot;&quot;):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Prepares the given HTTP auth data.&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># If no Auth provided, maybe get it from the URL (e.g., http://user:pass@host)</span></div>
<div class="line">        <span class="keywordflow">if</span> auth <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line">            url_auth = get_auth_from_url(self.url)</div>
<div class="line">            auth = url_auth <span class="keywordflow">if</span> any(url_auth) <span class="keywordflow">else</span> <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> auth:</div>
<div class="line">            <span class="comment"># If auth is a (&#39;user&#39;, &#39;pass&#39;) tuple, wrap it in HTTPBasicAuth</span></div>
<div class="line">            <span class="keywordflow">if</span> isinstance(auth, tuple) <span class="keywordflow">and</span> len(auth) == 2:</div>
<div class="line">                auth = HTTPBasicAuth(*auth)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># --- The Core Step ---</span></div>
<div class="line">            <span class="comment"># Call the auth object (which must be callable, like AuthBase subclasses)</span></div>
<div class="line">            <span class="comment"># Pass &#39;self&#39; (the PreparedRequest instance) to the auth object&#39;s __call__</span></div>
<div class="line">            r = auth(self)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># Update self to reflect any changes made by the auth object</span></div>
<div class="line">            <span class="comment"># (Auth objects typically just modify headers, but could do more)</span></div>
<div class="line">            self.__dict__.update(r.__dict__)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># Recompute Content-Length in case auth modified the body (unlikely for Basic/Digest)</span></div>
<div class="line">            self.prepare_content_length(self.body)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... (rest of PreparedRequest) ...</span></div>
</div><!-- fragment --><p>The key is the <code>r = auth(self)</code> line, where the <code>PreparedRequest</code> delegates the task of adding authentication details to the specific authentication handler object provided.</p>
<h2><a class="anchor" id="autotoc_md2963"></a>
Conclusion</h2>
<p>You've learned how <code>requests</code> handles HTTP authentication using <b>Authentication Handlers</b>.</p>
<ul>
<li>You saw that authentication is like providing an <b>ID badge</b> with your request.</li>
<li>You learned about common schemes like <b>Basic Auth</b> (using a simple <code>(user, pass)</code> tuple or <code>HTTPBasicAuth</code>) and <b>Digest Auth</b> (<code>HTTPDigestAuth</code>).</li>
<li>You know how to apply authentication to single requests or persistently using a <a class="el" href="../../dd/d2f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_203__session.html">Session</a> object via the <code>auth</code> parameter.</li>
<li>You understand that internally, <code>requests</code> calls the provided auth object, which modifies the <code>PreparedRequest</code> (usually by adding an <code>Authorization</code> header) before sending it.</li>
<li>You got a glimpse of how custom authentication can be built using <code>AuthBase</code>.</li>
</ul>
<p>Authentication is crucial for accessing protected resources. But what happens when things go wrong? A server might be down, a URL might be invalid, or authentication might fail. How does <code>requests</code> tell you about these problems?</p>
<p><b>Next:</b> <a class="el" href="../../d0/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_206__exception__hierarchy.html">Chapter 6: Exception Hierarchy</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
