#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_asynchronous_processing___asyncnode____asyncflow___</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d7/d6d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_205__asynchronous__processing___dbf1dc61cb3bcd98d46655d3ab8e2dd9.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_asynchronous_processing___asyncnode____asyncflow___</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2770"></a>
autotoc_md2770</h2>
<p>layout: default title: "Asynchronous Processing (AsyncNode, AsyncFlow)" parent: "PocketFlow" </p>
<h2><a class="anchor" id="autotoc_md2771"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md2772"></a>
Chapter 5: Asynchronous Processing (<code>AsyncNode</code>, <code>AsyncFlow</code>)</h1>
<p>In Chapter 4: Flow (<code>Flow</code>, <code>AsyncFlow</code>), we learned how <code>Flow</code> and <code>AsyncFlow</code> orchestrate sequences of Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) to create complete applications. Now, we're going to zoom in on a powerful feature that <code>AsyncFlow</code> enables: <b>Asynchronous Processing</b>. This is key to building AI applications that feel responsive and can handle tasks that involve waiting, like calling web APIs or interacting with users.</p>
<h2><a class="anchor" id="autotoc_md2773"></a>
The Problem: Waiting Can Be Wasteful!</h2>
<p>Imagine you're building an AI assistant that needs to:</p><ol type="1">
<li>Ask the user for a city name.</li>
<li>Fetch the current weather for that city from an online weather service (this involves a network request, which can take a few seconds).</li>
<li>Tell the user the weather.</li>
</ol>
<p>If we build this "synchronously" (one step strictly after the other, waiting for each to finish), your application would <em>freeze</em> while it's waiting for the weather service. The user can't do anything else; the app just hangs. This isn't a great experience!</p>
<p>This is where asynchronous processing helps. It's like a skilled chef in a busy kitchen.</p><ul>
<li>A <b>synchronous chef</b> would prepare one dish from start to finish: chop vegetables, put it on the stove, wait for it to simmer, then plate it. Only <em>after</em> that one dish is completely done would they start the next. If simmering takes 20 minutes, they're just standing there waiting!</li>
<li>An <b>asynchronous chef</b> is much more efficient! They can start chopping vegetables for dish A, put it on the stove to simmer, and <em>while it's simmering</em> (a waiting period), they can start preparing dish B, or perhaps clean up. They don't idly wait; they switch to other tasks that can be done.</li>
</ul>
<p>PocketFlow's <code>AsyncNode</code> and <code>AsyncFlow</code> let your AI application be like that efficient, asynchronous chef.</p>
<h2><a class="anchor" id="autotoc_md2774"></a>
What is Asynchronous Processing?</h2>
<p>Asynchronous processing allows your program to start a potentially long-running task (like an API call or waiting for user input) and then, instead of freezing and waiting for it to complete, it can switch to doing other work. When the long-running task eventually finishes, the program can pick up where it left off with that task.</p>
<p>This is especially crucial for <b>I/O-bound tasks</b>. "I/O" stands for Input/Output, like:</p><ul>
<li>Reading/writing files from a disk.</li>
<li>Making requests over a network (e.g., to an LLM API, a database, or a web service).</li>
<li>Waiting for user input.</li>
</ul>
<p>These tasks often involve waiting for something external to the program itself. Asynchronous processing ensures your application remains responsive and can handle multiple things (seemingly) at once, improving overall throughput and user experience.</p>
<p>In Python, this is often achieved using the <code>async</code> and <code>await</code> keywords.</p><ul>
<li><code>async def</code> is used to define an asynchronous function (also called a "coroutine").</li>
<li><code>await</code> is used inside an <code>async</code> function to pause its execution until an awaited task (another coroutine or an I/O operation) completes. While paused, other asynchronous tasks can run.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2775"></a>
Meet <code>AsyncNode</code>: The Asynchronous Worker</h2>
<p>In PocketFlow, an <code>AsyncNode</code> is a special type of Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) designed for asynchronous operations. It looks very similar to a regular <code>Node</code>, but its core methods (<code>prep</code>, <code>exec</code>, <code>post</code>) are defined as <code>async</code> functions:</p>
<ul>
<li><code>async def prep_async(self, shared)</code></li>
<li><code>async def exec_async(self, prep_res)</code></li>
<li><code>async def post_async(self, shared, prep_res, exec_res)</code></li>
</ul>
<p>Inside these methods, you can use <code>await</code> to call other asynchronous functions or perform non-blocking I/O operations.</p>
<p>Let's create a simple <code>AsyncNode</code> that simulates fetching data from a website. We'll use <code>asyncio.sleep()</code> to mimic the delay of a network request.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"><span class="keyword">from</span> pocketflow <span class="keyword">import</span> AsyncNode</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>WeatherFetcherNode(AsyncNode):</div>
<div class="line">    <span class="keyword">async def </span>prep_async(self, shared):</div>
<div class="line">        city = shared.get(<span class="stringliteral">&quot;city_name&quot;</span>, <span class="stringliteral">&quot;Unknown city&quot;</span>)</div>
<div class="line">        print(f<span class="stringliteral">&quot;WeatherFetcherNode: Preparing to fetch weather for {city}.&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> city</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>exec_async(self, city):</div>
<div class="line">        print(f<span class="stringliteral">&quot;WeatherFetcherNode: Calling weather API for {city}...&quot;</span>)</div>
<div class="line">        await asyncio.sleep(2) <span class="comment"># Simulate a 2-second API call</span></div>
<div class="line">        weather_data = f<span class="stringliteral">&quot;Sunny in {city}&quot;</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;WeatherFetcherNode: Got weather: {weather_data}&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> weather_data</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>post_async(self, shared, prep_res, exec_res):</div>
<div class="line">        shared[<span class="stringliteral">&quot;weather_report&quot;</span>] = exec_res</div>
<div class="line">        print(f<span class="stringliteral">&quot;WeatherFetcherNode: Weather report stored in shared.&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;done&quot;</span> <span class="comment"># Action to signify completion</span></div>
</div><!-- fragment --><p> In this <code>WeatherFetcherNode</code>:</p><ul>
<li>All methods are <code>async def</code>.</li>
<li><code>exec_async</code> uses <code>await asyncio.sleep(2)</code> to pause for 2 seconds. If this were a real application, it might be <code>await http_client.get(...)</code>. While this <code>await</code> is active, other asynchronous tasks in your program could run.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2776"></a>
Orchestrating with <code>AsyncFlow</code></h2>
<p>To run <code>AsyncNode</code>s, you need an <code>AsyncFlow</code>. As we saw in Chapter 4: Flow (<code>Flow</code>, <code>AsyncFlow</code>), an <code>AsyncFlow</code> can manage both <code>AsyncNode</code>s and regular <code>Node</code>s. When it encounters an <code>AsyncNode</code>, it will correctly <code>await</code> its asynchronous methods.</p>
<p>Let's set up an <code>AsyncFlow</code> to use our <code>WeatherFetcherNode</code>.</p>
<p><b>1. Instantiate your Node(s):</b> </p><div class="fragment"><div class="line">weather_node = WeatherFetcherNode()</div>
<div class="line"><span class="comment"># You could have other nodes here, sync or async</span></div>
</div><!-- fragment --><p><b>2. (Optional) Define Transitions:</b> If you have multiple nodes, you define transitions as usual. Since we only have one node, its returned action <code>"done"</code> will simply end this branch of the flow.</p>
<div class="fragment"><div class="line"><span class="comment"># Example: weather_node - &quot;done&quot; &gt;&gt; some_other_node</span></div>
<div class="line"><span class="comment"># For this example, we&#39;ll let it end.</span></div>
</div><!-- fragment --><p><b>3. Create the <code>AsyncFlow</code>:</b> </p><div class="fragment"><div class="line"><span class="keyword">from</span> pocketflow <span class="keyword">import</span> AsyncFlow</div>
<div class="line"> </div>
<div class="line">weather_flow = AsyncFlow(start=weather_node)</div>
</div><!-- fragment --><p><b>4. Run the <code>AsyncFlow</code>:</b> Running an <code>AsyncFlow</code> requires <code>await</code> because the flow itself is an asynchronous operation. You'll typically do this inside an <code>async</code> function.</p>
<div class="fragment"><div class="line"><span class="comment"># main.py</span></div>
<div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Assume WeatherFetcherNode is defined as above</span></div>
<div class="line"><span class="comment"># Assume weather_flow is created as above</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span><a class="code hl_namespace" href="../../d2/dc1/namespacemain.html">main</a>():</div>
<div class="line">    shared_data = {<span class="stringliteral">&quot;city_name&quot;</span>: <span class="stringliteral">&quot;London&quot;</span>}</div>
<div class="line">    print(<span class="stringliteral">&quot;Starting weather flow...&quot;</span>)</div>
<div class="line">    await weather_flow.run_async(shared_data) <span class="comment"># Use run_async()</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Weather flow finished.&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Final shared data: {shared_data}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:</div>
<div class="line">    asyncio.run(<a class="code hl_namespace" href="../../d2/dc1/namespacemain.html">main</a>()) <span class="comment"># Standard way to run an async main function</span></div>
<div class="ttc" id="anamespacemain_html"><div class="ttname"><a href="../../d2/dc1/namespacemain.html">main</a></div><div class="ttdef"><b>Definition</b> <a href="../../dc/dba/main_8py_source.html#l00001">main.py:1</a></div></div>
</div><!-- fragment --><p><b>Expected Output/Behavior:</b></p>
<p>When you run <code><a class="el" href="../../dc/dba/main_8py.html">main.py</a></code>:</p><ol type="1">
<li>"Starting weather flow..." is printed.</li>
<li><code>WeatherFetcherNode: Preparing to fetch weather for London.</code> is printed.</li>
<li><code>WeatherFetcherNode: Calling weather API for London...</code> is printed.</li>
<li>The program will <em>pause</em> here for about 2 seconds (due to <code>await asyncio.sleep(2)</code>). If other <code>async</code> tasks were scheduled, Python's event loop could run them during this time.</li>
<li>After 2 seconds:<ul>
<li><code>WeatherFetcherNode: Got weather: Sunny in London</code> is printed.</li>
<li><code>WeatherFetcherNode: Weather report stored in shared.</code> is printed.</li>
</ul>
</li>
<li>"Weather flow finished." is printed.</li>
<li>&lsquo;Final shared data: {'city_name&rsquo;: 'London', 'weather_report': 'Sunny in London'}` is printed.</li>
</ol>
<p>The key is that during the 2-second "API call," a well-structured asynchronous application wouldn't be frozen. It could be handling other user requests, updating a UI, or performing other background tasks.</p>
<h2><a class="anchor" id="autotoc_md2777"></a>
What Happens Under the Hood?</h2>
<p>When an <code>AsyncFlow</code> runs an <code>AsyncNode</code>, it leverages Python's <code>asyncio</code> event loop.</p>
<ol type="1">
<li><b><code>AsyncFlow</code> starts:</b> You call <code>await my_async_flow.run_async(shared)</code>.</li>
<li><b>Node Execution:</b> The <code>AsyncFlow</code>'s orchestrator (<code>_orch_async</code>) identifies the current node.</li>
<li><b>Calling <code>_run_async</code>:</b> If the current node is an <code>AsyncNode</code> (like our <code>WeatherFetcherNode</code>), the <code>AsyncFlow</code> calls <code>await current_node._run_async(shared)</code>.</li>
<li><b>Inside <code>AsyncNode</code>:</b><ul>
<li><code>_run_async</code> calls <code>await self.prep_async(shared)</code>.</li>
<li>Then, <code>await self._exec(prep_result)</code> (which internally calls <code>await self.exec_async(prep_result)</code>).</li>
<li>Finally, <code>await self.post_async(shared, prep_result, exec_result)</code>.</li>
</ul>
</li>
<li><b>The <code>await</code> Keyword:</b> When an <code>AsyncNode</code>'s method encounters an <code>await</code> statement (e.g., <code>await asyncio.sleep(2)</code> or <code>await some_api_call()</code>), execution of <em>that specific node's task</em> pauses. Control is yielded back to the <code>asyncio</code> event loop.</li>
<li><b>Event Loop Magic:</b> The event loop can then run other pending asynchronous tasks. It keeps track of the paused task.</li>
<li><b>Task Resumes:</b> When the awaited operation completes (e.g., <code>asyncio.sleep(2)</code> finishes, or the API responds), the event loop resumes the paused <code>AsyncNode</code> task from where it left off.</li>
<li><b>Action and Next Node:</b> The <code>AsyncNode</code>'s <code>post_async</code> eventually returns an action, and the <code>AsyncFlow</code> determines the next node, continuing the process.</li>
</ol>
<p>Here's a sequence diagram to visualize it:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant UserApp as Your main()</div>
<div class="line">    participant AFlow as AsyncFlow</div>
<div class="line">    participant ANode as AsyncNode (e.g., WeatherFetcherNode)</div>
<div class="line">    participant IOSim as Simulated I/O (e.g., asyncio.sleep)</div>
<div class="line">    participant EventLoop as Python Event Loop</div>
<div class="line"> </div>
<div class="line">    UserApp-&gt;&gt;AFlow: await flow.run_async(shared)</div>
<div class="line">    AFlow-&gt;&gt;ANode: await node._run_async(shared)</div>
<div class="line">    ANode-&gt;&gt;ANode: await self.prep_async(shared)</div>
<div class="line">    ANode-&gt;&gt;ANode: await self.exec_async(prep_res)</div>
<div class="line">    Note over ANode,IOSim: e.g., await asyncio.sleep(2)</div>
<div class="line">    ANode-&gt;&gt;IOSim: Start sleep operation</div>
<div class="line">    Note over ANode, EventLoop: Task yields control to Event Loop</div>
<div class="line">    EventLoop-&gt;&gt;EventLoop: (Runs other tasks, if any)</div>
<div class="line">    IOSim--&gt;&gt;ANode: Sleep operation complete</div>
<div class="line">    Note over ANode, EventLoop: Task resumes</div>
<div class="line">    ANode-&gt;&gt;ANode: await self.post_async(shared, exec_res)</div>
<div class="line">    ANode--&gt;&gt;AFlow: Returns action (e.g., &quot;done&quot;)</div>
<div class="line">    AFlow--&gt;&gt;UserApp: Flow complete (shared is updated)</div>
</div><!-- fragment --><p><b>Diving into PocketFlow's Code (Simplified):</b></p>
<ul>
<li><b><code>AsyncNode</code>'s Execution (<code>pocketflow/__init__.py</code>):</b> The <code>AsyncNode</code> has an <code>_run_async</code> method: <code>python @section autotoc_md2778 Inside AsyncNode class async def _run_async(self, shared): p = await self.prep_async(shared) e = await self._exec(p) # _exec calls exec_async with retries return await self.post_async(shared, p, e) </code> And its <code>_exec</code> method handles calling <code>exec_async</code> (and retries, similar to <code>Node</code> but <code>async</code>): <code>python @section autotoc_md2779 Inside AsyncNode class (simplified _exec) async def _exec(self, prep_res): @section autotoc_md2780 ... (retry loop) ... try: return await self.exec_async(prep_res) # Key: await exec_async except Exception as e: @section autotoc_md2781 ... (fallback logic) ... </code></li>
<li><b><code>AsyncFlow</code>'s Orchestration (<code>pocketflow/__init__.py</code>):</b> The <code>AsyncFlow</code> has an <code>_orch_async</code> method that handles running nodes: <code>python @section autotoc_md2782 Inside AsyncFlow class async def _orch_async(self, shared, params=None): curr, p, last_action = self.start_node, (params or {}), None while curr: @section autotoc_md2783 ... (set params for current node) ... if isinstance(curr, AsyncNode): last_action = await curr._run_async(shared) # AWAIT AsyncNode else: last_action = curr._run(shared) # Run sync Node normally curr = self.get_next_node(curr, last_action) return last_action </code> Notice how it checks if <code>curr</code> is an <code>AsyncNode</code> and uses <code>await curr._run_async(shared)</code> if it is. Otherwise, for regular synchronous Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>), it calls <code>curr._run(shared)</code> directly.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2784"></a>
Benefits of Asynchronous Processing</h2>
<ol type="1">
<li><b>Responsiveness:</b> Your application doesn't freeze while waiting for I/O tasks. This is vital for user interfaces or servers handling multiple requests.</li>
<li><b>Improved Throughput:</b> For applications with many I/O-bound tasks (e.g., making multiple API calls), asynchronous processing allows these tasks to overlap their waiting periods, leading to faster overall completion. Imagine our chef preparing multiple simmering dishes at once!</li>
<li><b>Efficient Resource Usage:</b> Threads can be resource-intensive. <code>asyncio</code> often uses a single thread more efficiently by switching between tasks during their I/O wait times.</li>
</ol>
<p>Use <code>AsyncNode</code> and <code>AsyncFlow</code> when your workflow involves tasks that spend significant time waiting for external operations.</p>
<h2><a class="anchor" id="autotoc_md2785"></a>
Conclusion</h2>
<p>You've now unlocked the power of asynchronous processing in PocketFlow with <code>AsyncNode</code> and <code>AsyncFlow</code>!</p><ul>
<li>Asynchronous operations prevent your application from freezing during I/O-bound tasks like API calls.</li>
<li><code>AsyncNode</code> defines its logic with <code>async def</code> methods (<code>prep_async</code>, <code>exec_async</code>, <code>post_async</code>) and uses <code>await</code> for non-blocking waits.</li>
<li><code>AsyncFlow</code> orchestrates these <code>AsyncNode</code>s (and regular <code>Node</code>s) using <code>await flow.run_async()</code>.</li>
<li>This approach leads to more responsive and efficient applications, especially when dealing with network requests or user interactions.</li>
</ul>
<p>This "asynchronous chef" model is incredibly useful. What if you have many similar items to process, perhaps even asynchronously and in parallel? That's where batch processing comes in.</p>
<p>Next up: <a class="el" href="../../d5/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_206__batch__processing______batc450c527fc70ac874b2a5e6905704e4f6.html">Chapter 6: Batch Processing (<code>BatchNode</code>, <code>BatchFlow</code>, <code>AsyncParallelBatchNode</code>)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
