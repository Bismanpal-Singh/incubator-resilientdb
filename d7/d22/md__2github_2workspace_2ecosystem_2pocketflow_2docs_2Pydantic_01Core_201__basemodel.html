#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 01_basemodel</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d7/d22/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_201__basemodel.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">01_basemodel</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2819"></a>
autotoc_md2819</h2>
<p>layout: default title: "BaseModel" parent: "Pydantic Core" </p>
<h2><a class="anchor" id="autotoc_md2820"></a>
nav_order: 1</h2>
<h1><a class="anchor" id="autotoc_md2821"></a>
Chapter 1: BaseModel - Your Data Blueprint</h1>
<p>Welcome to the Pydantic tutorial! We're excited to guide you through the powerful features of Pydantic, starting with the absolute core concept: <code>BaseModel</code>.</p>
<h2><a class="anchor" id="autotoc_md2822"></a>
Why Do We Need Structured Data?</h2>
<p>Imagine you're building a web application. You receive data from users – maybe their name and age when they sign up. This data might come as JSON, form data, or just plain Python dictionaries.</p>
<div class="fragment"><div class="line">// Example user data from an API</div>
<div class="line">{</div>
<div class="line">  &quot;username&quot;: &quot;cool_cat_123&quot;,</div>
<div class="line">  &quot;age&quot;: &quot;28&quot;, // Oops, age is a string!</div>
<div class="line">  &quot;email&quot;: &quot;cat@example.com&quot;</div>
<div class="line">}</div>
</div><!-- fragment --><p>How do you make sure this data is correct? Is <code>username</code> always provided? Is <code>age</code> actually a number, or could it be text like <code>"twenty-eight"</code>? Handling all these checks manually can be tedious and error-prone.</p>
<p>This is where Pydantic and <code>BaseModel</code> come in!</p>
<h2><a class="anchor" id="autotoc_md2823"></a>
Introducing <code>BaseModel</code>: The Blueprint</h2>
<p>Think of <code>BaseModel</code> as a <b>blueprint</b> for your data. You define the structure you expect – what fields should exist and what their types should be (like <code>string</code>, <code>integer</code>, <code>boolean</code>, etc.). Pydantic then uses this blueprint to automatically:</p>
<ol type="1">
<li><b>Parse:</b> Read incoming data (like a dictionary).</li>
<li><b>Validate:</b> Check if the data matches your blueprint (e.g., is <code>age</code> really an integer?). If not, it tells you exactly what's wrong.</li>
<li><b>Serialize:</b> Convert your structured data back into simple formats (like a dictionary or JSON) when you need to send it somewhere else.</li>
</ol>
<p>It's like having an automatic quality checker and translator for your data!</p>
<h2><a class="anchor" id="autotoc_md2824"></a>
Defining Your First Model</h2>
<p>Let's create a blueprint for a simple <code>User</code>. We want each user to have a <code>name</code> (which should be text) and an <code>age</code> (which should be a whole number).</p>
<p>In Pydantic, you do this by creating a class that inherits from <code>BaseModel</code> and using standard Python type hints:</p>
<div class="fragment"><div class="line"><span class="comment"># Import BaseModel from Pydantic</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define your data blueprint (Model)</span></div>
<div class="line"><span class="keyword">class </span>User(BaseModel):</div>
<div class="line">    name: str  <span class="comment"># The user&#39;s name must be a string</span></div>
<div class="line">    age: int   <span class="comment"># The user&#39;s age must be an integer</span></div>
</div><!-- fragment --><p>That's it! This simple class <code>User</code> is now a Pydantic model. It acts as the blueprint for creating user objects.</p>
<h2><a class="anchor" id="autotoc_md2825"></a>
Using Your <code>BaseModel</code> Blueprint</h2>
<p>Now that we have our <code>User</code> blueprint, let's see how to use it.</p>
<h3><a class="anchor" id="autotoc_md2826"></a>
Creating Instances (Parsing and Validation)</h3>
<p>You create instances of your model just like any regular Python class, passing the data as keyword arguments. Pydantic automatically parses and validates the data against your type hints (<code>name: str</code>, <code>age: int</code>).</p>
<p><b>1. Valid Data:</b></p>
<div class="fragment"><div class="line"><span class="comment"># Input data (e.g., from a dictionary)</span></div>
<div class="line">user_data = {<span class="stringliteral">&#39;name&#39;</span>: <span class="stringliteral">&#39;Alice&#39;</span>, <span class="stringliteral">&#39;age&#39;</span>: 30}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a User instance</span></div>
<div class="line">user_alice = User(**user_data) <span class="comment"># The ** unpacks the dictionary</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Pydantic checked that &#39;name&#39; is a string and &#39;age&#39; is an integer.</span></div>
<div class="line"><span class="comment"># It worked! Let&#39;s see the created object.</span></div>
<div class="line">print(user_alice)</div>
<div class="line"><span class="comment"># Expected Output: name=&#39;Alice&#39; age=30</span></div>
</div><!-- fragment --><p>Behind the scenes, Pydantic looked at <code>user_data</code>, compared it to the <code>User</code> blueprint, saw that &lsquo;'Alice&rsquo;<code>is a valid</code>str<code>and</code>30<code>is a valid</code>int<code>, and created the</code>user_alice` object.</p>
<p><b>2. Invalid Data:</b></p>
<p>What happens if the data doesn't match the blueprint?</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, ValidationError</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>User(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    age: int</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Input data with age as a string that isn&#39;t a number</span></div>
<div class="line">invalid_data = {<span class="stringliteral">&#39;name&#39;</span>: <span class="stringliteral">&#39;Bob&#39;</span>, <span class="stringliteral">&#39;age&#39;</span>: <span class="stringliteral">&#39;twenty-eight&#39;</span>}</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    user_bob = User(**invalid_data)</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(e)</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Expected Output (simplified):</span></div>
<div class="line"><span class="stringliteral">    1 validation error for User</span></div>
<div class="line"><span class="stringliteral">    age</span></div>
<div class="line"><span class="stringliteral">      Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value=&#39;twenty-eight&#39;, input_type=str]</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
</div><!-- fragment --><p>Pydantic catches the error! Because &lsquo;'twenty-eight&rsquo;<code>cannot be understood as an</code>int<code>for the</code>age<code>field, it raises a helpful</code>ValidationError<code>telling you exactly which field (</code>age`) failed and why.</p>
<p><b>3. Type Coercion (Smart Conversion):</b></p>
<p>Pydantic is often smart enough to convert types when it makes sense. For example, if you provide <code>age</code> as a string containing digits:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>User(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    age: int</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Input data with age as a numeric string</span></div>
<div class="line">data_with_string_age = {<span class="stringliteral">&#39;name&#39;</span>: <span class="stringliteral">&#39;Charlie&#39;</span>, <span class="stringliteral">&#39;age&#39;</span>: <span class="stringliteral">&#39;35&#39;</span>}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a User instance</span></div>
<div class="line">user_charlie = User(**data_with_string_age)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Pydantic converted the string &#39;35&#39; into the integer 35!</span></div>
<div class="line">print(user_charlie)</div>
<div class="line"><span class="comment"># Expected Output: name=&#39;Charlie&#39; age=35</span></div>
<div class="line">print(type(user_charlie.age))</div>
<div class="line"><span class="comment"># Expected Output: &lt;class &#39;int&#39;&gt;</span></div>
</div><!-- fragment --><p>Pydantic automatically <em>coerced</em> the string &lsquo;'35&rsquo;<code>into the integer</code>35<code>because the blueprint specified</code>age: int`. This leniency is often very convenient.</p>
<h3><a class="anchor" id="autotoc_md2827"></a>
Accessing Data</h3>
<p>Once you have a valid model instance, you access its data using standard attribute access:</p>
<div class="fragment"><div class="line"><span class="comment"># Continuing from the user_alice example:</span></div>
<div class="line">print(f<span class="stringliteral">&quot;User&#39;s Name: {user_alice.name}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: User&#39;s Name: Alice</span></div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;User&#39;s Age: {user_alice.age}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: User&#39;s Age: 30</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2828"></a>
Serialization (Converting Back)</h3>
<p>Often, you'll need to convert your model instance back into a basic Python dictionary (e.g., to send it as JSON over a network). <code>BaseModel</code> provides easy ways to do this:</p>
<p><b>1. <code>model_dump()</code>:</b> Converts the model to a dictionary.</p>
<div class="fragment"><div class="line"><span class="comment"># Continuing from the user_alice example:</span></div>
<div class="line">user_dict = user_alice.model_dump()</div>
<div class="line"> </div>
<div class="line">print(user_dict)</div>
<div class="line"><span class="comment"># Expected Output: {&#39;name&#39;: &#39;Alice&#39;, &#39;age&#39;: 30}</span></div>
<div class="line">print(type(user_dict))</div>
<div class="line"><span class="comment"># Expected Output: &lt;class &#39;dict&#39;&gt;</span></div>
</div><!-- fragment --><p><b>2. <code>model_dump_json()</code>:</b> Converts the model directly to a JSON string.</p>
<div class="fragment"><div class="line"><span class="comment"># Continuing from the user_alice example:</span></div>
<div class="line">user_json = user_alice.model_dump_json(indent=2) <span class="comment"># indent for pretty printing</span></div>
<div class="line"> </div>
<div class="line">print(user_json)</div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># {</span></div>
<div class="line"><span class="comment">#   &quot;name&quot;: &quot;Alice&quot;,</span></div>
<div class="line"><span class="comment">#   &quot;age&quot;: 30</span></div>
<div class="line"><span class="comment"># }</span></div>
<div class="line">print(type(user_json))</div>
<div class="line"><span class="comment"># Expected Output: &lt;class &#39;str&#39;&gt;</span></div>
</div><!-- fragment --><p>These methods allow you to easily share your structured data.</p>
<h2><a class="anchor" id="autotoc_md2829"></a>
Under the Hood: How Does <code>BaseModel</code> Work?</h2>
<p>You don't <em>need</em> to know the internals to use Pydantic effectively, but a little insight can be helpful!</p>
<p><b>High-Level Steps:</b></p>
<p>When Python creates your <code>User</code> class (which inherits from <code>BaseModel</code>), some Pydantic magic happens via its <code>ModelMetaclass</code>:</p>
<ol type="1">
<li><b>Inspection:</b> Pydantic looks at your class definition (<code>User</code>), finding the fields (<code>name</code>, <code>age</code>) and their type hints (<code>str</code>, <code>int</code>).</li>
<li><b>Schema Generation:</b> It generates an internal "Core Schema". This is a detailed, language-agnostic description of your data structure and validation rules. Think of it as an even more detailed blueprint used internally by Pydantic's fast validation engine (written in Rust!). We'll explore this more in <a class="el" href="../../d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html">Chapter 5</a>.</li>
<li><b>Validator/Serializer Creation:</b> Based on this Core Schema, Pydantic creates highly optimized functions (internally) for validating input data and serializing model instances for <em>this specific model</em> (<code>User</code>).</li>
</ol>
<p>Here's a simplified diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Dev as Developer</div>
<div class="line">    participant Py as Python Interpreter</div>
<div class="line">    participant Meta as BaseModel Metaclass</div>
<div class="line">    participant Core as Pydantic Core Engine</div>
<div class="line"> </div>
<div class="line">    Dev-&gt;&gt;Py: Define `class User(BaseModel): name: str, age: int`</div>
<div class="line">    Py-&gt;&gt;Meta: Ask to create the `User` class</div>
<div class="line">    Meta-&gt;&gt;Meta: Inspect fields (`name: str`, `age: int`)</div>
<div class="line">    Meta-&gt;&gt;Core: Request schema based on fields &amp; types</div>
<div class="line">    Core--&gt;&gt;Meta: Provide internal Core Schema for User</div>
<div class="line">    Meta-&gt;&gt;Core: Request validator function from schema</div>
<div class="line">    Core--&gt;&gt;Meta: Provide optimized validator</div>
<div class="line">    Meta-&gt;&gt;Core: Request serializer function from schema</div>
<div class="line">    Core--&gt;&gt;Meta: Provide optimized serializer</div>
<div class="line">    Meta--&gt;&gt;Py: Return the fully prepared `User` class (with hidden validator/serializer attached)</div>
<div class="line">    Py--&gt;&gt;Dev: `User` class is ready to use</div>
</div><!-- fragment --><p><b>Instantiation and Serialization Flow:</b></p>
<ul>
<li>When you call &lsquo;User(name='Alice&rsquo;, age=30)<code>, Python calls the</code>User<code>class's</code>__init__<code>method. Pydantic intercepts this and uses the optimized **validator** created earlier to check the input data against the Core Schema. If valid, it creates the instance; otherwise, it raises</code>ValidationError<code>.</code></li>
<li><code> When you call</code>user_alice.model_dump()`, Pydantic uses the optimized <b>serializer</b> created earlier to convert the instance's data back into a dictionary, again following the rules defined in the Core Schema.</li>
</ul>
<p><b>Code Location:</b></p>
<p>Most of this intricate setup logic happens within the <code>ModelMetaclass</code> found in <code>pydantic._internal._model_construction.py</code>. It coordinates with the <code>pydantic-core</code> Rust engine to build the schema and the validation/serialization logic.</p>
<div class="fragment"><div class="line"><span class="comment"># Extremely simplified conceptual view of metaclass action</span></div>
<div class="line"><span class="keyword">class </span>ModelMetaclass(type):</div>
<div class="line">    <span class="keyword">def </span>__new__(mcs, name, bases, namespace, **kwargs):</div>
<div class="line">        <span class="comment"># 1. Find fields and type hints in &#39;namespace&#39;</span></div>
<div class="line">        fields = {} <span class="comment"># Simplified: find &#39;name: str&#39;, &#39;age: int&#39;</span></div>
<div class="line">        annotations = {} <span class="comment"># Simplified</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># ... collect fields, config, etc. ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 2. Generate Core Schema (pseudo-code)</span></div>
<div class="line">        <span class="comment"># core_schema = pydantic_core.generate_schema(fields, annotations, config)</span></div>
<div class="line">        <span class="comment"># (This happens internally, see Chapter 5)</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 3. Create validator &amp; serializer (pseudo-code)</span></div>
<div class="line">        <span class="comment"># validator = pydantic_core.SchemaValidator(core_schema)</span></div>
<div class="line">        <span class="comment"># serializer = pydantic_core.SchemaSerializer(core_schema)</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Create the actual class object</span></div>
<div class="line">        cls = super().__new__(mcs, name, bases, namespace, **kwargs)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Attach the generated validator/serializer (simplified)</span></div>
<div class="line">        <span class="comment"># cls.__pydantic_validator__ = validator</span></div>
<div class="line">        <span class="comment"># cls.__pydantic_serializer__ = serializer</span></div>
<div class="line">        <span class="comment"># cls.__pydantic_core_schema__ = core_schema # Store the schema</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> cls</div>
<div class="line"> </div>
<div class="line"><span class="comment"># class BaseModel(metaclass=ModelMetaclass):</span></div>
<div class="line"><span class="comment">#    ... rest of BaseModel implementation ...</span></div>
</div><!-- fragment --><p>This setup ensures that validation and serialization are defined <em>once</em> when the class is created, making instance creation (<code>User(...)</code>) and dumping (<code>model_dump()</code>) very fast.</p>
<h2><a class="anchor" id="autotoc_md2830"></a>
Conclusion</h2>
<p>You've learned the fundamentals of <code>pydantic.BaseModel</code>:</p>
<ul>
<li>It acts as a <b>blueprint</b> for your data structures.</li>
<li>You define fields and their types using standard <b>Python type hints</b>.</li>
<li>Pydantic automatically handles <b>parsing</b>, <b>validation</b> (with helpful errors), and <b>serialization</b> (<code>model_dump</code>, <code>model_dump_json</code>).</li>
<li>It uses a powerful internal <b>Core Schema</b> and optimized validators/serializers for great performance.</li>
</ul>
<p><code>BaseModel</code> is the cornerstone of Pydantic. Now that you understand the basics, you might be wondering how to add more specific validation rules (like "age must be positive") or control how fields are handled during serialization.</p>
<p>In the next chapter, we'll dive into customizing fields using the <code>Field</code> function.</p>
<p>Next: <a class="el" href="../../d9/df6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_202__fields____fieldinfo______field__function__.html">Chapter 2: Fields (FieldInfo / Field function)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
