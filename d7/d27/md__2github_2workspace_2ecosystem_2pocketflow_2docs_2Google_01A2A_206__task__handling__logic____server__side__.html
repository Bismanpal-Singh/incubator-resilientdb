#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_task_handling_logic__server_side_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d7/d27/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_206__task__handling__logic____server__side__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_task_handling_logic__server_side_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2010"></a>
autotoc_md2010</h2>
<p>layout: default title: "Task Handling Logic (Server-side)" parent: "Google A2A" </p>
<h2><a class="anchor" id="autotoc_md2011"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md2012"></a>
Chapter 6: Task Handling Logic (Server-side)</h1>
<p>Welcome back! In <a class="el" href="../../dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html">Chapter 5: A2A Client Implementation</a>, we learned how to build the "customer" side – the <b>A2A Client</b> – that sends requests to an agent's server. We saw how it formats messages and talks to the agent's "embassy" (<a class="el" href="../../d6/dcb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_204__a2a__server__implementation.html">A2A Server Implementation</a>).</p>
<p>But what happens <em>inside</em> the embassy once a request arrives? Who actually reads the request, does the work, and prepares the response?</p>
<p>This chapter focuses on the <b>Task Handling Logic</b>. It solves the problem: <b>What is the core "brain" inside the A2A Server that performs the requested work?</b></p>
<h2><a class="anchor" id="autotoc_md2013"></a>
The Agent's "Brain" - The Chef in the Kitchen</h2>
<p>Imagine our A2A Server (<a class="el" href="../../d6/dcb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_204__a2a__server__implementation.html">Chapter 4</a>) is like a restaurant's front desk. It takes orders (<a class="el" href="../../d2/d9c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_202__task.html">Tasks</a>) from customers (<a class="el" href="../../dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html">A2A Clients</a>) using the standard A2A language (<a class="el" href="../../d8/d90/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_203__a2a__protocol______core__types.html">A2A Protocol &amp; Core Types</a>).</p>
<p>But the front desk doesn't cook the food! It passes the order to the <b>kitchen</b>, where the <b>chef</b> takes over. The chef:</p>
<ol type="1">
<li><b>Reads the Order:</b> Understands what the customer wants (e.g., "Translate 'hello' to French").</li>
<li><b>Prepares the Dish:</b> Uses ingredients (data), tools (APIs, databases), and expertise (AI models like Gemini) to fulfill the request.</li>
<li><b>Updates the Waiter:</b> Might send updates back like "Order is being prepared" (<code>working</code> state).</li>
<li><b>Finishes the Dish:</b> Creates the final product (the translated text "Bonjour le monde").</li>
<li><b>Plates the Dish:</b> Packages the result (<code>Artifacts</code>) and signals completion (<code>completed</code> state).</li>
</ol>
<p>The <b>Task Handling Logic</b> is the "chef" inside your A2A Server. It's the core piece of code that contains the agent's specific skills and business logic.</p>
<h2><a class="anchor" id="autotoc_md2014"></a>
What Does the Task Handler Do?</h2>
<p>When the A2A Server receives a request like <code>tasks/send</code>, it hands off the details to the Task Handling Logic. This logic is responsible for:</p>
<ul>
<li><b>Understanding the Request:</b> Receiving the user's <code>Message</code> and any other context associated with the <code>Task</code>.</li>
<li><b>Executing the Work:</b><ul>
<li>Calling AI models (like Gemini via libraries like Genkit) for generation, analysis, etc.</li>
<li>Using tools (like calling a weather API, searching a database, or using specific libraries like CrewAI or LangGraph).</li>
<li>Performing custom calculations or data manipulation.</li>
</ul>
</li>
<li><b>Managing State:</b> Signaling progress by updating the <code>Task</code>'s status (e.g., changing from <code>submitted</code> to <code>working</code>).</li>
<li><b>Generating Output:</b> Creating the final results (<code>Artifacts</code>) or intermediate updates.</li>
<li><b>Handling Errors:</b> Reporting back if something goes wrong (<code>failed</code> state).</li>
</ul>
<h2><a class="anchor" id="autotoc_md2015"></a>
Implementing the "Brain"</h2>
<p>The <code>Google A2A</code> libraries provide structures to help you implement this logic. Let's look at simplified examples.</p>
<h3><a class="anchor" id="autotoc_md2016"></a>
JavaScript Example (Async Generator Handler)</h3>
<p>In JavaScript, the task handler is often an <code>async function*</code> (an asynchronous generator). It receives <code>TaskContext</code> and uses <code>yield</code> to send back updates.</p>
<p>Imagine a simple agent that pretends to call an AI to greet the user.</p>
<div class="fragment"><div class="line">// File: samples/js/src/server/handler.ts (Conceptual Example of a Handler)</div>
<div class="line">import * as schema from &quot;../schema.js&quot;; // For types like Task, Message, etc.</div>
<div class="line">import { TaskContext, TaskYieldUpdate } from &quot;./handler.js&quot;; // Handler types</div>
<div class="line"> </div>
<div class="line">// The Task Handling Logic for our &#39;Greeter Agent&#39;</div>
<div class="line">async function* greeterAgentHandler(</div>
<div class="line">  context: TaskContext</div>
<div class="line">): AsyncGenerator&lt;TaskYieldUpdate&gt; { // It yields updates</div>
<div class="line"> </div>
<div class="line">  // 1. Get the user&#39;s name from the input message</div>
<div class="line">  const userMessageText = context.userMessage.parts[0].text ?? &quot;there&quot;;</div>
<div class="line">  const userName = userMessageText.split(&quot; &quot;).pop(); // Simple extraction</div>
<div class="line"> </div>
<div class="line">  // 2. Signal that work is starting</div>
<div class="line">  console.log(`[GreeterAgent] Task ${context.task.id}: Starting`);</div>
<div class="line">  yield {</div>
<div class="line">    state: &quot;working&quot;, // Update status to &#39;working&#39;</div>
<div class="line">    message: { role: &quot;agent&quot;, parts: [{ text: &quot;Thinking...&quot; }] }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  // 3. Simulate calling an AI (the &quot;chef&quot; uses an &quot;ingredient&quot;)</div>
<div class="line">  await new Promise(resolve =&gt; setTimeout(resolve, 500)); // Pretend work</div>
<div class="line">  const greeting = `Hello, ${userName}! Welcome.`;</div>
<div class="line"> </div>
<div class="line">  // 4. Signal completion and provide the final message</div>
<div class="line">  console.log(`[GreeterAgent] Task ${context.task.id}: Completing`);</div>
<div class="line">  yield {</div>
<div class="line">    state: &quot;completed&quot;, // Update status to &#39;completed&#39;</div>
<div class="line">    message: { role: &quot;agent&quot;, parts: [{ text: greeting }] }</div>
<div class="line">  };</div>
<div class="line">  // For more complex results, we could yield Artifacts here too.</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// This handler function (`greeterAgentHandler`) would be passed</div>
<div class="line">// to the A2AServer constructor, like in Chapter 4.</div>
<div class="line">// const server = new A2AServer(greeterAgentHandler, { card: greeterAgentCard });</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Input:</b> The function receives <code>context</code> which contains the current <code>task</code> and the <code>userMessage</code>. We extract the user's name.</li>
<li><b>Signal Working:</b> It <code>yield</code>s an update object setting the <code>state</code> to <code>working</code> and providing an optional status message. The A2A Server receives this yield.</li>
<li><b>Do Work:</b> It simulates calling an AI to generate a greeting. In real agents (like <code>samples/js/src/agents/coder/index.ts</code> or <code>samples/js/src/agents/movie-agent/index.ts</code>), this is where you'd interact with Genkit, external APIs, or other tools.</li>
<li><b>Signal Completion:</b> It <code>yield</code>s the final update, setting the <code>state</code> to <code>completed</code> and including the greeting in the agent's <code>message</code>.</li>
</ol>
<h3><a class="anchor" id="autotoc_md2017"></a>
Python Example (TaskManager with Streaming)</h3>
<p>In Python, you typically subclass <code>TaskManager</code> and implement methods like <code>on_send_task</code> or <code>on_send_task_subscribe</code>. For streaming responses, <code>on_send_task_subscribe</code> can also be an async generator.</p>
<p>Let's create a similar Greeter Agent.</p>
<div class="fragment"><div class="line"><span class="comment"># File: my_agent/task_manager.py (Conceptual Example)</span></div>
<div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Union, AsyncIterable</div>
<div class="line"><span class="keyword">from</span> common.server.task_manager <span class="keyword">import</span> InMemoryTaskManager <span class="comment"># Base class</span></div>
<div class="line"><span class="keyword">from</span> common.types <span class="keyword">import</span> (</div>
<div class="line">    Task, TaskSendParams, TaskStatus, TaskState, Message, TextPart,</div>
<div class="line">    SendTaskStreamingRequest, SendTaskStreamingResponse, TaskStatusUpdateEvent,</div>
<div class="line">    JSONRPCResponse</div>
<div class="line">)</div>
<div class="line"><span class="keyword">import</span> logging</div>
<div class="line"> </div>
<div class="line">logger = logging.getLogger(__name__)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>GreeterTaskManager(InMemoryTaskManager): <span class="comment"># Inherit from base</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Handle non-streaming requests (optional)</span></div>
<div class="line">    <span class="keyword">async def </span>on_send_task(self, request):</div>
<div class="line">        <span class="comment"># ... implementation for non-streaming ...</span></div>
<div class="line">        <span class="keywordflow">raise</span> NotImplementedError()</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Handle STREAMING requests using an async generator</span></div>
<div class="line">    <span class="keyword">async def </span>on_send_task_subscribe(</div>
<div class="line">        self, request: SendTaskStreamingRequest</div>
<div class="line">    ) -&gt; Union[AsyncIterable[SendTaskStreamingResponse], JSONRPCResponse]:</div>
<div class="line"> </div>
<div class="line">        task_params: TaskSendParams = request.params</div>
<div class="line">        task_id = task_params.id</div>
<div class="line">        logger.info(f<span class="stringliteral">&quot;[GreeterAgent] Task {task_id}: Received&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 0. Set up internal queue for SSE events</span></div>
<div class="line">        <span class="comment"># (Handled by library/base class, conceptually)</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 1. Update store &amp; get initial Task object</span></div>
<div class="line">        await self.upsert_task(task_params) <span class="comment"># Store the task initially</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># --- Start the async generator part ---</span></div>
<div class="line">        <span class="keyword">async def </span>_process_task() -&gt; AsyncIterable[SendTaskStreamingResponse]:</div>
<div class="line">            <span class="keywordflow">try</span>:</div>
<div class="line">                <span class="comment"># 2. Get user name from input</span></div>
<div class="line">                user_message_text = task_params.message.parts[0].text <span class="keywordflow">if</span> task_params.message.parts <span class="keywordflow">else</span> <span class="stringliteral">&quot;there&quot;</span></div>
<div class="line">                user_name = user_message_text.split(<span class="stringliteral">&quot; &quot;</span>).pop()</div>
<div class="line"> </div>
<div class="line">                <span class="comment"># 3. Signal working (Yield a status update event)</span></div>
<div class="line">                working_status = TaskStatus(state=TaskState.WORKING, message=Message(role=<span class="stringliteral">&quot;agent&quot;</span>, parts=[TextPart(text=<span class="stringliteral">&quot;Thinking...&quot;</span>)]))</div>
<div class="line">                working_event = TaskStatusUpdateEvent(id=task_id, status=working_status, final=<span class="keyword">False</span>)</div>
<div class="line">                <span class="keywordflow">yield</span> SendTaskStreamingResponse(id=request.id, result=working_event)</div>
<div class="line">                <span class="comment"># Update internal store (optional, depending on base class)</span></div>
<div class="line">                await self.update_store(task_id, working_status, artifacts=<span class="keywordtype">None</span>)</div>
<div class="line"> </div>
<div class="line">                <span class="comment"># 4. Simulate AI call</span></div>
<div class="line">                await asyncio.sleep(0.5)</div>
<div class="line">                greeting = f<span class="stringliteral">&quot;Hello, {user_name}! Welcome from Python.&quot;</span></div>
<div class="line"> </div>
<div class="line">                <span class="comment"># 5. Signal completion (Yield final status update event)</span></div>
<div class="line">                completed_status = TaskStatus(state=TaskState.COMPLETED, message=Message(role=<span class="stringliteral">&quot;agent&quot;</span>, parts=[TextPart(text=greeting)]))</div>
<div class="line">                completed_event = TaskStatusUpdateEvent(id=task_id, status=completed_status, final=<span class="keyword">True</span>) <span class="comment"># final=True</span></div>
<div class="line">                <span class="keywordflow">yield</span> SendTaskStreamingResponse(id=request.id, result=completed_event)</div>
<div class="line">                <span class="comment"># Update internal store</span></div>
<div class="line">                await self.update_store(task_id, completed_status, artifacts=<span class="keywordtype">None</span>)</div>
<div class="line"> </div>
<div class="line">                logger.info(f<span class="stringliteral">&quot;[GreeterAgent] Task {task_id}: Completed&quot;</span>)</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">                logger.error(f<span class="stringliteral">&quot;[GreeterAgent] Task {task_id}: Error - {e}&quot;</span>)</div>
<div class="line">                <span class="comment"># Signal failure</span></div>
<div class="line">                failed_status = TaskStatus(state=TaskState.FAILED, message=Message(role=<span class="stringliteral">&quot;agent&quot;</span>, parts=[TextPart(text=f<span class="stringliteral">&quot;Error: {e}&quot;</span>)]))</div>
<div class="line">                failed_event = TaskStatusUpdateEvent(id=task_id, status=failed_status, final=<span class="keyword">True</span>)</div>
<div class="line">                <span class="keywordflow">yield</span> SendTaskStreamingResponse(id=request.id, result=failed_event)</div>
<div class="line">                await self.update_store(task_id, failed_status, artifacts=<span class="keywordtype">None</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Return the async generator</span></div>
<div class="line">        <span class="keywordflow">return</span> _process_task()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># This GreeterTaskManager class would be passed to the A2AServer</span></div>
<div class="line"><span class="comment"># server = A2AServer(task_manager=GreeterTaskManager(), ...)</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Inheritance:</b> We create <code>GreeterTaskManager</code> inheriting from <code>InMemoryTaskManager</code> (which provides basic task storage).</li>
<li><b><code>on_send_task_subscribe</code>:</b> This method handles streaming requests. It first stores the initial task details.</li>
<li><b>Async Generator (<code>_process_task</code>):</b> The core logic is inside an inner <code>async def</code> that returns an <code>AsyncIterable</code>. This allows us to <code>yield</code> updates over time, similar to the JavaScript generator.</li>
<li><b>Yielding Events:</b> Instead of yielding raw status updates, we yield <code>SendTaskStreamingResponse</code> objects containing <code>TaskStatusUpdateEvent</code>. The <code>final=True</code> flag marks the last event. (<a class="el" href="../../d0/d60/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_207__streaming__communication____sse__.html">Chapter 7: Streaming Communication (SSE)</a> covers SSE in detail).</li>
<li><b>Updating Store:</b> We explicitly call <code>self.update_store</code> after yielding events to keep the task's state consistent in our <code>InMemoryTaskManager</code>.</li>
<li><b>Error Handling:</b> A <code>try...except</code> block handles potential errors and yields a <code>failed</code> state event.</li>
</ol>
<p>Real-world Python agents might use frameworks like CrewAI (<code>samples/python/agents/crewai/agent.py</code>) or LangGraph (<code>samples/python/agents/langgraph/agent.py</code>) within these handler methods to orchestrate more complex logic.</p>
<h2><a class="anchor" id="autotoc_md2018"></a>
Key Inputs to the Handler</h2>
<p>The handler needs information to do its job. The context typically includes:</p>
<ul>
<li><b>Task Details:</b> The current <code>Task</code> object, including its unique <code>id</code>, current <code>status</code>, and any <code>metadata</code>.</li>
<li><b>User Message:</b> The specific <code>Message</code> from the user that triggered this work (containing <code>Parts</code> like text or files).</li>
<li><b>History (Optional):</b> Previous <code>Messages</code> exchanged within this <code>Task</code> for conversational context.</li>
<li><b>Cancellation Check:</b> A way to see if the client has requested to cancel the task.</li>
</ul>
<p>These inputs are bundled in <code>TaskContext</code> (JS) or passed as parameters to the <code>TaskManager</code> methods (Python).</p>
<h2><a class="anchor" id="autotoc_md2019"></a>
Signaling Progress and Delivering Results</h2>
<ul>
<li><b>Status Updates:</b> Yielding status changes (<code>working</code>, <code>input-required</code>, <code>completed</code>, <code>failed</code>) keeps the client informed, especially for long-running tasks. This often includes a <code>Message</code> from the agent (e.g., "Looking up information...", "Please provide the city name.").</li>
<li><b>Artifacts (Results):</b> For tasks that produce distinct outputs (like files, structured data, or images), the handler yields <code>Artifact</code> objects. These artifacts are collected and associated with the <code>Task</code>.<ul>
<li>JS: Yield <code>schema.Artifact</code> objects directly. (<code>samples/js/src/agents/coder/index.ts</code>)</li>
<li>Python (Streaming): Yield <code>SendTaskStreamingResponse</code> containing <code>TaskArtifactUpdateEvent</code>. (<code>demo/ui/service/server/adk_host_manager.py</code> shows <code>process_artifact_event</code>)</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md2020"></a>
Connecting to the Server</h2>
<p>As shown in <a class="el" href="../../d6/dcb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_204__a2a__server__implementation.html">Chapter 4</a>, you connect your Task Handling Logic to the <code>A2AServer</code> during its setup:</p>
<ul>
<li><b>JS:</b> Pass the async generator function (<code>greeterAgentHandler</code>) to the <code>A2AServer</code> constructor.</li>
<li><b>Python:</b> Pass an instance of your <code>TaskManager</code> subclass (<code>GreeterTaskManager()</code>) to the <code>A2AServer</code> constructor.</li>
</ul>
<p>The server then knows exactly which "chef" to call when an order comes in.</p>
<h2><a class="anchor" id="autotoc_md2021"></a>
Under the Hood: Server Invoking the Handler</h2>
<p>Let's visualize how the server uses the handler when a streaming <code>tasks/sendSubscribe</code> request arrives:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant C as A2A Client</div>
<div class="line">    participant S as A2A Server</div>
<div class="line">    participant TH as Task Handler (e.g., greeterAgentHandler)</div>
<div class="line">    participant AI as AI Model/Tool (Optional)</div>
<div class="line">    participant TS as Task Store</div>
<div class="line"> </div>
<div class="line">    C-&gt;&gt;S: POST / (JSON-RPC: method=&quot;tasks/sendSubscribe&quot;, params={...})</div>
<div class="line">    Note right of S: Receives request, parses JSON-RPC</div>
<div class="line"> </div>
<div class="line">    S-&gt;&gt;TS: Create/Get Task Record (ID: task-123)</div>
<div class="line">    TS--&gt;&gt;S: Task Object (state: submitted)</div>
<div class="line"> </div>
<div class="line">    S-&gt;&gt;TH: Invoke handler(context) / Call on_send_task_subscribe()</div>
<div class="line">    Note right of TH: Handler starts executing</div>
<div class="line"> </div>
<div class="line">    TH-&gt;&gt;TS: Update Task (state: working)</div>
<div class="line">    TH--&gt;&gt;S: yield {state: &quot;working&quot;, ...} / yield TaskStatusUpdateEvent(working)</div>
<div class="line">    Note right of S: Receives yielded update</div>
<div class="line"> </div>
<div class="line">    S--&gt;&gt;C: Send SSE Event (data: TaskStatusUpdateEvent - working)</div>
<div class="line">    Note left of C: Client receives &#39;working&#39; status</div>
<div class="line"> </div>
<div class="line">    alt Handler needs AI/Tool</div>
<div class="line">        TH-&gt;&gt;AI: Request generation(&quot;greet user&quot;)</div>
<div class="line">        AI--&gt;&gt;TH: Response (&quot;Hello there!&quot;)</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    TH-&gt;&gt;TS: Update Task (state: completed, message: &quot;Hello...&quot;)</div>
<div class="line">    TH--&gt;&gt;S: yield {state: &quot;completed&quot;, ...} / yield TaskStatusUpdateEvent(completed, final=True)</div>
<div class="line">    Note right of S: Receives final yielded update</div>
<div class="line"> </div>
<div class="line">    S--&gt;&gt;C: Send SSE Event (data: TaskStatusUpdateEvent - completed, final=True)</div>
<div class="line">    Note left of C: Client receives &#39;completed&#39; status, stream ends</div>
</div><!-- fragment --><p><b>Steps:</b></p>
<ol type="1">
<li><b>Request In:</b> The <code>A2A Server</code> receives the <code>tasks/sendSubscribe</code> request.</li>
<li><b>Task Prep:</b> It looks up or creates the <code>Task</code> in the <code>Task Store</code>.</li>
<li><b>Invoke Handler:</b> It calls your registered Task Handling Logic (e.g., <code>greeterAgentHandler</code> or <code>GreeterTaskManager.on_send_task_subscribe</code>), providing the necessary context.</li>
<li><b>Handler Executes &amp; Yields:</b> Your handler runs. When it <code>yield</code>s a status update (like <code>working</code>):<ul>
<li>It might update the <code>Task Store</code>.</li>
<li>It returns the update to the <code>A2AServer</code>.</li>
</ul>
</li>
<li><b>Server Sends Update:</b> The <code>A2AServer</code> formats the update as a Server-Sent Event (SSE) and sends it to the <code>A2A Client</code>.</li>
<li><b>(Optional) External Calls:</b> The handler might call external services (AI, tools).</li>
<li><b>Handler Yields Final Result:</b> When the handler is done, it <code>yield</code>s the final <code>completed</code> (or <code>failed</code>) status update (often marked as <code>final=True</code> in streaming).</li>
<li><b>Server Sends Final Update:</b> The <code>A2AServer</code> sends the final SSE event to the client, closing the stream.</li>
</ol>
<p>Key files involved:</p>
<ul>
<li><b>JS Handler Definition:</b> <code>samples/js/src/server/handler.ts</code> (defines <code>TaskContext</code>, <code>TaskYieldUpdate</code>, <code>TaskHandler</code>)</li>
<li><b>JS Agent Example:</b> <code>samples/js/src/agents/coder/index.ts</code>, <code>samples/js/src/agents/movie-agent/index.ts</code></li>
<li><b>Python Base Manager:</b> <code>samples/python/common/server/task_manager.py</code> (defines <code>TaskManager</code>, <code>InMemoryTaskManager</code>)</li>
<li><b>Python Agent Examples:</b> <code>samples/python/agents/crewai/agent.py</code>, <code>samples/python/agents/langgraph/agent.py</code>, <code>demo/ui/service/server/adk_host_manager.py</code> (more complex, uses ADK)</li>
</ul>
<h2><a class="anchor" id="autotoc_md2022"></a>
Conclusion</h2>
<p>The <b>Task Handling Logic</b> is the heart of your A2A agent – the "chef" that actually does the work. It receives requests via the <code>A2AServer</code>, interacts with AI models or tools, manages the task's state transitions, and generates the final response or intermediate updates.</p>
<p>By implementing this logic (often as an async generator in JS or a <code>TaskManager</code> subclass in Python) and connecting it to your server, you define your agent's unique capabilities and how it fulfills the tasks requested by clients.</p>
<p>We saw how handlers can <code>yield</code> updates. But how do these updates actually get sent back to the client in real-time? Let's dive into the mechanism used for that: Streaming Communication using Server-Sent Events (SSE).</p>
<p><b>Next:</b> <a class="el" href="../../d0/d60/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_207__streaming__communication____sse__.html">Chapter 7: Streaming Communication (SSE)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
