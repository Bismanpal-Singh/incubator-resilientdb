#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_writebatch</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d1/dce/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_205__writebatch.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_writebatch</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2294"></a>
autotoc_md2294</h2>
<p>layout: default title: "WriteBatch" parent: "LevelDB" </p>
<h2><a class="anchor" id="autotoc_md2295"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md2296"></a>
Chapter 5: WriteBatch - Grouping Changes Together</h1>
<p>Welcome back! In <a class="el" href="../../df/dc9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_204__dbimpl.html">Chapter 4: DBImpl</a>, we saw how <code>DBImpl</code> acts as the general manager, coordinating writes, reads, and background tasks. We learned that when you call <code>Put</code> or <code>Delete</code>, <code>DBImpl</code> handles writing to the <a class="el" href="../../df/d85/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_203__write__ahead__log____wal________logwriter__logreader.html">Write-Ahead Log (WAL)</a> and then updating the <a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">MemTable</a>.</p>
<p>But what if you need to make <em>multiple</em> changes that should happen <em>together</em>?</p>
<h2><a class="anchor" id="autotoc_md2297"></a>
What's the Problem? Making Multiple Changes Atomically</h2>
<p>Imagine you're managing game scores. When Player A beats Player B, you need to do two things: increase Player A's score and decrease Player B's score.</p>
<div class="fragment"><div class="line">// Goal: Increase playerA score, decrease playerB score</div>
<div class="line">db-&gt;Put(options, &quot;score_playerA&quot;, &quot;101&quot;);</div>
<div class="line">db-&gt;Put(options, &quot;score_playerB&quot;, &quot;49&quot;);</div>
</div><!-- fragment --><p>What happens if the system crashes right <em>after</em> the first <code>Put</code> but <em>before</em> the second <code>Put</code>? Player A gets a point, but Player B <em>doesn't</em> lose one. The scores are now inconsistent! This isn't good.</p>
<p>We need a way to tell LevelDB: "Please perform these *multiple* operations (like updating both scores) as a single, indivisible unit. Either *all* of them should succeed, or *none* of them should." This property is called <b>atomicity</b>.</p>
<h2><a class="anchor" id="autotoc_md2298"></a>
WriteBatch: The Atomic To-Do List</h2>
<p>LevelDB provides the <code>WriteBatch</code> class to solve this exact problem.</p>
<p>Think of a <code>WriteBatch</code> like making a <b>shopping list</b> before you go to the store, or giving a librarian a list of multiple transactions to perform all at once (check out book A, return book B).</p>
<ol type="1">
<li><b>Collect Changes:</b> You create an empty <code>WriteBatch</code> object. Then, instead of calling <code>db-&gt;Put</code> or <code>db-&gt;Delete</code> directly, you call <code>batch.Put</code> and <code>batch.Delete</code> to add your desired changes to the batch object. This just adds items to your "to-do list" in memory; it doesn't modify the database yet.</li>
<li><b>Apply Atomically:</b> Once your list is complete, you hand the entire <code>WriteBatch</code> to the database using a single <code>db-&gt;Write(options, &amp;batch)</code> call.</li>
<li><b>All or Nothing:</b> LevelDB guarantees that all the operations (<code>Put</code>s and <code>Delete</code>s) listed in the <code>WriteBatch</code> will be applied <b>atomically</b>. They will either <em>all</em> succeed and become durable together, or if something goes wrong (like a crash during the process), <em>none</em> of them will appear to have happened after recovery.</li>
</ol>
<p>Using <code>WriteBatch</code> for our score update:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;leveldb/write_batch.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;leveldb/db.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... assume db is an open LevelDB database ...</span></div>
<div class="line">leveldb::WriteOptions write_options;</div>
<div class="line">write_options.sync = <span class="keyword">true</span>; <span class="comment">// Ensure durability</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Create an empty WriteBatch</span></div>
<div class="line">leveldb::WriteBatch batch;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Add changes to the batch (in memory)</span></div>
<div class="line">batch.Put(<span class="stringliteral">&quot;score_playerA&quot;</span>, <span class="stringliteral">&quot;101&quot;</span>); <span class="comment">// Add &#39;Put playerA&#39; to the list</span></div>
<div class="line">batch.Delete(<span class="stringliteral">&quot;old_temp_key&quot;</span>);       <span class="comment">// Add &#39;Delete old_temp_key&#39; to the list</span></div>
<div class="line">batch.Put(<span class="stringliteral">&quot;score_playerB&quot;</span>, <span class="stringliteral">&quot;49&quot;</span>);  <span class="comment">// Add &#39;Put playerB&#39; to the list</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Apply the entire batch atomically</span></div>
<div class="line">leveldb::Status status = db-&gt;Write(write_options, &amp;batch);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (status.ok()) {</div>
<div class="line">  <span class="comment">// Success! Both score_playerA and score_playerB are updated,</span></div>
<div class="line">  <span class="comment">// and old_temp_key is deleted.</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">  <span class="comment">// Failure! The database state is unchanged. Neither score was updated,</span></div>
<div class="line">  <span class="comment">// and old_temp_key was not deleted.</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>We create a <code>WriteBatch</code> called <code>batch</code>.</li>
<li>We call <code>batch.Put</code> and <code>batch.Delete</code>. These methods modify the <code>batch</code> object itself, not the database. They are very fast as they just record the desired operations internally.</li>
<li>We call <code>db-&gt;Write</code> with the completed <code>batch</code>. LevelDB now takes this list and applies it atomically. Thanks to the <a class="el" href="../../df/d85/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_203__write__ahead__log____wal________logwriter__logreader.html">WAL</a>, even if the system crashes <em>during</em> the <code>db-&gt;Write</code> call, recovery will ensure either all changes from the batch are applied or none are.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2299"></a>
Performance Benefit Too!</h2>
<p>Besides atomicity, <code>WriteBatch</code> also often improves performance when making multiple changes:</p>
<ul>
<li><b>Single Log Write:</b> LevelDB can write the <em>entire batch</em> as a single record to the WAL file on disk. This is usually much faster than writing separate log records for each individual <code>Put</code> or <code>Delete</code>, reducing disk I/O.</li>
<li><b>Single Lock Acquisition:</b> The <code>DBImpl</code> only needs to acquire its internal lock once for the entire <code>Write</code> call, rather than once per operation.</li>
</ul>
<p>So, even if you don't strictly <em>need</em> atomicity, using <code>WriteBatch</code> for bulk updates can be faster.</p>
<h2><a class="anchor" id="autotoc_md2300"></a>
Under the Hood: How WriteBatch Works</h2>
<p>What happens inside LevelDB when you call <code>db-&gt;Write(options, &amp;batch)</code>?</p>
<ol type="1">
<li><b>Serialization:</b> The <code>WriteBatch</code> object holds a simple, serialized representation of all the <code>Put</code> and <code>Delete</code> operations you added. It's basically a byte string (<code>rep_</code> internally) containing the sequence of operations and their arguments.</li>
<li><b>DBImpl Coordination:</b> The <code>DBImpl::Write</code> method receives the <code>WriteBatch</code>.</li>
<li><b>WAL Write:</b> <code>DBImpl</code> takes the entire serialized content of the <code>WriteBatch</code> (from <code>WriteBatchInternal::Contents</code>) and writes it as <b>one single record</b> to the <a class="el" href="../../df/d85/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_203__write__ahead__log____wal________logwriter__logreader.html">Write-Ahead Log (WAL)</a> using <code>log_-&gt;AddRecord()</code>.</li>
<li><b>MemTable Update:</b> If the WAL write is successful (and synced to disk if <code>options.sync</code> is true), <code>DBImpl</code> then iterates through the operations <em>within</em> the <code>WriteBatch</code>. For each operation, it applies the change to the in-memory <a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">MemTable</a> (<code>WriteBatchInternal::InsertInto(batch, mem_)</code>).</li>
</ol>
<p>This two-step process (WAL first, then MemTable) ensures both durability and atomicity. If a crash occurs after the WAL write but before the MemTable update finishes, the recovery process will read the <em>entire batch</em> from the WAL and re-apply it to the MemTable, ensuring all changes are present.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant App as Application</div>
<div class="line">    participant DBImpl as DBImpl::Write</div>
<div class="line">    participant WriteBatch as WriteBatch Object</div>
<div class="line">    participant WAL as WAL File (Disk)</div>
<div class="line">    participant MemTable as MemTable (RAM)</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;WriteBatch: batch.Put(&quot;k1&quot;, &quot;v1&quot;)</div>
<div class="line">    App-&gt;&gt;WriteBatch: batch.Delete(&quot;k2&quot;)</div>
<div class="line">    App-&gt;&gt;WriteBatch: batch.Put(&quot;k3&quot;, &quot;v3&quot;)</div>
<div class="line">    App-&gt;&gt;DBImpl: db-&gt;Write(options, &amp;batch)</div>
<div class="line">    DBImpl-&gt;&gt;WriteBatch: Get serialized contents (rep_)</div>
<div class="line">    WriteBatch--&gt;&gt;DBImpl: Return byte string representing all ops</div>
<div class="line">    DBImpl-&gt;&gt;WAL: AddRecord(entire batch content)</div>
<div class="line">    Note right of WAL: Single disk write (if sync)</div>
<div class="line">    WAL--&gt;&gt;DBImpl: WAL Write OK</div>
<div class="line">    DBImpl-&gt;&gt;WriteBatch: Iterate through operations</div>
<div class="line">    loop Apply each operation from Batch</div>
<div class="line">        WriteBatch--&gt;&gt;DBImpl: Next Op: Put(&quot;k1&quot;, &quot;v1&quot;)</div>
<div class="line">        DBImpl-&gt;&gt;MemTable: Add(&quot;k1&quot;, &quot;v1&quot;)</div>
<div class="line">        WriteBatch--&gt;&gt;DBImpl: Next Op: Delete(&quot;k2&quot;)</div>
<div class="line">        DBImpl-&gt;&gt;MemTable: Add(&quot;k2&quot;, deletion_marker)</div>
<div class="line">        WriteBatch--&gt;&gt;DBImpl: Next Op: Put(&quot;k3&quot;, &quot;v3&quot;)</div>
<div class="line">        DBImpl-&gt;&gt;MemTable: Add(&quot;k3&quot;, &quot;v3&quot;)</div>
<div class="line">    end</div>
<div class="line">    MemTable--&gt;&gt;DBImpl: MemTable Updates Done</div>
<div class="line">    DBImpl--&gt;&gt;App: Write Successful</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2301"></a>
WriteBatch Internals (Code View)</h2>
<p>Let's peek at the code.</p>
<p><b>Adding to the Batch:</b></p>
<p>When you call <code>batch.Put("key", "val")</code> or <code>batch.Delete("key")</code>, the <code>WriteBatch</code> simply appends a representation of that operation to its internal string buffer (<code>rep_</code>).</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: leveldb/write_batch.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Simplified serialization format:</span></div>
<div class="line"><span class="comment">// rep_ :=</span></div>
<div class="line"><span class="comment">//    sequence: fixed64 (8 bytes, initially 0)</span></div>
<div class="line"><span class="comment">//    count:    fixed32 (4 bytes, number of records)</span></div>
<div class="line"><span class="comment">//    data:     record[count]</span></div>
<div class="line"><span class="comment">// record :=</span></div>
<div class="line"><span class="comment">//    kTypeValue  varstring varstring |</span></div>
<div class="line"><span class="comment">//    kTypeDeletion varstring</span></div>
<div class="line"><span class="comment">// varstring :=</span></div>
<div class="line"><span class="comment">//    len: varint32</span></div>
<div class="line"><span class="comment">//    data: uint8[len]</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> WriteBatch::Put(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value) {</div>
<div class="line">  <span class="comment">// Increment the record count stored in the header</span></div>
<div class="line">  WriteBatchInternal::SetCount(<span class="keyword">this</span>, WriteBatchInternal::Count(<span class="keyword">this</span>) + 1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Append the type marker (kTypeValue)</span></div>
<div class="line">  rep_.push_back(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(kTypeValue));</div>
<div class="line">  <span class="comment">// Append the key (length-prefixed)</span></div>
<div class="line">  PutLengthPrefixedSlice(&amp;rep_, key);</div>
<div class="line">  <span class="comment">// Append the value (length-prefixed)</span></div>
<div class="line">  PutLengthPrefixedSlice(&amp;rep_, value);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> WriteBatch::Delete(<span class="keyword">const</span> Slice&amp; key) {</div>
<div class="line">  <span class="comment">// Increment the record count stored in the header</span></div>
<div class="line">  WriteBatchInternal::SetCount(<span class="keyword">this</span>, WriteBatchInternal::Count(<span class="keyword">this</span>) + 1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Append the type marker (kTypeDeletion)</span></div>
<div class="line">  rep_.push_back(<span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(kTypeDeletion));</div>
<div class="line">  <span class="comment">// Append the key (length-prefixed)</span></div>
<div class="line">  PutLengthPrefixedSlice(&amp;rep_, key);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper to get/set the 4-byte count from the header (bytes 8-11)</span></div>
<div class="line"><span class="keywordtype">int</span> WriteBatchInternal::Count(<span class="keyword">const</span> WriteBatch* b) {</div>
<div class="line">  <span class="keywordflow">return</span> DecodeFixed32(b-&gt;rep_.data() + 8); <span class="comment">// Read count from header</span></div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> WriteBatchInternal::SetCount(WriteBatch* b, <span class="keywordtype">int</span> n) {</div>
<div class="line">  EncodeFixed32(&amp;b-&gt;rep_[8], n); <span class="comment">// Write count to header</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper to get the full serialized content</span></div>
<div class="line">Slice WriteBatchInternal::Contents(<span class="keyword">const</span> WriteBatch* batch) {</div>
<div class="line">  <span class="keywordflow">return</span> Slice(batch-&gt;rep_);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>Each <code>Put</code> or <code>Delete</code> increments a counter stored in the first 12 bytes (<code>kHeader</code>) of the internal string <code>rep_</code>.</li>
<li>It then appends a 1-byte type marker (<code>kTypeValue</code> or <code>kTypeDeletion</code>).</li>
<li>Finally, it appends the key (and value for <code>Put</code>) using <code>PutLengthPrefixedSlice</code>, which writes the length of the slice followed by its data. This makes it easy to parse the operations back later.</li>
</ul>
<p><b>Applying the Batch to MemTable:</b></p>
<p>When <code>DBImpl::Write</code> calls <code>WriteBatchInternal::InsertInto(batch, mem_)</code>, this helper function iterates through the serialized <code>rep_</code> string and applies each operation to the MemTable.</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: leveldb/write_batch.cc ---</span></div>
<div class="line"><span class="comment">// Helper class used by InsertInto</span></div>
<div class="line"><span class="keyword">namespace </span>{</div>
<div class="line"><span class="keyword">class </span>MemTableInserter : <span class="keyword">public</span> WriteBatch::Handler {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  SequenceNumber sequence_; <span class="comment">// Starting sequence number for the batch</span></div>
<div class="line">  MemTable* mem_;           <span class="comment">// MemTable to insert into</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> Put(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)<span class="keyword"> override </span>{</div>
<div class="line">    <span class="comment">// Add the Put operation to the MemTable</span></div>
<div class="line">    mem_-&gt;Add(sequence_, kTypeValue, key, value);</div>
<div class="line">    sequence_++; <span class="comment">// Increment sequence number for the next operation</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">void</span> Delete(<span class="keyword">const</span> Slice&amp; key)<span class="keyword"> override </span>{</div>
<div class="line">    <span class="comment">// Add the Delete operation (as a deletion marker) to the MemTable</span></div>
<div class="line">    mem_-&gt;Add(sequence_, kTypeDeletion, key, Slice()); <span class="comment">// Value is ignored</span></div>
<div class="line">    sequence_++; <span class="comment">// Increment sequence number for the next operation</span></div>
<div class="line">  }</div>
<div class="line">};</div>
<div class="line">} <span class="comment">// namespace</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Applies the batch operations to the MemTable</span></div>
<div class="line">Status WriteBatchInternal::InsertInto(<span class="keyword">const</span> WriteBatch* b, MemTable* memtable) {</div>
<div class="line">  MemTableInserter inserter;</div>
<div class="line">  <span class="comment">// Get the starting sequence number assigned by DBImpl::Write</span></div>
<div class="line">  inserter.sequence_ = WriteBatchInternal::Sequence(b);</div>
<div class="line">  inserter.mem_ = memtable;</div>
<div class="line">  <span class="comment">// Iterate() parses rep_ and calls handler.Put/handler.Delete</span></div>
<div class="line">  <span class="keywordflow">return</span> b-&gt;Iterate(&amp;inserter);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper to get/set the 8-byte sequence number from header (bytes 0-7)</span></div>
<div class="line">SequenceNumber WriteBatchInternal::Sequence(<span class="keyword">const</span> WriteBatch* b) {</div>
<div class="line">  <span class="keywordflow">return</span> SequenceNumber(DecodeFixed64(b-&gt;rep_.data()));</div>
<div class="line">}</div>
<div class="line"><span class="keywordtype">void</span> WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {</div>
<div class="line">  EncodeFixed64(&amp;b-&gt;rep_[0], seq);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><code>InsertInto</code> creates a helper object <code>MemTableInserter</code>.</li>
<li>It gets the starting <code>SequenceNumber</code> for this batch (which was assigned by <code>DBImpl::Write</code> and stored in the batch's header).</li>
<li>It calls <code>b-&gt;Iterate(&amp;inserter)</code>. The <code>Iterate</code> method (code not shown, but it reverses the serialization process) parses the <code>rep_</code> string. For each operation it finds, it calls the appropriate method on the <code>inserter</code> object (<code>Put</code> or <code>Delete</code>).</li>
<li>The <code>inserter.Put</code> and <code>inserter.Delete</code> methods simply call <code>mem_-&gt;Add</code>, passing along the correct sequence number (which increments for each operation within the batch) and the type (<code>kTypeValue</code> or <code>kTypeDeletion</code>).</li>
</ol>
<h2><a class="anchor" id="autotoc_md2302"></a>
Conclusion</h2>
<p>The <code>WriteBatch</code> is a simple yet powerful tool in LevelDB. It allows you to:</p>
<ol type="1">
<li><b>Group Multiple Changes:</b> Collect several <code>Put</code> and <code>Delete</code> operations together.</li>
<li><b>Ensure Atomicity:</b> Apply these changes as a single, all-or-nothing unit using <code>db-&gt;Write</code>. This prevents inconsistent states if errors or crashes occur mid-operation.</li>
<li><b>Improve Performance:</b> Often makes bulk updates faster by reducing the number of WAL writes and lock acquisitions.</li>
</ol>
<p>It works by serializing the list of operations into a byte string, which LevelDB writes to the WAL as a single record and then replays into the MemTable.</p>
<p>Now that we understand how individual changes and batches of changes are safely written and stored temporarily in the MemTable and WAL, how does LevelDB manage the overall state of the database, including all the SSTable files on disk? How does it know which files contain the data for a particular key?</p>
<p>Next up: <a class="el" href="../../d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html">Chapter 6: Version &amp; VersionSet</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
