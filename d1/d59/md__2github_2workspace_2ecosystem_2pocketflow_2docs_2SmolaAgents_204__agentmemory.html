#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_agentmemory</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_agentmemory</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md3046"></a>
autotoc_md3046</h2>
<p>layout: default title: "AgentMemory" parent: "SmolaAgents" </p>
<h2><a class="anchor" id="autotoc_md3047"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md3048"></a>
Chapter 4: AgentMemory - The Agent's Notepad</h1>
<p>Welcome back! In <a class="el" href="../../d4/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_203__tool.html">Chapter 3: Tool</a>, we equipped our agent with "superpowers" ‚Äì tools like web search or calculators that let it interact with the world and perform actions. We saw how the agent's "brain" (the LLM) decides which tool to use, and the agent executes it.</p>
<p>But wait... how does the agent remember what it has already done? If it searches for the capital of France in Step 1, how does it remember "Paris" when deciding what to do in Step 2 (like finding the weather in Paris)?</p>
<p>This is where <b>AgentMemory</b> comes in. Think of it as the agent's dedicated notepad or, even better, a <b>ship's logbook</b>.</p>
<h2><a class="anchor" id="autotoc_md3049"></a>
The Problem: An Agent with Amnesia</h2>
<p>Imagine a captain sailing a ship on a long voyage. After each hour, they completely forget everything that happened before ‚Äì the course they set, the islands they passed, the storms they weathered. How could they possibly reach their destination? They'd be lost!</p>
<p><img src="https://img.icons8.com/ios/50/000000/confused.png" alt="Confused Captain" class="inline"/> ‚ùì "Where am I? What was I doing?"</p>
<p>An agent without memory is like that forgetful captain. It might perform a single action correctly, but it wouldn't understand the context. It wouldn't know:</p>
<ul>
<li>What the original goal (task) was.</li>
<li>What steps it has already taken.</li>
<li>What results (observations) it got from those steps.</li>
<li>What errors it might have encountered.</li>
</ul>
<p>Without this history, the agent can't make informed decisions about what to do next. It can't build upon previous results or learn from mistakes within the same task.</p>
<h2><a class="anchor" id="autotoc_md3050"></a>
The Solution: The Ship's Logbook (<code>AgentMemory</code>)</h2>
<p>The <code>AgentMemory</code> is the component that solves this problem. It automatically records every significant event during the agent's "voyage" (its execution run).</p>
<p><img src="https://img.icons8.com/ios/50/000000/scroll.png" alt="Ship's Logbook" class="inline"/> üìú "Log Entry: Searched 'Capital of France'. Result: 'Paris'."</p>
<p>Just like a ship's logbook helps the captain navigate, the <code>AgentMemory</code> helps the agent maintain context and proceed effectively.</p>
<h2><a class="anchor" id="autotoc_md3051"></a>
What Does the <code>AgentMemory</code> Store?</h2>
<p>The <code>AgentMemory</code> keeps a chronological record of the agent's journey. For each run, it typically stores:</p>
<ol type="1">
<li><b>System Prompt:</b> The initial instructions given to the agent's LLM brain (we'll see more in <a class="el" href="../../d3/d9e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_205__prompttemplates.html">Chapter 5: PromptTemplates</a>).</li>
<li><b>Initial Task:</b> The main goal the user gave the agent (e.g., "What is the capital of France, and what is its current weather?").</li>
<li><b>Steps:</b> A list detailing each cycle of the agent's operation:<ul>
<li><b>Planning (Optional):</b> If the agent makes plans, the plan itself is recorded.</li>
<li><b>Thinking:</b> The LLM's reasoning process and the action it decided to take (e.g., "Thought: I need the capital. Action: Use `search` tool").</li>
<li><b>Action:</b> The specific <a class="el" href="../../d4/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_203__tool.html">Tool</a> called and the arguments used (e.g., <code>search("Capital of France")</code>). This could also be code execution for code-based agents.</li>
<li><b>Observation:</b> The result received after performing the action (e.g., "Paris").</li>
<li><b>Errors:</b> If something went wrong during the step (e.g., a tool failed), the error is noted.</li>
</ul>
</li>
</ol>
<p>This detailed history allows the agent (specifically, the LLM guiding it) to look back at any point and understand the full context before deciding the next move.</p>
<h2><a class="anchor" id="autotoc_md3052"></a>
How is <code>AgentMemory</code> Used? (Mostly Automatic!)</h2>
<p>The good news is that you, as the user, usually don't need to interact directly with <code>AgentMemory</code>. The <code>MultiStepAgent</code> manages it automatically behind the scenes!</p>
<p>Here's the key interaction:</p>
<ol type="1">
<li><b>Before "Thinking":</b> When the agent needs to decide the next step (the "Think" phase), the <code>MultiStepAgent</code> asks the <code>AgentMemory</code> to format the recorded history (task, previous actions, observations, errors) into a sequence of messages. This happens via a method often called <code>write_memory_to_messages</code>.</li>
<li><b>Consulting the Brain:</b> This formatted history is sent to the LLM via the <a class="el" href="../../dc/db5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_202__model__interface.html">Model Interface</a>. This gives the LLM the full context it needs to provide a sensible next step. ("Okay, based on the task 'Capital and Weather', and the fact we just found 'Paris', what should we do now?").</li>
<li><b>After "Acting" and "Observing":</b> Once the agent performs an action and gets an observation (or an error), the <code>MultiStepAgent</code> records this new information as a new step in the <code>AgentMemory</code>.</li>
</ol>
<p>So, the memory is constantly being read from (to inform the LLM) and written to (to record new events).</p>
<h2><a class="anchor" id="autotoc_md3053"></a>
Example Revisited: Capital and Weather Logbook</h2>
<p>Let's trace our "Capital of France and Weather" example from <a class="el" href="../../dc/d92/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_201__multistepagent.html">Chapter 1: MultiStepAgent</a> and see what the <code>AgentMemory</code> logbook might look like (simplified):</p>
<p><b>(Start of Run)</b></p>
<ol type="1">
<li><b>System Prompt:</b> Recorded (e.g., "You are a helpful assistant...")</li>
<li><b>Task:</b> Recorded (<code>task: "What is the capital of France, and what is its current weather?"</code>)</li>
</ol>
<p><b>(Step 1)</b></p>
<ol type="1">
<li><b>Think/Action:</b> Recorded (<code>thought: "Need capital.", action: search("Capital of France")</code>)</li>
<li><b>Observation:</b> Recorded (<code>observation: "Paris"</code>)</li>
</ol>
<p><b>(Step 2)</b></p>
<ol type="1">
<li><b>Think/Action:</b> Recorded (<code>thought: "Have capital (Paris), need weather.", action: weather("Paris")</code>)</li>
<li><b>Observation:</b> Recorded (<code>observation: "Sunny, 25¬∞C"</code>)</li>
</ol>
<p><b>(Step 3)</b></p>
<ol type="1">
<li><b>Think/Action:</b> Recorded (<code>thought: "Have capital and weather. Task complete.", action: final_answer("The capital of France is Paris, and the current weather there is Sunny, 25¬∞C.")</code>)</li>
<li><b>Observation:</b> Recorded (Result of <code>final_answer</code> is the final output).</li>
</ol>
<p><b>(End of Run)</b></p>
<p>Now, before Step 2 started, the agent would read entries 1-4 from memory to give context to the LLM. Before Step 3, it would read entries 1-6. This prevents the agent from forgetting what it's doing!</p>
<h2><a class="anchor" id="autotoc_md3054"></a>
Under the Hood: Memory Structure</h2>
<p>How does <code>SmolaAgents</code> actually implement this?</p>
<p><b>Core Idea:</b> The <code>AgentMemory</code> object holds a list called <code>steps</code>. Each item in this list represents one distinct event or phase in the agent's run. These items are usually instances of specific "Step" classes.</p>
<p><b>Key Step Types (Simplified from <code>memory.py</code>):</b></p>
<ul>
<li><code>SystemPromptStep</code>: Stores the initial system prompt text.</li>
<li><code>TaskStep</code>: Stores the user's task description (and potentially input images).</li>
<li><code>PlanningStep</code> (Optional): Stores any explicit plans the agent generates.</li>
<li><code>ActionStep</code>: This is the most common one, recording a single Think-Act-Observe cycle. It contains fields for:<ul>
<li><code>step_number</code></li>
<li><code>model_input_messages</code>: What was sent to the LLM for thinking.</li>
<li><code>model_output_message</code>: The LLM's raw response (thought + action plan).</li>
<li><code>tool_calls</code>: Which <a class="el" href="../../d4/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_203__tool.html">Tool</a> was called (name, arguments). Stored as <code>ToolCall</code> objects.</li>
<li><code>observations</code>: The result returned by the tool.</li>
<li><code>error</code>: Any error that occurred.</li>
<li><code>start_time</code>, <code>end_time</code>, <code>duration</code>: Timing information.</li>
</ul>
</li>
<li><code>FinalAnswerStep</code>: A special step indicating the final result returned by the agent.</li>
</ul>
<p><b>Interaction Flow:</b></p>
<p>Here's how the <code>MultiStepAgent</code> uses <code>AgentMemory</code>:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant MSA as MultiStepAgent</div>
<div class="line">    participant Memory as AgentMemory</div>
<div class="line">    participant Model as LLM Brain</div>
<div class="line">    participant Tool</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;MSA: run(&quot;Task: Capital &amp; Weather?&quot;)</div>
<div class="line">    MSA-&gt;&gt;Memory: Store TaskStep(&quot;Capital &amp; Weather?&quot;)</div>
<div class="line">    loop Think-Act-Observe Cycle (Step 1)</div>
<div class="line">        MSA-&gt;&gt;Memory: write_memory_to_messages() --&gt; Get History [Task]</div>
<div class="line">        MSA-&gt;&gt;Model: What&#39;s next? (with History)</div>
<div class="line">        Model--&gt;&gt;MSA: Think: Need capital. Act: search(...) -&gt; LLM Response</div>
<div class="line">        MSA-&gt;&gt;Memory: Store LLM Response in new ActionStep</div>
<div class="line">        MSA-&gt;&gt;Tool: Execute search(...)</div>
<div class="line">        Tool--&gt;&gt;MSA: Observation: &quot;Paris&quot;</div>
<div class="line">        MSA-&gt;&gt;Memory: Store Observation in current ActionStep</div>
<div class="line">        MSA-&gt;&gt;Memory: Append finished ActionStep to steps list</div>
<div class="line">    end</div>
<div class="line">    loop Think-Act-Observe Cycle (Step 2)</div>
<div class="line">        MSA-&gt;&gt;Memory: write_memory_to_messages() --&gt; Get History [Task, Step 1]</div>
<div class="line">        MSA-&gt;&gt;Model: What&#39;s next? (with History)</div>
<div class="line">        Model--&gt;&gt;MSA: Think: Need weather. Act: weather(...) -&gt; LLM Response</div>
<div class="line">        MSA-&gt;&gt;Memory: Store LLM Response in new ActionStep</div>
<div class="line">        MSA-&gt;&gt;Tool: Execute weather(...)</div>
<div class="line">        Tool--&gt;&gt;MSA: Observation: &quot;Sunny, 25C&quot;</div>
<div class="line">        MSA-&gt;&gt;Memory: Store Observation in current ActionStep</div>
<div class="line">        MSA-&gt;&gt;Memory: Append finished ActionStep to steps list</div>
<div class="line">    end</div>
<div class="line">    MSA--&gt;&gt;User: Final Answer</div>
</div><!-- fragment --><p><b>Code Glimpse (Simplified):</b></p>
<p>Let's look at some relevant pieces from <code>memory.py</code> and <code>agents.py</code>.</p>
<ul>
<li><p class="startli"><b>Memory Step Dataclasses (<code>memory.py</code>):</b> Define the structure of log entries.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3055"></a>
&mdash; File: memory.py (Simplified Step Structures) &mdash;</h1>
<p>from dataclasses import dataclass from typing import List, Any, Dict</p>
<p>@dataclass class ToolCall: # Represents a tool invocation request name: str arguments: Any id: str # Unique ID for matching responses</p>
<p>@dataclass class MemoryStep: # Base class for all memory entries def to_messages(self, **kwargs) -&gt; List[Dict[str, Any]]: </p>
<h1><a class="anchor" id="autotoc_md3056"></a>
Each step type knows how to format itself for the LLM</h1>
<p>raise NotImplementedError</p>
<p>@dataclass class TaskStep(MemoryStep): task: str </p>
<h1><a class="anchor" id="autotoc_md3057"></a>
... (potentially images)</h1>
<p>def to_messages(self, **kwargs) -&gt; List[Dict[str, Any]]: </p>
<h1><a class="anchor" id="autotoc_md3058"></a>
Format: {"role": "user", "content": [{"type": "text", "text": "New task: ..."}]}</h1>
<h1><a class="anchor" id="autotoc_md3059"></a>
... simplified ...</h1>
<p>return [{"role": "user", "content": f"New task:\n{self.task}"}]</p>
<p>@dataclass class ActionStep(MemoryStep): step_number: int </p>
<h1><a class="anchor" id="autotoc_md3060"></a>
model_input_messages: List = None # What was sent to LLM</h1>
<p>model_output: str | None = None # LLM's thought/action text tool_calls: List[ToolCall] | None = None # Parsed tool calls observations: str | None = None # Tool results or code output error: Any | None = None # Any error encountered </p>
<h1><a class="anchor" id="autotoc_md3061"></a>
... other fields like timing ...</h1>
<p>def to_messages(self, **kwargs) -&gt; List[Dict[str, Any]]: </p>
<h1><a class="anchor" id="autotoc_md3062"></a>
Formats the LLM output, tool calls, observations/errors</h1>
<h1><a class="anchor" id="autotoc_md3063"></a>
into messages for the next LLM call.</h1>
<p>messages = [] if self.model_output: messages.append({"role": "assistant", "content": self.model_output}) if self.tool_calls: </p>
<h1><a class="anchor" id="autotoc_md3064"></a>
Simplified representation</h1>
<p>messages.append({"role": "tool_call", "content": f"Calling: {self.tool_calls[0].name}(...)"}) if self.observations: messages.append({"role": "tool_response", "content": f"Observation:\n{self.observations}"}) if self.error: messages.append({"role": "tool_response", "content": f"Error:\n{self.error}"}) return messages</p>
<h1><a class="anchor" id="autotoc_md3065"></a>
... potentially other step types like SystemPromptStep, PlanningStep ...</h1>
<p>```</p>
<ul>
<li><p class="startli"><b>AgentMemory Class (<code>memory.py</code>):</b> Holds the list of steps.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3066"></a>
&mdash; File: memory.py (Simplified AgentMemory) &mdash;</h1>
<p>from typing import List, Union</p>
<p>@dataclass class SystemPromptStep(MemoryStep): # Simplified system_prompt: str def to_messages(self, **kwargs): # Simplified return [{"role": "system", "content": self.system_prompt}]</p>
<p>class AgentMemory: def <b>init</b>(self, system_prompt: str): </p>
<h1><a class="anchor" id="autotoc_md3067"></a>
Initialize with the system prompt</h1>
<p>self.system_prompt = SystemPromptStep(system_prompt=system_prompt) </p>
<h1><a class="anchor" id="autotoc_md3068"></a>
The main logbook - a list of steps taken</h1>
<p>self.steps: List[Union[TaskStep, ActionStep, PlanningStep]] = []</p>
<p>def reset(self): """Clears the memory for a new run.""" self.steps = []</p>
<p>def replay(self, logger, detailed: bool = False): """Utility to print the memory steps nicely.""" </p>
<h1><a class="anchor" id="autotoc_md3069"></a>
... implementation uses logger to print each step ...</h1>
<p>pass ```</p>
<ul>
<li><p class="startli"><b>Agent Using Memory (<code>agents.py</code>):</b> How <code>MultiStepAgent</code> reads and writes.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3070"></a>
&mdash; File: agents.py (Simplified MultiStepAgent interactions) &mdash;</h1>
<p>from .memory import AgentMemory, TaskStep, ActionStep, ToolCall # Import memory components</p>
<p>class MultiStepAgent: def <b>init</b>(self, ..., memory: Optional[AgentMemory] = None): </p>
<h1><a class="anchor" id="autotoc_md3071"></a>
... setup model, tools ...</h1>
<p>self.system_prompt = self.initialize_system_prompt() # Define system prompt </p>
<h1><a class="anchor" id="autotoc_md3072"></a>
Create the memory instance</h1>
<p>self.memory = memory if memory is not None else AgentMemory(self.system_prompt) </p>
<h1><a class="anchor" id="autotoc_md3073"></a>
... setup logger, monitor ...</h1>
<p>def run(self, task: str, ...): </p>
<h1><a class="anchor" id="autotoc_md3074"></a>
... setup ...</h1>
<p>if reset: # Option to clear memory before a new run self.memory.reset()</p>
<h1><a class="anchor" id="autotoc_md3075"></a>
Record the initial task in memory</h1>
<p>self.memory.steps.append(TaskStep(task=self.task))</p>
<h1><a class="anchor" id="autotoc_md3076"></a>
Start the internal execution loop (_run)</h1>
<h1><a class="anchor" id="autotoc_md3077"></a>
... calls _run ...</h1>
<p>final_result = # ... get result from _run ... return final_result</p>
<p>def _run(self, task: str, max_steps: int, ...) -&gt; Generator: </p>
<h1><a class="anchor" id="autotoc_md3078"></a>
... loop initialization ...</h1>
<p>while final_answer is None and self.step_number &lt;= max_steps: </p>
<h1><a class="anchor" id="autotoc_md3079"></a>
... (handle planning steps if enabled) ...</h1>
<h1><a class="anchor" id="autotoc_md3080"></a>
Create a placeholder for the current step's data</h1>
<p>action_step = self._create_action_step(...)</p>
<p>try: </p>
<h1><a class="anchor" id="autotoc_md3081"></a>
=== Execute one step (Think -&gt; Act -&gt; Observe) ===</h1>
<h1><a class="anchor" id="autotoc_md3082"></a>
This method internally calls write_memory_to_messages,</h1>
<h1><a class="anchor" id="autotoc_md3083"></a>
calls the model, executes the tool, and populates</h1>
<h1><a class="anchor" id="autotoc_md3084"></a>
the 'action_step' object with results.</h1>
<p>final_answer = self._execute_step(task, action_step)</p>
<p>except AgentError as e: </p>
<h1><a class="anchor" id="autotoc_md3085"></a>
Record errors in the memory step</h1>
<p>action_step.error = e finally: </p>
<h1><a class="anchor" id="autotoc_md3086"></a>
Finalize timing etc. for the step</h1>
<p>self._finalize_step(action_step, ...) </p>
<h1><a class="anchor" id="autotoc_md3087"></a>
=== Store the completed step in memory ===</h1>
<p>self.memory.steps.append(action_step) </p>
<h1><a class="anchor" id="autotoc_md3088"></a>
... yield step details ...</h1>
<p>self.step_number += 1 </p>
<h1><a class="anchor" id="autotoc_md3089"></a>
... handle finish ...</h1>
<p>yield FinalAnswerStep(final_answer)</p>
<pre class="fragment">    def write_memory_to_messages(self, summary_mode: Optional[bool] = False) -&gt; List[Dict[str, str]]:
        """
        Reads history from memory and formats it for the LLM.
        """
        messages = self.memory.system_prompt.to_messages(summary_mode=summary_mode)
        # Go through each step recorded in memory
        for memory_step in self.memory.steps:
            # Ask each step to format itself into messages
            messages.extend(memory_step.to_messages(summary_mode=summary_mode))
        return messages

    def _execute_step(self, task: str, memory_step: ActionStep) -&gt; Union[None, Any]:
        self.logger.log_rule(f"Step {self.step_number}", level=LogLevel.INFO)
        # === THINK ===
        # 1. Get history from memory
        messages_for_llm = self.write_memory_to_messages()
        memory_step.model_input_messages = messages_for_llm # Record input to LLM

        # 2. Call the LLM brain
        llm_response = self.model(messages_for_llm, ...) # Call Model Interface
        memory_step.model_output_message = llm_response # Record LLM response

        # 3. Parse LLM response for action
        # (Specific parsing logic depends on AgentType - ToolCallingAgent, CodeAgent)
        tool_name, arguments = self._parse_action(llm_response) # Simplified
        memory_step.tool_calls = [ToolCall(name=tool_name, arguments=arguments, id=...)]

        # === ACT &amp; OBSERVE ===
        # 4. Execute the action (tool call or code)
        observation = self._execute_action(tool_name, arguments) # Simplified

        # 5. Record observation
        memory_step.observations = str(observation)

        # 6. Check if it's the final answer
        if tool_name == "final_answer":
             return observation # Return the final answer to stop the loop
        else:
             return None # Continue to the next step

    # ... other methods like _create_action_step, _finalize_step ...
```
</pre><p><b>Key Takeaways from Code:</b></p><ul>
<li>Memory holds a list of <code>Step</code> objects (<code>self.memory.steps</code>).</li>
<li>The agent adds new <code>TaskStep</code> or <code>ActionStep</code> objects to this list as it progresses (<code>self.memory.steps.append(...)</code>).</li>
<li>Before calling the LLM, <code>write_memory_to_messages</code> iterates through <code>self.memory.steps</code>, calling <code>to_messages()</code> on each step to build the history.</li>
<li>Each step (like <code>ActionStep</code>) stores details like the LLM's output (<code>model_output</code>), tool calls (<code>tool_calls</code>), and results (<code>observations</code> or <code>error</code>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md3090"></a>
Conclusion</h2>
<p><code>AgentMemory</code> is the agent's essential logbook, providing the context needed to navigate complex, multi-step tasks. It diligently records the initial task, system instructions, and every action, observation, and error along the way.</p>
<p>You've learned:</p>
<ul>
<li>Why memory is crucial for agents (avoiding amnesia).</li>
<li>The "ship's logbook" analogy.</li>
<li>What kind of information <code>AgentMemory</code> stores (task, system prompt, steps with thoughts, actions, observations, errors).</li>
<li>How the <code>MultiStepAgent</code> uses memory automatically: reading history before thinking, and writing results after acting/observing.</li>
<li>The basic structure of <code>AgentMemory</code> and its <code>Step</code> objects (<code>TaskStep</code>, <code>ActionStep</code>).</li>
</ul>
<p>While you often don't need to manipulate memory directly, understanding its role is key to understanding how agents maintain context and achieve complex goals. The content of this memory directly influences the prompts sent to the LLM. How can we customize those prompts? Let's find out!</p>
<p><b>Next Chapter:</b> <a class="el" href="../../d3/d9e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_205__prompttemplates.html">Chapter 5: PromptTemplates</a> - Customizing Your Agent's Instructions.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
