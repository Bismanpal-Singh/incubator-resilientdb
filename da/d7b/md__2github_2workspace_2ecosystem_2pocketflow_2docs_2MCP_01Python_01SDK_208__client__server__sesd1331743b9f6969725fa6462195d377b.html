#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 08_client_server_sessions___clientsession____serversession__</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('da/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_208__client__server__sesd1331743b9f6969725fa6462195d377b.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">08_client_server_sessions___clientsession____serversession__</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2480"></a>
autotoc_md2480</h2>
<p>layout: default title: "Client/Server Sessions (ClientSession, ServerSession)" parent: "MCP Python SDK" </p>
<h2><a class="anchor" id="autotoc_md2481"></a>
nav_order: 8</h2>
<h1><a class="anchor" id="autotoc_md2482"></a>
Chapter 8: Client/Server Sessions (<code>ClientSession</code>, <code>ServerSession</code>)</h1>
<p>Welcome back! In <a class="el" href="../../de/dcd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_207__mcp__protocol__types.html">Chapter 7: MCP Protocol Types</a>, we learned about the standardized "digital forms" – the Pydantic models – that define the structure of messages exchanged between an MCP client and server. We saw examples like <code>CallToolRequest</code> and <code>ProgressNotification</code>.</p>
<p>But knowing the <em>format</em> of a letter isn't enough. How does a specific conversation between one client and one server actually happen over time? How does the server know which incoming response belongs to which outgoing request it sent earlier? How is the initial connection "hello" handled?</p>
<p>Imagine you call a large company's support line. You don't just shout into the void; you get connected to a specific operator who handles <em>your</em> call from start to finish. This operator keeps track of your requests, finds the answers, and manages the connection until you hang up.</p>
<p>In the <code>MCP Python SDK</code>, this "phone line operator" role is played by <b>Session</b> objects: <code>ClientSession</code> and <code>ServerSession</code>.</p>
<h2><a class="anchor" id="autotoc_md2483"></a>
What's a Session? The Dedicated Conversation Line</h2>
<p>A <b>Session</b> object (<code>ClientSession</code> or <code>ServerSession</code>) manages the state and lifecycle of a <b>single, ongoing connection</b> between one MCP client and one MCP server. Think of it as establishing a dedicated phone line for one specific conversation.</p>
<p>This "operator" handles several crucial tasks for that single connection:</p>
<ol type="1">
<li><b>Initialization:</b> Manages the initial "handshake" where the client and server introduce themselves, agree on the protocol version, and share their capabilities (like saying "Hello, I can do X, Y, and Z").</li>
<li><b>Sending &amp; Receiving:</b> Handles the low-level details of sending outgoing messages (requests, notifications) and receiving incoming messages over the communication channel (like Stdio, WebSockets, etc., which we'll cover in <a class="el" href="../../dd/db1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_209__communication__tran26c952f5654fc90ff2967a2bea333d2f.html">Chapter 9: Communication Transports</a>).</li>
<li><b>Request/Response Matching:</b> When you send a request, it gets a unique ID. When a response comes back later with that same ID, the Session makes sure it's delivered to the part of the code that's waiting for <em>that specific</em> answer. It's like the operator remembering who asked which question.</li>
<li><b>State Management:</b> Keeps track of whether the connection is initializing, active, or closed.</li>
<li><b>Lifecycle:</b> Manages the setup and eventual teardown (hang-up) of the connection.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2484"></a>
Two Sides of the Coin: <code>ClientSession</code> vs. <code>ServerSession</code></h2>
<p>Why are there two types of sessions? Because the client and server have different roles in the conversation:</p>
<ul>
<li><b><code>ClientSession</code></b>: Represents the <em>client's</em> end of the connection. It's primarily responsible for:<ul>
<li><em>Initiating</em> the connection and the handshake (<code>initialize</code> request).</li>
<li><em>Sending</em> requests to the server (like <code>callTool</code>, <code>readResource</code>, <code>getPrompt</code>).</li>
<li><em>Receiving</em> responses and notifications <em>from</em> the server.</li>
<li>Handling server-initiated requests (like asking the client to generate text if the client has that capability).</li>
</ul>
</li>
<li><b><code>ServerSession</code></b>: Represents the <em>server's</em> end of the connection. It's primarily responsible for:<ul>
<li><em>Responding</em> to the client's <code>initialize</code> request.</li>
<li><em>Receiving</em> requests <em>from</em> the client.</li>
<li><em>Sending</em> responses and notifications <em>back</em> to the client (like tool results, resource content, log messages, progress updates).</li>
<li>Handling client-initiated notifications (like <code>initialized</code>).</li>
</ul>
</li>
</ul>
<p>They use the same underlying mechanisms but have different methods tailored to their role (e.g., <code>ClientSession</code> has <code>call_tool</code>, <code>ServerSession</code> has <code>send_log_message</code>).</p>
<h2><a class="anchor" id="autotoc_md2485"></a>
How <code>FastMCP</code> Uses <code>ServerSession</code> (Behind the Scenes)</h2>
<p>If you're building a server using <code>FastMCP</code> (as we did in chapters <a class="el" href="../../d8/d5c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_202__fastmcp__server______fastmcp____.html">2</a> through <a class="el" href="../../d2/de0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_206__fastmcp__context______context____.html">6</a>), you generally <b>don't interact with <code>ServerSession</code> directly</b>.</p>
<p>When a client connects to your <code>FastMCP</code> server:</p><ol type="1">
<li>The underlying transport layer (e.g., Stdio handler) accepts the connection.</li>
<li><code>FastMCP</code> (or its underlying <code>MCPServer</code>) automatically creates a <code>ServerSession</code> object specifically for that new client connection.</li>
<li>This <code>ServerSession</code> handles the initialization handshake with the client.</li>
<li>When the client sends a request (like <code>callTool</code>), the <code>ServerSession</code> receives it, identifies it, and passes it to the appropriate <code>FastMCP</code> handler (which might involve the <code>ToolManager</code>).</li>
<li>When your tool function uses <code>ctx.info()</code> or <code>ctx.report_progress()</code> (<a class="el" href="../../d2/de0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_206__fastmcp__context______context____.html">Chapter 6: FastMCP Context (<code>Context</code>)</a>), the <code>Context</code> object talks to its associated <code>ServerSession</code> to actually send the <code>LoggingMessageNotification</code> or <code>ProgressNotification</code> back to the client.</li>
<li>The <code>ServerSession</code> manages this connection until the client disconnects.</li>
</ol>
<p>So, <code>ServerSession</code> is the hidden engine powering the communication for each connected client in a <code>FastMCP</code> server. You benefit from its work without needing to manage it manually.</p>
<h2><a class="anchor" id="autotoc_md2486"></a>
When Might You Use <code>ClientSession</code>?</h2>
<p>You would typically use <code>ClientSession</code> if you were writing a standalone Python application that needs to <em>connect to</em> and <em>interact with</em> an existing MCP server (which might be one you built with <code>FastMCP</code> or someone else's).</p>
<p><b>Example Scenario: A Simple Client</b></p>
<p><em>(This is conceptual; we won't build a full client here.)</em></p>
<p>Imagine you write a script that needs to ask our <code>CalculatorServer</code> (<a class="el" href="../../dc/df6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_204__fastmcp__tools______tool________toolmanager____.html">Chapter 4</a>) to add two numbers.</p>
<div class="fragment"><div class="line"><span class="comment"># --- Conceptual Client Code ---</span></div>
<div class="line"><span class="keyword">import</span> anyio</div>
<div class="line"><span class="keyword">from</span> mcp.client.session <span class="keyword">import</span> ClientSession</div>
<div class="line"><span class="comment"># Assume we have transport streams (read_stream, write_stream)</span></div>
<div class="line"><span class="comment"># connected to the CalculatorServer (more in Chapter 9)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span>run_client():</div>
<div class="line">    <span class="comment"># 1. Create a ClientSession using the transport streams</span></div>
<div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> ClientSession(read_stream, write_stream) <span class="keyword">as</span> session:</div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="comment"># 2. Perform the initialization handshake</span></div>
<div class="line">            init_result = await session.initialize()</div>
<div class="line">            print(f<span class="stringliteral">&quot;Connected to: {init_result.serverInfo.name}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># 3. Send a &#39;callTool&#39; request using the session</span></div>
<div class="line">            tool_result = await session.call_tool(</div>
<div class="line">                name=<span class="stringliteral">&quot;add&quot;</span>,</div>
<div class="line">                arguments={<span class="stringliteral">&quot;num1&quot;</span>: 15, <span class="stringliteral">&quot;num2&quot;</span>: 27}</div>
<div class="line">            )</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># 4. Process the result (session handled matching response)</span></div>
<div class="line">            <span class="comment"># Assuming the result is simple text content</span></div>
<div class="line">            <span class="keywordflow">if</span> tool_result.content <span class="keywordflow">and</span> tool_result.content[0].type == <span class="stringliteral">&#39;text&#39;</span>:</div>
<div class="line">               print(f<span class="stringliteral">&quot;Server calculated: {tool_result.content[0].text}&quot;</span>) <span class="comment"># Expected: 42</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">            print(f<span class="stringliteral">&quot;An error occurred: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># In a real script, you&#39;d set up the transport and run this async function</span></div>
<div class="line"><span class="comment"># anyio.run(run_client)</span></div>
</div><!-- fragment --><p>In this scenario:</p><ol type="1">
<li>We create the <code>ClientSession</code>.</li>
<li>We explicitly call <code>session.initialize()</code> to start the conversation.</li>
<li>We use <code>session.call_tool()</code> to send the request. The <code>ClientSession</code> assigns an ID, sends the message, and waits for the specific response with that ID.</li>
<li>The result comes back directly from the <code>call_tool</code> method.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2487"></a>
How Sessions Work Under the Hood: The Operator's Workflow</h2>
<p>Let's trace the lifecycle and the request/response matching managed by a session. We'll use our phone operator analogy.</p>
<ol type="1">
<li><b>Connection Established:</b> A communication channel (like Stdio or WebSocket, see <a class="el" href="../../dd/db1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_209__communication__tran26c952f5654fc90ff2967a2bea333d2f.html">Chapter 9</a>) is opened between the client and server.</li>
<li><b>Session Creation:</b> A <code>ClientSession</code> is created on the client side, and a <code>ServerSession</code> on the server side, both linked to this channel.</li>
<li><b>Initialization (Handshake):</b><ul>
<li><code>ClientSession</code> sends an <code>InitializeRequest</code> (like calling and saying "Hi, I'm ClientApp v1.0, I support MCP v0.3, can we talk?"). It assigns this request ID 0.</li>
<li><code>ServerSession</code> receives ID 0. It knows this is the <code>initialize</code> method. It checks the protocol version, stores the client's capabilities, and prepares its own info.</li>
<li><code>ServerSession</code> sends back an <code>InitializeResult</code> linked to ID 0 (like "Yes, I'm CalculatorServer v1.1, I also support v0.3, here are my capabilities...").</li>
<li><code>ClientSession</code> receives the response for ID 0. It checks the server's info and considers the handshake successful.</li>
<li><code>ClientSession</code> sends an <code>InitializedNotification</code> (just saying "Okay, great!").</li>
<li><code>ServerSession</code> receives this notification and marks the session as fully initialized. The line is now open for regular business.</li>
</ul>
</li>
<li><b>Client Sends Request:</b><ul>
<li><code>ClientSession</code> wants to call the <code>add</code> tool. It calls <code>session.call_tool("add", {...})</code>.</li>
<li>The <code>ClientSession</code> assigns a <em>new</em> unique ID (e.g., ID 1) to this request.</li>
<li>It stores a "waiting placeholder" (an <code>anyio</code> event or future) associated with ID 1.</li>
<li>It sends the <code>CallToolRequest</code> message with ID 1 over the channel.</li>
</ul>
</li>
<li><b>Server Processes Request:</b><ul>
<li><code>ServerSession</code> receives the message with ID 1.</li>
<li>It sees it's a <code>callTool</code> request for <code>add</code>.</li>
<li>It passes the request details to the <code>FastMCP</code> handler (which uses the <code>ToolManager</code>).</li>
<li>The tool function <code>add_numbers(15, 27)</code> runs and returns <code>42</code>.</li>
<li><code>FastMCP</code> gets the result.</li>
</ul>
</li>
<li><b>Server Sends Response:</b><ul>
<li><code>ServerSession</code> constructs a <code>CallToolResult</code> containing <code>42</code>.</li>
<li>It sends this result back over the channel, making sure to include the <em>original</em> request ID (ID 1).</li>
</ul>
</li>
<li><b>Client Receives Response:</b><ul>
<li><code>ClientSession</code> receives the message with ID 1.</li>
<li>It looks up ID 1 in its "waiting placeholders".</li>
<li>It finds the placeholder created in step 4 and delivers the received <code>CallToolResult</code> to it.</li>
<li>The code that was waiting on <code>session.call_tool(...)</code> now receives the result (<code>42</code>) and continues execution.</li>
</ul>
</li>
<li><b>Notifications (Example: Progress):</b><ul>
<li>If the server tool called <code>ctx.report_progress(...)</code>, the <code>Context</code> tells the <code>ServerSession</code>.</li>
<li><code>ServerSession</code> constructs a <code>ProgressNotification</code> (which doesn't have a request ID, as it's not a response).</li>
<li><code>ServerSession</code> sends the notification.</li>
<li><code>ClientSession</code> receives the notification. It sees it's not a response to a specific request. It might trigger a callback or event handler registered in the client application to update a progress bar.</li>
</ul>
</li>
<li><b>Hang-up:</b> When the connection closes (client exits, server shuts down, network error), the sessions clean up their resources.</li>
</ol>
<p><b>Simplified Sequence Diagram (Client Calls Tool):</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant ClientApp</div>
<div class="line">    participant ClientSess as ClientSession</div>
<div class="line">    participant ServerSess as ServerSession</div>
<div class="line">    participant ServerTool as Tool Function (e.g., add_numbers)</div>
<div class="line"> </div>
<div class="line">    ClientApp-&gt;&gt;+ClientSess: call_tool(&quot;add&quot;, {num1: 15, num2: 27})</div>
<div class="line">    ClientSess-&gt;&gt;ClientSess: Assign Request ID (e.g., 1)</div>
<div class="line">    ClientSess-&gt;&gt;ClientSess: Store &#39;waiter&#39; for ID 1</div>
<div class="line">    ClientSess-&gt;&gt;+ServerSess: Send CallToolRequest (ID=1, method=&quot;tools/call&quot;, params={...})</div>
<div class="line">    ServerSess-&gt;&gt;ServerSess: Receive request ID=1</div>
<div class="line">    ServerSess-&gt;&gt;+ServerTool: Dispatch request to tool handler</div>
<div class="line">    ServerTool--&gt;&gt;-ServerSess: Return result (e.g., 42)</div>
<div class="line">    ServerSess-&gt;&gt;-ClientSess: Send CallToolResult (ID=1, result={content: [{&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;42&quot;}]})</div>
<div class="line">    ClientSess-&gt;&gt;ClientSess: Receive response ID=1</div>
<div class="line">    ClientSess-&gt;&gt;ClientSess: Match ID=1 to &#39;waiter&#39;</div>
<div class="line">    ClientSess--&gt;&gt;-ClientApp: Return result (CallToolResult object)</div>
</div><!-- fragment --><p>This flow highlights how the session objects act as intermediaries, managing IDs and matching responses back to their original requests.</p>
<h2><a class="anchor" id="autotoc_md2488"></a>
Diving into the Code (Briefly!)</h2>
<p>You typically won't call these methods directly when using <code>FastMCP</code> for servers, but seeing the structure helps understand the session's role. These snippets are heavily simplified.</p>
<p><b>Base Class (<code>shared/session.py</code>):</b></p>
<p>Both <code>ClientSession</code> and <code>ServerSession</code> inherit from <code>BaseSession</code>, which contains the core logic for sending/receiving and request/response matching.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified from shared/session.py</span></div>
<div class="line"><span class="keyword">import</span> anyio</div>
<div class="line"><span class="keyword">from</span> mcp.types <span class="keyword">import</span> JSONRPCRequest, JSONRPCResponse, JSONRPCError, ErrorData</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>BaseSession:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, read_stream, write_stream, ...):</div>
<div class="line">        self._read_stream = read_stream</div>
<div class="line">        self._write_stream = write_stream</div>
<div class="line">        self._response_streams = {} <span class="comment"># Stores &#39;waiters&#39; for responses, keyed by request ID</span></div>
<div class="line">        self._request_id_counter = 0</div>
<div class="line">        <span class="comment"># ... other setup ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>send_request(self, request, result_type):</div>
<div class="line">        <span class="comment"># 1. Get a new unique ID</span></div>
<div class="line">        request_id = self._request_id_counter</div>
<div class="line">        self._request_id_counter += 1</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 2. Create a &#39;waiter&#39; (memory stream) to receive the response</span></div>
<div class="line">        response_receiver, response_sender = anyio.create_memory_object_stream(1)</div>
<div class="line">        self._response_streams[request_id] = response_sender</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 3. Format the request with the ID</span></div>
<div class="line">        jsonrpc_request = JSONRPCRequest(id=request_id, **request.model_dump())</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 4. Send it over the write stream</span></div>
<div class="line">        await self._write_stream.send(JSONRPCMessage(jsonrpc_request))</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 5. Wait for the response to arrive on the &#39;waiter&#39; stream</span></div>
<div class="line">        response_or_error = await response_receiver.receive() <span class="comment"># Timeout logic omitted</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 6. Process response/error and return result</span></div>
<div class="line">        <span class="keywordflow">if</span> isinstance(response_or_error, JSONRPCError):</div>
<div class="line">            <span class="keywordflow">raise</span> McpError(response_or_error.error)</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            <span class="keywordflow">return</span> result_type.model_validate(response_or_error.result)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>_receive_loop(self):</div>
<div class="line">        <span class="comment"># Runs in the background, reading from the read_stream</span></div>
<div class="line">        <span class="keyword">async</span> <span class="keywordflow">for</span> message <span class="keywordflow">in</span> self._read_stream:</div>
<div class="line">            <span class="keywordflow">if</span> isinstance(message.root, (JSONRPCResponse, JSONRPCError)):</div>
<div class="line">                <span class="comment"># It&#39;s a response or error for a request we sent</span></div>
<div class="line">                request_id = message.root.id</div>
<div class="line">                <span class="comment"># Find the matching &#39;waiter&#39; stream</span></div>
<div class="line">                response_sender = self._response_streams.pop(request_id, <span class="keywordtype">None</span>)</div>
<div class="line">                <span class="keywordflow">if</span> response_sender:</div>
<div class="line">                    <span class="comment"># Send the response back to the waiting send_request call</span></div>
<div class="line">                    await response_sender.send(message.root)</div>
<div class="line">                <span class="keywordflow">else</span>:</div>
<div class="line">                    print(f<span class="stringliteral">&quot;Warning: Received response for unknown request ID {request_id}&quot;</span>)</div>
<div class="line">            <span class="keywordflow">elif</span> isinstance(message.root, JSONRPCRequest):</div>
<div class="line">                <span class="comment"># It&#39;s a new request *from* the other side</span></div>
<div class="line">                <span class="comment"># Subclasses (Client/ServerSession) handle this differently</span></div>
<div class="line">                await self._handle_incoming_request(message.root)</div>
<div class="line">            <span class="keywordflow">elif</span> isinstance(message.root, JSONRPCNotification):</div>
<div class="line">                 <span class="comment"># It&#39;s a notification *from* the other side</span></div>
<div class="line">                 await self._handle_incoming_notification(message.root)</div>
</div><!-- fragment --><p>This shows the core <code>send_request</code> logic (assign ID, store waiter, send, wait) and the <code>_receive_loop</code> logic (read message, if response -&gt; find waiter, if request/notification -&gt; handle).</p>
<p><b>Server Session (<code>server/session.py</code>):</b></p>
<p>Adds server-specific logic, like handling the <code>initialize</code> request and sending server-to-client notifications.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified from server/session.py</span></div>
<div class="line"><span class="keyword">from</span> mcp.types <span class="keyword">import</span> InitializeRequest, InitializeResult, InitializedNotification</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ServerSession(BaseSession):</div>
<div class="line">    <span class="comment"># ... (init with server info, capabilities) ...</span></div>
<div class="line">    _initialization_state = InitializationState.NotInitialized</div>
<div class="line">    _client_params = <span class="keywordtype">None</span> <span class="comment"># Stores client info after initialization</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>_handle_incoming_request(self, request: JSONRPCRequest):</div>
<div class="line">        <span class="comment"># Server specifically handles &#39;initialize&#39; request first</span></div>
<div class="line">        <span class="keywordflow">if</span> request.method == <span class="stringliteral">&quot;initialize&quot;</span>:</div>
<div class="line">            <span class="comment"># ... (validate request, store client capabilities in self._client_params) ...</span></div>
<div class="line">            self._initialization_state = InitializationState.Initializing</div>
<div class="line">            init_result = InitializeResult(...) <span class="comment"># Build result with server info</span></div>
<div class="line">            <span class="comment"># Respond directly using the base class&#39;s internal send method</span></div>
<div class="line">            await self._send_response(request.id, ServerResult(init_result))</div>
<div class="line">        <span class="keywordflow">elif</span> self._initialization_state == InitializationState.Initialized:</div>
<div class="line">            <span class="comment"># For other requests, pass them to the main server logic</span></div>
<div class="line">            <span class="comment"># (e.g., to FastMCP&#39;s request router) via an internal queue</span></div>
<div class="line">            await self._pass_request_to_server_handler(request)</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            <span class="comment"># Error: Request received before initialization complete</span></div>
<div class="line">            error = ErrorData(code=..., message=<span class="stringliteral">&quot;Server not initialized&quot;</span>)</div>
<div class="line">            await self._send_response(request.id, error)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>_handle_incoming_notification(self, notification: JSONRPCNotification):</div>
<div class="line">        <span class="keywordflow">if</span> notification.method == <span class="stringliteral">&quot;initialized&quot;</span>:</div>
<div class="line">             self._initialization_state = InitializationState.Initialized</div>
<div class="line">             print(<span class="stringliteral">&quot;ServerSession: Client initialization complete.&quot;</span>)</div>
<div class="line">        <span class="keywordflow">elif</span> self._initialization_state == InitializationState.Initialized:</div>
<div class="line">            <span class="comment"># Pass other notifications to server logic if needed</span></div>
<div class="line">            <span class="keywordflow">pass</span></div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">             <span class="comment"># Ignore notifications before initialized, or log warning</span></div>
<div class="line">             <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>send_log_message(self, level, data, logger=None):</div>
<div class="line">        <span class="comment"># Helper method to send a specific notification type</span></div>
<div class="line">        log_notification = LoggingMessageNotification(...)</div>
<div class="line">        await self.send_notification(ServerNotification(log_notification))</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... other methods like send_progress_notification, send_resource_updated ...</span></div>
</div><!-- fragment --><p>This highlights how <code>ServerSession</code> intercepts the <code>initialize</code> request and the <code>initialized</code> notification to manage the connection state before passing other messages to the main server logic.</p>
<h2><a class="anchor" id="autotoc_md2489"></a>
Conclusion</h2>
<p>You've now explored <code>ClientSession</code> and <code>ServerSession</code>, the dedicated operators managing individual communication lines between MCP clients and servers.</p>
<ul>
<li>A <b>Session</b> handles the lifecycle of a single connection.</li>
<li>It manages the <b>initialization handshake</b>.</li>
<li>It reliably <b>sends and receives</b> messages (requests, responses, notifications).</li>
<li>Crucially, it <b>matches incoming responses to outgoing requests</b> using unique IDs.</li>
<li><b><code>ClientSession</code></b> is used by clients to initiate connections and send requests <em>to</em> servers.</li>
<li><b><code>ServerSession</code></b> is used by servers to handle connections and respond <em>to</em> clients.</li>
<li>Frameworks like <b><code>FastMCP</code> manage <code>ServerSession</code> automatically</b> for you; interaction often happens indirectly via the <code>Context</code> object.</li>
</ul>
<p>Sessions provide the robust foundation for the request-response patterns and asynchronous notifications that make MCP communication work.</p>
<p>In the final chapter of this foundational series, we'll look at the different ways these sessions can actually transmit their messages back and forth: the various <a class="el" href="../../dd/db1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_209__communication__tran26c952f5654fc90ff2967a2bea333d2f.html">Chapter 9: Communication Transports (Stdio, SSE, WebSocket, Memory)</a>.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
