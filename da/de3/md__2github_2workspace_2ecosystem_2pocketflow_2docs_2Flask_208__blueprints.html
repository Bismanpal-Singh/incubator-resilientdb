#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 08_blueprints</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('da/de3/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_208__blueprints.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">08_blueprints</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1947"></a>
autotoc_md1947</h2>
<p>layout: default title: "Blueprints" parent: "Flask" </p>
<h2><a class="anchor" id="autotoc_md1948"></a>
nav_order: 8</h2>
<h1><a class="anchor" id="autotoc_md1949"></a>
Chapter 8: Blueprints</h1>
<p>Welcome back! In <a class="el" href="../../d6/da8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_207__application__and__request__contexts.html">Chapter 7: Application and Request Contexts</a>, we explored the "magic" behind Flask's context system, understanding how variables like <code>request</code> and <code>current_app</code> work reliably even with multiple concurrent requests.</p>
<p>Now, imagine your simple "Hello, World!" application starts growing. You add user profiles, an admin section, maybe a blog. Putting all your routes, view functions, and related logic into a single Python file (like our <code>hello.py</code>) quickly becomes messy and hard to manage. How can we organize our growing Flask application into smaller, more manageable pieces?</p>
<p>That's where <b>Blueprints</b> come in!</p>
<h2><a class="anchor" id="autotoc_md1950"></a>
What Problem Do They Solve? Organizing a Growing House</h2>
<p>Think about building a house. You wouldn't try to build the kitchen, bathroom, and bedrooms all mixed together in one big pile. Instead, you might have separate plans or even pre-fabricated modules for each section. The kitchen module has its specific plumbing and electrical needs, the bathroom has its fixtures, etc. Once these modules are ready, you assemble them into the main structure of the house.</p>
<p>Similarly, as your Flask application grows, you want to group related features together. For example:</p>
<ul>
<li>All the routes related to user authentication (<code>/login</code>, <code>/logout</code>, <code>/register</code>).</li>
<li>All the routes for an admin control panel (<code>/admin/dashboard</code>, <code>/admin/users</code>).</li>
<li>All the routes for a public-facing blog (<code>/blog</code>, <code>/blog/&lt;post_slug&gt;</code>).</li>
</ul>
<p>Trying to manage all these in one file leads to:</p>
<ul>
<li><b>Clutter:</b> The main application file becomes huge and hard to navigate.</li>
<li><b>Confusion:</b> It's difficult to see which routes belong to which feature.</li>
<li><b>Poor Reusability:</b> If you wanted to reuse the "blog" part in another project, it would be hard to extract just that code.</li>
</ul>
<p><b>Blueprints</b> provide Flask's solution for this. They let you define collections of routes, view functions, templates, and static files as separate modules. You can develop these modules independently and then "register" them with your main Flask application, potentially multiple times or under different URL prefixes.</p>
<p>They are like the <b>prefabricated sections of your house</b>. You build the "user authentication module" (a blueprint) separately, then plug it into your main application structure.</p>
<h2><a class="anchor" id="autotoc_md1951"></a>
Creating and Using a Simple Blueprint</h2>
<p>Let's see how this works. Imagine we want to create a separate section for user-related pages.</p>
<ol type="1">
<li><b>Create a Blueprint Object:</b> Instead of using <code>@app.route()</code>, we first create a <code>Blueprint</code> object.</li>
<li><b>Define Routes on the Blueprint:</b> We use decorators like <code>@bp.route()</code> (where <code>bp</code> is our blueprint object) to define routes <em>within</em> that blueprint.</li>
<li><b>Register the Blueprint with the App:</b> In our main application file, we tell the Flask <code>app</code> object about our blueprint using <code>app.register_blueprint()</code>.</li>
</ol>
<p>Let's structure our project. We'll have our main <code><a class="el" href="../../de/d0e/app_8py.html">app.py</a></code> and a separate file for our user routes, maybe inside a <code>blueprints</code> folder:</p>
<div class="fragment"><div class="line">yourproject/</div>
<div class="line">├── app.py              # Main Flask application setup</div>
<div class="line">├── blueprints/</div>
<div class="line">│   └── __init__.py     # Makes &#39;blueprints&#39; a Python package (can be empty)</div>
<div class="line">│   └── user.py         # Our user blueprint routes</div>
<div class="line">└── templates/</div>
<div class="line">    └── user/</div>
<div class="line">        └── profile.html # Template for the user profile</div>
</div><!-- fragment --><p><b>Step 1 &amp; 2: Define the Blueprint (<code>blueprints/user.py</code>)</b></p>
<div class="fragment"><div class="line"><span class="comment"># blueprints/user.py</span></div>
<div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint, render_template, abort</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 1. Create the Blueprint object</span></div>
<div class="line"><span class="comment"># &#39;user&#39; is the name of the blueprint. Used internally by Flask.</span></div>
<div class="line"><span class="comment"># __name__ helps locate the blueprint&#39;s resources (like templates).</span></div>
<div class="line"><span class="comment"># template_folder specifies where to look for this blueprint&#39;s templates.</span></div>
<div class="line">user_bp = Blueprint(<span class="stringliteral">&#39;user&#39;</span>, __name__, template_folder=<span class="stringliteral">&#39;../templates/user&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Sample user data (replace with database logic in a real app)</span></div>
<div class="line">users = {</div>
<div class="line">    <span class="stringliteral">&quot;alice&quot;</span>: {<span class="stringliteral">&quot;name&quot;</span>: <span class="stringliteral">&quot;Alice&quot;</span>, <span class="stringliteral">&quot;email&quot;</span>: <span class="stringliteral">&quot;alice@example.com&quot;</span>},</div>
<div class="line">    <span class="stringliteral">&quot;bob&quot;</span>: {<span class="stringliteral">&quot;name&quot;</span>: <span class="stringliteral">&quot;Bob&quot;</span>, <span class="stringliteral">&quot;email&quot;</span>: <span class="stringliteral">&quot;bob@example.com&quot;</span>},</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 2. Define routes ON THE BLUEPRINT using @user_bp.route()</span></div>
<div class="line"><span class="preprocessor">@user_bp.route(&#39;/profile/&lt;username&gt;&#39;)</span></div>
<div class="line"><span class="keyword">def </span>profile(username):</div>
<div class="line">  user_info = users.get(username)</div>
<div class="line">  <span class="keywordflow">if</span> <span class="keywordflow">not</span> user_info:</div>
<div class="line">    abort(404) <span class="comment"># User not found</span></div>
<div class="line">  <span class="comment"># Note: render_template will now look in &#39;templates/user/&#39; first</span></div>
<div class="line">  <span class="comment"># because of template_folder=&#39;../templates/user&#39; in Blueprint()</span></div>
<div class="line">  <span class="keywordflow">return</span> render_template(<span class="stringliteral">&#39;profile.html&#39;</span>, user=user_info)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@user_bp.route(&#39;/&#39;)</span></div>
<div class="line"><span class="keyword">def </span>user_list():</div>
<div class="line">    <span class="comment"># A simple view within the user blueprint</span></div>
<div class="line">    <span class="keywordflow">return</span> f<span class="stringliteral">&quot;List of users: {&#39;, &#39;.join(users.keys())}&quot;</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>from flask import Blueprint</code>: We import the <code>Blueprint</code> class.</li>
<li>&lsquo;user_bp = Blueprint('user&rsquo;, <b>name</b>, template_folder='../templates/user')<code>: We create an instance. *</code>'user'<code>: The name of this blueprint. This is used later for generating URLs (</code>url_for<code>). *</code>__name__<code>: Helps Flask determine the blueprint's root path, similar to how it works for the main</code>Flask<code>app object ([Chapter 1](<a class="el" href="../../d0/dce/01__application__object______flask_____8md.html">01_application_object___flask__.md</a>)). *</code>template_folder='../templates/user'<code>: Tells this blueprint where its specific templates are located relative to</code>user.py<code>. *</code>@user_bp.route(...)<code>: We define routes using the blueprint object, *not* the main</code>app` object.</li>
</ul>
<p><b>Step 3: Register the Blueprint (<code><a class="el" href="../../de/d0e/app_8py.html">app.py</a></code>)</b></p>
<p>Now, we need to tell our main Flask application about this blueprint.</p>
<div class="fragment"><div class="line"><span class="comment"># app.py</span></div>
<div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div>
<div class="line"><span class="keyword">from</span> blueprints.user <span class="keyword">import</span> user_bp <span class="comment"># Import the blueprint object</span></div>
<div class="line"> </div>
<div class="line">app = Flask(__name__)</div>
<div class="line"><span class="comment"># We might have other config here, like SECRET_KEY from Chapter 6</span></div>
<div class="line"><span class="comment"># app.config[&#39;SECRET_KEY&#39;] = &#39;your secret key&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Register the blueprint with the main application</span></div>
<div class="line"><span class="comment"># We can add a url_prefix here!</span></div>
<div class="line">app.register_blueprint(user_bp, url_prefix=<span class="stringliteral">&#39;/users&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Maybe add a simple homepage route directly on the app</span></div>
<div class="line"><span class="preprocessor">@app.route(&#39;/&#39;)</span></div>
<div class="line"><span class="keyword">def </span>home():</div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&#39;Welcome to the main application!&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&#39;__main__&#39;</span>:</div>
<div class="line">  app.run(debug=<span class="keyword">True</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>from blueprints.user import user_bp</code>: We import the <code>Blueprint</code> instance we created in <code>user.py</code>.</li>
<li>&lsquo;app.register_blueprint(user_bp, url_prefix=&rsquo;/users')<code>: This is the crucial step.<ul>
<li>It tells the</li>
</ul>
</code>app<code>object to include all the routes defined in</code>user_bp<code>. *</code>url_prefix='/users'<code>: This is very useful! It means all routes defined *within* the</code>user_bp<code>will automatically be prefixed with</code>/users<code>.<ul>
<li>The</li>
</ul>
</code>/profile/&lt;username&gt;<code>route in</code>user.py<code>becomes</code>/users/profile/&lt;username&gt;<code>.<ul>
<li>The</li>
</ul>
</code>/<code>route in</code>user.py<code>becomes</code>/users/`.</li>
</ul>
<p><b>Template (<code>templates/user/profile.html</code>)</b></p>
<div class="fragment"><div class="line">&lt;!-- templates/user/profile.html --&gt;</div>
<div class="line">&lt;!doctype html&gt;</div>
<div class="line">&lt;html&gt;</div>
<div class="line">&lt;head&gt;&lt;title&gt;User Profile&lt;/title&gt;&lt;/head&gt;</div>
<div class="line">&lt;body&gt;</div>
<div class="line">  &lt;h1&gt;Profile for {{ user.name }}&lt;/h1&gt;</div>
<div class="line">  &lt;p&gt;Email: {{ user.email }}&lt;/p&gt;</div>
<div class="line">  &lt;p&gt;&lt;a href=&quot;{{ url_for(&#39;user.user_list&#39;) }}&quot;&gt;Back to User List&lt;/a&gt;&lt;/p&gt;</div>
<div class="line">  &lt;p&gt;&lt;a href=&quot;{{ url_for(&#39;home&#39;) }}&quot;&gt;Back to Home&lt;/a&gt;&lt;/p&gt;</div>
<div class="line">&lt;/body&gt;</div>
<div class="line">&lt;/html&gt;</div>
</div><!-- fragment --><p><b>Running this:</b></p>
<ol type="1">
<li>Create the directory structure and files as shown above.</li>
<li>Run <code>python <a class="el" href="../../de/d0e/app_8py.html">app.py</a></code> in your terminal.</li>
<li>Visit <code><a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a></code>. You'll see "Welcome to the main application!" (Handled by <code><a class="el" href="../../de/d0e/app_8py.html">app.py</a></code>).</li>
<li>Visit <code><a href="http://127.0.0.1:5000/users/">http://127.0.0.1:5000/users/</a></code>. You'll see "List of users: alice, bob" (Handled by <code>user.py</code>, route <code>/</code>, with prefix <code>/users</code>).</li>
<li>Visit <code><a href="http://127.0.0.1:5000/users/profile/alice">http://127.0.0.1:5000/users/profile/alice</a></code>. You'll see the profile page for Alice (Handled by <code>user.py</code>, route <code>/profile/&lt;username&gt;</code>, with prefix <code>/users</code>).</li>
<li>Visit <code><a href="http://127.0.0.1:5000/users/profile/charlie">http://127.0.0.1:5000/users/profile/charlie</a></code>. You'll get a 404 Not Found error, as handled by <code>profile()</code> in <code>user.py</code>.</li>
</ol>
<p>Notice how the blueprint allowed us to neatly separate the user-related code into <code>blueprints/user.py</code>, keeping <code><a class="el" href="../../de/d0e/app_8py.html">app.py</a></code> cleaner. The <code>url_prefix</code> made it easy to group all user routes under <code>/users/</code>.</p>
<h2><a class="anchor" id="autotoc_md1952"></a>
Generating URLs with <code>url_for</code> and Blueprints</h2>
<p>How does <code>url_for</code> work when routes are defined in blueprints? You need to prefix the endpoint name with the <b>blueprint name</b>, followed by a dot (<code>.</code>).</p>
<p>Look back at the <code>profile.html</code> template:</p>
<ul>
<li>&lsquo;{{ url_for('user.user_list&rsquo;) }}<code>: Generates the URL for the</code>user_list<code>view function *within* the</code>user<code>blueprint. Because of the</code>url_prefix='/users'<code>, this generates</code>/users/<code>. *</code>{{ url_for('user.profile', username='alice') }}<code>(if used in Python): Would generate</code>/users/profile/alice<code>. *</code>{{ url_for('home') }}<code>: Generates the URL for the</code>home<code>view function, which is registered directly on the</code>app<code>, not a blueprint. This generates</code>/`.</li>
</ul>
<p>If you are generating a URL for an endpoint <em>within the same blueprint</em>, you can use a dot prefix for a relative link:</p>
<div class="fragment"><div class="line"><span class="comment"># Inside blueprints/user.py</span></div>
<div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> url_for</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@user_bp.route(&#39;/link-example&#39;)</span></div>
<div class="line"><span class="keyword">def </span>link_example():</div>
<div class="line">    <span class="comment"># Generate URL for &#39;profile&#39; endpoint within the *same* blueprint (&#39;user&#39;)</span></div>
<div class="line">    alice_url = url_for(<span class="stringliteral">&#39;.profile&#39;</span>, username=<span class="stringliteral">&#39;alice&#39;</span>) <span class="comment"># Note the leading dot!</span></div>
<div class="line">    <span class="comment"># alice_url will be &#39;/users/profile/alice&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Generate URL for the main app&#39;s &#39;home&#39; endpoint</span></div>
<div class="line">    home_url = url_for(<span class="stringliteral">&#39;home&#39;</span>) <span class="comment"># No dot needed for app routes</span></div>
<div class="line">    <span class="comment"># home_url will be &#39;/&#39;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> f<span class="stringliteral">&#39;Alice profile: {alice_url}&lt;br&gt;Homepage: {home_url}&#39;</span></div>
</div><!-- fragment --><p>Using the blueprint name (<code>user.profile</code>) or the relative dot (<code>.profile</code>) ensures <code>url_for</code> finds the correct endpoint, even if multiple blueprints happen to use the same view function name (like <code>index</code>).</p>
<h2><a class="anchor" id="autotoc_md1953"></a>
Blueprint Resources: Templates and Static Files</h2>
<p>As we saw, you can specify <code>template_folder</code> when creating a <code>Blueprint</code>. When &lsquo;render_template('profile.html&rsquo;)<code>is called from within the</code>user_bp<code>'s</code>profile<code>view, Flask (via Jinja2's</code>DispatchingJinjaLoader<code>, see [Chapter 4](<a class="el" href="../../d6/dc9/04__templating____jinja2__integration___8md.html">04_templating__jinja2_integration_.md</a>)) will look for</code>profile.html` in this order:</p>
<ol type="1">
<li>The application's template folder (<code>templates/</code>).</li>
<li>The blueprint's template folder (<code>templates/user/</code> in our example).</li>
</ol>
<p>This allows blueprints to have their own templates, potentially overriding application-wide templates if needed, but usually just keeping them organized.</p>
<p>Similarly, you can specify a <code>static_folder</code> and <code>static_url_path</code> for a blueprint. This allows a blueprint to bundle its own CSS, JavaScript, or image files.</p>
<div class="fragment"><div class="line"><span class="comment"># blueprints/admin.py</span></div>
<div class="line">admin_bp = Blueprint(<span class="stringliteral">&#39;admin&#39;</span>, __name__,</div>
<div class="line">                     static_folder=<span class="stringliteral">&#39;static&#39;</span>, <span class="comment"># Look in blueprints/admin/static/</span></div>
<div class="line">                     static_url_path=<span class="stringliteral">&#39;/admin-static&#39;</span>, <span class="comment"># URL like /admin-static/style.css</span></div>
<div class="line">                     template_folder=<span class="stringliteral">&#39;templates&#39;</span>) <span class="comment"># Look in blueprints/admin/templates/</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Then register with the app:</span></div>
<div class="line"><span class="comment"># app.register_blueprint(admin_bp, url_prefix=&#39;/admin&#39;)</span></div>
</div><!-- fragment --><p>Accessing blueprint static files uses <code>url_for</code> with the special <code>static</code> endpoint, prefixed by the blueprint name:</p>
<div class="fragment"><div class="line">&lt;!-- Inside an admin blueprint template --&gt;</div>
<div class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;{{ url_for(&#39;admin.static&#39;, filename=&#39;style.css&#39;) }}&quot;&gt;</div>
<div class="line">&lt;!-- Generates a URL like: /admin-static/style.css --&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1954"></a>
Under the Hood: How Registration Works</h2>
<p>What actually happens when you call <code>app.register_blueprint(bp)</code>?</p>
<ol type="1">
<li><b>Deferred Functions:</b> When you use decorators like <code>@bp.route</code>, <code>@bp.before_request</code>, <code>@bp.errorhandler</code>, etc., on a <code>Blueprint</code> object, the blueprint doesn't immediately tell the application about them. Instead, it stores these actions as "deferred functions" in a list (<code>bp.deferred_functions</code>). See <code>Blueprint.route</code> calling <code>Blueprint.add_url_rule</code>, which calls <code>Blueprint.record</code>.</li>
<li><b>Registration Call:</b> &lsquo;app.register_blueprint(bp, url_prefix=&rsquo;/users')<code>is called.</code></li>
<li><code> **State Creation:** The application creates a</code>BlueprintSetupState<code>object. This object holds references to the blueprint (</code>bp<code>), the application (</code>app<code>), and the options passed during registration (like</code>url_prefix='/users'<code>).</code></li>
<li><code> **Recording the Blueprint:** The app adds the blueprint to its</code>app.blueprints<code>dictionary. This is important for routing and</code>url_for<code>.</code></li>
<li><code> **Executing Deferred Functions:** The app iterates through the list of</code>deferred_functions<code>stored in the blueprint. For each deferred function, it calls it, passing the</code>BlueprintSetupState<code>object.</code></li>
<li><code> **Applying Settings:** Inside the deferred function (which was created back when you used, e.g.,</code>@bp.route<code>), the function now has access to both the original arguments (</code>'/'<code>,</code>view_func<code>, etc.) and the setup state (</code>state<code>).<ul>
<li>For a route, the deferred function typically calls</li>
</ul>
</code>state.add_url_rule(...)<code>. *</code>state.add_url_rule<code>then calls</code>app.add_url_rule(...)<code>, but it *modifies* the arguments first:<ul>
<li>It prepends the</li>
</ul>
</code>url_prefix<code>from the</code>state<code>(e.g.,</code>/users<code>) to the route's</code>rule<code>.<ul>
<li>It prepends the blueprint's name (</li>
</ul>
</code>state.name<code>, e.g.,</code>user<code>) plus a dot to the route's</code>endpoint<code>(e.g.,</code>profile<code>becomes</code>user.profile<code>).<ul>
<li>It applies other options like</li>
</ul>
</code>subdomain<code>.<ul>
<li>For other decorators like</li>
</ul>
</code>@bp.before_request<code>, the deferred function registers the handler function in the appropriate application dictionary (e.g.,</code>app.before_request_funcs<code>) but uses the blueprint's name as the key (or</code>None` for app-wide handlers added via the blueprint).</li>
<li><b>Nested Blueprints:</b> If the blueprint being registered itself contains nested blueprints, the registration process is called recursively for those nested blueprints, adjusting prefixes and names accordingly.</li>
</ol>
<p>Here's a simplified diagram for registering a route via a blueprint:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Code as Your Code (e.g., user.py)</div>
<div class="line">    participant BP as user_bp (Blueprint obj)</div>
<div class="line">    participant App as Main App (Flask obj)</div>
<div class="line">    participant State as BlueprintSetupState</div>
<div class="line"> </div>
<div class="line">    Code-&gt;&gt;+BP: @user_bp.route(&#39;/profile/&lt;name&gt;&#39;)</div>
<div class="line">    BP-&gt;&gt;BP: record(deferred_add_rule_func)</div>
<div class="line">    BP--&gt;&gt;-Code: Decorator applied</div>
<div class="line"> </div>
<div class="line">    Note over App: Later, in app.py...</div>
<div class="line">    App-&gt;&gt;App: app.register_blueprint(user_bp, url_prefix=&#39;/users&#39;)</div>
<div class="line">    App-&gt;&gt;+State: Create BlueprintSetupState(bp=user_bp, app=app, options={...})</div>
<div class="line">    State--&gt;&gt;-App: Return state object</div>
<div class="line">    App-&gt;&gt;BP: For func in user_bp.deferred_functions:</div>
<div class="line">    Note right of BP: func = deferred_add_rule_func</div>
<div class="line">    App-&gt;&gt;BP: func(state)</div>
<div class="line">    BP-&gt;&gt;+State: deferred_add_rule_func calls state.add_url_rule(&#39;/profile/&lt;name&gt;&#39;, ...)</div>
<div class="line">    State-&gt;&gt;App: Calls app.add_url_rule(&#39;/users/profile/&lt;name&gt;&#39;, endpoint=&#39;user.profile&#39;, ...)</div>
<div class="line">    App-&gt;&gt;App: Adds rule to app.url_map</div>
<div class="line">    State--&gt;&gt;-BP: add_url_rule finished</div>
<div class="line">    BP--&gt;&gt;App: Deferred function finished</div>
</div><!-- fragment --><p>The key idea is <b>deferral</b>. Blueprints record actions but don't apply them until they are registered on an actual application, using the <code>BlueprintSetupState</code> to correctly prefix routes and endpoints.</p>
<h2><a class="anchor" id="autotoc_md1955"></a>
Conclusion</h2>
<p>Blueprints are Flask's powerful solution for organizing larger applications. They allow you to group related routes, views, templates, and static files into modular, reusable components.</p>
<ul>
<li>We learned how to <b>create</b> a <code>Blueprint</code> object.</li>
<li>We saw how to <b>define routes</b> and other handlers using blueprint decorators (<code>@bp.route</code>, <code>@bp.before_request</code>, etc.).</li>
<li>We learned how to <b>register</b> a blueprint with the main application using <code>app.register_blueprint()</code>, optionally specifying a <code>url_prefix</code>.</li>
<li>We understood how <code>url_for</code> works with blueprint endpoints (using <code>blueprint_name.endpoint_name</code> or <code>.endpoint_name</code>).</li>
<li>Blueprints help keep your codebase <b>organized, maintainable, and modular</b>.</li>
</ul>
<p>By breaking down your application into logical blueprints, you can manage complexity much more effectively as your project grows. This structure also makes it easier for teams to work on different parts of the application simultaneously.</p>
<p>This concludes our core tutorial on Flask's fundamental concepts! You now have a solid understanding of the Application Object, Routing, Request/Response, Templating, Context Globals, Configuration, Contexts, and Blueprints. With these tools, you're well-equipped to start building your own web applications with Flask.</p>
<p>From here, you might explore Flask extensions for common tasks (like database integration with Flask-SQLAlchemy, user authentication with Flask-Login, form handling with Flask-WTF), delve into testing your Flask applications, or learn about different deployment strategies. Happy Flasking!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
