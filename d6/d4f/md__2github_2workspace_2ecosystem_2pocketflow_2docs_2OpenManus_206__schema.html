#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_schema</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d4f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_206__schema.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_schema</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2638"></a>
autotoc_md2638</h2>
<p>layout: default title: "Schema" parent: "OpenManus" </p>
<h2><a class="anchor" id="autotoc_md2639"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md2640"></a>
Chapter 6: Schema - The Official Data Forms</h1>
<p>In <a class="el" href="../../d0/d93/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_205__baseflow.html">Chapter 5: BaseFlow</a>, we saw how Flows act like project managers, coordinating different <a class="el" href="../../d0/d71/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_203__baseagent.html">Agents</a> and <a class="el" href="../../de/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_204__tool______toolcollection.html">Tools</a> to complete complex tasks. But for all these different parts (Flows, Agents, LLMs, Tools) to work together smoothly, they need to speak the same language and use the same formats when exchanging information.</p>
<p>Imagine a busy office where everyone fills out forms for requests, reports, and messages. If everyone uses their <em>own</em> unique form layout, it quickly becomes chaotic! Someone might forget a required field, use the wrong data type (like writing "yesterday" instead of a specific date), or mislabel information. It would be incredibly hard to process anything efficiently.</p>
<p>This is where <b>Schemas</b> come into play in OpenManus.</p>
<h2><a class="anchor" id="autotoc_md2641"></a>
What Problem Does Schema Solve?</h2>
<p>In our digital "office" (the OpenManus application), various components need to pass data back and forth:</p><ul>
<li>The User sends a request (a message).</li>
<li>The Agent stores this message in its <a class="el" href="../../dc/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_202__message______memory.html">Memory</a>.</li>
<li>The Agent might ask the <a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">LLM</a> for help, sending the conversation history.</li>
<li>The LLM might decide to use a <a class="el" href="../../de/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_204__tool______toolcollection.html">Tool</a>, sending back instructions on which tool and what inputs to use.</li>
<li>The Tool executes and sends back its results.</li>
<li>The Agent updates its status (e.g., from <code>RUNNING</code> to <code>FINISHED</code>).</li>
</ul>
<p>Without a standard way to structure all this information, we'd face problems:</p><ul>
<li><b>Inconsistency:</b> One part might expect a user message to have a <code>sender</code> field, while another expects a <code>role</code> field.</li>
<li><b>Errors:</b> A Tool might expect a number as input but receive text, causing it to crash.</li>
<li><b>Confusion:</b> It would be hard for developers (and the system itself!) to know exactly what information is contained in a piece of data.</li>
<li><b>Maintenance Nightmares:</b> Changing how data is structured in one place could break many other parts unexpectedly.</li>
</ul>
<p><b>Schemas solve this by defining the official "forms" or "templates" for all the important data structures used in OpenManus.</b> Think of them as the agreed-upon standard formats that everyone must use.</p>
<p><b>Use Case:</b> When the LLM decides the agent should use the <code>web_search</code> tool with the query "latest AI news", it doesn't just send back a vague text string. It needs to send structured data that clearly says:</p><ol type="1">
<li>"I want to call a tool."</li>
<li>"The tool's name is `web_search`."</li>
<li>"The input parameter `query` should be set to `latest AI news`."</li>
</ol>
<p>A schema defines exactly how this "tool call request" should look, ensuring the Agent understands it correctly.</p>
<h2><a class="anchor" id="autotoc_md2642"></a>
Key Concepts: Standard Templates via Pydantic</h2>
<ol type="1">
<li><b>Schema as Templates:</b> At its core, a schema is a formal definition of a data structure. It specifies:<ul>
<li>What pieces of information (fields) must be included (e.g., a <code>Message</code> must have a <code>role</code>).</li>
<li>What type each piece of information should be (e.g., <code>role</code> must be text, <code>current_step</code> in an Agent must be a number).</li>
<li>Which fields are optional and which are required.</li>
<li>Sometimes, default values or specific allowed values (e.g., <code>role</code> must be one of "user", "assistant", "system", or "tool").</li>
</ul>
</li>
<li><b>Pydantic: The Schema Engine:</b> OpenManus uses a popular Python library called <b>Pydantic</b> to define and enforce these schemas. You don't need to be a Pydantic expert, but understanding its role is helpful. Pydantic lets us define these data structures using simple Python classes. When data is loaded into these classes, Pydantic automatically:<ul>
<li><b>Validates</b> the data: Checks if all required fields are present and if the data types are correct. If not, it raises an error <em>before</em> the bad data can cause problems elsewhere.</li>
<li><b>Provides Auto-completion and Clarity:</b> Because the structure is clearly defined in code, developers get better auto-completion hints in their editors, making the code easier to write and understand.</li>
</ul>
</li>
</ol>
<p>Think of Pydantic as the strict office manager who checks every form submitted, ensuring it's filled out correctly according to the official template before passing it on.</p>
<h2><a class="anchor" id="autotoc_md2643"></a>
How Do We Use Schemas? (Examples)</h2>
<p>Schemas are defined throughout the OpenManus codebase, primarily as Pydantic models. You've already encountered some! Let's look at a few key examples found mostly in <code>app/schema.py</code> and <code>app/tool/base.py</code>.</p>
<p><b>1. <code>Message</code> (from <code>app/schema.py</code>): The Chat Bubble</b></p>
<p>We saw this in <a class="el" href="../../dc/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_202__message______memory.html">Chapter 2: Message / Memory</a>. It defines the structure for a single turn in a conversation.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified Pydantic model from app/schema.py</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Optional, Literal</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define allowed roles</span></div>
<div class="line">ROLE_TYPE = Literal[<span class="stringliteral">&quot;system&quot;</span>, <span class="stringliteral">&quot;user&quot;</span>, <span class="stringliteral">&quot;assistant&quot;</span>, <span class="stringliteral">&quot;tool&quot;</span>]</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Message(BaseModel):</div>
<div class="line">    role: ROLE_TYPE = Field(...) <span class="comment"># &#39;...&#39; means this field is required</span></div>
<div class="line">    content: Optional[str] = Field(default=<span class="keywordtype">None</span>) <span class="comment"># Optional text content</span></div>
<div class="line">    <span class="comment"># ... other optional fields like tool_calls, name, tool_call_id ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Class methods like user_message, assistant_message are here...</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li>This Pydantic class <code>Message</code> defines the "form" for a message.</li>
<li><code>role: ROLE_TYPE = Field(...)</code> means every message <em>must</em> have a <code>role</code>, and its value must be one of the strings defined in <code>ROLE_TYPE</code>. Pydantic enforces this.</li>
<li><code>content: Optional[str] = Field(default=None)</code> means a message <em>can</em> have text <code>content</code>, but it's optional. If not provided, it defaults to <code>None</code>.</li>
<li>Pydantic ensures that if you try to create a <code>Message</code> object without a valid <code>role</code>, or with <code>content</code> that isn't a string, you'll get an error immediately.</li>
</ul>
<p><b>2. <code>ToolCall</code> and <code>Function</code> (from <code>app/schema.py</code>): The Tool Request Form</b></p>
<p>When the LLM tells the agent to use a tool, it sends back data structured according to the <code>ToolCall</code> schema.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified Pydantic models from app/schema.py</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Function(BaseModel):</div>
<div class="line">    name: str      <span class="comment"># The name of the tool/function to call</span></div>
<div class="line">    arguments: str <span class="comment"># The input arguments as a JSON string</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ToolCall(BaseModel):</div>
<div class="line">    id: str              <span class="comment"># A unique ID for this specific call</span></div>
<div class="line">    type: str = <span class="stringliteral">&quot;function&quot;</span> <span class="comment"># Currently always &quot;function&quot;</span></div>
<div class="line">    function: Function   <span class="comment"># Embeds the Function details above</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li>The <code>Function</code> schema defines that we need the <code>name</code> of the tool (as text) and its <code>arguments</code> (also as text, expected to be formatted as JSON).</li>
<li>The <code>ToolCall</code> schema includes a unique <code>id</code>, the <code>type</code> (always "function" for now), and embeds the <code>Function</code> data.</li>
<li>This ensures that whenever the agent receives a tool call instruction from the LLM, it knows exactly where to find the tool's name and arguments, preventing guesswork and errors.</li>
</ul>
<p><b>3. <code>AgentState</code> (from <code>app/schema.py</code>): The Agent Status Report</b></p>
<p>We saw this in <a class="el" href="../../d0/d71/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_203__baseagent.html">Chapter 3: BaseAgent</a>. It standardizes how we represent the agent's current status.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified definition from app/schema.py</span></div>
<div class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>AgentState(str, Enum):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Agent execution states&quot;&quot;&quot;</span></div>
<div class="line">    IDLE = <span class="stringliteral">&quot;IDLE&quot;</span></div>
<div class="line">    RUNNING = <span class="stringliteral">&quot;RUNNING&quot;</span></div>
<div class="line">    FINISHED = <span class="stringliteral">&quot;FINISHED&quot;</span></div>
<div class="line">    ERROR = <span class="stringliteral">&quot;ERROR&quot;</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li>This uses Python's <code>Enum</code> (Enumeration) type, which is automatically compatible with Pydantic.</li>
<li>It defines a fixed set of allowed values for the agent's state. An agent's state <em>must</em> be one of these four strings.</li>
<li>This prevents typos (like "Runing" or "Idle") and makes it easy to check the agent's status reliably.</li>
</ul>
<p><b>4. <code>ToolResult</code> (from <code>app/tool/base.py</code>): The Tool Output Form</b></p>
<p>When a <a class="el" href="../../de/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_204__tool______toolcollection.html">Tool</a> finishes its job, it needs to report back its findings in a standard way.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified Pydantic model from app/tool/base.py</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any, Optional</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ToolResult(BaseModel):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Represents the result of a tool execution.&quot;&quot;&quot;</span></div>
<div class="line">    output: Any = Field(default=<span class="keywordtype">None</span>)          <span class="comment"># The main result data</span></div>
<div class="line">    error: Optional[str] = Field(default=<span class="keywordtype">None</span>) <span class="comment"># Error message, if any</span></div>
<div class="line">    <span class="comment"># ... other optional fields like base64_image, system message ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">class </span>Config:</div>
<div class="line">        arbitrary_types_allowed = <span class="keyword">True</span> <span class="comment"># Allows &#39;Any&#39; type for output</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li>Defines a standard structure for <em>any</em> tool's output.</li>
<li>It includes an <code>output</code> field for the successful result (which can be of <code>Any</code> type, allowing flexibility for different tools) and an optional <code>error</code> field to report problems.</li>
<li>Specific tools might <em>inherit</em> from <code>ToolResult</code> to add more specific fields, like <code>SearchResult</code> adding <code>url</code>, <code>title</code>, etc. (see <code>app/tool/web_search.py</code>). Using <code>ToolResult</code> as a base ensures all tool outputs have a consistent minimum structure.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2644"></a>
Under the Hood: Pydantic Validation</h2>
<p>The real power of using Pydantic for schemas comes from its automatic data validation. Let's illustrate with a simplified <code>Message</code> example.</p>
<p>Imagine you have this Pydantic model:</p>
<div class="fragment"><div class="line"><span class="comment"># Standalone Example (Illustrative)</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, ValidationError</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Literal</div>
<div class="line"> </div>
<div class="line">ROLE_TYPE = Literal[<span class="stringliteral">&quot;user&quot;</span>, <span class="stringliteral">&quot;assistant&quot;</span>] <span class="comment"># Only allow these roles</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SimpleMessage(BaseModel):</div>
<div class="line">    role: ROLE_TYPE</div>
<div class="line">    content: str</div>
</div><!-- fragment --><p>Now, let's see what happens when we try to create instances:</p>
<div class="fragment"><div class="line"><span class="comment"># --- Valid Data ---</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    msg1 = SimpleMessage(role=<span class="stringliteral">&quot;user&quot;</span>, content=<span class="stringliteral">&quot;Hello there!&quot;</span>)</div>
<div class="line">    print(<span class="stringliteral">&quot;msg1 created successfully:&quot;</span>, msg1.model_dump()) <span class="comment"># .model_dump() shows dict</span></div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(<span class="stringliteral">&quot;Error creating msg1:&quot;</span>, e)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Missing Required Field (&#39;content&#39;) ---</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    msg2 = SimpleMessage(role=<span class="stringliteral">&quot;assistant&quot;</span>)</div>
<div class="line">    print(<span class="stringliteral">&quot;msg2 created successfully:&quot;</span>, msg2.model_dump())</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(<span class="stringliteral">&quot;\nError creating msg2:&quot;</span>)</div>
<div class="line">    print(e) <span class="comment"># Pydantic gives a detailed error</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Invalid Role ---</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    msg3 = SimpleMessage(role=<span class="stringliteral">&quot;system&quot;</span>, content=<span class="stringliteral">&quot;System message&quot;</span>) <span class="comment"># &#39;system&#39; is not allowed</span></div>
<div class="line">    print(<span class="stringliteral">&quot;msg3 created successfully:&quot;</span>, msg3.model_dump())</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(<span class="stringliteral">&quot;\nError creating msg3:&quot;</span>)</div>
<div class="line">    print(e) <span class="comment"># Pydantic catches the wrong role</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Wrong Data Type for &#39;content&#39; ---</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    msg4 = SimpleMessage(role=<span class="stringliteral">&quot;user&quot;</span>, content=123) <span class="comment"># content should be string</span></div>
<div class="line">    print(<span class="stringliteral">&quot;msg4 created successfully:&quot;</span>, msg4.model_dump())</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(<span class="stringliteral">&quot;\nError creating msg4:&quot;</span>)</div>
<div class="line">    print(e) <span class="comment"># Pydantic catches the type error</span></div>
</div><!-- fragment --><p><b>Example Output:</b></p>
<div class="fragment"><div class="line">msg1 created successfully: {&#39;role&#39;: &#39;user&#39;, &#39;content&#39;: &#39;Hello there!&#39;}</div>
<div class="line"> </div>
<div class="line">Error creating msg2:</div>
<div class="line">1 validation error for SimpleMessage</div>
<div class="line">content</div>
<div class="line">  Field required [type=missing, input_value={&#39;role&#39;: &#39;assistant&#39;}, input_type=dict]</div>
<div class="line">    For further information visit https://errors.pydantic.dev/2.7/v/missing</div>
<div class="line"> </div>
<div class="line">Error creating msg3:</div>
<div class="line">1 validation error for SimpleMessage</div>
<div class="line">role</div>
<div class="line">  Input should be &#39;user&#39; or &#39;assistant&#39; [type=literal_error, input_value=&#39;system&#39;, input_type=str]</div>
<div class="line">    For further information visit https://errors.pydantic.dev/2.7/v/literal_error</div>
<div class="line"> </div>
<div class="line">Error creating msg4:</div>
<div class="line">1 validation error for SimpleMessage</div>
<div class="line">content</div>
<div class="line">  Input should be a valid string [type=string_type, input_value=123, input_type=int]</div>
<div class="line">    For further information visit https://errors.pydantic.dev/2.7/v/string_type</div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li>When the data matches the schema (<code>msg1</code>), the object is created successfully.</li>
<li>When data is missing (<code>msg2</code>), has an invalid value (<code>msg3</code>), or the wrong type (<code>msg4</code>), Pydantic automatically raises a <code>ValidationError</code>.</li>
<li>The error message clearly explains <em>what</em> is wrong and <em>where</em>.</li>
</ul>
<p>This validation happens automatically whenever data is loaded into these Pydantic models within OpenManus, catching errors early and ensuring data consistency across the entire application. You mostly find these schema definitions in <code>app/schema.py</code>, but also within specific tool files (like <code>app/tool/base.py</code>, <code>app/tool/web_search.py</code>) for their specific results.</p>
<h2><a class="anchor" id="autotoc_md2645"></a>
Wrapping Up Chapter 6</h2>
<p>You've learned that <b>Schemas</b> are like official data templates or forms used throughout OpenManus. They define the expected structure for important data like messages, tool calls, agent states, and tool results. By using the <b>Pydantic</b> library, OpenManus automatically <b>validates</b> data against these schemas, ensuring consistency, preventing errors, and making the whole system more reliable and easier to understand. They are the backbone of structured communication between different components.</p>
<p>We've now covered most of the core functional building blocks of OpenManus. But how do we configure things like which LLM model to use, API keys, or which tools an agent should have? That's handled by the Configuration system.</p>
<p>Let's move on to <a class="el" href="../../d5/d05/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_207__configuration____config__.html">Chapter 7: Configuration (Config)</a> to see how we manage settings and secrets for our agents and flows.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
