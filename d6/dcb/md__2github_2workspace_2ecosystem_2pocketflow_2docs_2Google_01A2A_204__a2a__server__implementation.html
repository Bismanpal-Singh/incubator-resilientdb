#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_a2a_server_implementation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/dcb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_204__a2a__server__implementation.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_a2a_server_implementation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1989"></a>
autotoc_md1989</h2>
<p>layout: default title: "A2A Server Implementation" parent: "Google A2A" </p>
<h2><a class="anchor" id="autotoc_md1990"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md1991"></a>
Chapter 4: A2A Server Implementation</h1>
<p>In the <a class="el" href="../../d8/d90/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_203__a2a__protocol______core__types.html">previous chapter</a>, we learned the "language" and "grammar" that AI agents use to talk to each other – the <b>A2A Protocol</b> based on JSON-RPC and its <b>Core Types</b> like <code>Task</code> and <code>Message</code>. Think of it like learning the rules of diplomacy and the standard format for official documents.</p>
<p>But just knowing the rules isn't enough. If one country (an AI agent) wants to send a diplomatic message (a <a class="el" href="../../d2/d9c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_202__task.html">Task</a>) to another, it needs an official reception point – an embassy. How does an AI agent set up its "embassy" to receive and handle these official A2A communications?</p>
<p>That's the role of the <b>A2A Server Implementation</b>. It solves the problem of <b>hosting an agent</b> and making it <b>accessible</b> according to the A2A protocol rules.</p>
<h2><a class="anchor" id="autotoc_md1992"></a>
What is an A2A Server? The Agent's Embassy</h2>
<p>Imagine our AI agent is like a skilled expert (a translator, a coder, an image generator) working inside a building. How do people from the outside world reach this expert and give them work? They can't just barge into the building!</p>
<p>They need to go through the official <b>reception desk</b> or <b>front office</b>. This office:</p>
<ol type="1">
<li>Listens for visitors (incoming requests).</li>
<li>Understands the standard procedures for submitting work (the A2A protocol).</li>
<li>Takes the request (the <code>Task</code>), logs it, and passes it to the right expert inside.</li>
<li>Keeps track of the work's progress.</li>
<li>Delivers the results back to the visitor when ready.</li>
<li>Provides basic information about the building and its services (the <a class="el" href="../../d7/d4e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_201__agent__card.html">Agent Card</a>).</li>
</ol>
<p>An <b>A2A Server</b> is exactly like that front office or embassy for your AI agent. It's the software component that runs on a server, listens for incoming network requests, and acts as the official gateway for all A2A communication.</p>
<h2><a class="anchor" id="autotoc_md1993"></a>
Why Do We Need It?</h2>
<p>Without a server, our AI agent is isolated. It might be brilliant at its job, but no other agent or application can interact with it using the standard A2A protocol. The A2A Server provides the necessary "infrastructure" to:</p>
<ul>
<li><b>Listen:</b> Be constantly available on the network (at a specific URL) for incoming requests.</li>
<li><b>Understand:</b> Decode the JSON-RPC messages and figure out what the client wants (e.g., <code>tasks/send</code>, <code>tasks/get</code>).</li>
<li><b>Delegate:</b> Pass the work request (the <code>Task</code> details) to the actual AI logic (which might be implemented using tools like LangGraph, CrewAI, Genkit, or custom code).</li>
<li><b>Manage:</b> Keep track of ongoing <code>Tasks</code>, their current <code>status</code> (e.g., <code>submitted</code>, <code>working</code>, <code>completed</code>), and store their results (<code>Artifacts</code>).</li>
<li><b>Respond:</b> Send back properly formatted JSON-RPC responses (confirming task creation, providing results, or reporting errors).</li>
<li><b>Advertise:</b> Serve the agent's <code>agent.json</code> (<a class="el" href="../../d7/d4e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_201__agent__card.html">Agent Card</a>) so others can discover it.</li>
</ul>
<p>Think of it as the bridge connecting your agent's internal world to the external world of A2A communication.</p>
<h2><a class="anchor" id="autotoc_md1994"></a>
Setting Up a Basic Server</h2>
<p>Luckily, the <code>Google A2A</code> project provides helper libraries to make setting up a server much easier! You don't need to build the entire "embassy" from scratch. You mainly need to provide:</p>
<ol type="1">
<li>Your agent's specific logic (the "expert" who does the actual work).</li>
<li>The agent's <a class="el" href="../../d7/d4e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_201__agent__card.html">Agent Card</a> details.</li>
</ol>
<p>Let's look at simplified examples in JavaScript (Node.js) and Python.</p>
<h3><a class="anchor" id="autotoc_md1995"></a>
JavaScript Example (using <code>A2AServer</code> from the library)</h3>
<p>Imagine we have a very simple "Echo Agent" that just sends back whatever text it receives.</p>
<div class="fragment"><div class="line">// File: simple-agent/index.ts (Conceptual Example)</div>
<div class="line">import { A2AServer, TaskContext, TaskYieldUpdate } from &quot;google-a2a/server&quot;; // Simplified import</div>
<div class="line">import * as schema from &quot;google-a2a/schema&quot;;</div>
<div class="line"> </div>
<div class="line">// 1. Define the Agent&#39;s Logic (The &quot;Expert&quot;)</div>
<div class="line">// This function handles a single task.</div>
<div class="line">async function* echoAgentLogic(</div>
<div class="line">  context: TaskContext</div>
<div class="line">): AsyncGenerator&lt;TaskYieldUpdate, schema.Task | void&gt; {</div>
<div class="line">  const inputText = context.userMessage.parts[0].text ?? &quot;No text found&quot;;</div>
<div class="line"> </div>
<div class="line">  // Yield a status update: &quot;working&quot;</div>
<div class="line">  yield { state: &quot;working&quot;, message: { role: &quot;agent&quot;, parts: [{ text: &quot;Echoing...&quot; }] } };</div>
<div class="line"> </div>
<div class="line">  // Yield the final result: &quot;completed&quot;</div>
<div class="line">  yield {</div>
<div class="line">    state: &quot;completed&quot;,</div>
<div class="line">    message: { role: &quot;agent&quot;, parts: [{ text: `You said: ${inputText}` }] }</div>
<div class="line">  };</div>
<div class="line">  // (Artifacts could also be yielded here if needed)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// 2. Define the Agent Card</div>
<div class="line">const echoAgentCard: schema.AgentCard = {</div>
<div class="line">  name: &quot;Echo Agent&quot;,</div>
<div class="line">  description: &quot;Replies with the text it receives.&quot;,</div>
<div class="line">  url: &quot;http://localhost:4000&quot;, // Where this server will run</div>
<div class="line">  version: &quot;1.0&quot;,</div>
<div class="line">  capabilities: { streaming: true }, // It yields updates</div>
<div class="line">  skills: [{ id: &quot;echo&quot;, name: &quot;Echo Text&quot; }],</div>
<div class="line">  // ... other card details</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// 3. Create and Start the Server</div>
<div class="line">const server = new A2AServer(echoAgentLogic, { card: echoAgentCard });</div>
<div class="line">server.start(4000); // Start listening on port 4000</div>
<div class="line"> </div>
<div class="line">console.log(&quot;Echo Agent server running on http://localhost:4000&quot;);</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Agent Logic (<code>echoAgentLogic</code>):</b> This is the core function defining <em>what</em> the agent does. It receives the <code>TaskContext</code> (containing the user's message) and uses <code>yield</code> to send back status updates (<code>working</code>) and the final result (<code>completed</code>). We'll dive deeper into this logic in <a class="el" href="../../d7/d27/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_206__task__handling__logic____server__side__.html">Chapter 6: Task Handling Logic (Server-side)</a>. For now, just see it as the agent's brain.</li>
<li><b>Agent Card (<code>echoAgentCard</code>):</b> We define the agent's public profile, including its name, description, and importantly, the <code>url</code> where the server will be listening.</li>
<li><b>Server Setup:</b> We create an instance of <code>A2AServer</code>, passing our agent's logic function and its card. Then, we call <code>server.start()</code> to make it listen for requests on the specified port (4000).</li>
</ol>
<p>That's it! With this code, we have a running A2A server ready to accept <code>tasks/send</code> requests for our Echo Agent.</p>
<h3><a class="anchor" id="autotoc_md1996"></a>
Python Example (using <code>A2AServer</code> from the library)</h3>
<p>Let's do the same for Python.</p>
<div class="fragment"><div class="line"><span class="comment"># File: simple_agent/main.py (Conceptual Example)</span></div>
<div class="line"><span class="keyword">from</span> common.server <span class="keyword">import</span> A2AServer, TaskManager  <span class="comment"># Simplified import</span></div>
<div class="line"><span class="keyword">from</span> common.types <span class="keyword">import</span> (</div>
<div class="line">    AgentCard, AgentCapabilities, AgentSkill,</div>
<div class="line">    Task, TaskSendParams, TaskStatus, TaskState, Message, TextPart, SendTaskResponse</div>
<div class="line">)</div>
<div class="line"><span class="keyword">import</span> logging</div>
<div class="line"> </div>
<div class="line">logging.basicConfig(level=logging.INFO)</div>
<div class="line">logger = logging.getLogger(__name__)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 1. Define the Agent&#39;s Logic Handler (Task Manager)</span></div>
<div class="line"><span class="comment"># This class bridges the server and the agent&#39;s actual logic.</span></div>
<div class="line"><span class="keyword">class </span>EchoTaskManager(TaskManager): <span class="comment"># Inherit from the base TaskManager</span></div>
<div class="line">    <span class="keyword">async def </span>on_send_task(self, params: TaskSendParams) -&gt; SendTaskResponse:</div>
<div class="line">        <span class="comment"># Simulate processing the task</span></div>
<div class="line">        input_text = params.message.parts[0].text <span class="keywordflow">if</span> params.message.parts <span class="keywordflow">else</span> <span class="stringliteral">&quot;No text&quot;</span></div>
<div class="line">        logger.info(f<span class="stringliteral">&quot;Echo Agent received: {input_text}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Create the final Task object (simplified for non-streaming)</span></div>
<div class="line">        final_task = Task(</div>
<div class="line">            id=params.id,</div>
<div class="line">            status=TaskStatus(</div>
<div class="line">                state=TaskState.COMPLETED,</div>
<div class="line">                message=Message(role=<span class="stringliteral">&quot;agent&quot;</span>, parts=[TextPart(text=f<span class="stringliteral">&quot;You said: {input_text}&quot;</span>)])</div>
<div class="line">            ),</div>
<div class="line">            <span class="comment"># ... other Task fields ...</span></div>
<div class="line">        )</div>
<div class="line">        <span class="comment"># In a real scenario, you&#39;d store/update the task state</span></div>
<div class="line">        <span class="comment"># self.tasks[params.id] = final_task # Example storage</span></div>
<div class="line">        <span class="keywordflow">return</span> SendTaskResponse(id=params.id, result=final_task)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Implement other abstract methods from TaskManager (get, cancel, etc.)</span></div>
<div class="line">    <span class="comment"># (Skipped for brevity in this example)</span></div>
<div class="line">    <span class="keyword">async def </span>on_get_task(self, request): <span class="keywordflow">raise</span> NotImplementedError()</div>
<div class="line">    <span class="keyword">async def </span>on_cancel_task(self, request): <span class="keywordflow">raise</span> NotImplementedError()</div>
<div class="line">    <span class="comment"># ... and so on for streaming, push notifications etc.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 2. Define the Agent Card</span></div>
<div class="line">echo_agent_card = AgentCard(</div>
<div class="line">    name=<span class="stringliteral">&quot;Echo Agent&quot;</span>,</div>
<div class="line">    description=<span class="stringliteral">&quot;Replies with the text it receives.&quot;</span>,</div>
<div class="line">    url=<span class="stringliteral">&quot;http://localhost:5000/&quot;</span>, <span class="comment"># Where this server will run</span></div>
<div class="line">    version=<span class="stringliteral">&quot;1.0&quot;</span>,</div>
<div class="line">    capabilities=AgentCapabilities(streaming=<span class="keyword">False</span>), <span class="comment"># Simplified non-streaming Python example</span></div>
<div class="line">    skills=[AgentSkill(id=<span class="stringliteral">&quot;echo&quot;</span>, name=<span class="stringliteral">&quot;Echo Text&quot;</span>)],</div>
<div class="line">    <span class="comment"># ... other card details</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 3. Create and Start the Server</span></div>
<div class="line">server = A2AServer(</div>
<div class="line">    agent_card=echo_agent_card,</div>
<div class="line">    task_manager=EchoTaskManager(), <span class="comment"># Pass our task handler</span></div>
<div class="line">    host=<span class="stringliteral">&quot;localhost&quot;</span>,</div>
<div class="line">    port=5000,</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">logger.info(<span class="stringliteral">&quot;Starting Echo Agent server on http://localhost:5000&quot;</span>)</div>
<div class="line">server.start()</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Agent Logic Handler (<code>EchoTaskManager</code>):</b> In the Python library structure, we often create a class that inherits from <code>TaskManager</code>. This class implements methods like <code>on_send_task</code> to handle specific A2A commands. Here, <code>on_send_task</code> simulates processing and returns the final <code>Task</code> object wrapped in a <code>SendTaskResponse</code>. <a class="el" href="../../d7/d27/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_206__task__handling__logic____server__side__.html">Chapter 6</a> will cover this in detail.</li>
<li><b>Agent Card (<code>echo_agent_card</code>):</b> Similar to the JS example, we define the agent's profile.</li>
<li><b>Server Setup:</b> We create an <code>A2AServer</code> instance, providing the card and our custom <code>EchoTaskManager</code>. We then call <code>server.start()</code>.</li>
</ol>
<p>Both examples achieve the same goal: they use the library's <code>A2AServer</code> class to quickly stand up a web server that listens for A2A requests, delegates the work to the provided agent logic, and handles the communication details.</p>
<h2><a class="anchor" id="autotoc_md1997"></a>
Under the Hood: How a Request is Processed</h2>
<p>What happens when a client sends a <code>tasks/send</code> request to our running A2A server?</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant C as Client App</div>
<div class="line">    participant S as A2A Server (e.g., Express/Starlette)</div>
<div class="line">    participant TM as Task Manager/Handler (Your Logic Bridge)</div>
<div class="line">    participant AL as Agent Logic (e.g., echoAgentLogic, CrewAI)</div>
<div class="line">    participant TS as Task Store (Memory/DB)</div>
<div class="line"> </div>
<div class="line">    C-&gt;&gt;S: POST / (JSON-RPC: method=&quot;tasks/send&quot;, params={...})</div>
<div class="line">    Note right of S: Receives HTTP POST, parses JSON-RPC</div>
<div class="line"> </div>
<div class="line">    S-&gt;&gt;TM: Call on_send_task / Invoke Handler(params)</div>
<div class="line">    Note right of TM: Validates parameters</div>
<div class="line"> </div>
<div class="line">    TM-&gt;&gt;TS: Load/Create Task Record (ID: task-123)</div>
<div class="line">    Note right of TS: Creates Task in &#39;submitted&#39; state</div>
<div class="line"> </div>
<div class="line">    TM-&gt;&gt;AL: Execute Agent Logic (Input: user message)</div>
<div class="line">    Note right of AL: Performs the core work (e.g., echo)</div>
<div class="line"> </div>
<div class="line">    AL--&gt;&gt;TM: Returns result/Yields updates (e.g., &quot;working&quot;, &quot;completed&quot;)</div>
<div class="line"> </div>
<div class="line">    loop For each update/result</div>
<div class="line">        TM-&gt;&gt;TS: Update Task Record (ID: task-123, state: working/completed, artifacts: [...])</div>
<div class="line">        Note right of TS: Saves the latest task state</div>
<div class="line">        alt Streaming Response (SSE)</div>
<div class="line">           S--&gt;&gt;C: SSE Event (data: {TaskStatusUpdateEvent/Artifact})</div>
<div class="line">        end</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    alt Non-Streaming Response</div>
<div class="line">        TM--&gt;&gt;S: Final Task object</div>
<div class="line">        S--&gt;&gt;C: 200 OK (JSON-RPC: result={Final Task Object})</div>
<div class="line">    else Streaming Response (SSE)</div>
<div class="line">        Note over S,C: Stream ends after final event</div>
<div class="line">    end</div>
</div><!-- fragment --><p><b>Steps:</b></p>
<ol type="1">
<li><b>Receive Request:</b> The client sends an HTTP POST request containing the JSON-RPC payload to the server's URL (e.g., <code><a href="http://localhost:4000">http://localhost:4000</a></code>). The web server part of the <code>A2AServer</code> (like Express in JS or Starlette in Python) receives this.</li>
<li><b>Parse &amp; Route:</b> The <code>A2AServer</code> parses the JSON body, validates it's a valid JSON-RPC request, and looks at the <code>method</code> field (e.g., <code>tasks/send</code>). Based on the method, it calls the appropriate handler function (like <code>handleTaskSend</code> in the JS server or delegates to the <code>on_send_task</code> method of the <code>TaskManager</code> in Python).</li>
<li><b>Task Management:</b> The task handler (your <code>echoAgentLogic</code> or <code>EchoTaskManager</code>) takes over. It typically interacts with a <code>TaskStore</code> (like <code>InMemoryTaskStore</code>) to create or retrieve the <a class="el" href="../../d2/d9c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_202__task.html">Task</a> record associated with the request's <code>taskId</code>. It updates the task's status to <code>submitted</code> or <code>working</code>.</li>
<li><b>Execute Agent Logic:</b> The handler calls the actual underlying AI agent code, passing the necessary input (like the user's message).</li>
<li><b>Process Results/Updates:</b> As the agent logic runs, it might produce results or status updates. The handler receives these.</li>
<li><b>Update Store &amp; Respond:</b> The handler updates the <code>Task</code> record in the <code>TaskStore</code> with the new status or results (<code>Artifacts</code>).<ul>
<li>For a simple request/response like <code>tasks/send</code> (non-streaming), it waits for the final result and sends back a single JSON-RPC response containing the completed <code>Task</code>.</li>
<li>For a streaming request like <code>tasks/sendSubscribe</code>, it sends back Server-Sent Events (SSE) for each update as they happen. (<a class="el" href="../../d0/d60/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_207__streaming__communication____sse__.html">Chapter 7: Streaming Communication (SSE)</a> covers this).</li>
</ul>
</li>
<li><b>Serve Agent Card:</b> Separately, if a client sends a GET request to <code>/.well-known/agent.json</code>, the <code>A2AServer</code> simply responds with the content of the <code>AgentCard</code> you provided during setup.</li>
</ol>
<p>The <code>A2AServer</code> libraries (<code>samples/js/src/server/server.ts</code>, <code>samples/python/common/server/server.py</code>) handle the complexities of HTTP, JSON-RPC parsing, routing, and response formatting, letting you focus on implementing your agent's specific capabilities within the task handler (<a class="el" href="../../d7/d27/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_206__task__handling__logic____server__side__.html">Chapter 6</a>).</p>
<h2><a class="anchor" id="autotoc_md1998"></a>
Conclusion</h2>
<p>The <b>A2A Server Implementation</b> is the crucial component that brings your AI agent to life on the network, acting as its official "embassy" for A2A communication. It listens for requests, understands the A2A protocol, manages tasks, interacts with your agent's core logic, and sends back responses.</p>
<p>By using the provided <code>A2AServer</code> libraries, you can quickly set up a compliant server without worrying about the low-level details of web servers and JSON-RPC, allowing you to concentrate on building your agent's unique skills.</p>
<p>Now that we know how to build the <em>server</em> side (the agent's embassy), how does another application or agent <em>talk</em> to it? We need to build an <b>A2A Client</b>.</p>
<p><b>Next:</b> <a class="el" href="../../dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html">Chapter 5: A2A Client Implementation</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
