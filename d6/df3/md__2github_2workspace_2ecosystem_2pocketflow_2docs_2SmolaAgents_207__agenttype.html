#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 07_agenttype</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/df3/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_207__agenttype.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">07_agenttype</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md3169"></a>
autotoc_md3169</h2>
<p>layout: default title: "AgentType" parent: "SmolaAgents" </p>
<h2><a class="anchor" id="autotoc_md3170"></a>
nav_order: 7</h2>
<h1><a class="anchor" id="autotoc_md3171"></a>
Chapter 7: AgentType - Handling More Than Just Text</h1>
<p>Welcome back! In the previous chapters, especially when discussing <a class="el" href="../../d4/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_203__tool.html">Tools</a> and the <a class="el" href="../../df/dec/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_206__pythonexecutor.html">PythonExecutor</a>, we saw how agents can perform actions and generate results. So far, we've mostly focused on text-based tasks and results.</p>
<p>But what happens when an agent needs to work with images, audio, or other types of data? For example:</p><ul>
<li>An agent uses a tool to generate an image based on a description.</li>
<li>An agent uses a tool to transcribe an audio file into text.</li>
<li>An agent receives an image as input and needs to describe it.</li>
</ul>
<p>How does the <code>SmolaAgents</code> framework handle these different kinds of data consistently? How does it make sure an image generated by a tool is displayed correctly in your notebook, or saved properly in the agent's <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">Memory</a>?</p>
<p>This is where the <b><code>AgentType</code></b> concept comes in!</p>
<h2><a class="anchor" id="autotoc_md3172"></a>
The Problem: Shipping Different Kinds of Cargo</h2>
<p>Imagine you run a shipping company. Most of the time, you ship standard boxes (like text). But sometimes, customers need to ship different things:</p><ul>
<li>Fresh produce that needs a refrigerated container (like audio data).</li>
<li>Large machinery that needs a flatbed truck (like image data).</li>
</ul>
<p>You can't just stuff the fresh produce into a standard box â€“ it would spoil! And the machinery won't even fit. You need specialized containers designed for specific types of cargo.</p>
<p><img src="https://img.icons8.com/plasticine/100/shipping-container.png" alt="Standard Box vs Specialized Containers" class="inline"/> <img src="https://img.icons8.com/plasticine/100/temperature-sensitive.png" alt="Standard Box vs Specialized Containers" class="inline"/> <img src="https://img.icons8.com/plasticine/100/image-file.png" alt="Standard Box vs Specialized Containers" class="inline"/></p>
<p>Similarly, our agents need a way to handle data beyond simple text strings. Using Python's built-in types directly (like a raw <code>PIL.Image</code> object for images) can cause problems:</p><ul>
<li><b>How do you display it?</b> A raw image object doesn't automatically show up as a picture in a Jupyter notebook.</li>
<li><b>How do you save it?</b> How do you store an image or audio clip in the agent's text-based <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">Memory</a> log? You can't just put the raw image data there.</li>
<li><b>How do you pass it around?</b> How does the framework ensure different components (tools, agent core, memory) know how to handle these different data types consistently?</li>
</ul>
<h2><a class="anchor" id="autotoc_md3173"></a>
The Solution: Specialized Data Containers (<code>AgentType</code>)</h2>
<p><code>SmolaAgents</code> introduces special "data containers" to solve this problem. These are custom data types that inherit from a base <code>AgentType</code> class:</p>
<ul>
<li><b><code>AgentText</code></b>: For handling plain text. It behaves just like a standard Python string.</li>
<li><b><code>AgentImage</code></b>: For handling images (usually as <code>PIL.Image</code> objects).</li>
<li><b><code>AgentAudio</code></b>: For handling audio data (often as <code>torch.Tensor</code> or file paths).</li>
</ul>
<p>Think of these as the specialized shipping containers:</p>
<ul>
<li><code>AgentText</code> is like the standard shipping box.</li>
<li><code>AgentImage</code> is like a container designed to safely transport and display pictures.</li>
<li><code>AgentAudio</code> is like a container designed to safely transport and play audio clips.</li>
</ul>
<p>These <code>AgentType</code> objects <b>wrap</b> the actual data (the string, the image object, the audio data) but add extra capabilities.</p>
<h2><a class="anchor" id="autotoc_md3174"></a>
Why Use <code>AgentType</code>? (The Benefits)</h2>
<p>Using these specialized containers gives us several advantages:</p>
<ol type="1">
<li><b>Consistent Handling:</b> The <code>SmolaAgents</code> framework knows how to recognize and work with <code>AgentType</code> objects, regardless of whether they contain text, images, or audio.</li>
<li><b>Smart Display:</b> Objects like <code>AgentImage</code> and <code>AgentAudio</code> know how to display themselves correctly in environments like Jupyter notebooks or Gradio interfaces. For example, an <code>AgentImage</code> will automatically render as an image, not just print <code>&lt;PIL.Image.Image ...&gt;</code>.</li>
<li><b>Proper Serialization:</b> They know how to convert themselves into a string representation suitable for logging or storing in <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">Memory</a>.<ul>
<li><code>AgentText</code> simply returns its string content.</li>
<li><code>AgentImage</code> automatically saves the image to a temporary file and returns the <em>path</em> to that file when converted to a string (<code>to_string()</code> method). This path can be safely logged.</li>
<li><code>AgentAudio</code> does something similar for audio data, saving it to a temporary <code>.wav</code> file.</li>
</ul>
</li>
<li><b>Clear Communication:</b> Tools can clearly state what type of output they produce (e.g., <code>output_type="image"</code>), and the framework ensures the output is wrapped correctly.</li>
</ol>
<h2><a class="anchor" id="autotoc_md3175"></a>
How is <code>AgentType</code> Used? (Mostly Automatic!)</h2>
<p>The best part is that you often don't need to manually create or handle these <code>AgentType</code> objects. The framework does the heavy lifting.</p>
<p><b>Scenario 1: A Tool Returning an Image</b></p>
<p>Imagine you have a tool that generates images using a library like <code>diffusers</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: image_tool.py ---</span></div>
<div class="line"><span class="keyword">from</span> smolagents <span class="keyword">import</span> Tool</div>
<div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div>
<div class="line"><span class="comment"># Assume &#39;diffusion_pipeline&#39; is a pre-loaded image generation model</span></div>
<div class="line"><span class="comment"># from diffusers import DiffusionPipeline</span></div>
<div class="line"><span class="comment"># diffusion_pipeline = DiffusionPipeline.from_pretrained(...)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ImageGeneratorTool(Tool):</div>
<div class="line">    name: str = <span class="stringliteral">&quot;image_generator&quot;</span></div>
<div class="line">    description: str = <span class="stringliteral">&quot;Generates an image based on a text prompt.&quot;</span></div>
<div class="line">    inputs: dict = {</div>
<div class="line">        <span class="stringliteral">&quot;prompt&quot;</span>: {</div>
<div class="line">            <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;string&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;The text description for the image.&quot;</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="comment"># Tell the framework this tool outputs an image!</span></div>
<div class="line">    output_type: str = <span class="stringliteral">&quot;image&quot;</span> <span class="comment"># &lt;--- Crucial Hint!</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>forward(self, prompt: str) -&gt; Image.Image:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Generates the image using a diffusion model.&quot;&quot;&quot;</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;--- ImageGeneratorTool generating image for: &#39;{prompt}&#39; ---&quot;</span>)</div>
<div class="line">        <span class="comment"># image = diffusion_pipeline(prompt).images[0] # Actual generation</span></div>
<div class="line">        <span class="comment"># For simplicity, let&#39;s create a dummy blank image</span></div>
<div class="line">        image = Image.new(<span class="stringliteral">&#39;RGB&#39;</span>, (60, 30), color = <span class="stringliteral">&#39;red&#39;</span>)</div>
<div class="line">        print(f<span class="stringliteral">&quot;--- Tool returning a PIL Image object ---&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> image</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- How the framework uses it (conceptual) ---</span></div>
<div class="line">image_tool = ImageGeneratorTool()</div>
<div class="line">prompt = <span class="stringliteral">&quot;A red rectangle&quot;</span></div>
<div class="line">raw_output = image_tool(prompt=prompt) <span class="comment"># Calls forward(), gets a PIL.Image object</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Framework automatically wraps the output because output_type=&quot;image&quot;</span></div>
<div class="line"><span class="comment"># Uses handle_agent_output_types(raw_output, output_type=&quot;image&quot;)</span></div>
<div class="line"><span class="keyword">from</span> smolagents.agent_types <span class="keyword">import</span> handle_agent_output_types</div>
<div class="line">wrapped_output = handle_agent_output_types(raw_output, output_type=<span class="stringliteral">&quot;image&quot;</span>)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Raw output type: {type(raw_output)}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Wrapped output type: {type(wrapped_output)}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># When storing in memory or logging, the framework calls to_string()</span></div>
<div class="line">output_string = wrapped_output.to_string()</div>
<div class="line">print(f<span class="stringliteral">&quot;String representation for logs: {output_string}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Expected Output (path will vary):</span></div>
<div class="line"><span class="comment"># --- ImageGeneratorTool generating image for: &#39;A red rectangle&#39; ---</span></div>
<div class="line"><span class="comment"># --- Tool returning a PIL Image object ---</span></div>
<div class="line"><span class="comment"># Raw output type: &lt;class &#39;PIL.Image.Image&#39;&gt;</span></div>
<div class="line"><span class="comment"># Wrapped output type: &lt;class &#39;smolagents.agent_types.AgentImage&#39;&gt;</span></div>
<div class="line"><span class="comment"># String representation for logs: /tmp/tmpxxxxxx/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.png</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>We define <code>ImageGeneratorTool</code> and crucially set <code>output_type="image"</code>.</li>
<li>The <code>forward</code> method does its work and returns a standard <code>PIL.Image.Image</code> object.</li>
<li>When the agent framework receives this output, it checks the tool's <code>output_type</code>. Since it's <code>"image"</code>, it automatically uses the <code>handle_agent_output_types</code> function (or similar internal logic) to wrap the <code>PIL.Image.Image</code> object inside an <code>AgentImage</code> container.</li>
<li>If this <code>AgentImage</code> needs to be logged or stored in <a class="el" href="../../d1/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_204__agentmemory.html">Memory</a>, the framework calls its <code>to_string()</code> method, which saves the image to a temporary file and returns the file path.</li>
</ol>
<p><b>Scenario 2: Passing an <code>AgentType</code> to a Tool</b></p>
<p>What if an <code>AgentImage</code> object (maybe retrieved from memory or state) needs to be passed <em>into</em> another tool, perhaps one that analyzes images?</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: image_analyzer_tool.py ---</span></div>
<div class="line"><span class="keyword">from</span> smolagents <span class="keyword">import</span> Tool</div>
<div class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</div>
<div class="line"><span class="keyword">from</span> smolagents.agent_types <span class="keyword">import</span> AgentImage, handle_agent_input_types</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ImageAnalyzerTool(Tool):</div>
<div class="line">    name: str = <span class="stringliteral">&quot;image_analyzer&quot;</span></div>
<div class="line">    description: str = <span class="stringliteral">&quot;Analyzes an image and returns its dimensions.&quot;</span></div>
<div class="line">    inputs: dict = {</div>
<div class="line">        <span class="stringliteral">&quot;input_image&quot;</span>: {</div>
<div class="line">            <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;image&quot;</span>, <span class="comment"># Expects an image type</span></div>
<div class="line">            <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;The image to analyze.&quot;</span></div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    output_type: str = <span class="stringliteral">&quot;string&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>forward(self, input_image: Image.Image) -&gt; str:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Analyzes the image.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># IMPORTANT: input_image here is ALREADY the raw PIL.Image object!</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;--- ImageAnalyzerTool received image of type: {type(input_image)} ---&quot;</span>)</div>
<div class="line">        width, height = input_image.size</div>
<div class="line">        <span class="keywordflow">return</span> f<span class="stringliteral">&quot;Image dimensions are {width}x{height}.&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- How the framework uses it (conceptual) ---</span></div>
<div class="line">analyzer_tool = ImageAnalyzerTool()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Let&#39;s pretend &#39;agent_image_object&#39; is an AgentImage retrieved from memory</span></div>
<div class="line"><span class="comment"># (It wraps a red PIL.Image.Image object like the one from Scenario 1)</span></div>
<div class="line">agent_image_object = AgentImage(Image.new(<span class="stringliteral">&#39;RGB&#39;</span>, (60, 30), color = <span class="stringliteral">&#39;red&#39;</span>))</div>
<div class="line">print(f<span class="stringliteral">&quot;Input object type: {type(agent_image_object)}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Framework automatically unwraps the input before calling &#39;forward&#39;</span></div>
<div class="line"><span class="comment"># Uses handle_agent_input_types(input_image=agent_image_object)</span></div>
<div class="line"><span class="comment"># args_tuple, kwargs_dict = handle_agent_input_types(input_image=agent_image_object)</span></div>
<div class="line"><span class="comment"># result = analyzer_tool.forward(**kwargs_dict) # Simplified conceptual call</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Simulate the unwrapping and call:</span></div>
<div class="line">raw_image = agent_image_object.to_raw() <span class="comment"># Get the underlying PIL Image</span></div>
<div class="line">result = analyzer_tool.forward(input_image=raw_image)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Analysis result: {result}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># Input object type: &lt;class &#39;smolagents.agent_types.AgentImage&#39;&gt;</span></div>
<div class="line"><span class="comment"># --- ImageAnalyzerTool received image of type: &lt;class &#39;PIL.Image.Image&#39;&gt; ---</span></div>
<div class="line"><span class="comment"># Analysis result: Image dimensions are 60x30.</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><code>ImageAnalyzerTool</code> defines its input <code>input_image</code> as type <code>"image"</code>. Its <code>forward</code> method expects a standard <code>PIL.Image.Image</code>.</li>
<li>We have an <code>AgentImage</code> object (maybe from a previous step).</li>
<li>When the framework prepares to call <code>analyzer_tool.forward</code>, it sees that the input <code>agent_image_object</code> is an <code>AgentType</code>. It uses <code>handle_agent_input_types</code> (or similar logic) to automatically call the <code>.to_raw()</code> method on <code>agent_image_object</code>.</li>
<li>This <code>to_raw()</code> method extracts the underlying <code>PIL.Image.Image</code> object.</li>
<li>The framework passes this <em>raw</em> image object to the <code>forward</code> method. The tool developer doesn't need to worry about unwrapping the <code>AgentType</code> inside their tool logic.</li>
</ol>
<h2><a class="anchor" id="autotoc_md3176"></a>
Under the Hood: A Peek at the Code</h2>
<p>Let's look at simplified versions of the <code>AgentType</code> classes and helper functions from <code>agent_types.py</code>.</p>
<ul>
<li><p class="startli"><b>Base <code>AgentType</code> Class:</b></p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3177"></a>
&mdash; File: agent_types.py (Simplified AgentType) &mdash;</h1>
<p>import logging logger = logging.getLogger(<b>name</b>)</p>
<p>class AgentType: """Abstract base class for custom agent data types.""" def <b>init</b>(self, value): </p>
<h1><a class="anchor" id="autotoc_md3178"></a>
Stores the actual data (string, PIL Image, etc.)</h1>
<p>self._value = value</p>
<p>def <b>str</b>(self): </p>
<h1><a class="anchor" id="autotoc_md3179"></a>
Default string conversion uses the to_string method</h1>
<p>return self.to_string()</p>
<p>def to_raw(self): """Returns the underlying raw Python object.""" logger.error("to_raw() called on base AgentType!") return self._value</p>
<p>def to_string(self) -&gt; str: """Returns a string representation suitable for logging/memory.""" logger.error("to_string() called on base AgentType!") return str(self._value)</p>
<h1><a class="anchor" id="autotoc_md3180"></a>
Other potential common methods...</h1>
<p>``<code></p><ul>
<li>It holds the original</li>
</ul>
<p></code>_value<code>.</p><ul>
<li>Defines the basic methods</li>
</ul>
<p></code>to_raw<code>and</code>to_string` that subclasses will implement properly.</p>
<ul>
<li><p class="startli"><b><code>AgentImage</code> Implementation:</b></p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3181"></a>
&mdash; File: agent_types.py (Simplified AgentImage) &mdash;</h1>
<p>import PIL.Image import os import tempfile import uuid from io import BytesIO</p>
<p>class AgentImage(AgentType): # Doesn't inherit from PIL.Image directly in reality, but conceptually similar """Handles image data, behaving like a PIL.Image."""</p>
<p>def <b>init</b>(self, value): </p>
<h1><a class="anchor" id="autotoc_md3182"></a>
value can be PIL.Image, path string, bytes, etc.</h1>
<p>AgentType.__init__(self, value) # Store original value form self._raw_image = None # To store the loaded PIL Image self._path = None # To store the path if saved to temp file</p>
<h1><a class="anchor" id="autotoc_md3183"></a>
Logic to load image from different input types (simplified)</h1>
<p>if isinstance(value, PIL.Image.Image): self._raw_image = value elif isinstance(value, (str, os.PathLike)): </p>
<h1><a class="anchor" id="autotoc_md3184"></a>
We might load it lazily later in to_raw()</h1>
<p>self._path = str(value) # Assume it's already a path </p>
<h1><a class="anchor" id="autotoc_md3185"></a>
In reality, it loads here if path exists</h1>
<p>elif isinstance(value, bytes): self._raw_image = PIL.Image.open(BytesIO(value)) </p>
<h1><a class="anchor" id="autotoc_md3186"></a>
... (handle tensors, etc.) ...</h1>
<p>else: raise TypeError(f"Unsupported type for AgentImage: {type(value)}")</p>
<pre class="fragment">    def to_raw(self) -&gt; PIL.Image.Image:
        """Returns the raw PIL.Image.Image object."""
        if self._raw_image is None:
            # Lazy loading if initialized with a path
            if self._path and os.path.exists(self._path):
                self._raw_image = PIL.Image.open(self._path)
            else:
                 # Handle error or create placeholder
                 raise ValueError("Cannot get raw image data.")
        return self._raw_image

    def to_string(self) -&gt; str:
        """Saves image to temp file (if needed) and returns the path."""
        if self._path and os.path.exists(self._path):
            # Already have a path (e.g., loaded from file initially)
            return self._path

        # Need to save the raw image data to a temp file
        raw_img = self.to_raw() # Ensure image is loaded
        directory = tempfile.mkdtemp()
        # Generate a unique filename
        self._path = os.path.join(directory, str(uuid.uuid4()) + ".png")
        raw_img.save(self._path, format="png")
        print(f"--- AgentImage saved to temp file: {self._path} ---")
        return self._path

    def _ipython_display_(self):
        """Special method for display in Jupyter/IPython."""
        from IPython.display import display
        display(self.to_raw()) # Display the raw PIL image

    # We can also make AgentImage behave like PIL.Image by delegating methods
    # (e.g., using __getattr__ or explicit wrappers)
    @property
    def size(self):
         return self.to_raw().size

    def save(self, *args, **kwargs):
         self.to_raw().save(*args, **kwargs)

    # ... other PIL.Image methods ...
```
*   It can be initialized with various image sources (PIL object, path, bytes).
*   `to_raw()` ensures a PIL Image object is returned, loading from disk if necessary.
*   `to_string()` saves the image to a temporary PNG file if it doesn't already have a path, and returns that path.
*   `_ipython_display_` allows Jupyter notebooks to automatically display the image.
*   It can delegate common image methods (like `.size`, `.save`) to the underlying raw image.
</pre><ul>
<li><p class="startli"><b>Helper Functions (Conceptual):</b></p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3187"></a>
&mdash; File: agent_types.py / agents.py (Simplified Helpers) &mdash;</h1>
<h1><a class="anchor" id="autotoc_md3188"></a>
Mapping from type name string to AgentType class</h1>
<p>_AGENT_TYPE_MAPPING = {"string": AgentText, "image": AgentImage, "audio": AgentAudio}</p>
<p>def handle_agent_output_types(output: Any, output_type: Optional[str] = None) -&gt; Any: """Wraps raw output into an AgentType if needed.""" if output_type in _AGENT_TYPE_MAPPING: </p>
<h1><a class="anchor" id="autotoc_md3189"></a>
If the tool explicitly defines output type (e.g., "image")</h1>
<p>wrapper_class = _AGENT_TYPE_MAPPING[output_type] return wrapper_class(output) else: </p>
<h1><a class="anchor" id="autotoc_md3190"></a>
If no type defined, try to guess based on Python type (optional)</h1>
<p>if isinstance(output, str): return AgentText(output) if isinstance(output, PIL.Image.Image): return AgentImage(output) </p>
<h1><a class="anchor" id="autotoc_md3191"></a>
... add checks for audio tensors etc. ...</h1>
<h1><a class="anchor" id="autotoc_md3192"></a>
Otherwise, return the output as is</h1>
<p>return output</p>
<p>def handle_agent_input_types(*args, **kwargs) -&gt; tuple[list, dict]: """Unwraps AgentType inputs into raw types before passing to a tool.""" processed_args = [] for arg in args: </p>
<h1><a class="anchor" id="autotoc_md3193"></a>
If it's an AgentType instance, call to_raw(), otherwise keep as is</h1>
<p>processed_args.append(arg.to_raw() if isinstance(arg, AgentType) else arg)</p>
<p>processed_kwargs = {} for key, value in kwargs.items(): processed_kwargs[key] = value.to_raw() if isinstance(value, AgentType) else value</p>
<p>return tuple(processed_args), processed_kwargs ``<code> *</code>handle_agent_output_types<code>checks the tool's</code>output_type<code>or the actual Python type of the output and wraps it in the corresponding</code>AgentType<code>class (e.g.,</code>AgentImage<code>). *</code>handle_agent_input_types<code>iterates through arguments, checks if any are</code>AgentType<code>instances, and calls</code>.to_raw()<code>on them to get the underlying data before the tool's</code>forward` method is called.</p>
<h2><a class="anchor" id="autotoc_md3194"></a>
Conclusion</h2>
<p><code>AgentType</code> (<code>AgentText</code>, <code>AgentImage</code>, <code>AgentAudio</code>) provides a crucial layer for handling diverse data types within the <code>SmolaAgents</code> framework. They act as specialized containers that ensure non-text data can be consistently processed, displayed correctly (especially in notebooks), and serialized appropriately for logging and memory.</p>
<p>You've learned:</p>
<ul>
<li>Why standard Python types aren't always enough for agent inputs/outputs.</li>
<li>The "specialized shipping container" analogy for <code>AgentType</code>.</li>
<li>The benefits: consistent handling, smart display, and proper serialization (like saving images/audio to temp files).</li>
<li>How the framework automatically wraps tool outputs (<code>handle_agent_output_types</code>) and unwraps tool inputs (<code>handle_agent_input_types</code>).</li>
<li>Seen simplified code examples for <code>AgentImage</code> and the helper functions.</li>
</ul>
<p>By using <code>AgentType</code>, <code>SmolaAgents</code> makes it much easier to build agents that can work seamlessly with multi-modal data like images and audio, without you having to manually handle the complexities of display and serialization in most cases.</p>
<p>Now that we understand how agents handle different data types, how can we keep track of everything the agent is doing, monitor its performance, and debug issues?</p>
<p><b>Next Chapter:</b> <a class="el" href="../../dc/dee/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_208__agentlogger______monitor.html">Chapter 8: AgentLogger &amp; Monitor</a> - Observing Your Agent in Action.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
