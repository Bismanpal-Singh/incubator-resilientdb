#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_ufunc__universal_function_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/def/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_203__ufunc____universal__function__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_ufunc__universal_function_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2501"></a>
autotoc_md2501</h2>
<p>layout: default title: "ufunc (universal function)" parent: "NumPy Core" </p>
<h2><a class="anchor" id="autotoc_md2502"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md2503"></a>
Chapter 3: ufunc (Universal Function)</h1>
<p>Welcome back! In <a class="el" href="../../de/d16/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_201__ndarray____n__dimensional__array__.html">Chapter 1: ndarray (N-dimensional array)</a>, we met the <code>ndarray</code>, NumPy's powerful container for numerical data. In <a class="el" href="../../d6/d31/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_202__dtype____data__type__object__.html">Chapter 2: dtype (Data Type Object)</a>, we learned how <code>dtype</code>s specify the exact <em>kind</em> of data stored within those arrays.</p>
<p>Now, let's tackle a fundamental question: How does NumPy actually <em>perform calculations</em> on these arrays so quickly? If you have two large arrays, <code>a</code> and <code>b</code>, why is <code>a + b</code> massively faster than using a Python <code>for</code> loop? The answer lies in a special type of function: the <b>ufunc</b>.</p>
<h2><a class="anchor" id="autotoc_md2504"></a>
What Problem Do ufuncs Solve? Speeding Up Element-wise Math</h2>
<p>Imagine you have temperature readings from a sensor stored in a NumPy array, and you need to convert them from Celsius to Fahrenheit. The formula is <code>F = C * 9/5 + 32</code>.</p>
<p>With standard Python lists, you'd loop through each temperature:</p>
<div class="fragment"><div class="line"><span class="comment"># Celsius temperatures in a Python list</span></div>
<div class="line">celsius_list = [0.0, 10.0, 20.0, 30.0, 100.0]</div>
<div class="line">fahrenheit_list = []</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Python loop for conversion</span></div>
<div class="line"><span class="keywordflow">for</span> temp_c <span class="keywordflow">in</span> celsius_list:</div>
<div class="line">  temp_f = temp_c * (9/5) + 32</div>
<div class="line">  fahrenheit_list.append(temp_f)</div>
<div class="line"> </div>
<div class="line">print(fahrenheit_list)</div>
<div class="line"><span class="comment"># Output: [32.0, 50.0, 68.0, 86.0, 212.0]</span></div>
</div><!-- fragment --><p> This works, but as we saw in Chapter 1, Python loops are relatively slow, especially for millions of data points.</p>
<p>NumPy offers a much faster way using its <code>ndarray</code> and vectorized operations:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Celsius temperatures in a NumPy array</span></div>
<div class="line">celsius_array = np.array([0.0, 10.0, 20.0, 30.0, 100.0])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># NumPy vectorized conversion - NO explicit Python loop!</span></div>
<div class="line">fahrenheit_array = celsius_array * (9/5) + 32</div>
<div class="line"> </div>
<div class="line">print(fahrenheit_array)</div>
<div class="line"><span class="comment"># Output: [ 32.  50.  68.  86. 212.]</span></div>
</div><!-- fragment --><p> Look how clean that is! We just wrote the math formula directly using the array. But <em>how</em> does NumPy execute <code>*</code>, <code>/</code>, and <code>+</code> so efficiently on <em>every element</em> without a visible loop? This magic is powered by ufuncs.</p>
<h2><a class="anchor" id="autotoc_md2505"></a>
What is a ufunc (Universal Function)?</h2>
<p>A <b>ufunc</b> (Universal Function) is a special type of function in NumPy designed to operate on <code>ndarray</code>s <b>element by element</b>. Think of them as super-powered mathematical functions specifically built for NumPy arrays.</p>
<p>Examples include <code>np.add</code>, <code>np.subtract</code>, <code>np.multiply</code>, <code>np.sin</code>, <code>np.cos</code>, <code>np.exp</code>, <code>np.sqrt</code>, <code>np.maximum</code>, <code>np.equal</code>, and many more.</p>
<p><b>Key Features:</b></p>
<ol type="1">
<li><b>Element-wise Operation:</b> A ufunc applies the same operation independently to each element of the input array(s). When you do <code>np.add(a, b)</code>, it conceptually does <code>result[0] = a[0] + b[0]</code>, <code>result[1] = a[1] + b[1]</code>, and so on for all elements.</li>
<li><b>Speed (Optimized C Loops):</b> This is the secret sauce! Ufuncs don't actually perform the element-wise operation using slow Python loops. Instead, they execute highly optimized, pre-compiled <b>C loops</b> under the hood. This C code can work directly with the raw data buffers of the arrays (remember, ndarrays store data contiguously), making the computations extremely fast.<ul>
<li><b>Analogy:</b> Imagine you need to staple 1000 documents. A Python loop is like picking up the stapler, stapling one document, putting the stapler down, picking it up again, stapling the next... A ufunc is like using an industrial stapling machine that processes the entire stack almost instantly.</li>
</ul>
</li>
<li><b>Broadcasting Support:</b> Ufuncs automatically handle operations between arrays of different, but compatible, shapes. For example, you can add a single number (a scalar) to every element of an array, or add a 1D array to each row of a 2D array. The ufunc "stretches" or "broadcasts" the smaller array to match the shape of the larger one during the calculation. (We won't dive deep into broadcasting rules here, just know that ufuncs enable it).</li>
<li><b>Type Casting:</b> Ufuncs can intelligently handle inputs with different <a class="el" href="../../d6/d31/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_202__dtype____data__type__object__.html">Chapter 2: dtype (Data Type Object)</a>s. For instance, if you add an <code>int32</code> array and a <code>float64</code> array, the ufunc might decide to convert the integers to <code>float64</code> before performing the addition to avoid losing precision, returning a <code>float64</code> array. This happens according to well-defined casting rules.</li>
<li><b>Optional Output Arrays (<code>out</code> argument):</b> You can tell a ufunc to place its result into an <em>existing</em> array instead of creating a new one. This can save memory, especially when working with very large arrays or inside loops.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2506"></a>
Using ufuncs</h2>
<p>You use ufuncs just like regular Python functions, but you pass NumPy arrays as arguments. Many common mathematical operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code>, <code>==</code>, <code>&lt;</code>, etc.) also call ufuncs behind the scenes when used with NumPy arrays.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line">a = np.array([1, 2, 3, 4])</div>
<div class="line">b = np.array([5, 0, 7, 2])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Using the ufunc directly</span></div>
<div class="line">c = np.add(a, b)</div>
<div class="line">print(f<span class="stringliteral">&quot;np.add(a, b)  = {c}&quot;</span>)</div>
<div class="line"><span class="comment"># Output: np.add(a, b)  = [ 6  2 10  6]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Using the corresponding operator (which calls np.add internally)</span></div>
<div class="line">d = a + b</div>
<div class="line">print(f<span class="stringliteral">&quot;a + b         = {d}&quot;</span>)</div>
<div class="line"><span class="comment"># Output: a + b         = [ 6  2 10  6]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Other examples</span></div>
<div class="line">print(f<span class="stringliteral">&quot;np.maximum(a, b) = {np.maximum(a, b)}&quot;</span>) <span class="comment"># Element-wise maximum</span></div>
<div class="line"><span class="comment"># Output: np.maximum(a, b) = [5 2 7 4]</span></div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;np.sin(a)      = {np.sin(a)}&quot;</span>) <span class="comment"># Element-wise sine</span></div>
<div class="line"><span class="comment"># Output: np.sin(a)      = [ 0.84147098  0.90929743  0.14112001 -0.7568025 ]</span></div>
</div><!-- fragment --><p><b>Using the <code>out</code> Argument:</b></p>
<p>Let's pre-allocate an array and tell the ufunc to use it for the result.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line">a = np.arange(5)       <span class="comment"># [0 1 2 3 4]</span></div>
<div class="line">b = np.arange(5, 10)   <span class="comment"># [5 6 7 8 9]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create an empty array with the same shape and type</span></div>
<div class="line">result = np.empty_like(a)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Perform addition, storing the result in the &#39;result&#39; array</span></div>
<div class="line">np.add(a, b, out=result)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;a = {a}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;b = {b}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;result (after np.add(a, b, out=result)) = {result}&quot;</span>)</div>
<div class="line"><span class="comment"># Output:</span></div>
<div class="line"><span class="comment"># a = [0 1 2 3 4]</span></div>
<div class="line"><span class="comment"># b = [5 6 7 8 9]</span></div>
<div class="line"><span class="comment"># result (after np.add(a, b, out=result)) = [ 5  7  9 11 13]</span></div>
</div><!-- fragment --><p> Instead of creating a <em>new</em> array for the sum, <code>np.add</code> placed the values directly into <code>result</code>.</p>
<h2><a class="anchor" id="autotoc_md2507"></a>
A Glimpse Under the Hood</h2>
<p>So, what happens internally when you call, say, <code>np.add(array1, array2)</code>?</p>
<ol type="1">
<li><b>Identify Ufunc:</b> NumPy recognizes <code>np.add</code> as a specific ufunc object. This object holds metadata about the operation (like its name, number of inputs/outputs, identity element if any, etc.).</li>
<li><b>Check Dtypes:</b> NumPy inspects the <code>dtype</code> of <code>array1</code> and <code>array2</code> (e.g., <code>int32</code>, <code>float64</code>). This uses the <code>dtype</code> information we learned about in <a class="el" href="../../d6/d31/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_202__dtype____data__type__object__.html">Chapter 2: dtype (Data Type Object)</a>.</li>
<li><b>Find the Loop:</b> The ufunc object contains an internal table (a list of "loops"). Each loop is a specific, pre-compiled C function designed to handle a particular combination of input/output <code>dtype</code>s (e.g., <code>int32 + int32 -&gt; int32</code>, <code>float32 + float32 -&gt; float32</code>, <code>int32 + float64 -&gt; float64</code>). NumPy searches this table to find the most appropriate C function based on the input dtypes and casting rules. It might need to select a loop that involves converting one or both inputs to a common, safer type (type casting).</li>
<li><b>Check Broadcasting:</b> NumPy checks if the shapes of <code>array1</code> and <code>array2</code> are compatible according to broadcasting rules. If they are compatible but different, it calculates how to "stretch" the smaller array's dimensions virtually.</li>
<li><b>Allocate Output:</b> If the <code>out</code> argument wasn't provided, NumPy allocates a new block of memory for the result array, determining its shape (based on broadcasting) and <code>dtype</code> (based on the chosen loop).</li>
<li><b>Execute C Loop:</b> NumPy calls the selected C function. This function iterates through the elements of the input arrays (using pointers to their raw memory locations, respecting broadcasting rules) and performs the addition, storing the result in the output array's memory. This loop is <em>very</em> fast because it's simple, compiled C code operating on primitive types.</li>
<li><b>Return ndarray:</b> NumPy wraps the output memory block (either the newly allocated one or the one provided via <code>out</code>) into a new Python <code>ndarray</code> object (<a class="el" href="../../de/d16/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_201__ndarray____n__dimensional__array__.html">Chapter 1: ndarray (N-dimensional array)</a>) with the correct <code>shape</code>, <code>dtype</code>, etc., and returns it to your Python code.</li>
</ol>
<p>Here's a simplified sequence diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant P as Python Code</div>
<div class="line">    participant UFunc as np.add (Ufunc Object)</div>
<div class="line">    participant C_API as NumPy C Core (Ufunc Machinery)</div>
<div class="line">    participant C_Loop as Specific C Loop (e.g., int32_add)</div>
<div class="line">    participant Mem as Memory</div>
<div class="line"> </div>
<div class="line">    P-&gt;&gt;UFunc: np.add(arr1, arr2)</div>
<div class="line">    UFunc-&gt;&gt;C_API: Request execution</div>
<div class="line">    C_API-&gt;&gt;C_API: Check dtypes (arr1.dtype, arr2.dtype)</div>
<div class="line">    C_API-&gt;&gt;UFunc: Find appropriate C loop (e.g., int32_add)</div>
<div class="line">    C_API-&gt;&gt;C_API: Check broadcasting rules</div>
<div class="line">    C_API-&gt;&gt;Mem: Allocate memory for result (if no &#39;out&#39;)</div>
<div class="line">    C_API-&gt;&gt;C_Loop: Execute C loop(arr1_data, arr2_data, result_data)</div>
<div class="line">    C_Loop-&gt;&gt;Mem: Read inputs, Compute, Write output</div>
<div class="line">    C_Loop--&gt;&gt;C_API: Signal completion</div>
<div class="line">    C_API-&gt;&gt;Mem: Wrap result memory in ndarray object</div>
<div class="line">    C_API--&gt;&gt;P: Return result ndarray</div>
</div><!-- fragment --><p><b>Where is the Code?</b></p>
<ul>
<li>The ufunc objects themselves are typically defined in C, often generated by helper scripts like <code>numpy/core/code_generators/generate_umath.py</code>. This script reads definitions (like those in the <code>defdict</code> variable within the script) specifying the ufunc's name, inputs, outputs, and the C functions to use for different type combinations. <code>python @section autotoc_md2508 Snippet from generate_umath.py's defdict for 'add' 'add': Ufunc(2, 1, Zero, # nin=2, nout=1, identity=0 docstrings.get('numpy._core.umath.add'), 'PyUFunc_AdditionTypeResolver', # Function for type resolution TD('?', cfunc_alias='logical_or', ...), # Loop for bools TD(no_bool_times_obj, dispatch=[...]), # Loops for numeric types @section autotoc_md2509 ... loops for datetime, object ... indexed=intfltcmplx # Types supporting indexed access ), </code></li>
<li>The Python functions you call (like <code>numpy.add</code>) are often thin wrappers defined in places like <code>numpy/core/umath.py</code> or <code>numpy/core/numeric.py</code>. These Python functions essentially just retrieve the corresponding C ufunc object and trigger its execution mechanism.</li>
<li>The core C machinery for handling ufunc dispatch (finding the right loop), broadcasting, and executing the loops resides within the compiled <code>_multiarray_umath</code> C extension module. We'll touch upon these modules in <a class="el" href="../../db/d8b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_206__multiarray__module.html">Chapter 6: multiarray Module</a> and <a class="el" href="../../d0/db5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_207__umath__module.html">Chapter 7: umath Module</a>.</li>
<li>Helper Python modules like <code>numpy/core/_methods.py</code> provide Python implementations for array methods (like <code>.sum()</code>, <code>.mean()</code>, <code>.max()</code>) which often leverage the underlying ufunc's reduction capabilities.</li>
<li>Error handling during ufunc execution (e.g., division by zero, invalid operations) can be configured using functions like <code>seterr</code> defined in <code>numpy/core/_ufunc_config.py</code>, and specific exception types like <code>UFuncTypeError</code> from <code>numpy/core/_exceptions.py</code> might be raised if things go wrong (e.g., no suitable loop found for the input types).</li>
</ul>
<h2><a class="anchor" id="autotoc_md2510"></a>
Conclusion</h2>
<p>Ufuncs are the powerhouses behind NumPy's speed for element-wise operations. You've learned:</p>
<ul>
<li>They perform operations <b>element by element</b> on arrays.</li>
<li>Their speed comes from executing optimized <b>C loops</b>, avoiding slow Python loops.</li>
<li>They support <b>broadcasting</b> (handling compatible shapes) and <b>type casting</b> (handling different dtypes).</li>
<li>You can use them directly (<code>np.add(a, b)</code>) or often via operators (<code>a + b</code>).</li>
<li>The <code>out</code> argument allows reusing existing arrays, saving memory.</li>
<li>Internally, NumPy finds the right C loop based on input dtypes, handles broadcasting, executes the loop, and returns a new ndarray.</li>
</ul>
<p>Now that we understand how basic element-wise operations work, let's delve deeper into the different kinds of numbers NumPy works with.</p>
<p>Next up: <a class="el" href="../../d4/d1f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_204__numeric__types______numerictypes____.html">Chapter 4: Numeric Types (<code>numerictypes</code>)</a>.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
