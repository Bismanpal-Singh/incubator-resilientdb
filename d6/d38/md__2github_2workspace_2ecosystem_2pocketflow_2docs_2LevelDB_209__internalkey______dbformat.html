#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 09_internalkey___dbformat</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d38/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_209__internalkey______dbformat.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">09_internalkey___dbformat</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2309"></a>
autotoc_md2309</h2>
<p>layout: default title: "InternalKey &amp; DBFormat" parent: "LevelDB" </p>
<h2><a class="anchor" id="autotoc_md2310"></a>
nav_order: 9</h2>
<h1><a class="anchor" id="autotoc_md2311"></a>
Chapter 9: InternalKey &amp; DBFormat - LevelDB's Internal Bookkeeping</h1>
<p>Welcome to the final chapter of our deep dive into LevelDB's core components! In <a class="el" href="../../df/d5d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_208__compaction.html">Chapter 8: Compaction</a>, we saw how LevelDB keeps its storage tidy by merging and rewriting <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">SSTables</a> in the background. This compaction process relies heavily on being able to correctly compare different versions of the same key and discard old or deleted data.</p>
<p>But how does LevelDB know which version of a key is newer? If you write <code>("mykey", "value1")</code> and later <code>("mykey", "value2")</code>, how does LevelDB know that <code>value2</code> is the current one? And how does it handle <code>Delete("mykey")</code>? It can't just erase entries from immutable SSTable files.</p>
<h2><a class="anchor" id="autotoc_md2312"></a>
What's the Problem? Tracking Versions and Deletions</h2>
<p>Imagine a simple library catalog that only lists book titles (user keys) and their shelf locations (user values).</p><ol type="1">
<li>You add "Adventures of Tom Sawyer" on Shelf A. Catalog: <code>("Tom Sawyer", "Shelf A")</code></li>
<li>Later, you move it to Shelf B. If you just add <code>("Tom Sawyer", "Shelf B")</code>, how do you know Shelf A is wrong? The catalog now has two entries!</li>
<li>Later still, you remove the book entirely. How do you mark this in the catalog?</li>
</ol>
<p>Just storing the user's key and value isn't enough. LevelDB needs extra internal bookkeeping information attached to every entry to handle updates, deletions, and also <a class="el" href="../../d8/dd9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_207__iterator.html">Snapshots</a> (reading the database as it was at a specific point in time).</p>
<h2><a class="anchor" id="autotoc_md2313"></a>
The Solution: Sequence Numbers and Value Types</h2>
<p>LevelDB solves this by adding two extra pieces of information to every key-value pair internally:</p>
<ol type="1">
<li><b>Sequence Number:</b> Think of this like a <b>unique version number</b> or a <b>timestamp</b> assigned to every modification. Every time you <code>Put</code> or <code>Delete</code> data (usually as part of a <a class="el" href="../../d1/dce/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_205__writebatch.html">WriteBatch</a>), LevelDB assigns a strictly increasing sequence number to that operation. A higher sequence number means the operation happened more recently. This number increments globally for the entire database.</li>
<li><b>Value Type:</b> This is a simple flag indicating whether an entry represents a <b>value</b> or a <b>deletion</b>.<ul>
<li><code>kTypeValue</code>: Represents a regular key-value pair resulting from a <code>Put</code>.</li>
<li><code>kTypeDeletion</code>: Represents a "tombstone" marker indicating that a key was deleted by a <code>Delete</code> operation.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md2314"></a>
InternalKey: The Full Story</h2>
<p>LevelDB combines the user's key with these two extra pieces of information into a structure called an <b>InternalKey</b>.</p>
<p><b>InternalKey = <code>user_key</code> + <code>sequence_number</code> + <code>value_type</code></b></p>
<p>This <code>InternalKey</code> is what LevelDB <em>actually</em> stores and sorts within the <a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">MemTable</a> and <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">SSTables</a>. When you ask LevelDB for <code>Get("mykey")</code>, it internally searches for <code>InternalKey</code>s associated with <code>"mykey"</code> and uses the sequence numbers and value types to figure out the correct, most recent state.</p>
<h2><a class="anchor" id="autotoc_md2315"></a>
Sorting InternalKeys: The Magic Ingredient</h2>
<p>How <code>InternalKey</code>s are sorted is crucial for LevelDB's efficiency. They are sorted based on the following rules:</p>
<ol type="1">
<li><b>User Key:</b> First, compare the <code>user_key</code> part using the standard comparator you configured for the database (e.g., lexicographical order). Keys <code>apple</code> come before <code>banana</code>.</li>
<li><b>Sequence Number (Descending):</b> If the user keys are the same, compare the <code>sequence_number</code> in <b>DESCENDING</b> order. The entry with the <em>highest</em> sequence number comes <em>first</em>.</li>
<li><b>Value Type (Descending):</b> If user keys and sequence numbers are the same (which shouldn't normally happen for distinct operations), compare the <code>value_type</code> in <b>DESCENDING</b> order (<code>kTypeValue</code> comes before <code>kTypeDeletion</code>).</li>
</ol>
<p><b>Why sort sequence numbers descending?</b> Because when LevelDB looks for a user key, it wants to find the <em>most recent</em> version first. By sorting the highest sequence number first, a simple search or iteration naturally encounters the latest state of the key immediately.</p>
<p><b>Example:</b> Let's revisit our <code>Put</code>/<code>Put</code>/<code>Delete</code> example for <code>mykey</code>:</p><ol type="1">
<li><code>Put("mykey", "v1")</code> -&gt; gets Sequence = 5 -&gt; InternalKey: <code>("mykey", 5, kTypeValue)</code></li>
<li><code>Put("mykey", "v2")</code> -&gt; gets Sequence = 10 -&gt; InternalKey: <code>("mykey", 10, kTypeValue)</code></li>
<li><code>Delete("mykey")</code> -&gt; gets Sequence = 15 -&gt; InternalKey: <code>("mykey", 15, kTypeDeletion)</code></li>
</ol>
<p>When these are sorted according to the rules, the order is:</p><ol type="1">
<li><code>("mykey", 15, kTypeDeletion)</code> (Highest sequence)</li>
<li><code>("mykey", 10, kTypeValue)</code></li>
<li><code>("mykey", 5, kTypeValue)</code> (Lowest sequence)</li>
</ol>
<p>Now, when you call <code>Get("mykey")</code>:</p><ul>
<li>LevelDB searches for entries matching <code>mykey</code>.</li>
<li>It finds <code>("mykey", 15, kTypeDeletion)</code> first because it sorts first.</li>
<li>It sees the <code>kTypeDeletion</code> marker and immediately knows the key is deleted, returning <code>NotFound</code> without even needing to look at the older versions (<code>v2</code> and <code>v1</code>).</li>
</ul>
<p><b>Snapshots:</b> Snapshots work by using a specific sequence number. If you take a snapshot at sequence 12, a <code>Get("mykey")</code> using that snapshot would ignore sequence 15. It would find <code>("mykey", 10, kTypeValue)</code> first, see it's <code>kTypeValue</code> and <code>sequence &lt;= 12</code>, and return <code>"v2"</code>.</p>
<h2><a class="anchor" id="autotoc_md2316"></a>
The <code>dbformat</code> Module: Defining the Rules</h2>
<p>The code that defines the <code>InternalKey</code> structure, the <code>ValueType</code> enum, sequence numbers, helper functions for manipulating them, and crucial constants is located in <code>dbformat.h</code> and <code>dbformat.cc</code>.</p>
<p><b>1. Key Structures and Constants (<code>dbformat.h</code>)</b></p>
<p>This header file defines the core types:</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/dbformat.h ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>leveldb {</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Value types: Deletion or Value</span></div>
<div class="line"><span class="keyword">enum</span> ValueType { kTypeDeletion = 0x0, kTypeValue = 0x1 };</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ValueType used for seeking. (Uses highest type value)</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> ValueType kValueTypeForSeek = kTypeValue;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Type for sequence numbers. 56 bits available.</span></div>
<div class="line"><span class="keyword">typedef</span> uint64_t SequenceNumber;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Max possible sequence number.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> SequenceNumber kMaxSequenceNumber = ((0x1ull &lt;&lt; 56) - 1);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Structure to hold the parsed parts of an InternalKey</span></div>
<div class="line"><span class="keyword">struct </span>ParsedInternalKey {</div>
<div class="line">  Slice user_key;</div>
<div class="line">  SequenceNumber sequence;</div>
<div class="line">  ValueType type;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Constructors... DebugString()...</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Helper class to manage the encoded string representation</span></div>
<div class="line"><span class="keyword">class </span>InternalKey {</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  std::string rep_; <span class="comment">// Holds the encoded key: user_key + seq/type tag</span></div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Constructors... DecodeFrom()... Encode()... user_key()...</span></div>
<div class="line">  InternalKey(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber s, ValueType t);</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... other definitions like LookupKey, InternalKeyComparator ...</span></div>
<div class="line"> </div>
<div class="line">} <span class="comment">// namespace leveldb</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li>Defines <code>ValueType</code> enum (<code>kTypeDeletion</code>, <code>kTypeValue</code>).</li>
<li>Defines <code>SequenceNumber</code> (a 64-bit integer, but only 56 bits are used, leaving 8 bits for the type).</li>
<li><code>ParsedInternalKey</code>: A temporary struct holding the three components separately.</li>
<li><code>InternalKey</code>: A class that usually stores the <em>encoded</em> form (as a single string) for efficiency.</li>
</ul>
<p><b>2. Encoding and Parsing (<code>dbformat.cc</code>, <code>dbformat.h</code>)</b></p>
<p>LevelDB needs to combine the three parts (<code>user_key</code>, <code>sequence</code>, <code>type</code>) into a single <code>Slice</code> (a pointer + length, representing a string) for storage and comparison, and then parse them back out. The sequence and type are packed together into the last 8 bytes of the internal key string.</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/dbformat.h --- (Inline functions)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Combine sequence and type into 8 bytes (64 bits)</span></div>
<div class="line"><span class="keyword">static</span> uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {</div>
<div class="line">  <span class="comment">// seq uses upper 56 bits, type uses lower 8 bits</span></div>
<div class="line">  <span class="keywordflow">return</span> (seq &lt;&lt; 8) | t;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract the user_key part from an encoded internal key</span></div>
<div class="line"><span class="keyword">inline</span> Slice ExtractUserKey(<span class="keyword">const</span> Slice&amp; internal_key) {</div>
<div class="line">  assert(internal_key.size() &gt;= 8);</div>
<div class="line">  <span class="keywordflow">return</span> Slice(internal_key.data(), internal_key.size() - 8); <span class="comment">// All bytes EXCEPT the last 8</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// --- File: db/dbformat.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Append the encoded internal key to a string &#39;result&#39;</span></div>
<div class="line"><span class="keywordtype">void</span> AppendInternalKey(std::string* result, <span class="keyword">const</span> ParsedInternalKey&amp; key) {</div>
<div class="line">  <a class="code hl_variable" href="../../da/d34/namespaceutils_1_1crawl__github__files.html#abaeadc4a603ce2c7230819303321ec90">result</a>-&gt;append(key.user_key.data(), key.user_key.size()); <span class="comment">// Append user key</span></div>
<div class="line">  <span class="comment">// Append the 8-byte packed sequence and type</span></div>
<div class="line">  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Parse an encoded internal key &#39;internal_key&#39; into &#39;result&#39;</span></div>
<div class="line"><span class="keywordtype">bool</span> ParseInternalKey(<span class="keyword">const</span> Slice&amp; internal_key, ParsedInternalKey* result) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">size_t</span> n = internal_key.size();</div>
<div class="line">  <span class="keywordflow">if</span> (n &lt; 8) <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// Must have the 8-byte trailer</span></div>
<div class="line">  <span class="comment">// Decode the 8-byte trailer</span></div>
<div class="line">  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);</div>
<div class="line">  uint8_t c = num &amp; 0xff; <span class="comment">// Lower 8 bits are the type</span></div>
<div class="line">  <a class="code hl_variable" href="../../da/d34/namespaceutils_1_1crawl__github__files.html#abaeadc4a603ce2c7230819303321ec90">result</a>-&gt;sequence = num &gt;&gt; 8; <span class="comment">// Upper 56 bits are sequence</span></div>
<div class="line">  <a class="code hl_variable" href="../../da/d34/namespaceutils_1_1crawl__github__files.html#abaeadc4a603ce2c7230819303321ec90">result</a>-&gt;type = <span class="keyword">static_cast&lt;</span>ValueType<span class="keyword">&gt;</span>(c);</div>
<div class="line">  <a class="code hl_variable" href="../../da/d34/namespaceutils_1_1crawl__github__files.html#abaeadc4a603ce2c7230819303321ec90">result</a>-&gt;user_key = Slice(internal_key.data(), n - 8); <span class="comment">// The rest is user key</span></div>
<div class="line">  <span class="keywordflow">return</span> (c &lt;= <span class="keyword">static_cast&lt;</span>uint8_t<span class="keyword">&gt;</span>(kTypeValue)); <span class="comment">// Basic validation</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceutils_1_1crawl__github__files_html_abaeadc4a603ce2c7230819303321ec90"><div class="ttname"><a href="../../da/d34/namespaceutils_1_1crawl__github__files.html#abaeadc4a603ce2c7230819303321ec90">utils.crawl_github_files.result</a></div><div class="ttdeci">result</div><div class="ttdef"><b>Definition</b> <a href="../../d8/dd7/crawl__github__files_8py_source.html#l00357">crawl_github_files.py:357</a></div></div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li><code>PackSequenceAndType</code>: Shifts the sequence number left by 8 bits and combines it with the 1-byte type.</li>
<li><code>AppendInternalKey</code>: Builds the string representation: user key bytes followed by the 8-byte packed sequence/type.</li>
<li><code>ExtractUserKey</code>: Returns a slice pointing to the user key portion (all but the last 8 bytes).</li>
<li><code>ParseInternalKey</code>: Does the reverse of <code>AppendInternalKey</code>, extracting the parts from the encoded slice.</li>
</ul>
<p><b>3. Comparing Internal Keys (<code>dbformat.cc</code>)</b></p>
<p>The <code>InternalKeyComparator</code> uses the user-provided comparator for the user keys and then implements the descending sequence number logic.</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/dbformat.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> InternalKeyComparator::Compare(<span class="keyword">const</span> Slice&amp; akey, <span class="keyword">const</span> Slice&amp; bkey)<span class="keyword"> const </span>{</div>
<div class="line">  <span class="comment">// 1. Compare user keys using the user&#39;s comparator</span></div>
<div class="line">  <span class="keywordtype">int</span> r = user_comparator_-&gt;Compare(ExtractUserKey(akey), ExtractUserKey(bkey));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (r == 0) {</div>
<div class="line">    <span class="comment">// User keys are equal, compare sequence numbers (descending)</span></div>
<div class="line">    <span class="comment">// Decode the 8-byte tag (seq+type) from the end of each key</span></div>
<div class="line">    <span class="keyword">const</span> uint64_t anum = DecodeFixed64(akey.data() + akey.size() - 8);</div>
<div class="line">    <span class="keyword">const</span> uint64_t bnum = DecodeFixed64(bkey.data() + bkey.size() - 8);</div>
<div class="line">    <span class="comment">// Higher sequence number should come first (negative result)</span></div>
<div class="line">    <span class="keywordflow">if</span> (anum &gt; bnum) {</div>
<div class="line">      r = -1;</div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (anum &lt; bnum) {</div>
<div class="line">      r = +1;</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// If sequence numbers are also equal, type decides (descending,</span></div>
<div class="line">    <span class="comment">// but packed value comparison handles this implicitly).</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> r;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b> This function first compares user keys. If they differ, that result is returned. If they are the same, it decodes the 8-byte tag from both keys and compares them. Since a higher sequence number results in a larger packed <code>uint64_t</code> value, comparing <code>anum</code> and <code>bnum</code> directly and flipping the sign (<code>-1</code> if <code>anum &gt; bnum</code>, <code>+1</code> if <code>anum &lt; bnum</code>) achieves the desired descending order for sequence numbers.</p>
<p><b>4. Seeking with LookupKey (<code>dbformat.h</code>, <code>dbformat.cc</code>)</b></p>
<p>When you call <code>Seek(target_key)</code> on an iterator, LevelDB needs to find the internal key representing the latest version of <code>target_key</code> at or before the iterator's snapshot sequence number. Directly seeking using an internal key <code>(target_key, snapshot_seq, kTypeValue)</code> might overshoot, landing on an entry <em>newer</em> than the snapshot.</p>
<p><code>LookupKey</code> creates a specially formatted key for seeking in MemTables and internal iterators.</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/dbformat.h ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// A helper class useful for DBImpl::Get() and Iterator::Seek()</span></div>
<div class="line"><span class="keyword">class </span>LookupKey {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="comment">// Create a key for looking up user_key at snapshot &#39;sequence&#39;.</span></div>
<div class="line">  LookupKey(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber sequence);</div>
<div class="line">  ~LookupKey();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Key for MemTable lookup (includes length prefix for internal key)</span></div>
<div class="line">  Slice memtable_key() <span class="keyword">const</span>;</div>
<div class="line">  <span class="comment">// Key for Internal Iterator lookup (user_key + seq/type tag)</span></div>
<div class="line">  Slice internal_key() <span class="keyword">const</span>;</div>
<div class="line">  <span class="comment">// User key part</span></div>
<div class="line">  Slice user_key() <span class="keyword">const</span>;</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* start_; <span class="comment">// Beginning of allocated buffer</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* kstart_; <span class="comment">// Beginning of user_key portion</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* end_;   <span class="comment">// End of allocated buffer</span></div>
<div class="line">  <span class="keywordtype">char</span> space_[200]; <span class="comment">// Avoid heap allocation for short keys</span></div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// --- File: db/dbformat.cc --- (Simplified Constructor Logic)</span></div>
<div class="line"> </div>
<div class="line">LookupKey::LookupKey(<span class="keyword">const</span> Slice&amp; user_key, SequenceNumber s) {</div>
<div class="line">  <span class="keywordtype">size_t</span> usize = user_key.size();</div>
<div class="line">  <span class="comment">// Need space for: internal key length, user key, 8-byte tag</span></div>
<div class="line">  <span class="keywordtype">size_t</span> needed = VarintLength(usize + 8) + usize + 8;</div>
<div class="line">  <span class="keywordtype">char</span>* dst = <span class="comment">/* ... allocate space_ or new char[] ... */</span> ;</div>
<div class="line"> </div>
<div class="line">  start_ = dst;</div>
<div class="line">  <span class="comment">// Encode length of internal key (user_key size + 8)</span></div>
<div class="line">  dst = EncodeVarint32(dst, usize + 8);</div>
<div class="line">  kstart_ = dst; <span class="comment">// Mark start of internal key part</span></div>
<div class="line">  <span class="comment">// Copy user key data</span></div>
<div class="line">  std::memcpy(dst, user_key.data(), usize);</div>
<div class="line">  dst += usize;</div>
<div class="line">  <span class="comment">// Encode the 8-byte tag: Use the target sequence &#39;s&#39; BUT use</span></div>
<div class="line">  <span class="comment">// kValueTypeForSeek (which is kTypeValue, the highest type value).</span></div>
<div class="line">  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));</div>
<div class="line">  dst += 8;</div>
<div class="line">  end_ = dst; <span class="comment">// Mark end of buffer</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p><ul>
<li>A <code>LookupKey</code> bundles the <code>user_key</code> with the target <code>sequence</code> number.</li>
<li>Critically, when creating the 8-byte tag, it uses <code>kValueTypeForSeek</code>. Because internal keys are sorted by user key, then <em>descending</em> sequence, then <em>descending</em> type, seeking for <code>(user_key, sequence, kValueTypeForSeek)</code> ensures we find the <em>first</em> entry whose user key matches and whose sequence number is less than or equal to the target <code>sequence</code>. This correctly handles the descending sort order during seeks.</li>
</ul>
<p><b>5. Configuration Constants (<code>dbformat.h</code>)</b></p>
<p><code>dbformat.h</code> also defines key constants that control LevelDB's behavior, especially related to compaction triggers:</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/dbformat.h ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>config {</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kNumLevels = 7; <span class="comment">// Number of levels in the LSM tree</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Level-0 compaction is started when we hit this many files.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kL0_CompactionTrigger = 4;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Soft limit on number of level-0 files. We slow down writes at this point.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kL0_SlowdownWritesTrigger = 8;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Maximum number of level-0 files. We stop writes at this point.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kL0_StopWritesTrigger = 12;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Maximum level to push a new memtable compaction to if it doesn&#39;t overlap.</span></div>
<div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">int</span> kMaxMemCompactLevel = 2;</div>
<div class="line"><span class="comment">// ... other constants ...</span></div>
<div class="line">} <span class="comment">// namespace config</span></div>
</div><!-- fragment --><p><b>Explanation:</b> These constants define parameters like the number of levels and the file count thresholds in Level-0 that trigger compactions or slow down/stop writes. They are part of the database "format" because changing them affects performance and behavior.</p>
<p><b>Internal Key Structure Diagram</b></p>
<div class="fragment"><div class="line">graph TB</div>
<div class="line">    A[User Application] --&gt; |&quot;Put(&#39;key&#39;, &#39;value&#39;)&quot;| B(LevelDB)</div>
<div class="line">    B --&gt; |&quot;Assigns Seq=10&quot;| C{Internal Operation}</div>
<div class="line">    C --&gt; |&quot;Creates&quot;| D[InternalKey String]</div>
<div class="line">    </div>
<div class="line">    D --&gt; I{Storage}</div>
<div class="line">    </div>
<div class="line">    subgraph &quot;Key Components&quot;</div>
<div class="line">    D --- E[&quot;InternalKey Structure&quot;]</div>
<div class="line">    E --&gt; E1[&quot;User Key&quot;]</div>
<div class="line">    E --&gt; E2[&quot;8-byte Tag&quot;]</div>
<div class="line">    E2 --&gt; G[&quot;Seq # (56 bits)&quot;]</div>
<div class="line">    E2 --&gt; H[&quot;Type (8 bits)&quot;]</div>
<div class="line">    end</div>
<div class="line">    </div>
<div class="line">    subgraph &quot;Sort Order&quot;</div>
<div class="line">    I --&gt; J[&quot;By User Key&quot;]</div>
<div class="line">    J --&gt; K[&quot;By Sequence DESC&quot;]</div>
<div class="line">    K --&gt; L[&quot;By Type DESC&quot;]</div>
<div class="line">    end</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2317"></a>
Conclusion</h2>
<p>LevelDB doesn't just store your raw keys and values. It enhances them internally by adding a <b>sequence number</b> (like a version timestamp) and a <b>value type</b> (Value or Deletion). This combined structure, the <b>InternalKey</b>, is what LevelDB actually sorts and stores in its MemTables and SSTables.</p>
<p>The specific way InternalKeys are sorted (user key ascending, sequence number descending) is critical for efficiently finding the latest version of a key and handling deletions and snapshots correctly. The <code>dbformat</code> module (<code>dbformat.h</code>, <code>dbformat.cc</code>) defines these internal structures, their encoding/decoding rules, the comparison logic (<code>InternalKeyComparator</code>), the special <code>LookupKey</code> for seeks, and other important constants related to the database's structure and behavior.</p>
<p>Understanding <code>InternalKey</code> and <code>dbformat</code> reveals the clever bookkeeping that allows LevelDB's Log-Structured Merge-Tree design to function correctly and efficiently. This chapter concludes our tour of the fundamental building blocks of LevelDB!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
