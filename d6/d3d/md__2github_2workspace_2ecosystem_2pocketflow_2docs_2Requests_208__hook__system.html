#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 08_hook_system</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/d3d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_208__hook__system.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">08_hook_system</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2963"></a>
autotoc_md2963</h2>
<p>layout: default title: "Hook System" parent: "Requests" </p>
<h2><a class="anchor" id="autotoc_md2964"></a>
nav_order: 8</h2>
<h1><a class="anchor" id="autotoc_md2965"></a>
Chapter 8: The Hook System - Setting Up Checkpoints</h1>
<p>In <a class="el" href="../../d5/d83/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_207__transport__adapters.html">Chapter 7: Transport Adapters</a>, we saw how to customize the low-level details of <em>how</em> requests are sent and connections are managed, like setting custom retry strategies. Transport Adapters give you control over the delivery mechanism itself.</p>
<p>But what if you don't need to change <em>how</em> the request is sent, but instead want to simply <b>react</b> when something happens during the process? For example, maybe you want to log every single response your application receives, or perhaps automatically add a timestamp to every request header just before it goes out (though this specific header example isn't currently supported by the default hooks).</p>
<h2><a class="anchor" id="autotoc_md2966"></a>
The Problem: Reacting to Events</h2>
<p>Imagine you're building an application that interacts with several different web services. For debugging or monitoring purposes, you want to keep a record of every response you get back â€“ specifically, the URL you requested and the status code the server returned.</p>
<p>You could manually add <code>print()</code> statements after every single <code>requests.get()</code>, <code>s.post()</code>, etc., call throughout your code:</p>
<div class="fragment"><div class="line"><span class="comment"># Manual logging (Repetitive!)</span></div>
<div class="line">response1 = s.get(<span class="stringliteral">&#39;https://api.service1.com/data&#39;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;LOG: Got {response1.status_code} for {response1.url}&quot;</span>)</div>
<div class="line"><span class="comment"># ... process response1 ...</span></div>
<div class="line"> </div>
<div class="line">response2 = s.post(<span class="stringliteral">&#39;https://api.service2.com/action&#39;</span>, data={<span class="stringliteral">&#39;key&#39;</span>: <span class="stringliteral">&#39;value&#39;</span>})</div>
<div class="line">print(f<span class="stringliteral">&quot;LOG: Got {response2.status_code} for {response2.url}&quot;</span>)</div>
<div class="line"><span class="comment"># ... process response2 ...</span></div>
<div class="line"> </div>
<div class="line">response3 = s.get(<span class="stringliteral">&#39;https://api.service1.com/status&#39;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;LOG: Got {response3.status_code} for {response3.url}&quot;</span>)</div>
<div class="line"><span class="comment"># ... process response3 ...</span></div>
</div><!-- fragment --><p>This quickly becomes tedious and error-prone. If you forget to add the logging line, you miss that record. If you want to change the log format, you have to change it everywhere. Isn't there a way to tell <code>requests</code> to automatically run your logging code <em>every time</em> it gets a response?</p>
<h2><a class="anchor" id="autotoc_md2967"></a>
Meet the Hook System: Your Automated Checkpoints</h2>
<p>Yes, there is! <code>Requests</code> provides a <b>Hook System</b> that lets you do just that.</p>
<p>Think of hooks like setting up <b>checkpoints</b> in the process of making a request and getting a response. When the process reaches a specific checkpoint, <code>requests</code> pauses briefly and calls any custom functions you've registered for that checkpoint.</p>
<p><b>Analogy: Package Delivery Checkpoints</b> ðŸ“¦</p>
<p>Imagine a package delivery process:</p><ol type="1">
<li>Package picked up.</li>
<li>Package arrives at sorting facility. -&gt; <b>Checkpoint!</b> (Maybe run a function to scan the barcode).</li>
<li>Package loaded onto delivery truck.</li>
<li>Package delivered to recipient. -&gt; <b>Checkpoint!</b> (Maybe run a function to get a signature).</li>
</ol>
<p>The Hook System in <code>requests</code> works similarly. You can attach your own Python functions (called "hooks") to specific events (checkpoints).</p>
<p>Currently, the main event available is the <b><code>response</code></b> hook.</p><ul>
<li><b><code>response</code> Hook:</b> This hook runs <em>after</em> a response has been received from the server and the basic <code>Response</code> object has been built, but <em>before</em> that <code>Response</code> object is returned to your code that called <code>requests.get()</code> or <code>s.post()</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2968"></a>
Using the <code>response</code> Hook</h2>
<p>Let's solve our logging problem using the <code>response</code> hook.</p>
<p><b>Step 1: Define the Hook Function</b></p>
<p>First, we need to write a Python function that will perform our logging action. This function needs to accept the <code>Response</code> object as its first argument. It can also accept optional keyword arguments (<code>**kwargs</code>), which <code>requests</code> might pass in (though for the <code>response</code> hook, the <code>Response</code> object is the main thing).</p>
<div class="fragment"><div class="line"><span class="comment"># Our custom hook function for logging</span></div>
<div class="line"><span class="keyword">def </span>log_response_details(response, *args, **kwargs):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    This function will be called after each response.</span></div>
<div class="line"><span class="stringliteral">    It logs the request method, URL, and response status code.</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    <span class="comment"># &#39;response&#39; is the Response object just received</span></div>
<div class="line">    request_method = response.request.method <span class="comment"># Get the method from the original request</span></div>
<div class="line">    url = response.url                     <span class="comment"># Get the final URL</span></div>
<div class="line">    status_code = response.status_code       <span class="comment"># Get the status code</span></div>
<div class="line"> </div>
<div class="line">    print(f<span class="stringliteral">&quot;HOOK LOG: Received {status_code} for {request_method} request to {url}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># IMPORTANT: Hooks usually shouldn&#39;t return anything (or return None).</span></div>
<div class="line">    <span class="comment"># If a hook returns a value, it REPLACES the data being processed.</span></div>
<div class="line">    <span class="comment"># For the &#39;response&#39; hook, returning a value would replace the Response object!</span></div>
<div class="line">    <span class="comment"># Since we just want to log, we don&#39;t return anything.</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>The function <code>log_response_details</code> takes <code>response</code> as its first argument. This will be the <code>requests.Response</code> object.</li>
<li>It also accepts <code>*args</code> and <code>**kwargs</code> to be flexible, even though we don't use them here.</li>
<li>Inside the function, we access attributes of the <code>response</code> object (like <code>status_code</code>, <code>url</code>) and its associated request (<code>response.request.method</code>) to print our log message.</li>
<li>Crucially, this function <em>doesn't return anything</em>. If it did return a value, that value would replace the original <code>response</code> object for any further processing or for the final return value of <code>s.get()</code>.</li>
</ul>
<p><b>Step 2: Register the Hook</b></p>
<p>Now we need to tell <code>requests</code> to actually <em>use</em> our <code>log_response_details</code> function. We can register hooks in two main ways:</p>
<ol type="1">
<li><b>On a <code>Session</code> Object:</b> If you register a hook on a <a class="el" href="../../dd/d2f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_203__session.html">Session</a> object, it will be called for <em>every request</em> made using that session. This is perfect for our logging use case.</li>
<li><b>On a Single <code>Request</code>:</b> You can also attach hooks to an individual <code>Request</code> object before preparing it. This is less common but useful if you only want a hook to run for one specific request.</li>
</ol>
<p>Let's register our hook on a <code>Session</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> requests</div>
<div class="line"> </div>
<div class="line"><span class="comment"># (Paste the log_response_details function definition from above here)</span></div>
<div class="line"><span class="keyword">def </span>log_response_details(response, *args, **kwargs):</div>
<div class="line">    request_method = response.request.method</div>
<div class="line">    url = response.url</div>
<div class="line">    status_code = response.status_code</div>
<div class="line">    print(f<span class="stringliteral">&quot;HOOK LOG: Received {status_code} for {request_method} request to {url}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a Session</span></div>
<div class="line">s = requests.Session()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Register the hook on the session</span></div>
<div class="line"><span class="comment"># Hooks are stored in a dictionary: session.hooks = {&#39;event_name&#39;: [list_of_functions]}</span></div>
<div class="line"><span class="comment"># We add our function to the list for the &#39;response&#39; event.</span></div>
<div class="line">s.hooks[<span class="stringliteral">&#39;response&#39;</span>].append(log_response_details)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Now, make some requests using the session</span></div>
<div class="line">print(<span class="stringliteral">&quot;Making requests...&quot;</span>)</div>
<div class="line">response1 = s.get(<span class="stringliteral">&#39;https://httpbin.org/get&#39;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;  -&gt; Main code received response 1 with status: {response1.status_code}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">response2 = s.post(<span class="stringliteral">&#39;https://httpbin.org/post&#39;</span>, data={<span class="stringliteral">&#39;id&#39;</span>: <span class="stringliteral">&#39;123&#39;</span>})</div>
<div class="line">print(f<span class="stringliteral">&quot;  -&gt; Main code received response 2 with status: {response2.status_code}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">response3 = s.get(<span class="stringliteral">&#39;https://httpbin.org/status/404&#39;</span>) <span class="comment"># This will get a 404</span></div>
<div class="line">print(f<span class="stringliteral">&quot;  -&gt; Main code received response 3 with status: {response3.status_code}&quot;</span>)</div>
</div><!-- fragment --><p><b>Expected Output:</b></p>
<div class="fragment"><div class="line">Making requests...</div>
<div class="line">HOOK LOG: Received 200 for GET request to https://httpbin.org/get</div>
<div class="line">  -&gt; Main code received response 1 with status: 200</div>
<div class="line">HOOK LOG: Received 200 for POST request to https://httpbin.org/post</div>
<div class="line">  -&gt; Main code received response 2 with status: 200</div>
<div class="line">HOOK LOG: Received 404 for GET request to https://httpbin.org/status/404</div>
<div class="line">  -&gt; Main code received response 3 with status: 404</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><code>s = requests.Session()</code>: We created a session.</li>
<li>&lsquo;s.hooks['response&rsquo;].append(log_response_details)<code>: This is the key step.</code>s.hooks<code>is a dictionary where keys are event names (like</code>'response'<code>) and values are lists of functions to call for that event. We appended our logging function to the list for the</code>'response'<code>event.</code></li>
<li><code> When we called</code>s.get(...)<code>or</code>s.post(...)<code>, the following happened internally:<ul>
<li>The request was sent.</li>
<li>The response was received.</li>
<li>*Before* returning the response to our main code (</li>
</ul>
</code>response1 = ...<code>), the</code>requests<code>Session checked its</code>hooks<code>dictionary for the</code>'response'<code>event.<ul>
<li>It found our</li>
</ul>
</code>log_response_details<code>function and called it, passing the received</code>Response<code>object.<ul>
<li>Our hook function printed the log message.</li>
<li>Since the hook returned</li>
</ul>
</code>None<code>, the original</code>Response` object was then returned to our main code.</li>
<li>Notice how the "HOOK LOG" lines appear <em>before</em> the "Main code received response" lines, demonstrating that the hook runs after receiving the response but before the calling code gets it.</li>
</ol>
<p><b>Modifying the Response (Advanced)</b></p>
<p>While our logging hook didn't return anything, a hook <em>can</em> modify the <code>Response</code> object it receives, or even return a completely different <code>Response</code> object.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>add_custom_header_hook(response, *args, **kwargs):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Adds a custom header to the received response.&quot;&quot;&quot;</span></div>
<div class="line">    print(<span class="stringliteral">&quot;HOOK: Adding X-Hook-Processed header...&quot;</span>)</div>
<div class="line">    response.headers[<span class="stringliteral">&#39;X-Hook-Processed&#39;</span>] = <span class="stringliteral">&#39;True&#39;</span></div>
<div class="line">    <span class="comment"># We modified the response in-place, so we return None</span></div>
<div class="line">    <span class="comment"># to let requests continue using the modified response.</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Or, a hook that returns a *new* response (less common)</span></div>
<div class="line"><span class="comment"># def replace_response_hook(response, *args, **kwargs):</span></div>
<div class="line"><span class="comment">#     if response.status_code == 404:</span></div>
<div class="line"><span class="comment">#         print(&quot;HOOK: Replacing 404 response with a custom one!&quot;)</span></div>
<div class="line"><span class="comment">#         new_response = requests.Response()</span></div>
<div class="line"><span class="comment">#         new_response.status_code = 200</span></div>
<div class="line"><span class="comment">#         new_response.reason = &quot;Found via Hook&quot;</span></div>
<div class="line"><span class="comment">#         new_response._content = b&quot;Content generated by hook!&quot;</span></div>
<div class="line"><span class="comment">#         new_response.request = response.request # Keep original request link</span></div>
<div class="line"><span class="comment">#         return new_response # Return the NEW response</span></div>
<div class="line"><span class="comment">#     return None # Otherwise, keep the original response</span></div>
</div><!-- fragment --><p><b>Caution:</b> Modifying or replacing responses within hooks can be powerful but also confusing if not done carefully. For beginners, using hooks for actions like logging or metrics that don't change the response is often the safest starting point.</p>
<h2><a class="anchor" id="autotoc_md2969"></a>
How It Works Internally</h2>
<p>Where exactly does <code>requests</code> call these hooks? The <code>response</code> hook is triggered within the <code>Session.send()</code> method, after the underlying <a class="el" href="../../d5/d83/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_207__transport__adapters.html">Transport Adapter</a> has returned a response, but before things like cookie persistence and redirect handling are fully completed for that specific response.</p>
<ol type="1">
<li><b><code>Session.send()</code> Called:</b> Your code calls <code>s.get()</code> or <code>s.post()</code>, which eventually calls <code>Session.send()</code>.</li>
<li><b>Adapter Sends Request:</b> The session selects the appropriate <a class="el" href="../../d5/d83/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_207__transport__adapters.html">Transport Adapter</a> (e.g., <code>HTTPAdapter</code>). The adapter sends the request and receives the raw response (<code>r = adapter.send(...)</code>).</li>
<li><b>Dispatch Hook:</b> Right after the adapter returns the <code>Response</code> object <code>r</code>, <code>Session.send()</code> calls <code>dispatch_hook("response", hooks, r, **kwargs)</code>. <code>hooks</code> here refers to the merged hooks from the <code>Request</code> and the <code>Session</code>.</li>
<li><b><code>dispatch_hook()</code> Executes:</b> This helper function (from <code>requests.hooks</code>) looks up the list of functions registered for the <code>"response"</code> event. It iterates through this list, calling each hook function (like our <code>log_response_details</code>) one by one, passing the <code>Response</code> object (<code>r</code>) to it.</li>
<li><b>Hook Modifies/Replaces (Optional):</b> If a hook function returns a value, <code>dispatch_hook</code> updates <code>r</code> to be that new value. This allows hooks later in the list (or the main code) to see the modified response.</li>
<li><b>Further Processing:</b> After <code>dispatch_hook</code> returns the (potentially modified) <code>Response</code> object <code>r</code>, <code>Session.send()</code> continues with other tasks like extracting cookies from <code>r</code> into the session's jar and handling redirects (which might involve sending another request).</li>
<li><b>Return Response:</b> Finally, the <code>Response</code> object is returned to your original calling code.</li>
</ol>
<p>Here's a simplified sequence diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant UserCode as Your Code</div>
<div class="line">    participant Session as Session Object</div>
<div class="line">    participant Adapter as Transport Adapter</div>
<div class="line">    participant Hooks as dispatch_hook()</div>
<div class="line"> </div>
<div class="line">    UserCode-&gt;&gt;Session: s.get(url) / s.post(url)</div>
<div class="line">    Session-&gt;&gt;Session: Calls prepare_request()</div>
<div class="line">    Session-&gt;&gt;Session: Gets adapter based on URL</div>
<div class="line">    Session-&gt;&gt;Adapter: adapter.send(request)</div>
<div class="line">    activate Adapter</div>
<div class="line">    Note over Adapter: Sends request, gets raw response</div>
<div class="line">    Adapter-&gt;&gt;Adapter: build_response() -&gt; Response &#39;r&#39;</div>
<div class="line">    Adapter--&gt;&gt;Session: Return Response &#39;r&#39;</div>
<div class="line">    deactivate Adapter</div>
<div class="line"> </div>
<div class="line">    Note over Session: Merges request and session hooks</div>
<div class="line">    Session-&gt;&gt;Hooks: dispatch_hook(&#39;response&#39;, merged_hooks, r)</div>
<div class="line">    activate Hooks</div>
<div class="line">    Note over Hooks: Iterates through registered hook functions</div>
<div class="line">    Hooks-&gt;&gt;Hooks: Call each hook_function(r)</div>
<div class="line">    Note over Hooks: Hook might modify &#39;r&#39; or return a new one</div>
<div class="line">    Hooks--&gt;&gt;Session: Return (potentially modified) Response &#39;r&#39;</div>
<div class="line">    deactivate Hooks</div>
<div class="line"> </div>
<div class="line">    Note over Session: Persist cookies from &#39;r&#39;, handle redirects...</div>
<div class="line">    Session--&gt;&gt;UserCode: Return final Response &#39;r&#39;</div>
</div><!-- fragment --><p>Let's look at the key code pieces:</p>
<div class="fragment"><div class="line"><span class="comment"># File: requests/hooks.py (Simplified)</span></div>
<div class="line"> </div>
<div class="line">HOOKS = [<span class="stringliteral">&quot;response&quot;</span>] <span class="comment"># Currently, only &#39;response&#39; is actively used</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>default_hooks():</div>
<div class="line">    <span class="comment"># Creates the initial empty structure for hooks</span></div>
<div class="line">    <span class="keywordflow">return</span> {event: [] <span class="keywordflow">for</span> event <span class="keywordflow">in</span> HOOKS}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>dispatch_hook(key, hooks, hook_data, **kwargs):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Dispatches hooks for a given key event.&quot;&quot;&quot;</span></div>
<div class="line">    hooks = hooks <span class="keywordflow">or</span> {} <span class="comment"># Ensure hooks is a dict</span></div>
<div class="line">    hooks = hooks.get(key) <span class="comment"># Get the list of functions for this event key</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> hooks:</div>
<div class="line">        <span class="comment"># Allow a single callable or a list</span></div>
<div class="line">        <span class="keywordflow">if</span> hasattr(hooks, <span class="stringliteral">&quot;__call__&quot;</span>):</div>
<div class="line">            hooks = [hooks]</div>
<div class="line">        <span class="comment"># Call each registered hook function</span></div>
<div class="line">        <span class="keywordflow">for</span> hook <span class="keywordflow">in</span> hooks:</div>
<div class="line">            _hook_data = hook(hook_data, **kwargs) <span class="comment"># Call the user&#39;s function</span></div>
<div class="line">            <span class="keywordflow">if</span> _hook_data <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line">                <span class="comment"># If the hook returned something, update the data</span></div>
<div class="line">                hook_data = _hook_data</div>
<div class="line">    <span class="keywordflow">return</span> hook_data <span class="comment"># Return the (potentially modified) data</span></div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># File: requests/sessions.py (Simplified view of Session.send)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> .hooks <span class="keyword">import</span> dispatch_hook <span class="comment"># Import the dispatcher</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Session:</div>
<div class="line">    <span class="comment"># ... (other methods: __init__, request, prepare_request, get_adapter) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>send(self, request, **kwargs):</div>
<div class="line">        <span class="comment"># ... (setup: kwargs, get adapter) ...</span></div>
<div class="line"> </div>
<div class="line">        adapter = self.get_adapter(url=request.url)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># === ADAPTER SENDS THE REQUEST ===</span></div>
<div class="line">        r = adapter.send(request, **kwargs) <span class="comment"># Gets the Response object &#39;r&#39;</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># ... (calculate elapsed time) ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># === DISPATCH THE &#39;RESPONSE&#39; HOOK ===</span></div>
<div class="line">        <span class="comment"># request.hooks contains merged hooks from Request and Session</span></div>
<div class="line">        r = dispatch_hook(<span class="stringliteral">&quot;response&quot;</span>, request.hooks, r, **kwargs)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># === CONTINUE PROCESSING ===</span></div>
<div class="line">        <span class="comment"># Persist cookies from the (potentially modified) response &#39;r&#39;</span></div>
<div class="line">        extract_cookies_to_jar(self.cookies, request, r.raw)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Handle redirects if allowed (using the potentially modified &#39;r&#39;)</span></div>
<div class="line">        <span class="keywordflow">if</span> kwargs.get(<span class="stringliteral">&#39;allow_redirects&#39;</span>, <span class="keyword">True</span>):</div>
<div class="line">            <span class="comment"># ... redirect logic using self.resolve_redirects ...</span></div>
<div class="line">            <span class="comment"># This might modify &#39;r&#39; further if redirects occur</span></div>
<div class="line">            <span class="keywordflow">pass</span></div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            <span class="comment"># ... store potential next request for non-redirected responses ...</span></div>
<div class="line">            <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># ... (maybe consume content if stream=False) ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> r <span class="comment"># Return the final Response object</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># File: requests/models.py (Simplified view of PreparedRequest)</span></div>
<div class="line"><span class="comment"># Shows where hooks are stored initially</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>RequestHooksMixin:</div>
<div class="line">    <span class="comment"># Mixin used by Request and PreparedRequest</span></div>
<div class="line">    <span class="keyword">def </span>register_hook(self, event, hook):</div>
<div class="line">        <span class="comment"># ... logic to add hook functions to self.hooks[event] list ...</span></div>
<div class="line">        <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Request(RequestHooksMixin):</div>
<div class="line">    <span class="keyword">def </span>__init__(self, ..., hooks=None):</div>
<div class="line">        <span class="comment"># ...</span></div>
<div class="line">        self.hooks = default_hooks() <span class="comment"># Initialize hooks dict</span></div>
<div class="line">        <span class="keywordflow">if</span> hooks:</div>
<div class="line">            <span class="keywordflow">for</span> k, v <span class="keywordflow">in</span> list(hooks.items()):</div>
<div class="line">                self.register_hook(event=k, hook=v) <span class="comment"># Register hooks passed in</span></div>
<div class="line">        <span class="comment"># ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>PreparedRequest(..., RequestHooksMixin):</div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        <span class="comment"># ...</span></div>
<div class="line">        self.hooks = default_hooks() <span class="comment"># Hooks are also on PreparedRequest</span></div>
<div class="line">        <span class="comment"># ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>prepare_hooks(self, hooks):</div>
<div class="line">        <span class="comment"># Called during prepare() to merge hooks from the original Request</span></div>
<div class="line">        hooks = hooks <span class="keywordflow">or</span> []</div>
<div class="line">        <span class="keywordflow">for</span> event <span class="keywordflow">in</span> hooks:</div>
<div class="line">            self.register_hook(event, hooks[event])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Note: Session.prepare_request merges Request hooks and Session hooks</span></div>
<div class="line"><span class="comment">#       into the PreparedRequest.hooks dictionary.</span></div>
</div><!-- fragment --><p>The <code>dispatch_hook</code> function is the core mechanism that allows <code>requests</code> to call your custom functions at the designated <code>"response"</code> checkpoint within <code>Session.send</code>.</p>
<h2><a class="anchor" id="autotoc_md2970"></a>
Conclusion</h2>
<p>You've learned about the <b>Hook System</b> in <code>requests</code>, a way to register custom callback functions that run at specific points in the request-response lifecycle.</p>
<ul>
<li>You understood the motivation: automating actions like logging without cluttering your main code.</li>
<li>You focused on the primary hook: <b><code>response</code></b>, which runs after a response is received but before it's returned to the caller.</li>
<li>You saw how to define a hook function (accepting the <code>response</code> object) and register it on a <code>Session</code> (using <code>session.hooks</code>) to apply it globally, or potentially on a single <code>Request</code>.</li>
<li>You implemented a practical example: logging response details automatically.</li>
<li>You got a glimpse into how hooks <em>can</em> modify responses (use with care!).</li>
<li>You learned that internally, the <code>dispatch_hook</code> function is called by <code>Session.send</code> to execute your registered hook functions.</li>
</ul>
<p>The Hook System provides a clean way to plug into the <code>requests</code> workflow and add custom behavior or monitoring without modifying the library itself.</p>
<p>This concludes our journey through the core abstractions of the <code>requests</code> library! From the simple <a class="el" href="../../d8/da9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_201__functional__api.html">Functional API</a> to the powerful <a class="el" href="../../dd/d2f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_203__session.html">Session</a> object, managing <a class="el" href="../../d1/df9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_204__cookie__jar.html">Cookies</a>, handling <a class="el" href="../../d7/df0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_205__authentication__handlers.html">Authentication</a>, dealing with <a class="el" href="../../d0/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_206__exception__hierarchy.html">Exceptions</a>, customizing connections with <a class="el" href="../../d5/d83/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_207__transport__adapters.html">Transport Adapters</a>, and reacting to events with the Hook System, you now have a solid foundation for using <code>requests</code> effectively in your Python projects. Happy requesting!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
