#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 07_application_and_request_contexts</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d6/da8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_207__application__and__request__contexts.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">07_application_and_request_contexts</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1936"></a>
autotoc_md1936</h2>
<p>layout: default title: "Application and Request Contexts" parent: "Flask" </p>
<h2><a class="anchor" id="autotoc_md1937"></a>
nav_order: 7</h2>
<h1><a class="anchor" id="autotoc_md1938"></a>
Chapter 7: Application and Request Contexts</h1>
<p>Welcome back! In <a class="el" href="../../d9/d88/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_206__configuration______config____.html">Chapter 6: Configuration (<code>Config</code>)</a>, we learned how to manage settings for our Flask application using the <code>app.config</code> object. And in <a class="el" href="../../d2/d15/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_205__context__globals______current__a0f66e55a619b85550f70ee0df6dbdc86.html">Chapter 5: Context Globals (<code>current_app</code>, <code>request</code>, <code>session</code>, <code>g</code>)</a>, we met special variables like <code>request</code> and <code>current_app</code> that seem to magically know about the current request or application.</p>
<p>But how does Flask keep track of which request is which, especially if multiple users are accessing our web app at the same time? How does it ensure that <code>request</code> refers to <em>User A's</em> request when handling User A, and <em>User B's</em> request when handling User B? This magic is managed by <b>Application and Request Contexts</b>.</p>
<h2><a class="anchor" id="autotoc_md1939"></a>
What Problem Do They Solve? Keeping Things Separate</h2>
<p>Imagine you're working at a busy service desk. Many people come up asking for different things simultaneously. You need a way to keep each person's request and related information separate from everyone else's. You can't just use one shared notepad for everyone â€“ that would be chaos! Instead, for each person, you might create a temporary folder or workspace to hold their specific documents and details while you help them.</p>
<p>In a web application, your Flask server might be handling requests from many different users at the same time. Each request has its own data (like form submissions or URL parameters) and potentially its own user session. Storing this information in simple global variables in your Python code would be disastrous, as data from one request could overwrite or interfere with data from another.</p>
<p>Flask uses <b>Contexts</b> to solve this problem. Contexts act like those temporary, isolated workspaces. They ensure that variables like <code>request</code>, <code>session</code>, <code>current_app</code>, and <code>g</code> always point to the information relevant to the <em>specific task</em> Flask is currently working on (usually, handling one particular incoming web request).</p>
<h2><a class="anchor" id="autotoc_md1940"></a>
The Two Main Types of Contexts</h2>
<p>Flask has two primary types of contexts:</p>
<ol type="1">
<li><b>Application Context (<code>AppContext</code>):</b><ul>
<li><b>Analogy:</b> Think of this as the main office building or the overall project workspace.</li>
<li><b>Purpose:</b> It holds information related to the application instance itself, regardless of any specific web request. It binds the <code>current_app</code> proxy (pointing to your <code>Flask</code> app instance) and the <code>g</code> proxy (a temporary storage space).</li>
<li><b>When is it active?</b> It's automatically active <em>during</em> a web request. It's also needed for tasks <em>outside</em> of web requests that still need access to the application, such as running command-line interface (CLI) commands (like database migrations) or background jobs.</li>
</ul>
</li>
<li><b>Request Context (<code>RequestContext</code>):</b><ul>
<li><b>Analogy:</b> Think of this as a specific meeting room set up just for handling one client's request (one incoming web request).</li>
<li><b>Purpose:</b> It holds information specific to <em>one single incoming web request</em>. It binds the <code>request</code> proxy (containing details of the HTTP request) and the <code>session</code> proxy (for user-specific session data).</li>
<li><b>When is it active?</b> Flask automatically creates and activates a Request Context when a web request comes in, and removes it after the request is handled.</li>
<li><b>Relationship:</b> A Request Context <em>always</em> includes an Application Context within it. You can't have a meeting room (<code>RequestContext</code>) without being inside the main office building (<code>AppContext</code>).</li>
</ul>
</li>
</ol>
<p>Here's a simple breakdown:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Context Type   </th><th class="markdownTableHeadLeft">Analogy   </th><th class="markdownTableHeadLeft">Key Globals Bound   </th><th class="markdownTableHeadLeft">Typical Use Case   </th><th class="markdownTableHeadLeft">Lifespan    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">Application   </td><td class="markdownTableBodyLeft">Main Office Building   </td><td class="markdownTableBodyLeft"><code>current_app</code>, <code>g</code>   </td><td class="markdownTableBodyLeft">CLI commands, background tasks   </td><td class="markdownTableBodyLeft">Active during requests, or manually activated    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">Request   </td><td class="markdownTableBodyLeft">Temporary Meeting Room   </td><td class="markdownTableBodyLeft"><code>request</code>, <code>session</code>   </td><td class="markdownTableBodyLeft">Handling a single web request   </td><td class="markdownTableBodyLeft">Created/destroyed for each web request   </td></tr>
</table>
<h2><a class="anchor" id="autotoc_md1941"></a>
How Flask Uses Contexts Automatically (During Requests)</h2>
<p>Most of the time, you don't need to worry about manually managing contexts. When a browser sends a request to your Flask application:</p>
<ol type="1">
<li><b>Request Arrives:</b> Your WSGI server (like the Flask development server) receives the HTTP request.</li>
<li><b>Context Creation:</b> Flask automatically creates a <code>RequestContext</code> object based on the incoming request details (the WSGI environment).</li>
<li><b>Context Pushing:</b> Flask <em>pushes</em> this <code>RequestContext</code>. This does two things:<ul>
<li>It makes the <code>request</code> and <code>session</code> proxies point to the specific request and session objects for <em>this</em> request.</li>
<li>It <em>also</em> pushes an <code>AppContext</code> (if one isn't already active for this thread/task), making <code>current_app</code> and <code>g</code> point to the correct application and a fresh <code>g</code> object. "Pushing" is like activating that temporary workspace.</li>
</ul>
</li>
<li><b>Code Execution:</b> Your view function runs. Because the contexts are active, you can freely use <code>request</code>, <code>session</code>, <code>current_app</code>, and <code>g</code> inside your function, and they will refer to the correct objects for the current request.</li>
<li><b>Response Sent:</b> Your view function returns a response.</li>
<li><b>Context Popping:</b> After the response is sent, Flask <em>pops</em> the <code>RequestContext</code> (and the <code>AppContext</code> if it was pushed along with it). This cleans up the workspace, effectively deactivating those specific <code>request</code>, <code>session</code>, and <code>g</code> objects for that request.</li>
</ol>
<p>This automatic push/pop mechanism ensures that each request is handled in its own isolated context, preventing data clashes between concurrent requests.</p>
<h2><a class="anchor" id="autotoc_md1942"></a>
Manually Pushing Contexts (Outside Requests)</h2>
<p>What if you need to access application settings or resources <em>outside</em> of a typical web request? For example, maybe you have a separate Python script (<code>init_db.py</code>) that needs to initialize your database using configuration stored in <code>app.config</code>. Since there's no incoming web request, Flask won't automatically create any contexts.</p>
<p>In these cases, you need to manually push an <b>Application Context</b> using <code>app.app_context()</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># init_db.py (Example script to run from command line)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Assume your main Flask app object is defined in hello.py</span></div>
<div class="line"><span class="comment"># We need to import it here.</span></div>
<div class="line"><span class="comment"># In a real project, you&#39;d structure this better, maybe using a factory function.</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    <span class="comment"># Let&#39;s assume hello.py has app = Flask(__name__)</span></div>
<div class="line">    <span class="keyword">from</span> hello <span class="keyword">import</span> app</div>
<div class="line"><span class="keywordflow">except</span> ImportError:</div>
<div class="line">    print(<span class="stringliteral">&quot;Could not import &#39;app&#39; from hello.py&quot;</span>)</div>
<div class="line">    print(<span class="stringliteral">&quot;Make sure hello.py exists and defines the Flask app.&quot;</span>)</div>
<div class="line">    exit(1)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define a function that needs app access</span></div>
<div class="line"><span class="keyword">def </span>setup_database():</div>
<div class="line">    <span class="comment"># We need an application context to access current_app.config</span></div>
<div class="line">    <span class="comment"># Without the &#39;with&#39; block, current_app would not be available here.</span></div>
<div class="line">    <span class="keyword">with</span> app.app_context():</div>
<div class="line">        <span class="comment"># Now we can safely access app configuration via current_app</span></div>
<div class="line">        db_uri = app.config.get(<span class="stringliteral">&#39;DATABASE_URI&#39;</span>, <span class="stringliteral">&#39;No DB URI Set!&#39;</span>)</div>
<div class="line">        print(f<span class="stringliteral">&quot;Inside app context: Accessing config...&quot;</span>)</div>
<div class="line">        print(f<span class="stringliteral">&quot;Database URI found: {db_uri}&quot;</span>)</div>
<div class="line">        <span class="comment"># Imagine database setup code here that uses the URI</span></div>
<div class="line">        print(<span class="stringliteral">&quot;Database initialization logic would run here.&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># ---- Main execution part of the script ----</span></div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:</div>
<div class="line">    print(<span class="stringliteral">&quot;Running database setup script...&quot;</span>)</div>
<div class="line">    setup_database()</div>
<div class="line">    print(<span class="stringliteral">&quot;Script finished.&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>from hello import app</code>: We import the actual <code>Flask</code> application instance.</li>
<li><code>with app.app_context():</code>: This is the key part! It creates an application context for the <code>app</code> instance and pushes it, making it active within the <code>with</code> block.</li>
<li>Inside the block, <code>current_app</code> becomes available and correctly points to our <code>app</code> object. We can now safely access <code>current_app.config</code>.</li>
<li>When the <code>with</code> block exits, the application context is automatically popped.</li>
</ul>
<p><b>To run this (assuming <code>hello.py</code> exists and defines <code>app</code>):</b></p>
<ol type="1">
<li>Save the code above as <code>init_db.py</code> in the same directory as <code>hello.py</code>.</li>
<li>Optionally, add &lsquo;app.config['DATABASE_URI&rsquo;] = 'sqlite:///mydatabase.db'<code>to</code>hello.py<code>to see it picked up.</code></li>
<li><code> Run from your terminal:</code>python init_db.py`</li>
<li>You'll see output showing that the config was accessed successfully <em>inside</em> the context.</li>
</ol>
<p>Similarly, if you need to simulate a request environment (perhaps for testing helper functions that rely on <code>request</code>), you can use <code>app.test_request_context()</code> which pushes both a Request and Application context.</p>
<div class="fragment"><div class="line"><span class="comment"># example_test_context.py</span></div>
<div class="line"><span class="keyword">from</span> hello <span class="keyword">import</span> app <span class="comment"># Assuming hello.py defines app = Flask(__name__)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># A helper function that might be used inside a view</span></div>
<div class="line"><span class="keyword">def </span>get_user_agent_info():</div>
<div class="line">    <span class="comment"># This function relies on the &#39;request&#39; context global</span></div>
<div class="line">    <span class="keyword">from</span> flask <span class="keyword">import</span> request</div>
<div class="line">    user_agent = request.headers.get(<span class="stringliteral">&#39;User-Agent&#39;</span>, <span class="stringliteral">&#39;Unknown&#39;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> f<span class="stringliteral">&quot;Request came from: {user_agent}&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Simulate calling the function outside a real request ---</span></div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:</div>
<div class="line">    <span class="comment"># Create a test request context for a fake GET request to &#39;/&#39;</span></div>
<div class="line">    <span class="comment"># This pushes both Request and App contexts</span></div>
<div class="line">    <span class="keyword">with</span> app.test_request_context(<span class="stringliteral">&#39;/&#39;</span>, method=<span class="stringliteral">&#39;GET&#39;</span>):</div>
<div class="line">        <span class="comment"># Now, inside this block, &#39;request&#39; is available!</span></div>
<div class="line">        print(<span class="stringliteral">&quot;Inside test request context...&quot;</span>)</div>
<div class="line">        agent_info = get_user_agent_info()</div>
<div class="line">        print(agent_info)</div>
<div class="line"> </div>
<div class="line">    print(<span class="stringliteral">&quot;Outside context.&quot;</span>)</div>
<div class="line">    <span class="comment"># Trying to call get_user_agent_info() here would fail because</span></div>
<div class="line">    <span class="comment"># the request context has been popped.</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1943"></a>
Under the Hood: Context Locals and Stacks</h2>
<p>How does Flask actually manage these contexts and make the globals like <code>request</code> point to the right object?</p>
<p>Historically, Flask used thread-local storage and maintained stacks of contexts for each thread. When <code>request</code> was accessed, it would look at the top of the request context stack <em>for the current thread</em>.</p>
<p>Modern Flask (leveraging updates in its core dependency, Werkzeug) relies on Python's built-in <code>contextvars</code> module. This module provides a more robust way to manage context-specific state that works correctly with both threads and modern asynchronous programming (like <code>async</code>/<code>await</code>).</p>
<p>Here's a simplified conceptual idea:</p>
<ol type="1">
<li><b>Context Variables:</b> Flask defines special "context variables" (using <code>contextvars.ContextVar</code>) for the application context (<code>_cv_app</code>) and the request context (<code>_cv_request</code>). Think of these like special slots that can hold different values depending on the current execution context (the specific request being handled).</li>
<li><b>Pushing:</b> When Flask pushes a context (e.g., <code>RequestContext.push()</code>), it stores the actual context object (like the <code>RequestContext</code> instance for the current request) into the corresponding context variable (<code>_cv_request.set(the_request_context)</code>).</li>
<li><b>Proxies:</b> The context globals (<code>request</code>, <code>session</code>, <code>current_app</code>, <code>g</code>) are special <code>LocalProxy</code> objects (from Werkzeug). They don't hold the data directly.</li>
<li><b>Proxy Access:</b> When you access something like <code>request.args</code>, the <code>request</code> proxy does the following:<ul>
<li>Looks up the <em>current</em> value stored in the <code>_cv_request</code> context variable. This gives it the <em>actual</em> <code>RequestContext</code> object for the currently active request.</li>
<li>Retrieves the real <code>request</code> object stored <em>within</em> that <code>RequestContext</code>.</li>
<li>Finally, accesses the <code>.args</code> attribute on that real request object.</li>
</ul>
</li>
<li><b>Popping:</b> When Flask pops a context (e.g., <code>RequestContext.pop()</code>), it resets the context variable (<code>_cv_request.reset(token)</code>), effectively clearing that slot for the current context.</li>
</ol>
<p>This <code>contextvars</code> mechanism ensures that even if your server is handling many requests concurrently (in different threads or async tasks), each one has its own isolated value for <code>_cv_app</code> and <code>_cv_request</code>, so the proxies always resolve to the correct objects for the task at hand.</p>
<p>Let's visualize the request lifecycle with contexts:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Browser</div>
<div class="line">    participant FlaskApp as Flask App (WSGI)</div>
<div class="line">    participant Contexts as Context Management</div>
<div class="line">    participant YourView as Your View Function</div>
<div class="line">    participant Globals as request Proxy</div>
<div class="line"> </div>
<div class="line">    Browser-&gt;&gt;+FlaskApp: Sends GET /user/alice</div>
<div class="line">    FlaskApp-&gt;&gt;+Contexts: Request arrives, create RequestContext (incl. AppContext)</div>
<div class="line">    Contexts-&gt;&gt;Contexts: Push RequestContext (sets _cv_request)</div>
<div class="line">    Contexts-&gt;&gt;Contexts: Push AppContext (sets _cv_app)</div>
<div class="line">    Note over Contexts: request, session, current_app, g are now active</div>
<div class="line">    FlaskApp-&gt;&gt;+YourView: Calls view_func(username=&#39;alice&#39;)</div>
<div class="line">    YourView-&gt;&gt;+Globals: Access request.method</div>
<div class="line">    Globals-&gt;&gt;Contexts: Lookup _cv_request -&gt; finds current RequestContext</div>
<div class="line">    Globals--&gt;&gt;YourView: Returns &#39;GET&#39; (from real request object)</div>
<div class="line">    YourView--&gt;&gt;-FlaskApp: Returns Response(&quot;Hello Alice&quot;)</div>
<div class="line">    FlaskApp-&gt;&gt;+Contexts: Response sent, Pop RequestContext (resets _cv_request)</div>
<div class="line">    Contexts-&gt;&gt;Contexts: Pop AppContext (resets _cv_app)</div>
<div class="line">    Note over Contexts: Context globals are now unbound for this request</div>
<div class="line">    FlaskApp--&gt;&gt;-Browser: Sends HTTP Response</div>
</div><!-- fragment --><p>This diagram shows that Flask sets up (pushes) the context before calling your view and tears it down (pops) afterwards, allowing the proxies like <code>request</code> to find the right data while your code runs.</p>
<h2><a class="anchor" id="autotoc_md1944"></a>
Conclusion</h2>
<p>Contexts are fundamental to how Flask manages state during the lifecycle of the application and individual requests. They provide isolated workspaces to prevent data from different requests interfering with each other.</p>
<ul>
<li><b>Application Context (<code>AppContext</code>):</b> Provides access to the application (<code>current_app</code>) and global storage (<code>g</code>). Used implicitly during requests and manually via <code>app.app_context()</code> for tasks like CLI commands.</li>
<li><b>Request Context (<code>RequestContext</code>):</b> Provides access to request-specific data (<code>request</code>) and the user session (<code>session</code>). Automatically managed by Flask during the web request cycle. Contains an <code>AppContext</code>.</li>
<li><b>Context Globals:</b> Proxies like <code>request</code> and <code>current_app</code> rely on the currently active contexts to find the correct objects.</li>
<li><b>Management:</b> Flask usually handles context push/pop automatically for web requests. Manual pushing (<code>app.app_context()</code>, <code>app.test_request_context()</code>) is needed for specific scenarios like scripts, background jobs, or testing.</li>
</ul>
<p>Understanding contexts helps explain how Flask allows convenient access to request and application data through globals while maintaining safety and isolation between concurrent operations.</p>
<p>Now that we understand how Flask manages state and configuration for the core application, how do we organize larger applications with multiple sections or features? That's where Blueprints come in.</p>
<p>Let's learn how to structure our projects in <a class="el" href="../../da/de3/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_208__blueprints.html">Chapter 8: Blueprints</a>.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
