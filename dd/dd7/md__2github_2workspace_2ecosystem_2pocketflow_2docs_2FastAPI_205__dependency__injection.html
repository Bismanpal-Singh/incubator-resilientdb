#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_dependency_injection</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/dd7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_205__dependency__injection.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_dependency_injection</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1754"></a>
autotoc_md1754</h2>
<p>layout: default title: "Dependency Injection" parent: "FastAPI" </p>
<h2><a class="anchor" id="autotoc_md1755"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md1756"></a>
Chapter 5: Dependency Injection</h1>
<p>Welcome back! In <a class="el" href="../../d9/d03/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_204__openapi______automatic__docs.html">Chapter 4: OpenAPI &amp; Automatic Docs</a>, we saw how FastAPI automatically generates interactive documentation for our API, making it easy for others (and ourselves!) to understand and use. This works because FastAPI understands the structure of our paths, parameters, and Pydantic models.</p>
<p>Now, let's explore another powerful feature that helps us write cleaner, more reusable, and better-organized code: <b>Dependency Injection</b>.</p>
<h2><a class="anchor" id="autotoc_md1757"></a>
What Problem Does This Solve?</h2>
<p>Imagine you're building several API endpoints, and many of them need the same piece of information or the same setup step performed before they can do their main job. For example:</p>
<ul>
<li><b>Database Connection:</b> Many endpoints might need to talk to a database. You need to get a database "session" or connection first.</li>
<li><b>User Authentication:</b> Many endpoints might require the user to be logged in. You need to check their credentials (like a token in a header) and fetch their user details.</li>
<li><b>Common Parameters:</b> Maybe several endpoints share common query parameters like <code>skip</code> and <code>limit</code> for pagination.</li>
</ul>
<p>You <em>could</em> write the code to get the database session, check the user, or parse the pagination parameters inside <em>each</em> path operation function. But that would be very repetitive (violating the DRY - Don't Repeat Yourself - principle) and hard to maintain. If you need to change how you get a database session, you'd have to update it in many places!</p>
<p>FastAPI's <b>Dependency Injection (DI)</b> system provides an elegant solution to this. It allows you to define these common pieces of logic (like getting a user or a DB session) as separate, reusable functions called "dependencies". Then, you simply "declare" that your path operation function needs the result of that dependency, and FastAPI automatically takes care of running the dependency and providing ("injecting") the result into your function.</p>
<p><b>Our Goal Today:</b> Learn how to use FastAPI's <code>Depends</code> function to manage dependencies, reuse code, and make our API logic cleaner and more modular.</p>
<p><b>Analogy:</b> Think of your path operation function as the main chef preparing a dish (handling the request). Before the chef can cook, they might need specific ingredients prepared or tools set up. Dependency Injection is like having specialized assistants (dependencies):</p><ul>
<li>One assistant fetches fresh vegetables (e.g., gets common query parameters).</li>
<li>Another assistant prepares the cooking station (e.g., gets a database session).</li>
<li>Another assistant checks the order ticket to see who the dish is for (e.g., authenticates the user).</li>
</ul>
<p>The chef simply tells the head waiter (<code>Depends</code>) what they need ("I need prepared vegetables", "I need the cooking station ready"), and the assistants automatically provide them just in time. The chef doesn't need to know the details of <em>how</em> the vegetables were fetched or the station prepared; they just get the result.</p>
<h2><a class="anchor" id="autotoc_md1758"></a>
Key Concepts</h2>
<ol type="1">
<li><b>Dependency:</b> A function (or other callable) that provides some value needed by your path operation function (or even by another dependency). Examples: a function to get the current user, a function to connect to the database, a function to parse common query parameters.</li>
<li><b><code>Depends</code>:</b> A special function imported from <code>fastapi</code> (<code>from fastapi import Depends</code>) that you use in the parameters of your path operation function to signal that it requires a dependency. You use it like this: <code>parameter_name: Annotated[ReturnType, Depends(dependency_function)]</code>.</li>
<li><b>Injection:</b> FastAPI "injects" the <em>result</em> returned by the dependency function into the parameter of your path operation function. If <code>dependency_function()</code> returns the value <code>10</code>, then <code>parameter_name</code> will be <code>10</code> inside your path function.</li>
<li><b>Automatic Execution:</b> FastAPI automatically figures out which dependencies are needed for a given request, calls them in the correct order (if dependencies depend on others), and manages their results.</li>
<li><b>Reusability:</b> Define a dependency once, and use <code>Depends(your_dependency)</code> in multiple path operations.</li>
<li><b>Caching (Per Request):</b> By default, if a dependency is declared multiple times for the <em>same request</em> (e.g., if multiple path operation parameters need it, or if other dependencies need it), FastAPI will only run the dependency function <em>once</em> per request and reuse the result. This is efficient, especially for things like database connections or fetching user data. You can disable this cache if needed.</li>
<li><b>Hierarchy:</b> Dependencies can depend on other dependencies using <code>Depends</code> in their own parameters, forming a chain or tree of dependencies. FastAPI resolves this entire structure.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1759"></a>
Using Dependencies: A Simple Example</h2>
<p>Let's start with a very common scenario: having shared query parameters for pagination.</p>
<ol type="1">
<li><p class="startli"><b>Define the Dependency Function:</b> Create a regular Python function that takes the parameters you want to share.</p>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md1760"></a>
common_dependencies.py (or within your router file)</h1>
<p>from typing import Annotated from fastapi import Query</p>
<h1><a class="anchor" id="autotoc_md1761"></a>
This is our dependency function</h1>
<h1><a class="anchor" id="autotoc_md1762"></a>
It takes the common query parameters</h1>
<p>async def common_parameters( q: Annotated[str | None, Query(description="Optional query string")] = None, skip: Annotated[int, Query(description="Items to skip", ge=0)] = 0, limit: Annotated[int, Query(description="Max items to return", le=100)] = 100, ): </p>
<h1><a class="anchor" id="autotoc_md1763"></a>
It simply returns a dictionary containing these parameters</h1>
<p>return {"q": q, "skip": skip, "limit": limit}</p>
<p>```</p>
<p><b>Explanation:</b></p><ul>
<li>This looks like a normal function that could handle path operation parameters.</li>
<li>It takes <code>q</code>, <code>skip</code>, and <code>limit</code> as arguments, using <code>Query</code> for validation and documentation just like we learned in <a class="el" href="../../d0/d13/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_202__path__operations______parameter__declaration.html">Chapter 2: Path Operations &amp; Parameter Declaration</a>.</li>
<li>It returns a dictionary containing the values it received. This dictionary will be the "result" injected into our path functions.</li>
</ul>
<p><b>Use <code>Depends</code> in Path Operations:</b> Now, import <code>Depends</code> and your dependency function, and use it in your path operation parameters.</p>
<p>```python </p>
<h1><a class="anchor" id="autotoc_md1764"></a>
routers/items.py (example)</h1>
<p>from typing import Annotated from fastapi import APIRouter, Depends </p>
<h1><a class="anchor" id="autotoc_md1765"></a>
Assume common_parameters is defined in common_dependencies.py</h1>
<p>from ..common_dependencies import common_parameters</p>
<p>router = APIRouter()</p>
<h1><a class="anchor" id="autotoc_md1766"></a>
Fake data for demonstration</h1>
<p>fake_items = [{"item_name": "Foo"}, {"item_name": "Bar"}, {"item_name": "Baz"}]</p>
<p>@router.get("/items/") </p>
<h1><a class="anchor" id="autotoc_md1767"></a>
Here's the magic! Declare 'commons' parameter using Depends</h1>
<p>async def read_items( commons: Annotated[dict, Depends(common_parameters)] # Dependency Injection! ): </p>
<h1><a class="anchor" id="autotoc_md1768"></a>
Inside this function, 'commons' will be the dictionary returned</h1>
<h1><a class="anchor" id="autotoc_md1769"></a>
by common_parameters after FastAPI calls it with the query params.</h1>
<p>print(f"Received common parameters: {commons}")</p>
<h1><a class="anchor" id="autotoc_md1770"></a>
Use the values from the dependency</h1>
<p>q = commons["q"] skip = commons["skip"] limit = commons["limit"]</p>
<p>response_items = fake_items[skip : skip + limit] if q: response_items = [item for item in response_items if q in item["item_name"]] return response_items</p>
<p>@router.get("/users/") </p>
<h1><a class="anchor" id="autotoc_md1771"></a>
We can reuse the SAME dependency here!</h1>
<p>async def read_users( commons: Annotated[dict, Depends(common_parameters)] # Reusing the dependency ): </p>
<h1><a class="anchor" id="autotoc_md1772"></a>
'commons' will again be the dict returned by common_parameters</h1>
<p>print(f"Received common parameters for users: {commons}") </p>
<h1><a class="anchor" id="autotoc_md1773"></a>
Imagine fetching users using commons['skip'], commons['limit']...</h1>
<p>return {"message": "Users endpoint", "params": commons}</p>
<p>```</p>
<p><b>Explanation:</b></p><ul>
<li><code>from fastapi import Depends</code>: We import <code>Depends</code>.</li>
<li><code>from ..common_dependencies import common_parameters</code>: We import our dependency function.</li>
<li><code>commons: Annotated[dict, Depends(common_parameters)]</code>: This is the key part!<ul>
<li>We declare a parameter named <code>commons</code>.</li>
<li>Its type hint is <code>dict</code> (because our dependency returns a dictionary). <em>Technically, FastAPI infers the type from the dependency function's return type hint if available, but explicitly adding <code>dict</code> here helps clarity.</em> For more complex types, use the exact return type.</li>
<li>We wrap the type hint and <code>Depends(common_parameters)</code> in <code>Annotated</code>. This is the standard way to use <code>Depends</code>.</li>
<li><code>Depends(common_parameters)</code> tells FastAPI: "Before running `read_items`, call the `common_parameters` function. Take the query parameters `q`, `skip`, `limit` from the incoming request, pass them to `common_parameters`, get its return value, and assign it to the `commons` variable."</li>
</ul>
</li>
<li><b>Reusability:</b> Notice how <code>read_users</code> uses the <em>exact same</em> dependency declaration <code>Annotated[dict, Depends(common_parameters)]</code>. We didn't have to repeat the <code>q</code>, <code>skip</code>, <code>limit</code> definitions.</li>
</ul>
<p><b>How it Behaves:</b></p>
<ol type="1">
<li>Run your app (<code>uvicorn main:app --reload</code>, assuming <code><a class="el" href="../../dc/dba/main_8py.html">main.py</a></code> includes this router).</li>
<li>Visit <code><a href="http://127.0.0.1:8000/items/?skip=1">http://127.0.0.1:8000/items/?skip=1</a>&amp;limit=1</code>.<ul>
<li>FastAPI sees <code>Depends(common_parameters)</code>.</li>
<li>It extracts <code>skip=1</code> and <code>limit=1</code> (and <code>q=None</code>) from the query string.</li>
<li>It calls <code>common_parameters(q=None, skip=1, limit=1)</code>.</li>
<li><code>common_parameters</code> returns <code>{"q": None, "skip": 1, "limit": 1}</code>.</li>
<li>FastAPI calls <code>read_items(commons={"q": None, "skip": 1, "limit": 1})</code>.</li>
<li>You see the print statement and get the response <code>[{"item_name":"Bar"}]</code>.</li>
</ul>
</li>
<li>Visit <code><a href="http://127.0.0.1:8000/users/?q=test">http://127.0.0.1:8000/users/?q=test</a></code>.<ul>
<li>FastAPI calls <code>common_parameters(q="test", skip=0, limit=100)</code>.</li>
<li><code>common_parameters</code> returns <code>{"q": "test", "skip": 0, "limit": 100}</code>.</li>
<li>FastAPI calls <code>read_users(commons={"q": "test", "skip": 0, "limit": 100})</code>.</li>
<li>You see the print statement and get the JSON response.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md1774"></a>
Dependencies Can Depend on Other Dependencies</h2>
<p>The real power comes when dependencies themselves need other dependencies. Let's sketch a simplified example for getting an item from a fake database.</p>
<ol type="1">
<li><p class="startli"><b>Define a "DB Session" Dependency:</b> (This will be fake, just returning a string).</p>
<p class="startli"><code>python @section autotoc_md1775 common_dependencies.py async def get_db_session(): print("Getting DB Session") @section autotoc_md1776 In reality, this would connect to a DB and yield/return a session object session = "fake_db_session_123" @section autotoc_md1777 You might use 'yield' here for setup/teardown (see FastAPI docs) return session </code></p>
</li>
<li><p class="startli"><b>Define a Dependency that Uses the DB Session:</b></p>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md1778"></a>
common_dependencies.py</h1>
<p>from typing import Annotated from fastapi import Depends, HTTPException</p>
<h1><a class="anchor" id="autotoc_md1779"></a>
Import the DB session dependency</h1>
<p>from .common_dependencies import get_db_session</p>
<p>async def get_item_from_db( item_id: int, # Takes a regular path parameter db: Annotated[str, Depends(get_db_session)] # Depends on get_db_session! ): print(f"Getting item {item_id} using DB session: {db}") </p>
<h1><a class="anchor" id="autotoc_md1780"></a>
Fake database interaction</h1>
<p>fake_db = {1: "Item One", 2: "Item Two"} if item_id not in fake_db: raise HTTPException(status_code=404, detail="Item not found in DB") return fake_db[item_id] ```</p>
<p><b>Explanation:</b></p><ul>
<li><code>get_item_from_db</code> takes a regular <code>item_id</code> (which FastAPI will get from the path).</li>
<li>It <em>also</em> takes <code>db: Annotated[str, Depends(get_db_session)]</code>. It declares its <em>own</em> dependency on <code>get_db_session</code>.</li>
<li>When FastAPI needs to run <code>get_item_from_db</code>, it first sees the <code>Depends(get_db_session)</code>. It runs <code>get_db_session</code>, gets <code>"fake_db_session_123"</code>, and then calls <code>get_item_from_db(item_id=..., db="fake_db_session_123")</code>.</li>
</ul>
<p><b>Use the High-Level Dependency in a Path Operation:</b></p>
<p>```python </p>
<h1><a class="anchor" id="autotoc_md1781"></a>
routers/items.py</h1>
<h1><a class="anchor" id="autotoc_md1782"></a>
... other imports ...</h1>
<p>from ..common_dependencies import get_item_from_db</p>
<p>@router.get("/db_items/{item_id}") </p>
<h1><a class="anchor" id="autotoc_md1783"></a>
This endpoint depends on get_item_from_db</h1>
<p>async def read_db_item( item_id: int, # Path parameter for get_item_from_db item_name: Annotated[str, Depends(get_item_from_db)] # Inject result here! ): </p>
<h1><a class="anchor" id="autotoc_md1784"></a>
'item_name' will be the string returned by get_item_from_db</h1>
<h1><a class="anchor" id="autotoc_md1785"></a>
after it used the result from get_db_session.</h1>
<p>return {"item_id": item_id, "name_from_db": item_name} ```</p>
<p><b>Explanation:</b></p><ul>
<li>The <code>read_db_item</code> function only needs to declare <code>Depends(get_item_from_db)</code>.</li>
<li>FastAPI automatically handles the whole chain: <code>read_db_item</code> -&gt; <code>get_item_from_db</code> -&gt; <code>get_db_session</code>.</li>
<li>Notice the <code>item_id: int</code> path parameter is declared in <em>both</em> <code>read_db_item</code> and <code>get_item_from_db</code>. FastAPI is smart enough to pass the path parameter value to the dependency that needs it.</li>
</ul>
<p><b>Caching in Action:</b></p>
<p>If <code>get_db_session</code> was also needed directly by <code>read_db_item</code> (e.g., <code>db_session: Annotated[str, Depends(get_db_session)]</code>), FastAPI would <em>still</em> only call <code>get_db_session</code> <b>once</b> for the entire request to <code>/db_items/{item_id}</code> because of the default caching (<code>use_cache=True</code> in <code>Depends</code>). The result <code>"fake_db_session_123"</code> would be shared.</p>
<h2><a class="anchor" id="autotoc_md1786"></a>
How it Works Under the Hood (Simplified)</h2>
<p>Let's trace a request to <code>/db_items/2</code> using the example above:</p>
<ol type="1">
<li><b>Request:</b> Client sends <code>GET /db_items/2</code>.</li>
<li><b>Routing:</b> FastAPI matches the request to the <code>read_db_item</code> path operation function.</li>
<li><b>Dependency Analysis:</b> FastAPI inspects the signature of <code>read_db_item</code>:<ul>
<li><code>item_id: int</code> -&gt; Needs value from path. Value is <code>2</code>.</li>
<li><code>item_name: Annotated[str, Depends(get_item_from_db)]</code> -&gt; Needs the result of <code>get_item_from_db</code>.</li>
</ul>
</li>
<li><b>Solving <code>get_item_from_db</code>:</b> FastAPI inspects <code>get_item_from_db</code>:<ul>
<li><code>item_id: int</code> -&gt; Needs a value. FastAPI sees <code>item_id</code> is also needed by the parent (<code>read_db_item</code>) and comes from the path. Value is <code>2</code>.</li>
<li><code>db: Annotated[str, Depends(get_db_session)]</code> -&gt; Needs the result of <code>get_db_session</code>.</li>
</ul>
</li>
<li><b>Solving <code>get_db_session</code>:</b> FastAPI inspects <code>get_db_session</code>:<ul>
<li>It has no parameters.</li>
<li>Checks cache: Has <code>get_db_session</code> run for this request? No.</li>
<li>Calls <code>get_db_session()</code>. It prints "Getting DB Session" and returns <code>"fake_db_session_123"</code>.</li>
<li>Stores <code>get_db_session</code> -&gt; <code>"fake_db_session_123"</code> in the request cache.</li>
</ul>
</li>
<li><b>Calling <code>get_item_from_db</code>:</b> FastAPI now has the dependencies for <code>get_item_from_db</code>:<ul>
<li><code>item_id</code> = <code>2</code> (from path)</li>
<li><code>db</code> = <code>"fake_db_session_123"</code> (from <code>get_db_session</code> result)</li>
<li>Calls <code>get_item_from_db(item_id=2, db="fake_db_session_123")</code>.</li>
<li>It prints "Getting item 2 using DB session: fake_db_session_123", looks up <code>2</code> in its fake DB, and returns <code>"Item Two"</code>.</li>
<li>Stores <code>get_item_from_db</code> -&gt; <code>"Item Two"</code> in the request cache.</li>
</ul>
</li>
<li><b>Calling <code>read_db_item</code>:</b> FastAPI now has the dependencies for <code>read_db_item</code>:<ul>
<li><code>item_id</code> = <code>2</code> (from path)</li>
<li><code>item_name</code> = <code>"Item Two"</code> (from <code>get_item_from_db</code> result)</li>
<li>Calls <code>read_db_item(item_id=2, item_name="Item Two")</code>.</li>
</ul>
</li>
<li><b>Response:</b> The function returns <code>{"item_id": 2, "name_from_db": "Item Two"}</code>, which FastAPI sends back to the client as JSON.</li>
</ol>
<p>Here's a simplified sequence diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client</div>
<div class="line">    participant FastAPIApp as FastAPI App</div>
<div class="line">    participant DepSolver as Dependency Solver</div>
<div class="line">    participant GetItemFunc as get_item_from_db</div>
<div class="line">    participant GetDBFunc as get_db_session</div>
<div class="line">    participant PathOpFunc as read_db_item</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;+FastAPIApp: GET /db_items/2</div>
<div class="line">    FastAPIApp-&gt;&gt;+DepSolver: Solve dependencies for read_db_item(item_id, Depends(get_item_from_db))</div>
<div class="line">    DepSolver-&gt;&gt;DepSolver: Need path param &#39;item_id&#39; (value=2)</div>
<div class="line">    DepSolver-&gt;&gt;DepSolver: Need result of get_item_from_db</div>
<div class="line">    DepSolver-&gt;&gt;+DepSolver: Solve dependencies for get_item_from_db(item_id, Depends(get_db_session))</div>
<div class="line">    DepSolver-&gt;&gt;DepSolver: Need &#39;item_id&#39; (value=2, from path)</div>
<div class="line">    DepSolver-&gt;&gt;DepSolver: Need result of get_db_session</div>
<div class="line">    DepSolver-&gt;&gt;DepSolver: Check cache for get_db_session: Miss</div>
<div class="line">    DepSolver-&gt;&gt;+GetDBFunc: Call get_db_session()</div>
<div class="line">    GetDBFunc--&gt;&gt;-DepSolver: Return &quot;fake_db_session_123&quot;</div>
<div class="line">    DepSolver-&gt;&gt;DepSolver: Cache: get_db_session -&gt; &quot;fake_db_session_123&quot;</div>
<div class="line">    DepSolver--&gt;&gt;-DepSolver: Dependencies for get_item_from_db ready</div>
<div class="line">    DepSolver-&gt;&gt;+GetItemFunc: Call get_item_from_db(item_id=2, db=&quot;fake_db_session_123&quot;)</div>
<div class="line">    GetItemFunc--&gt;&gt;-DepSolver: Return &quot;Item Two&quot;</div>
<div class="line">    DepSolver-&gt;&gt;DepSolver: Cache: get_item_from_db -&gt; &quot;Item Two&quot;</div>
<div class="line">    DepSolver--&gt;&gt;-FastAPIApp: Dependencies for read_db_item ready</div>
<div class="line">    FastAPIApp-&gt;&gt;+PathOpFunc: Call read_db_item(item_id=2, item_name=&quot;Item Two&quot;)</div>
<div class="line">    PathOpFunc--&gt;&gt;-FastAPIApp: Return {&quot;item_id&quot;: 2, &quot;name_from_db&quot;: &quot;Item Two&quot;}</div>
<div class="line">    FastAPIApp--&gt;&gt;-Client: Send JSON Response</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1787"></a>
Code Connections</h3>
<ul>
<li><b><code>fastapi.Depends</code></b> (<code>fastapi/param_functions.py</code>): This class is mostly a marker. When FastAPI analyzes function parameters, it looks for instances of <code>Depends</code>.</li>
<li><b><code>fastapi.dependencies.utils.get_dependant</code></b>: This crucial function takes a callable (like your path operation function or another dependency) and inspects its signature. It identifies which parameters are path/query/body parameters and which are dependencies (marked with <code>Depends</code>). It builds a <code>Dependant</code> object representing this.</li>
<li><b><code>fastapi.dependencies.models.Dependant</code></b>: A data structure (dataclass) that holds information about a callable: its name, the callable itself, its path/query/header/cookie/body parameters, and importantly, a list of <em>other</em> <code>Dependant</code> objects for its sub-dependencies. This creates the dependency tree/graph.</li>
<li><b><code>fastapi.dependencies.utils.solve_dependencies</code></b>: This is the engine that recursively traverses the <code>Dependant</code> graph for a given request. It figures out the order, checks the cache (<code>dependency_cache</code>), calls the dependency functions (using <code>run_in_threadpool</code> for sync functions or awaiting async ones), handles results from generators (<code>yield</code>), and gathers all the computed values needed to finally call the target path operation function.</li>
</ul>
<p>FastAPI intelligently combines Python's introspection capabilities with this structured dependency resolution system.</p>
<h2><a class="anchor" id="autotoc_md1788"></a>
Conclusion</h2>
<p>You've learned about FastAPI's powerful Dependency Injection system!</p>
<ul>
<li>You saw how to define reusable logic in <b>dependency functions</b>.</li>
<li>You learned to use <b><code>Depends</code></b> in your path operation function parameters to tell FastAPI what dependencies are needed.</li>
<li>You understood that FastAPI automatically <b>calls</b> dependencies and <b>injects</b> their results into your function.</li>
<li>You saw how dependencies can <b>depend on other dependencies</b>, creating manageable hierarchies.</li>
<li>You learned that results are <b>cached per request</b> by default for efficiency.</li>
<li>You grasped the core idea: separating concerns and promoting <b>reusable code</b>.</li>
</ul>
<p>Dependency Injection is fundamental to building complex, maintainable applications in FastAPI. It's used extensively for things like database connections, authentication, authorization, and processing complex parameter sets.</p>
<p>While dependencies help manage complexity, sometimes things inevitably go wrong â€“ a database might be unavailable, validation might fail within a dependency, or unexpected errors might occur. How should our API handle these situations gracefully? That's what we'll cover next.</p>
<p>Ready to handle errors like a pro? Let's move on to <a class="el" href="../../dc/d8a/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_206__error__handling.html">Chapter 6: Error Handling</a>!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
