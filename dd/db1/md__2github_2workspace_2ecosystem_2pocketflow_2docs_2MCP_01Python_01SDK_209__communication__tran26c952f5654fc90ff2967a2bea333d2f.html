#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 09_communication_transports__stdio__sse__websocket__memory_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/db1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_209__communication__tran26c952f5654fc90ff2967a2bea333d2f.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">09_communication_transports__stdio__sse__websocket__memory_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2466"></a>
autotoc_md2466</h2>
<p>layout: default title: "Communication Transports" parent: "MCP Python SDK" </p>
<h2><a class="anchor" id="autotoc_md2467"></a>
nav_order: 9</h2>
<h1><a class="anchor" id="autotoc_md2468"></a>
Chapter 9: Communication Transports (Stdio, SSE, WebSocket, Memory)</h1>
<p>Welcome to the final chapter of our introductory journey into the <code>MCP Python SDK</code>! In <a class="el" href="../../da/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_208__client__server__sesd1331743b9f6969725fa6462195d377b.html">Chapter 8: Client/Server Sessions (<code>ClientSession</code>, <code>ServerSession</code>)</a>, we learned how <code>Session</code> objects manage the ongoing conversation and state for a single connection between a client and a server, like dedicated phone operators handling a call.</p>
<p>But how do the messages actually <em>travel</em> over that phone line? If the client and server are different programs, possibly on different computers, what's the physical wire or digital equivalent carrying the signals?</p>
<p>Imagine our standardized MCP messages (<a class="el" href="../../de/dcd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_207__mcp__protocol__types.html">Chapter 7: MCP Protocol Types</a>) are like perfectly formatted letters. We need a delivery service to actually move these letters between the sender and receiver. This is where <b>Communication Transports</b> come in.</p>
<h2><a class="anchor" id="autotoc_md2469"></a>
What are Communication Transports? The Delivery Service</h2>
<p>Communication Transports define the <b>actual mechanisms</b> used to send the serialized MCP messages (those structured JSON strings) back and forth between the client and server processes.</p>
<p>Think of them as different <b>delivery services</b> you can choose from:</p>
<ol type="1">
<li><b><code>stdio</code> (Standard Input/Output): Postal Mail for Processes</b><ul>
<li><b>Mechanism:</b> Uses the standard input (<code>stdin</code>) and standard output (<code>stdout</code>) streams of the processes. One process writes messages (as lines of text) to its <code>stdout</code>, and the other reads them from its <code>stdin</code>.</li>
<li><b>Use Case:</b> Very common for command-line tools or when one process directly starts another (like when <code>mcp run</code> executes your server script). It's simple and works well when the client and server are running on the same machine and have a parent-child relationship.</li>
</ul>
</li>
<li><b><code>sse</code> (Server-Sent Events): One-Way Radio Broadcast (Server -&gt; Client)</b><ul>
<li><b>Mechanism:</b> Uses standard web protocols (HTTP). The client makes an initial HTTP request, and the server keeps the connection open, sending messages (events) <em>to</em> the client whenever it wants. Client-to-server communication usually happens via separate HTTP POST requests.</li>
<li><b>Use Case:</b> Good for web applications where the server needs to push updates (like notifications, progress) to the client (a web browser) efficiently.</li>
</ul>
</li>
<li><b><code>websocket</code>: Dedicated Two-Way Phone Line (Web)</b><ul>
<li><b>Mechanism:</b> Uses the WebSocket protocol, which provides a persistent, full-duplex (two-way) communication channel over a single TCP connection, typically initiated via an HTTP handshake.</li>
<li><b>Use Case:</b> Ideal for highly interactive web applications (like chat apps, real-time dashboards, or the MCP Inspector) where both the client and server need to send messages to each other at any time with low latency.</li>
</ul>
</li>
<li><b><code>memory</code>: Internal Office Courier</b><ul>
<li><b>Mechanism:</b> Uses in-memory queues within a <em>single</em> Python process. Messages are passed directly between the client and server components without going through external pipes or network connections.</li>
<li><b>Use Case:</b> Primarily used for <b>testing</b>. It allows you to run both the client and server parts of your code in the same test script and have them communicate directly, making tests faster and self-contained.</li>
</ul>
</li>
</ol>
<p>These transports are the concrete implementations that bridge the gap between the abstract <code>Session</code> objects (which manage the <em>conversation</em>) and the physical reality of sending bytes (the <em>delivery</em>).</p>
<h2><a class="anchor" id="autotoc_md2470"></a>
How Transports are Used (Often Indirectly)</h2>
<p>The good news is that if you're using <code>FastMCP</code> (<a class="el" href="../../d8/d5c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_202__fastmcp__server______fastmcp____.html">Chapter 2</a>) and the <code>mcp</code> command-line tool (<a class="el" href="../../d2/d9f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_201__cli______mcp____command__.html">Chapter 1</a>), you often <b>don't need to worry about explicitly choosing or configuring the transport</b>. The tools handle it for common scenarios:</p>
<ul>
<li><b><code>mcp run your_server.py</code></b>: By default, this command uses the <b><code>stdio</code></b> transport. It starts your Python script as a child process and communicates with it using <code>stdin</code> and <code>stdout</code>.</li>
<li><b><code>mcp dev your_server.py</code></b>: This command also typically runs your server using <b><code>stdio</code></b>. The <em>MCP Inspector</em> web application it launches then connects to your server (potentially via a WebSocket proxy managed by the dev tool) to monitor the <code>stdio</code> communication.</li>
<li><b><code>mcp install ...</code> (for Claude Desktop)</b>: This usually configures Claude to launch your server using <code>uv run ... mcp run your_server.py</code>, again defaulting to <b><code>stdio</code></b> communication between Claude and your server process.</li>
</ul>
<p>So, for many typical development and integration tasks, <code>stdio</code> is the default and works behind the scenes.</p>
<h2><a class="anchor" id="autotoc_md2471"></a>
Using Transports Programmatically (A Glimpse)</h2>
<p>While <code>mcp run</code> handles <code>stdio</code> automatically, what if you wanted to build a <em>custom</em> server application that listens over WebSockets? Or write tests using the <code>memory</code> transport? The SDK provides tools for this.</p>
<p>You typically use an <code>async context manager</code> provided by the SDK for the specific transport. These managers handle setting up the communication channel and yield a pair of streams (<code>read_stream</code>, <code>write_stream</code>) that the <code>ClientSession</code> or <code>ServerSession</code> can use.</p>
<p><b>Conceptual Server using Stdio (like <code>mcp run</code>)</b></p>
<div class="fragment"><div class="line"><span class="comment"># Conceptual code showing how stdio_server might be used</span></div>
<div class="line"><span class="keyword">import</span> anyio</div>
<div class="line"><span class="keyword">from</span> mcp.server.stdio <span class="keyword">import</span> stdio_server <span class="comment"># Import the stdio transport</span></div>
<div class="line"><span class="keyword">from</span> mcp.server.mcp_server <span class="keyword">import</span> MCPServer <span class="comment"># Low-level server</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Assume &#39;my_actual_server&#39; is your MCPServer instance</span></div>
<div class="line">my_actual_server = MCPServer(name=<span class="stringliteral">&quot;MyStdioServer&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span><a class="code hl_namespace" href="../../d2/dc1/namespacemain.html">main</a>():</div>
<div class="line">    print(<span class="stringliteral">&quot;Server: Waiting for client over stdio...&quot;</span>)</div>
<div class="line">    <span class="comment"># 1. Use the stdio_server context manager</span></div>
<div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> stdio_server() <span class="keyword">as</span> (read_stream, write_stream):</div>
<div class="line">        <span class="comment"># 2. It yields streams connected to stdin/stdout</span></div>
<div class="line">        print(<span class="stringliteral">&quot;Server: Stdio streams acquired. Running server logic.&quot;</span>)</div>
<div class="line">        <span class="comment"># 3. Pass streams to the server&#39;s run method</span></div>
<div class="line">        await my_actual_server.run(</div>
<div class="line">            read_stream,</div>
<div class="line">            write_stream,</div>
<div class="line">            my_actual_server.create_initialization_options()</div>
<div class="line">        )</div>
<div class="line">    print(<span class="stringliteral">&quot;Server: Stdio streams closed.&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:</div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        anyio.run(main)</div>
<div class="line">    <span class="keywordflow">except</span> KeyboardInterrupt:</div>
<div class="line">        print(<span class="stringliteral">&quot;Server: Exiting.&quot;</span>)</div>
<div class="ttc" id="anamespacemain_html"><div class="ttname"><a href="../../d2/dc1/namespacemain.html">main</a></div><div class="ttdef"><b>Definition</b> <a href="../../dc/dba/main_8py_source.html#l00001">main.py:1</a></div></div>
</div><!-- fragment --><p><b>Explanation:</b> The <code>stdio_server()</code> context manager handles wrapping the process's standard input and output. It provides the <code>read_stream</code> (to get messages <em>from</em> stdin) and <code>write_stream</code> (to send messages <em>to</em> stdout) that the underlying <code>MCPServer</code> (and thus <code>FastMCP</code>) needs to communicate.</p>
<p><b>Conceptual Server using WebSocket (within a web framework)</b></p>
<div class="fragment"><div class="line"><span class="comment"># Conceptual code using Starlette web framework</span></div>
<div class="line"><span class="keyword">from</span> starlette.applications <span class="keyword">import</span> Starlette</div>
<div class="line"><span class="keyword">from</span> starlette.routing <span class="keyword">import</span> WebSocketRoute</div>
<div class="line"><span class="keyword">from</span> starlette.websockets <span class="keyword">import</span> WebSocket</div>
<div class="line"><span class="keyword">from</span> mcp.server.websocket <span class="keyword">import</span> websocket_server <span class="comment"># Import WS transport</span></div>
<div class="line"><span class="keyword">from</span> mcp.server.mcp_server <span class="keyword">import</span> MCPServer <span class="comment"># Low-level server</span></div>
<div class="line"> </div>
<div class="line">my_actual_server = MCPServer(name=<span class="stringliteral">&quot;MyWebSocketServer&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the WebSocket endpoint handler</span></div>
<div class="line"><span class="keyword">async def </span>websocket_endpoint(websocket: WebSocket):</div>
<div class="line">    <span class="comment"># 1. Use the websocket_server context manager</span></div>
<div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> websocket_server(</div>
<div class="line">        websocket.scope, websocket.receive, websocket.send</div>
<div class="line">    ) <span class="keyword">as</span> (read_stream, write_stream):</div>
<div class="line">        <span class="comment"># 2. It yields streams connected to this specific WebSocket</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;Server: WebSocket client connected. Running server logic.&quot;</span>)</div>
<div class="line">        <span class="comment"># 3. Pass streams to the server&#39;s run method</span></div>
<div class="line">        await my_actual_server.run(</div>
<div class="line">            read_stream,</div>
<div class="line">            write_stream,</div>
<div class="line">            my_actual_server.create_initialization_options()</div>
<div class="line">        )</div>
<div class="line">    print(<span class="stringliteral">&quot;Server: WebSocket client disconnected.&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Set up the web application routes</span></div>
<div class="line">routes = [</div>
<div class="line">    WebSocketRoute(<span class="stringliteral">&quot;/mcp&quot;</span>, endpoint=websocket_endpoint)</div>
<div class="line">]</div>
<div class="line">app = Starlette(routes=routes)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># To run this, you&#39;d use an ASGI server like uvicorn:</span></div>
<div class="line"><span class="comment"># uvicorn your_module:app --host 0.0.0.0 --port 8000</span></div>
</div><!-- fragment --><p><b>Explanation:</b> Here, <code>websocket_server()</code> adapts the WebSocket connection provided by the web framework (Starlette) into the <code>read_stream</code> and <code>write_stream</code> expected by the MCP server. Each connecting client gets its own session handled through this endpoint.</p>
<p><b>Conceptual Test using Memory Transport</b></p>
<div class="fragment"><div class="line"><span class="keyword">import</span> anyio</div>
<div class="line"><span class="keyword">import</span> pytest <span class="comment"># Using pytest testing framework</span></div>
<div class="line"><span class="keyword">from</span> mcp.client.session <span class="keyword">import</span> ClientSession</div>
<div class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP <span class="comment"># Using FastMCP for the server part</span></div>
<div class="line"><span class="keyword">from</span> mcp.shared.memory <span class="keyword">import</span> create_client_server_memory_streams</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define a simple FastMCP server for the test</span></div>
<div class="line">test_server = FastMCP(name=<span class="stringliteral">&quot;TestServer&quot;</span>)</div>
<div class="line"><span class="preprocessor">@test_server.tool()</span></div>
<div class="line"><span class="keyword">def </span>ping() -&gt; str:</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;pong&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@pytest.mark.anyio</span> <span class="comment"># Mark test to be run with anyio</span></div>
<div class="line"><span class="keyword">async def </span>test_memory_transport():</div>
<div class="line">    <span class="comment"># 1. Use the memory stream generator</span></div>
<div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> create_client_server_memory_streams() <span class="keyword">as</span> (</div>
<div class="line">        (client_read, client_write), <span class="comment"># Client perspective</span></div>
<div class="line">        (server_read, server_write)  <span class="comment"># Server perspective</span></div>
<div class="line">    ):</div>
<div class="line">        print(<span class="stringliteral">&quot;Test: Memory streams created.&quot;</span>)</div>
<div class="line">        <span class="comment"># Run server and client concurrently</span></div>
<div class="line">        <span class="keyword">async</span> <span class="keyword">with</span> anyio.create_task_group() <span class="keyword">as</span> tg:</div>
<div class="line">            <span class="comment"># 2. Start the server using its streams</span></div>
<div class="line">            tg.start_soon(</div>
<div class="line">                test_server.run, server_read, server_write,</div>
<div class="line">                test_server.create_initialization_options()</div>
<div class="line">            )</div>
<div class="line">            print(<span class="stringliteral">&quot;Test: Server started in background task.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># 3. Create and run client using its streams</span></div>
<div class="line">            <span class="keyword">async</span> <span class="keyword">with</span> ClientSession(client_read, client_write) <span class="keyword">as</span> client:</div>
<div class="line">                print(<span class="stringliteral">&quot;Test: Client session created. Initializing...&quot;</span>)</div>
<div class="line">                await client.initialize()</div>
<div class="line">                print(<span class="stringliteral">&quot;Test: Client initialized. Calling &#39;ping&#39; tool...&quot;</span>)</div>
<div class="line">                result = await client.call_tool(<span class="stringliteral">&quot;ping&quot;</span>)</div>
<div class="line">                print(f<span class="stringliteral">&quot;Test: Client received result: {result}&quot;</span>)</div>
<div class="line">                <span class="comment"># Assert the result is correct</span></div>
<div class="line">                <span class="keyword">assert</span> result.content[0].text == <span class="stringliteral">&quot;pong&quot;</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment"># Cancel server task when client is done (optional)</span></div>
<div class="line">            tg.cancel_scope.cancel()</div>
<div class="line">        print(<span class="stringliteral">&quot;Test: Finished.&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b> <code>create_client_server_memory_streams()</code> creates pairs of connected in-memory queues. The server writes to <code>server_write</code>, which sends messages to <code>client_read</code>. The client writes to <code>client_write</code>, which sends messages to <code>server_read</code>. This allows direct, in-process communication for testing without actual pipes or network sockets.</p>
<h2><a class="anchor" id="autotoc_md2472"></a>
How Transports Work Under the Hood (Stdio Example)</h2>
<p>Let's focus on the simplest case: <code>stdio</code>. How does the <code>stdio_server</code> context manager actually work?</p>
<ol type="1">
<li><b>Process Startup:</b> When you run <code>mcp run your_server.py</code>, the <code>mcp</code> command starts your <code>your_server.py</code> script as a new process. The operating system connects the <code>stdout</code> of your server process to the <code>stdin</code> of the <code>mcp</code> process (or vice versa, depending on perspective, but essentially creating pipes between them).</li>
<li><b>Context Manager:</b> Inside your server script (when it calls <code>stdio_server()</code>), the context manager gets asynchronous wrappers around the process's standard input (<code>sys.stdin.buffer</code>) and standard output (<code>sys.stdout.buffer</code>), ensuring they handle text encoding (like UTF-8) correctly.</li>
<li><b>Internal Streams:</b> The context manager also creates internal <code>anyio</code> memory streams: <code>read_stream_writer</code> / <code>read_stream</code> and <code>write_stream_reader</code> / <code>write_stream</code>. It yields <code>read_stream</code> and <code>write_stream</code> to your server code.</li>
<li><b>Reader Task (<code>stdin_reader</code>)</b>: The context manager starts a background task that continuously reads lines from the process's actual <code>stdin</code>.<ul>
<li>For each line received:<ul>
<li>It tries to parse the line as a JSON string.</li>
<li>It validates the JSON against the <code>JSONRPCMessage</code> Pydantic model (<a class="el" href="../../de/dcd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_207__mcp__protocol__types.html">Chapter 7</a>).</li>
<li>If valid, it puts the <code>JSONRPCMessage</code> object onto the <code>read_stream_writer</code> (which sends it to the <code>read_stream</code> your server is listening on).</li>
<li>If invalid, it might send an <code>Exception</code> object instead.</li>
</ul>
</li>
</ul>
</li>
<li><b>Writer Task (<code>stdout_writer</code>)</b>: It starts another background task that continuously reads <code>JSONRPCMessage</code> objects from the <code>write_stream_reader</code> (which receives messages your server sends to the <code>write_stream</code>).<ul>
<li>For each message received:<ul>
<li>It serializes the <code>JSONRPCMessage</code> object back into a JSON string.</li>
<li>It adds a newline character (<code>\n</code>) because <code>stdio</code> communication is typically line-based.</li>
<li>It writes the resulting string to the process's actual <code>stdout</code>.</li>
</ul>
</li>
</ul>
</li>
<li><b>Server Interaction:</b> Your <code>MCPServer</code> (or <code>FastMCP</code>) interacts <em>only</em> with the yielded <code>read_stream</code> and <code>write_stream</code>. It doesn't know about <code>stdin</code> or <code>stdout</code> directly. The transport handles the translation between these memory streams and the actual process I/O.</li>
<li><b>Cleanup:</b> When the <code>async with stdio_server()...</code> block finishes, the background reader/writer tasks are stopped, and the streams are closed.</li>
</ol>
<p><b>Simplified Sequence Diagram (Stdio Transport during <code>callTool</code>)</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant ClientProc as Client Process (e.g., mcp CLI)</div>
<div class="line">    participant ClientStdio as Stdio Client Transport</div>
<div class="line">    participant ClientSess as ClientSession</div>
<div class="line">    participant ServerSess as ServerSession</div>
<div class="line">    participant ServerStdio as Stdio Server Transport</div>
<div class="line">    participant ServerProc as Server Process (your_server.py)</div>
<div class="line"> </div>
<div class="line">    Note over ClientProc, ServerProc: OS connects pipes (stdout -&gt; stdin)</div>
<div class="line"> </div>
<div class="line">    ClientSess-&gt;&gt;+ClientStdio: Send CallToolRequest via write_stream</div>
<div class="line">    ClientStdio-&gt;&gt;ClientStdio: Writer task reads from write_stream</div>
<div class="line">    ClientStdio-&gt;&gt;+ClientProc: Serialize &amp; write JSON line to stdout pipe</div>
<div class="line">    ServerProc-&gt;&gt;+ServerStdio: Reader task reads JSON line from stdin pipe</div>
<div class="line">    ServerStdio-&gt;&gt;ServerStdio: Parse &amp; validate JSONRPCMessage</div>
<div class="line">    ServerStdio-&gt;&gt;-ServerSess: Send message via read_stream_writer</div>
<div class="line"> </div>
<div class="line">    Note over ServerSess: Server processes request...</div>
<div class="line"> </div>
<div class="line">    ServerSess-&gt;&gt;+ServerStdio: Send CallToolResult via write_stream</div>
<div class="line">    ServerStdio-&gt;&gt;ServerStdio: Writer task reads from write_stream</div>
<div class="line">    ServerStdio-&gt;&gt;+ServerProc: Serialize &amp; write JSON line to stdout pipe</div>
<div class="line">    ClientProc-&gt;&gt;+ClientStdio: Reader task reads JSON line from stdin pipe</div>
<div class="line">    ClientStdio-&gt;&gt;ClientStdio: Parse &amp; validate JSONRPCMessage</div>
<div class="line">    ClientStdio-&gt;&gt;-ClientSess: Send message via read_stream_writer</div>
</div><!-- fragment --><p>This shows how the transport layers (<code>ClientStdio</code>, <code>ServerStdio</code>) act as intermediaries, translating between the Session's memory streams and the actual process I/O pipes (<code>stdin</code>/<code>stdout</code>). The other transports (SSE, WebSocket, Memory) perform analogous translation tasks for their respective communication mechanisms.</p>
<h2><a class="anchor" id="autotoc_md2473"></a>
Diving into the Code (Briefly!)</h2>
<p>Let's look at the structure inside the transport files.</p>
<p><b><code>server/stdio.py</code> (Simplified <code>stdio_server</code>)</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">@asynccontextmanager</span></div>
<div class="line"><span class="keyword">async def </span>stdio_server(stdin=None, stdout=None):</div>
<div class="line">    <span class="comment"># ... (wrap sys.stdin/stdout if needed) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Create the internal memory streams</span></div>
<div class="line">    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)</div>
<div class="line">    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>stdin_reader(): <span class="comment"># Reads from actual stdin</span></div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="keyword">async</span> <span class="keyword">with</span> read_stream_writer:</div>
<div class="line">                <span class="keyword">async</span> <span class="keywordflow">for</span> line <span class="keywordflow">in</span> stdin: <span class="comment"># Read line from process stdin</span></div>
<div class="line">                    <span class="keywordflow">try</span>:</div>
<div class="line">                        <span class="comment"># Validate and parse</span></div>
<div class="line">                        message = types.JSONRPCMessage.model_validate_json(line)</div>
<div class="line">                    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> exc:</div>
<div class="line">                        await read_stream_writer.send(exc) <span class="comment"># Send error upstream</span></div>
<div class="line">                        <span class="keywordflow">continue</span></div>
<div class="line">                    <span class="comment"># Send valid message to the session via internal stream</span></div>
<div class="line">                    await read_stream_writer.send(message)</div>
<div class="line">        <span class="comment"># ... (error/close handling) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>stdout_writer(): <span class="comment"># Writes to actual stdout</span></div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="keyword">async</span> <span class="keyword">with</span> write_stream_reader:</div>
<div class="line">                <span class="comment"># Read message from the session via internal stream</span></div>
<div class="line">                <span class="keyword">async</span> <span class="keywordflow">for</span> message <span class="keywordflow">in</span> write_stream_reader:</div>
<div class="line">                    <span class="comment"># Serialize to JSON string</span></div>
<div class="line">                    json_str = message.model_dump_json(...)</div>
<div class="line">                    <span class="comment"># Write line to process stdout</span></div>
<div class="line">                    await stdout.write(json_str + <span class="stringliteral">&quot;\n&quot;</span>)</div>
<div class="line">                    await stdout.flush()</div>
<div class="line">        <span class="comment"># ... (error/close handling) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Start reader/writer tasks in the background</span></div>
<div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> anyio.create_task_group() <span class="keyword">as</span> tg:</div>
<div class="line">        tg.start_soon(stdin_reader)</div>
<div class="line">        tg.start_soon(stdout_writer)</div>
<div class="line">        <span class="comment"># Yield the streams the session will use</span></div>
<div class="line">        <span class="keywordflow">yield</span> read_stream, write_stream</div>
<div class="line">        <span class="comment"># Context manager exit cleans up tasks</span></div>
</div><!-- fragment --><p><b><code>shared/memory.py</code> (Simplified <code>create_client_server_memory_streams</code>)</b></p>
<div class="fragment"><div class="line"><span class="preprocessor">@asynccontextmanager</span></div>
<div class="line"><span class="keyword">async def </span>create_client_server_memory_streams():</div>
<div class="line">    <span class="comment"># Create two pairs of connected memory streams</span></div>
<div class="line">    server_to_client_send, server_to_client_receive = anyio.create_memory_object_stream(...)</div>
<div class="line">    client_to_server_send, client_to_server_receive = anyio.create_memory_object_stream(...)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Define the streams from each perspective</span></div>
<div class="line">    client_streams = (server_to_client_receive, client_to_server_send)</div>
<div class="line">    server_streams = (client_to_server_receive, server_to_client_send)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Use async context manager to ensure streams are closed properly</span></div>
<div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> server_to_client_receive, client_to_server_send, \</div>
<div class="line">               client_to_server_receive, server_to_client_send:</div>
<div class="line">        <span class="comment"># Yield the pairs of streams</span></div>
<div class="line">        <span class="keywordflow">yield</span> client_streams, server_streams</div>
<div class="line">    <span class="comment"># Streams are automatically closed on exit</span></div>
</div><!-- fragment --><p>These snippets illustrate the pattern: set up the external communication (or fake it with memory streams), create internal memory streams for the Session, start background tasks to bridge the two, and yield the internal streams.</p>
<h2><a class="anchor" id="autotoc_md2474"></a>
Conclusion</h2>
<p>Congratulations on reaching the end of this introductory series! You've learned about Communication Transports â€“ the crucial delivery services that move MCP messages between clients and servers.</p>
<ul>
<li>Transports are the <b>mechanisms</b> for sending/receiving serialized messages (e.g., <code>stdio</code>, <code>sse</code>, <code>websocket</code>, <code>memory</code>).</li>
<li>Each transport suits different scenarios (command-line, web, testing).</li>
<li>Frameworks like <code>FastMCP</code> and tools like <code>mcp run</code> often handle the <b>default transport (<code>stdio</code>) automatically</b>.</li>
<li>Transports work by <b>bridging</b> the gap between the <code>Session</code>'s internal communication streams and the actual external I/O (pipes, sockets, queues).</li>
</ul>
<p>Understanding transports completes the picture of how MCP components fit together, from high-level abstractions like <code>FastMCP</code> down to the way messages are physically exchanged.</p>
<p>You now have a solid foundation in the core concepts of the <code>MCP Python SDK</code>. From here, you can delve deeper into specific features, explore more complex examples, or start building your own powerful AI tools and integrations! Good luck!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
