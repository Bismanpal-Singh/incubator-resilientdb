#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_flow___flow____asyncflow___</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_204__flow______flow________asyncflow______.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_flow___flow____asyncflow___</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2753"></a>
autotoc_md2753</h2>
<p>layout: default title: "Flow (Flow, AsyncFlow)" parent: "PocketFlow" </p>
<h2><a class="anchor" id="autotoc_md2754"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md2755"></a>
Chapter 4: Flow (<code>Flow</code>, <code>AsyncFlow</code>)</h1>
<p>In Chapter 3: Actions / Transitions, we saw how individual Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) can decide what should happen next by returning "action" strings, and how these actions lead to "transitions" between Nodes. But what actually manages this sequence? What's the conductor of this orchestra of Nodes? That's where <b>Flows</b> come in!</p>
<h2><a class="anchor" id="autotoc_md2756"></a>
What Problem Do Flows Solve? Meet the Orchestrator!</h2>
<p>Imagine you're building a simple AI application that interacts with a user:</p><ol type="1">
<li><b>Greet User Node</b>: Displays a welcome message.</li>
<li><b>Get Name Node</b>: Asks the user for their name and stores it.</li>
<li><b>Personalized Message Node</b>: Uses the name to give a personalized response.</li>
</ol>
<p>Each step is a Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>). But how do you ensure they run in the correct order? How does the "Get Name Node" know to run after "Greet User Node", and how is the name passed along? This is the job of a <b>Flow</b>.</p>
<p>A <b>Flow</b> is like the <b>blueprint</b> or the <b>manager</b> of an assembly line. It defines the sequence of operations by connecting multiple Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) into a complete workflow. It dictates:</p><ul>
<li>Which Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) starts the process.</li>
<li>How to move from one Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) to another based on the Actions / Transitions we learned about.</li>
<li>It ensures the <a class="el" href="../../d1/d94/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_201__shared__state______shared____dictionary____.html">shared dictionary</a> is passed along, so all Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) have access to the data they need.</li>
</ul>
<p>PocketFlow offers two main types of Flows:</p><ul>
<li><b><code>Flow</code></b>: For workflows that consist primarily of synchronous Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) (tasks that run one after another, blocking until complete).</li>
<li><b><code>AsyncFlow</code></b>: For workflows that include asynchronous Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) (tasks that can "pause" and let other operations run, like waiting for user input or a network request).</li>
</ul>
<p>Let's see how to build and use them!</p>
<h2><a class="anchor" id="autotoc_md2757"></a>
Building Your First <code>Flow</code></h2>
<p>Let's create a simple text transformation workflow using <code>Flow</code>. It will:</p><ol type="1">
<li>Get text input from the user.</li>
<li>Offer transformation choices (uppercase, lowercase, etc.).</li>
<li>Transform the text.</li>
<li>Ask if the user wants to do another transformation or exit.</li>
</ol>
<p>This example is inspired by <code>cookbook/pocketflow-flow/flow.py</code>.</p>
<p><b>Step 1: Define Your Nodes</b></p>
<p>First, we need our worker Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>). (We'll use conceptual Node definitions here for brevity; refer to Chapter 2 for Node details).</p>
<div class="fragment"><div class="line"><span class="comment"># Assume these Nodes are defined (simplified from cookbook/pocketflow-flow/flow.py)</span></div>
<div class="line"><span class="comment"># from pocketflow import Node</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>TextInput(Node): <span class="comment"># Gets input and choice</span></div>
<div class="line">    <span class="keyword">def </span>post(self, shared, prep_res, exec_res):</div>
<div class="line">        <span class="comment"># ... (gets user input for text and choice) ...</span></div>
<div class="line">        <span class="comment"># shared[&quot;text&quot;] = user_text</span></div>
<div class="line">        <span class="comment"># shared[&quot;choice&quot;] = user_choice</span></div>
<div class="line">        <span class="keywordflow">if</span> shared[<span class="stringliteral">&quot;choice&quot;</span>] == <span class="stringliteral">&quot;5&quot;</span>: <span class="comment"># Exit choice</span></div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;exit&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;transform&quot;</span> <span class="comment"># Action to proceed to transformation</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>TextTransform(Node): <span class="comment"># Transforms text based on choice</span></div>
<div class="line">    <span class="keyword">def </span>post(self, shared, prep_res, exec_res):</div>
<div class="line">        <span class="comment"># ... (transforms text, prints result) ...</span></div>
<div class="line">        <span class="comment"># shared[&quot;transformed_text&quot;] = result</span></div>
<div class="line">        <span class="keywordflow">if</span> input(<span class="stringliteral">&quot;Convert another? (y/n): &quot;</span>) == <span class="stringliteral">&#39;y&#39;</span>:</div>
<div class="line">            shared.pop(<span class="stringliteral">&quot;text&quot;</span>, <span class="keywordtype">None</span>) <span class="comment"># Clear for next input</span></div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;input&quot;</span> <span class="comment"># Action to go back to TextInput</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;exit&quot;</span> <span class="comment"># Action to end</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EndNode(Node): <span class="comment"># A simple Node to mark the end</span></div>
<div class="line">    <span class="keywordflow">pass</span></div>
</div><!-- fragment --><ul>
<li><code>TextInput</code>: Its <code>post</code> method will return <code>"transform"</code> to move to the <code>TextTransform</code> Node, or <code>"exit"</code>.</li>
<li><code>TextTransform</code>: Its <code>post</code> method will return <code>"input"</code> to loop back to <code>TextInput</code>, or <code>"exit"</code>.</li>
</ul>
<p><b>Step 2: Instantiate Your Nodes</b></p>
<p>Create an instance of each Node class: </p><div class="fragment"><div class="line">text_input = TextInput()</div>
<div class="line">text_transform = TextTransform()</div>
<div class="line">end_node = EndNode()</div>
</div><!-- fragment --><p><b>Step 3: Connect Nodes Using Transitions</b></p>
<p>Now, tell PocketFlow how these Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) connect based on the actions they return. We learned this in Chapter 3: Actions / Transitions.</p>
<div class="fragment"><div class="line"><span class="comment"># If text_input returns &quot;transform&quot;, go to text_transform</span></div>
<div class="line">text_input - <span class="stringliteral">&quot;transform&quot;</span> &gt;&gt; text_transform</div>
<div class="line"><span class="comment"># If text_input returns &quot;exit&quot; (or any other unhandled action by default for this setup)</span></div>
<div class="line"><span class="comment"># we&#39;ll eventually want it to go to end_node or the flow just ends.</span></div>
<div class="line"><span class="comment"># For simplicity here, let&#39;s make &quot;exit&quot; explicit if we want a dedicated end.</span></div>
<div class="line">text_input - <span class="stringliteral">&quot;exit&quot;</span> &gt;&gt; end_node <span class="comment"># Or simply let it end if no &quot;exit&quot; transition</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># If text_transform returns &quot;input&quot;, go back to text_input</span></div>
<div class="line">text_transform - <span class="stringliteral">&quot;input&quot;</span> &gt;&gt; text_input</div>
<div class="line"><span class="comment"># If text_transform returns &quot;exit&quot;, go to end_node</span></div>
<div class="line">text_transform - <span class="stringliteral">&quot;exit&quot;</span> &gt;&gt; end_node</div>
</div><!-- fragment --><p><b>Step 4: Create the <code>Flow</code></b></p>
<p>Now, create an instance of the <code>Flow</code> class, telling it which Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) to start with.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pocketflow <span class="keyword">import</span> Flow</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the flow, starting with the text_input node</span></div>
<div class="line">app_flow = Flow(start=text_input)</div>
</div><!-- fragment --><p> And that's it! <code>app_flow</code> is now a complete, runnable workflow.</p>
<p><b>Step 5: Run the <code>Flow</code></b></p>
<p>To execute your workflow, you call its <code>run</code> method, usually with an initial <a class="el" href="../../d1/d94/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_201__shared__state______shared____dictionary____.html">shared dictionary</a>.</p>
<div class="fragment"><div class="line">initial_shared_data = {} <span class="comment"># Start with an empty shared dictionary</span></div>
<div class="line">app_flow.run(initial_shared_data)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># After the flow finishes, initial_shared_data might contain final results</span></div>
<div class="line"><span class="comment"># if your nodes were designed to store them there.</span></div>
<div class="line">print(<span class="stringliteral">&quot;Flow finished!&quot;</span>)</div>
</div><!-- fragment --><p> When you run this:</p><ol type="1">
<li><code>app_flow</code> will start with <code>text_input</code>.</li>
<li><code>text_input</code> will execute (prompting you for text and choice).</li>
<li>Based on the action returned by <code>text_input</code> (e.g., <code>"transform"</code>), the <code>Flow</code> will look at the transitions you defined and execute the next Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) (e.g., <code>text_transform</code>).</li>
<li>This continues until a Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) returns an action for which no transition is defined, or it transitions to a Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) like <code>end_node</code> that doesn't lead anywhere else.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2758"></a>
Orchestrating Asynchronous Tasks with <code>AsyncFlow</code></h2>
<p>What if your workflow involves tasks that wait for external operations, like fetching data from a website or waiting for a user to type something slowly? If you use a regular <code>Flow</code> and synchronous Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) for these, your whole application would freeze during these waits.</p>
<p>This is where <code>AsyncFlow</code> and <a class="el" href="../../d7/d6d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_205__asynchronous__processing___dbf1dc61cb3bcd98d46655d3ab8e2dd9.html">Asynchronous Processing (<code>AsyncNode</code>, <code>AsyncFlow</code>)</a> come in. <code>AsyncFlow</code> is designed to work with <code>AsyncNode</code>s, which can perform tasks asynchronously.</p>
<p>Let's look at a conceptual recipe finder flow (inspired by <code>cookbook/pocketflow-async-basic/flow.py</code>).</p>
<p><b>Step 1: Define Your AsyncNodes</b> You'd define Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) using <code>AsyncNode</code> and <code>async def</code> methods.</p>
<div class="fragment"><div class="line"><span class="comment"># from pocketflow import AsyncNode, Node</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>FetchRecipes(AsyncNode): <span class="comment"># Gets ingredient &amp; fetches recipes (async)</span></div>
<div class="line">    <span class="keyword">async def </span>post_async(self, shared, prep_res, exec_res):</div>
<div class="line">        <span class="comment"># ... (stores recipes in shared) ...</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;suggest&quot;</span> <span class="comment"># Action to suggest a recipe</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SuggestRecipe(Node): <span class="comment"># Suggests a recipe (can be sync)</span></div>
<div class="line">    <span class="keyword">def </span>post(self, shared, prep_res, exec_res):</div>
<div class="line">        <span class="comment"># ... (prints suggestion) ...</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;approve&quot;</span> <span class="comment"># Action to get approval</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>GetApproval(AsyncNode): <span class="comment"># Gets user approval (async)</span></div>
<div class="line">    <span class="keyword">async def </span>post_async(self, shared, prep_res, exec_res):</div>
<div class="line">        <span class="comment"># ... (gets approval) ...</span></div>
<div class="line">        <span class="keywordflow">if</span> approved: <span class="keywordflow">return</span> <span class="stringliteral">&quot;accept&quot;</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;retry&quot;</span> <span class="comment"># Action to suggest another</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EndFlowNode(Node): <span class="keyword">pass</span> <span class="comment"># Simple synchronous end node</span></div>
</div><!-- fragment --><p><b>Step 2 &amp; 3: Instantiate and Connect</b> This is very similar to <code>Flow</code>:</p>
<div class="fragment"><div class="line">fetch_recipes = FetchRecipes()</div>
<div class="line">suggest_recipe = SuggestRecipe()</div>
<div class="line">get_approval = GetApproval()</div>
<div class="line">end_node = EndFlowNode()</div>
<div class="line"> </div>
<div class="line">fetch_recipes - <span class="stringliteral">&quot;suggest&quot;</span> &gt;&gt; suggest_recipe</div>
<div class="line">suggest_recipe - <span class="stringliteral">&quot;approve&quot;</span> &gt;&gt; get_approval</div>
<div class="line">get_approval - <span class="stringliteral">&quot;retry&quot;</span> &gt;&gt; suggest_recipe <span class="comment"># Loop back</span></div>
<div class="line">get_approval - <span class="stringliteral">&quot;accept&quot;</span> &gt;&gt; end_node</div>
</div><!-- fragment --><p><b>Step 4: Create the <code>AsyncFlow</code></b></p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pocketflow <span class="keyword">import</span> AsyncFlow</div>
<div class="line"> </div>
<div class="line">recipe_flow = AsyncFlow(start=fetch_recipes)</div>
</div><!-- fragment --><p> Notice we use <code>AsyncFlow</code> here.</p>
<p><b>Step 5: Run the <code>AsyncFlow</code></b></p>
<p>Running an <code>AsyncFlow</code> involves <code>async</code> and <code>await</code> because the flow itself is asynchronous.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span><a class="code hl_namespace" href="../../d2/dc1/namespacemain.html">main</a>():</div>
<div class="line">    initial_shared = {}</div>
<div class="line">    await recipe_flow.run_async(initial_shared) <span class="comment"># Use run_async()</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Recipe flow finished!&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># To run the main async function</span></div>
<div class="line"><span class="comment"># asyncio.run(main())</span></div>
<div class="ttc" id="anamespacemain_html"><div class="ttname"><a href="../../d2/dc1/namespacemain.html">main</a></div><div class="ttdef"><b>Definition</b> <a href="../../dc/dba/main_8py_source.html#l00001">main.py:1</a></div></div>
</div><!-- fragment --><p> The <code>AsyncFlow</code> will manage the <code>AsyncNode</code>s, allowing them to <code>await</code> their operations without blocking the entire event loop (if you're running other async tasks). We'll explore this more in <a class="el" href="../../d7/d6d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_205__asynchronous__processing___dbf1dc61cb3bcd98d46655d3ab8e2dd9.html">Chapter 5: Asynchronous Processing (<code>AsyncNode</code>, <code>AsyncFlow</code>)</a>.</p>
<h2><a class="anchor" id="autotoc_md2759"></a>
Nesting Flows: Managing Complexity</h2>
<p>What if your workflow becomes very large and complex? You can break it down! A <b>Flow can itself be treated as a Node and nested within another Flow.</b> This is like having a project manager who oversees several team leads, and each team lead manages their own team's tasks.</p>
<p>Consider the <code>cookbook/pocketflow-supervisor/flow.py</code> example. It has an <code>agent_inner_flow</code> which handles research, and then an outer <code>Flow</code> that uses this <code>agent_inner_flow</code> as a step, followed by a <code>SupervisorNode</code> to check the agent's work.</p>
<div class="fragment"><div class="line"><span class="comment"># Conceptual: from cookbook/pocketflow-supervisor/flow.py</span></div>
<div class="line"><span class="comment"># agent_inner_flow is a complete Flow instance itself</span></div>
<div class="line">agent_inner_flow = create_agent_inner_flow() </div>
<div class="line">supervisor = SupervisorNode()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># The inner flow is treated like a node in the outer flow&#39;s transitions</span></div>
<div class="line">agent_inner_flow &gt;&gt; supervisor <span class="comment"># Default transition</span></div>
<div class="line">supervisor - <span class="stringliteral">&quot;retry&quot;</span> &gt;&gt; agent_inner_flow</div>
<div class="line"> </div>
<div class="line">supervised_flow = Flow(start=agent_inner_flow)</div>
</div><!-- fragment --><p> Here, <code>agent_inner_flow</code> runs completely. When it finishes, the <code>supervised_flow</code> transitions to the <code>supervisor</code> Node. This is a powerful way to create hierarchical and modular workflows.</p>
<h2><a class="anchor" id="autotoc_md2760"></a>
Under the Hood: How Do Flows Orchestrate?</h2>
<p>At its core, a <code>Flow</code> (or <code>AsyncFlow</code>) runs a loop that:</p><ol type="1">
<li>Identifies the current Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) to run (starting with its <code>start_node</code>).</li>
<li>Executes this Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) (which involves its <code>prep</code>, <code>exec</code>, and <code>post</code> methods).</li>
<li>Gets the "action" string returned by the Node's <code>post</code> method.</li>
<li>Uses this action string to look up the <em>next</em> Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) based on the transitions you defined (e.g., <code>current_node - "action" &gt;&gt; next_node</code>).</li>
<li>If a next Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) is found, it becomes the current Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>), and the loop continues.</li>
<li>If no next Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) is found (no matching transition), the flow (or that branch of it) ends.</li>
</ol>
<p>Here's a simplified sequence diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant You</div>
<div class="line">    participant MyFlow as Flow Object</div>
<div class="line">    participant NodeA as Start Node</div>
<div class="line">    participant NodeB as Next Node</div>
<div class="line">    participant SharedDict as Shared Dictionary</div>
<div class="line"> </div>
<div class="line">    You-&gt;&gt;MyFlow: flow.run(initial_shared)</div>
<div class="line">    MyFlow-&gt;&gt;SharedDict: Initialize with initial_shared</div>
<div class="line">    MyFlow-&gt;&gt;NodeA: _run(SharedDict)</div>
<div class="line">    NodeA--&gt;&gt;MyFlow: returns action_A (from NodeA&#39;s post method)</div>
<div class="line">    MyFlow-&gt;&gt;MyFlow: get_next_node(NodeA, action_A)</div>
<div class="line">    Note right of MyFlow: Finds NodeB based on NodeA&#39;s transitions</div>
<div class="line">    MyFlow-&gt;&gt;NodeB: _run(SharedDict)</div>
<div class="line">    NodeB--&gt;&gt;MyFlow: returns action_B (from NodeB&#39;s post method)</div>
<div class="line">    MyFlow-&gt;&gt;MyFlow: get_next_node(NodeB, action_B)</div>
<div class="line">    Note right of MyFlow: No more nodes or no transition found. Flow ends.</div>
<div class="line">    MyFlow--&gt;&gt;You: Flow execution complete</div>
</div><!-- fragment --><p><b>A Glimpse into the Code (<code>pocketflow/__init__.py</code>):</b></p>
<p>The <code>Flow</code> class inherits from <code>BaseNode</code>, so it also has <code>prep</code>, <code>exec</code>, <code>post</code> methods. Its main job is done in its orchestration logic.</p>
<ol type="1">
<li><b>Initialization:</b> When you create a <code>Flow</code>, you give it a starting Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>). <code>python @section autotoc_md2761 Inside Flow class def __init__(self, start=None): super().__init__() # Initialize BaseNode parts self.start_node = start # Store the starting node </code></li>
<li><b>Getting the Next Node:</b> The <code>get_next_node</code> method is crucial. It checks the current node's <code>successors</code> dictionary (which was populated by your transition definitions like <code>nodeA - "action" &gt;&gt; nodeB</code>). <code>python @section autotoc_md2762 Inside Flow class def get_next_node(self, current_node, action_str): @section autotoc_md2763 Try specific action, then "default" next_node = current_node.successors.get(action_str) if not next_node: # If specific action's successor not found next_node = current_node.successors.get("default") @section autotoc_md2764 ... (warnings if no successor found but some exist) ... return next_node </code></li>
<li><b>The Orchestration Loop (<code>_orch</code>):</b> This is the heart of the <code>Flow</code>. <code>python @section autotoc_md2765 Inside Flow class (simplified) def _orch(self, shared, params=None): current_node = self.start_node last_action = None while current_node: @section autotoc_md2766 ... (set parameters for current_node if any) ... last_action = current_node._run(shared) # Run the node @section autotoc_md2767 Get the next node based on the action from the current one current_node = self.get_next_node(current_node, last_action) return last_action # Returns the very last action from the flow </code> The <code>current_node._run(shared)</code> call is what executes the <code>prep -&gt; exec -&gt; post</code> cycle of that Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>).</li>
</ol>
<p>For <code>AsyncFlow</code>, the structure is very similar. It has an <code>_orch_async</code> method: </p><div class="fragment"><div class="line"><span class="comment"># Inside AsyncFlow class (conceptual)</span></div>
<div class="line"><span class="keyword">async def </span>_orch_async(self, shared, params=None):</div>
<div class="line">    current_node = self.start_node</div>
<div class="line">    last_action = <span class="keywordtype">None</span></div>
<div class="line">    <span class="keywordflow">while</span> current_node:</div>
<div class="line">        <span class="comment"># ...</span></div>
<div class="line">        <span class="keywordflow">if</span> isinstance(current_node, AsyncNode):</div>
<div class="line">            last_action = await current_node._run_async(shared) <span class="comment"># Await async nodes</span></div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            last_action = current_node._run(shared) <span class="comment"># Run sync nodes normally</span></div>
<div class="line">        current_node = self.get_next_node(current_node, last_action)</div>
<div class="line">    <span class="keywordflow">return</span> last_action</div>
</div><!-- fragment --><p> The key difference is that it <code>await</code>s the <code>_run_async</code> method of <code>AsyncNode</code>s, allowing for non-blocking execution.</p>
<h2><a class="anchor" id="autotoc_md2768"></a>
Conclusion</h2>
<p>You've now learned about <b><code>Flow</code></b> and <b><code>AsyncFlow</code></b>, the orchestrators that bring your Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) together to form complete, dynamic workflows!</p><ul>
<li>Flows define the sequence and logic of how Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) are executed.</li>
<li>They use the "action" strings returned by Nodes (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) and the transition rules you define (e.g., <code>nodeA - "action" &gt;&gt; nodeB</code>) to decide the path of execution.</li>
<li><code>Flow</code> is for synchronous workflows, while <code>AsyncFlow</code> handles workflows with asynchronous tasks using <code>AsyncNode</code>s.</li>
<li>Flows can be nested to manage complexity.</li>
</ul>
<p>With Flows, you can build anything from simple linear sequences to complex, branching, and looping AI applications.</p>
<p>In the next chapter, we'll take a much deeper dive into the world of asynchronous operations specifically, exploring how <code>AsyncNode</code> and <code>AsyncFlow</code> enable you to build responsive, I/O-bound applications efficiently.</p>
<p>Next up: <a class="el" href="../../d7/d6d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_205__asynchronous__processing___dbf1dc61cb3bcd98d46655d3ab8e2dd9.html">Chapter 5: Asynchronous Processing (<code>AsyncNode</code>, <code>AsyncFlow</code>)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
