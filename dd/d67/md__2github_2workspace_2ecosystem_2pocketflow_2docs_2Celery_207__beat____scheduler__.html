#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 07_beat__scheduler_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/d67/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_207__beat____scheduler__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">07_beat__scheduler_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1083"></a>
autotoc_md1083</h2>
<p>layout: default title: "Beat (Scheduler)" parent: "Celery" </p>
<h2><a class="anchor" id="autotoc_md1084"></a>
nav_order: 7</h2>
<h1><a class="anchor" id="autotoc_md1085"></a>
Chapter 7: Beat (Scheduler) - Celery's Alarm Clock</h1>
<p>In the last chapter, <a class="el" href="../../d3/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_206__result__backend.html">Chapter 6: Result Backend</a>, we learned how to track the status and retrieve the results of our background tasks. This is great when we manually trigger tasks from our application. But what if we want tasks to run automatically, without us needing to press a button every time?</p>
<p>Maybe you need to:</p><ul>
<li>Send out a newsletter email every Friday morning.</li>
<li>Clean up temporary files in your system every night.</li>
<li>Check the health of your external services every 5 minutes.</li>
</ul>
<p>How can you make Celery do these things on a regular schedule? Meet <b>Celery Beat</b>.</p>
<h2><a class="anchor" id="autotoc_md1086"></a>
What Problem Does Beat Solve?</h2>
<p>Imagine you have a task, say <code>send_daily_report()</code>, that needs to run every morning at 8:00 AM. How would you achieve this? You could try setting up a system <code>cron</code> job to call a Python script that sends the Celery task, but that adds another layer of complexity.</p>
<p>Celery provides its own built-in solution: <b>Beat</b>.</p>
<p><b>Beat is Celery's periodic task scheduler.</b> Think of it like a dedicated alarm clock or a <code>cron</code> job system built specifically for triggering Celery tasks. It's a separate program that you run alongside your workers. Its job is simple:</p>
<ol type="1">
<li>Read a list of scheduled tasks (e.g., "run `send_daily_report` every day at 8:00 AM").</li>
<li>Keep track of the time.</li>
<li>When the time comes for a scheduled task, Beat sends the task message to the <a class="el" href="../../d3/dd5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_204__broker__connection____amqp__.html">Broker Connection (AMQP)</a>, just as if you had called <code>.delay()</code> yourself.</li>
<li>A regular Celery <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a> then picks up the task from the broker and executes it.</li>
</ol>
<p>Beat doesn't run the tasks itself; it just <em>schedules</em> them by sending the messages at the right time.</p>
<h2><a class="anchor" id="autotoc_md1087"></a>
Key Concepts</h2>
<ol type="1">
<li><b>Beat Process:</b> A separate Celery program you run (like <code>celery -A your_app beat</code>). It needs access to your Celery app's configuration.</li>
<li><b>Schedule:</b> A configuration setting (usually <code>beat_schedule</code> in your Celery config) that defines which tasks should run and when. This schedule can use simple intervals (like every 30 seconds) or cron-like patterns (like "every Monday at 9 AM").</li>
<li><b>Schedule Storage:</b> Beat needs to remember when each task was last run so it knows when it's due again. By default, it saves this information to a local file named <code>celerybeat-schedule</code> (using Python's <code>shelve</code> module).</li>
<li><b>Ticker:</b> The heart of Beat. It's an internal loop that wakes up periodically, checks the schedule against the current time, and sends messages for any due tasks.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1088"></a>
How to Use Beat</h2>
<p>Let's schedule two tasks:</p><ul>
<li>Our <code>add</code> task from <a class="el" href="../../d5/db8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_203__task.html">Chapter 3: Task</a> to run every 15 seconds.</li>
<li>A new (dummy) task <code>send_report</code> to run every minute.</li>
</ul>
<p><b>1. Define the Schedule in Configuration</b></p>
<p>The best place to define your schedule is in your configuration, either directly on the <code>app</code> object or in a separate <code>celeryconfig.py</code> file (see <a class="el" href="../../d7/df5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_202__configuration.html">Chapter 2: Configuration</a>). We'll use a separate file.</p>
<p>First, create the new task in your <code>tasks.py</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># tasks.py (add this new task)</span></div>
<div class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app</div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>add(x, y):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;A simple task that adds two numbers.&quot;&quot;&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Task &#39;add&#39; starting with ({x}, {y})&quot;</span>)</div>
<div class="line">    time.sleep(2) <span class="comment"># Simulate short work</span></div>
<div class="line">    result = x + y</div>
<div class="line">    print(f<span class="stringliteral">&quot;Task &#39;add&#39; finished with result: {result}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> result</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>send_report(name):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;A task simulating sending a report.&quot;&quot;&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Task &#39;send_report&#39; starting for report: {name}&quot;</span>)</div>
<div class="line">    time.sleep(5) <span class="comment"># Simulate longer work</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Report &#39;{name}&#39; supposedly sent.&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> f<span class="stringliteral">&quot;Report {name} sent.&quot;</span></div>
</div><!-- fragment --><p>Now, update or create <code>celeryconfig.py</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># celeryconfig.py</span></div>
<div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</div>
<div class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Basic Broker/Backend settings (replace with your actual URLs)</span></div>
<div class="line">broker_url = <span class="stringliteral">&#39;redis://localhost:6379/0&#39;</span></div>
<div class="line">result_backend = <span class="stringliteral">&#39;redis://localhost:6379/1&#39;</span></div>
<div class="line">timezone = <span class="stringliteral">&#39;UTC&#39;</span> <span class="comment"># Or your preferred timezone, e.g., &#39;America/New_York&#39;</span></div>
<div class="line">enable_utc = <span class="keyword">True</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># List of modules to import when the Celery worker starts.</span></div>
<div class="line"><span class="comment"># Make sure tasks.py is discoverable in your Python path</span></div>
<div class="line">imports = (<span class="stringliteral">&#39;tasks&#39;</span>,)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the Beat schedule</span></div>
<div class="line">beat_schedule = {</div>
<div class="line">    <span class="comment"># Executes tasks.add every 15 seconds with arguments (16, 16)</span></div>
<div class="line">    <span class="stringliteral">&#39;add-every-15-seconds&#39;</span>: {</div>
<div class="line">        <span class="stringliteral">&#39;task&#39;</span>: <span class="stringliteral">&#39;tasks.add&#39;</span>,          <span class="comment"># The task name</span></div>
<div class="line">        <span class="stringliteral">&#39;schedule&#39;</span>: 15.0,             <span class="comment"># Run every 15 seconds (float or timedelta)</span></div>
<div class="line">        <span class="stringliteral">&#39;args&#39;</span>: (16, 16),             <span class="comment"># Positional arguments for the task</span></div>
<div class="line">    },</div>
<div class="line">    <span class="comment"># Executes tasks.send_report every minute</span></div>
<div class="line">    <span class="stringliteral">&#39;send-report-every-minute&#39;</span>: {</div>
<div class="line">        <span class="stringliteral">&#39;task&#39;</span>: <span class="stringliteral">&#39;tasks.send_report&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;schedule&#39;</span>: crontab(),        <span class="comment"># Use crontab() for &quot;every minute&quot;</span></div>
<div class="line">        <span class="stringliteral">&#39;args&#39;</span>: (<span class="stringliteral">&#39;daily-summary&#39;</span>,),   <span class="comment"># Argument for the report name</span></div>
<div class="line">        <span class="comment"># Example using crontab for more specific timing:</span></div>
<div class="line">        <span class="comment"># &#39;schedule&#39;: crontab(hour=8, minute=0, day_of_week=&#39;fri&#39;), # Every Friday at 8:00 AM</span></div>
<div class="line">    },</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>from datetime import timedelta</code>: Used for simple interval schedules.</li>
<li><code>from celery.schedules import crontab</code>: Used for cron-like scheduling.</li>
<li>&lsquo;imports = ('tasks&rsquo;,)<code>: Ensures the worker and beat know about the tasks defined in</code>tasks.py<code>. *</code>beat_schedule = {...}<code>: This dictionary holds all your scheduled tasks.<ul>
<li>Each key (</li>
</ul>
</code>'add-every-15-seconds'<code>,</code>'send-report-every-minute'<code>) is a unique name for the schedule entry.<ul>
<li>Each value is another dictionary describing the schedule: *</li>
</ul>
</code>'task'<code>: The full name of the task to run (e.g.,</code>'module_name.task_name'<code>). *</code>'schedule'<code>: Defines *when* to run.<ul>
<li>A</li>
</ul>
</code>float<code>or</code>int<code>: number of seconds between runs.<ul>
<li>A</li>
</ul>
</code>timedelta<code>object: the time interval between runs.<ul>
<li>A</li>
</ul>
</code>crontab<code>object: for complex schedules (minute, hour, day_of_week, etc.).</code>crontab()<code>with no arguments means "every minute". *</code>'args'<code>: A tuple of positional arguments to pass to the task. *</code>'kwargs'<code>: (Optional) A dictionary of keyword arguments to pass to the task. *</code>'options'<code>: (Optional) A dictionary of execution options like</code>queue<code>,</code>priority`.</li>
</ul>
<p><b>2. Load the Configuration in Your App</b></p>
<p>Make sure your <code>celery_app.py</code> loads this configuration:</p>
<div class="fragment"><div class="line"><span class="comment"># celery_app.py</span></div>
<div class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the app instance</span></div>
<div class="line">app = Celery(<span class="stringliteral">&#39;tasks&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Load configuration from the &#39;celeryconfig&#39; module</span></div>
<div class="line">app.config_from_object(<span class="stringliteral">&#39;celeryconfig&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Tasks might be defined here, but we put them in tasks.py</span></div>
<div class="line"><span class="comment"># which is loaded via the &#39;imports&#39; setting in celeryconfig.py</span></div>
</div><!-- fragment --><p><b>3. Run Celery Beat</b></p>
<p>Now, open a terminal and run the Beat process. You need to tell it where your app is (<code>-A celery_app</code>):</p>
<div class="fragment"><div class="line"># In your terminal</div>
<div class="line">celery -A celery_app beat --loglevel=info</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>celery</code>: The Celery command-line tool.</li>
<li><code>-A celery_app</code>: Points to your app instance (in <code>celery_app.py</code>).</li>
<li><code>beat</code>: Tells Celery to start the scheduler process.</li>
<li><code>--loglevel=info</code>: Shows informational messages about what Beat is doing.</li>
</ul>
<p>You'll see output similar to this:</p>
<div class="fragment"><div class="line">celery beat v5.x.x is starting.</div>
<div class="line">__    -    ... __   -        _</div>
<div class="line">LocalTime -&gt; 2023-10-27 11:00:00</div>
<div class="line">Configuration -&gt;</div>
<div class="line">    . broker -&gt; redis://localhost:6379/0</div>
<div class="line">    . loader -&gt; celery.loaders.app.AppLoader</div>
<div class="line">    . scheduler -&gt; celery.beat.PersistentScheduler</div>
<div class="line">    . db -&gt; celerybeat-schedule</div>
<div class="line">    . logfile -&gt; [stderr]@INFO</div>
<div class="line">    . maxinterval -&gt; 300.0s (5m0s)</div>
<div class="line">celery beat v5.x.x has started.</div>
</div><!-- fragment --><p>Beat is now running! It will check the schedule and:</p><ul>
<li>Every 15 seconds, it will send a message to run <code>tasks.add(16, 16)</code>.</li>
<li>Every minute, it will send a message to run &lsquo;tasks.send_report('daily-summary&rsquo;)`.</li>
</ul>
<p><b>4. Run a Worker (Crucial!)</b></p>
<p>Beat only <em>sends</em> the task messages. You still need a <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a> running to actually <em>execute</em> the tasks. Open <b>another terminal</b> and start a worker:</p>
<div class="fragment"><div class="line"># In a SECOND terminal</div>
<div class="line">celery -A celery_app worker --loglevel=info</div>
</div><!-- fragment --><p>Now, watch the output in the <b>worker's terminal</b>. You should see logs appearing periodically as the worker receives and executes the tasks sent by Beat:</p>
<div class="fragment"><div class="line"># Output in the WORKER terminal (example)</div>
<div class="line">[2023-10-27 11:00:15,000: INFO/MainProcess] Task tasks.add[task-id-1] received</div>
<div class="line">Task &#39;add&#39; starting with (16, 16)</div>
<div class="line">Task &#39;add&#39; finished with result: 32</div>
<div class="line">[2023-10-27 11:00:17,050: INFO/MainProcess] Task tasks.add[task-id-1] succeeded in 2.05s: 32</div>
<div class="line"> </div>
<div class="line">[2023-10-27 11:01:00,000: INFO/MainProcess] Task tasks.send_report[task-id-2] received</div>
<div class="line">Task &#39;send_report&#39; starting for report: daily-summary</div>
<div class="line">[2023-10-27 11:01:00,000: INFO/MainProcess] Task tasks.add[task-id-3] received  # Another &#39;add&#39; task might arrive while &#39;send_report&#39; runs</div>
<div class="line">Task &#39;add&#39; starting with (16, 16)</div>
<div class="line">Task &#39;add&#39; finished with result: 32</div>
<div class="line">[2023-10-27 11:01:02,050: INFO/MainProcess] Task tasks.add[task-id-3] succeeded in 2.05s: 32</div>
<div class="line">Report &#39;daily-summary&#39; supposedly sent.</div>
<div class="line">[2023-10-27 11:01:05,100: INFO/MainProcess] Task tasks.send_report[task-id-2] succeeded in 5.10s: &quot;Report daily-summary sent.&quot;</div>
<div class="line">... and so on ...</div>
</div><!-- fragment --><p>You have successfully set up scheduled tasks!</p>
<h2><a class="anchor" id="autotoc_md1089"></a>
How It Works Internally (Simplified)</h2>
<ol type="1">
<li><b>Startup:</b> You run <code>celery -A celery_app beat</code>. The Beat process starts.</li>
<li><b>Load Config:</b> It loads the Celery app (<code>celery_app</code>) and reads its configuration, paying special attention to <code>beat_schedule</code>.</li>
<li><b>Load State:</b> It opens the schedule file (e.g., <code>celerybeat-schedule</code>) to see when each task was last run. If the file doesn't exist, it creates it.</li>
<li><b>Main Loop (Tick):</b> Beat enters its main loop (the "ticker").</li>
<li><b>Calculate Due Tasks:</b> In each tick, Beat looks at every entry in <code>beat_schedule</code>. For each entry, it compares the current time with the task's <code>schedule</code> definition and its <code>last_run_at</code> time (from the schedule file). It calculates which tasks are due to run <em>right now</em>.</li>
<li><b>Send Task Message:</b> If a task (e.g., <code>add-every-15-seconds</code>) is due, Beat constructs a task message (containing &lsquo;'tasks.add&rsquo;<code>,</code>args=(16, 16)<code>, etc.) just like</code>.delay()<code>would. It sends this message to the configured **Broker**.</code></li>
<li><code> **Update State:** Beat updates the</code>last_run_at<code>time for the task it just sent in its internal state and saves this back to the schedule file.</code></li>
<li><code> **Sleep:** Beat calculates the time until the *next* scheduled task is due and sleeps for that duration (or up to a maximum interval,</code>beat_max_loop_interval`, usually 5 minutes, whichever is shorter).</li>
<li><b>Repeat:</b> Go back to step 5.</li>
</ol>
<p>Meanwhile, a <b>Worker</b> process is connected to the same <b>Broker</b>, picks up the task messages sent by Beat, and executes them.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Beat as Celery Beat Process</div>
<div class="line">    participant ScheduleCfg as beat_schedule Config</div>
<div class="line">    participant ScheduleDB as celerybeat-schedule File</div>
<div class="line">    participant Broker as Message Broker</div>
<div class="line">    participant Worker as Celery Worker</div>
<div class="line"> </div>
<div class="line">    Beat-&gt;&gt;ScheduleCfg: Load schedule definitions on startup</div>
<div class="line">    Beat-&gt;&gt;ScheduleDB: Load last run times on startup</div>
<div class="line"> </div>
<div class="line">    loop Tick Loop (e.g., every second or more)</div>
<div class="line">        Beat-&gt;&gt;Beat: Check current time</div>
<div class="line">        Beat-&gt;&gt;ScheduleCfg: Get definition for &#39;add-every-15&#39;</div>
<div class="line">        Beat-&gt;&gt;ScheduleDB: Get last run time for &#39;add-every-15&#39;</div>
<div class="line">        Beat-&gt;&gt;Beat: Calculate if &#39;add-every-15&#39; is due now</div>
<div class="line">        alt Task &#39;add-every-15&#39; is due</div>
<div class="line">            Beat-&gt;&gt;Broker: Send task message(&#39;tasks.add&#39;, (16, 16))</div>
<div class="line">            Broker--&gt;&gt;Beat: Ack (Message Queued)</div>
<div class="line">            Beat-&gt;&gt;ScheduleDB: Update last run time for &#39;add-every-15&#39;</div>
<div class="line">            ScheduleDB--&gt;&gt;Beat: Ack (Saved)</div>
<div class="line">        end</div>
<div class="line">        Beat-&gt;&gt;Beat: Calculate time until next task is due</div>
<div class="line">        Beat-&gt;&gt;Beat: Sleep until next check</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    Worker-&gt;&gt;Broker: Fetch task message (&#39;tasks.add&#39;, ...)</div>
<div class="line">    Broker--&gt;&gt;Worker: Deliver message</div>
<div class="line">    Worker-&gt;&gt;Worker: Execute task add(16, 16)</div>
<div class="line">    Worker-&gt;&gt;Broker: Ack message complete</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1090"></a>
Code Dive: Where Beat Lives</h2>
<ul>
<li><b>Command Line (<code>celery/bin/beat.py</code>):</b> Handles the <code>celery beat</code> command, parses arguments (<code>-A</code>, <code>-s</code>, <code>-S</code>, <code>--loglevel</code>), and creates/runs the <code>Beat</code> service object.</li>
<li><b>Beat Service Runner (<code>celery/apps/beat.py</code>):</b> The <code>Beat</code> class sets up the environment, loads the app, initializes logging, creates the actual scheduler service (<code>celery.beat.Service</code>), installs signal handlers, and starts the service.</li>
<li><b>Beat Service (<code>celery/beat.py:Service</code>):</b> This class manages the lifecycle of the scheduler. Its <code>start()</code> method contains the main loop that repeatedly calls <code>scheduler.tick()</code>. It loads the scheduler class specified in the configuration (defaulting to <code>PersistentScheduler</code>).</li>
<li><b>Scheduler (<code>celery/beat.py:Scheduler</code> / <code>PersistentScheduler</code>):</b> This is the core logic.<ul>
<li><code>Scheduler</code> is the base class. Its <code>tick()</code> method calculates the time until the next event, finds due tasks, calls <code>apply_entry</code> for due tasks, and returns the sleep interval.</li>
<li><code>PersistentScheduler</code> inherits from <code>Scheduler</code> and adds the logic to load/save the schedule state (last run times) using <code>shelve</code> (the <code>celerybeat-schedule</code> file). It overrides methods like <code>setup_schedule</code>, <code>sync</code>, <code>close</code>, and <code>schedule</code> property to interact with the <code>shelve</code> store (<code>self._store</code>).</li>
</ul>
</li>
<li><b>Schedule Types (<code>celery/schedules.py</code>):</b> Defines classes like <code>schedule</code> (for <code>timedelta</code> intervals) and <code>crontab</code>. These classes implement the <code>is_due(last_run_at)</code> method, which the <code>Scheduler.tick()</code> method uses to determine if a task entry should run.</li>
</ul>
<p>A simplified conceptual look at the <code>beat_schedule</code> config structure:</p>
<div class="fragment"><div class="line"><span class="comment"># Example structure from celeryconfig.py</span></div>
<div class="line"> </div>
<div class="line">beat_schedule = {</div>
<div class="line">    <span class="stringliteral">&#39;schedule-name-1&#39;</span>: {              <span class="comment"># Unique name for this entry</span></div>
<div class="line">        <span class="stringliteral">&#39;task&#39;</span>: <span class="stringliteral">&#39;my_app.tasks.task1&#39;</span>,  <span class="comment"># Task to run (module.task_name)</span></div>
<div class="line">        <span class="stringliteral">&#39;schedule&#39;</span>: 30.0,             <span class="comment"># When to run (e.g., seconds, timedelta, crontab)</span></div>
<div class="line">        <span class="stringliteral">&#39;args&#39;</span>: (arg1, arg2),         <span class="comment"># Optional: Positional arguments</span></div>
<div class="line">        <span class="stringliteral">&#39;kwargs&#39;</span>: {<span class="stringliteral">&#39;key&#39;</span>: <span class="stringliteral">&#39;value&#39;</span>},   <span class="comment"># Optional: Keyword arguments</span></div>
<div class="line">        <span class="stringliteral">&#39;options&#39;</span>: {<span class="stringliteral">&#39;queue&#39;</span>: <span class="stringliteral">&#39;hipri&#39;</span>},<span class="comment"># Optional: Execution options</span></div>
<div class="line">    },</div>
<div class="line">    <span class="stringliteral">&#39;schedule-name-2&#39;</span>: {</div>
<div class="line">        <span class="stringliteral">&#39;task&#39;</span>: <span class="stringliteral">&#39;my_app.tasks.task2&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;schedule&#39;</span>: crontab(minute=0, hour=0), <span class="comment"># e.g., Run at midnight</span></div>
<div class="line">        <span class="comment"># ... other options ...</span></div>
<div class="line">    },</div>
<div class="line">}</div>
</div><!-- fragment --><p>And a very simplified concept of the <code>Scheduler.tick()</code> method:</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified conceptual logic of Scheduler.tick()</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>tick(self):</div>
<div class="line">    remaining_times = []</div>
<div class="line">    due_tasks = []</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># 1. Iterate through schedule entries</span></div>
<div class="line">    <span class="keywordflow">for</span> entry <span class="keywordflow">in</span> self.schedule.values(): <span class="comment"># self.schedule reads from PersistentScheduler._store[&#39;entries&#39;]</span></div>
<div class="line">        <span class="comment"># 2. Check if entry is due using its schedule object (e.g., crontab)</span></div>
<div class="line">        is_due, next_time_to_run = entry.is_due() <span class="comment"># Calls schedule.is_due(entry.last_run_at)</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> is_due:</div>
<div class="line">            due_tasks.append(entry)</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            remaining_times.append(next_time_to_run) <span class="comment"># Store time until next check</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># 3. Apply due tasks (send message to broker)</span></div>
<div class="line">    <span class="keywordflow">for</span> entry <span class="keywordflow">in</span> due_tasks:</div>
<div class="line">        self.apply_entry(entry) <span class="comment"># Sends task message and updates entry&#39;s last_run_at in schedule store</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># 4. Calculate minimum sleep time until next event</span></div>
<div class="line">    <span class="keywordflow">return</span> min(remaining_times + [self.max_interval])</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1091"></a>
Conclusion</h2>
<p>Celery Beat is your tool for automating task execution within the Celery ecosystem.</p>
<ul>
<li>It acts as a <b>scheduler</b>, like an alarm clock or <code>cron</code> for Celery tasks.</li>
<li>It runs as a <b>separate process</b> (<code>celery beat</code>).</li>
<li>You define the schedule using the <code>beat_schedule</code> setting in your configuration, specifying <b>what</b> tasks run, <b>when</b> (using intervals or crontabs), and with what <b>arguments</b>.</li>
<li>Beat <b>sends task messages</b> to the broker at the scheduled times.</li>
<li>Running <b>Workers</b> are still required to pick up and execute these tasks.</li>
</ul>
<p>Beat allows you to reliably automate recurring background jobs, from simple periodic checks to complex, time-specific operations.</p>
<p>Now that we know how to run individual tasks, get their results, and schedule them automatically, what if we want to create more complex workflows involving multiple tasks that depend on each other? That's where Celery's Canvas comes in.</p>
<p><b>Next:</b> <a class="el" href="../../dc/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_208__canvas____signatures______primitives__.html">Chapter 8: Canvas (Signatures &amp; Primitives)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
