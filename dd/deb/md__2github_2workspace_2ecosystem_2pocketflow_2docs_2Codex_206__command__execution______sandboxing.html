#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_command_execution___sandboxing</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_206__command__execution______sandboxing.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_command_execution___sandboxing</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1306"></a>
autotoc_md1306</h2>
<p>layout: default title: "Command Execution &amp; Sandboxing" parent: "Codex" </p>
<h2><a class="anchor" id="autotoc_md1307"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md1308"></a>
Chapter 6: Command Execution &amp; Sandboxing</h1>
<p>In the <a class="el" href="../../dc/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_205__response______tool__call__handling.html">previous chapter</a>, we learned how Codex listens to the AI and understands when it wants to use a tool, like running a specific shell command (<code>git status</code> or <code>npm install</code>). We also know from the <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy &amp; Security</a> chapter that Codex checks if it <em>should</em> run the command based on your chosen safety level.</p>
<p>But once Codex has the command and permission (either from you or automatically), how does it actually <em>run</em> that command? And how does it do it safely, especially if you've given it more freedom in <code>full-auto</code> mode?</p>
<p>That's the job of the <b>Command Execution &amp; Sandboxing</b> system.</p>
<h2><a class="anchor" id="autotoc_md1309"></a>
What's the Big Idea? The Workshop Safety Zones</h2>
<p>Imagine Codex is working in a workshop. This system is like the different areas and safety procedures in that workshop:</p>
<ul>
<li><b>The Main Workbench (Raw Execution):</b> For simple, safe tasks (like running <code>ls</code> to list files), Codex might just use the tools directly on the main workbench. It's straightforward, but you wouldn't use dangerous chemicals there.</li>
<li><b>The Safety Cage (Sandboxing):</b> For potentially risky tasks (like testing a powerful new tool, or maybe running a command the AI suggested that you haven't manually approved in <code>full-auto</code> mode), Codex moves the work inside a special safety cage. This cage has reinforced walls and maybe limited power outlets, preventing any accidents from affecting the rest of the workshop.</li>
</ul>
<p>This system takes a command requested by the AI (like <code>python script.py</code> or <code>git commit -m "AI commit"</code>) and actually runs it on your computer's command line. Crucially, it decides <em>whether</em> to run it directly (on the workbench) or inside a restricted environment (the safety cage or "sandbox"). It also collects the results – what the command printed (output/stdout), any errors (stderr), and whether it finished successfully (exit code).</p>
<h2><a class="anchor" id="autotoc_md1310"></a>
Key Concepts</h2>
<ol type="1">
<li><b>Raw Execution:</b><ul>
<li><b>What:</b> Running the command directly using your system's shell, just like you would type it.</li>
<li><b>When:</b> Used for commands deemed safe, or when you explicitly approve a command in <code>suggest</code> or <code>auto-edit</code> mode.</li>
<li><b>Pros:</b> Simple, has full access to your environment (which might be needed).</li>
<li><b>Cons:</b> If the AI makes a mistake and suggests a harmful command, running it raw could cause problems.</li>
</ul>
</li>
<li><b>Sandboxing:</b><ul>
<li><b>What:</b> Running the command inside a restricted environment that limits what it can do. Think of it as putting the command in "jail."</li>
<li><b>How (Examples):</b><ul>
<li><b>macOS Seatbelt:</b> Uses a built-in macOS feature (<code>sandbox-exec</code>) with a specific policy file to strictly control what the command can access (e.g., only allow writing to the project folder, block network access).</li>
<li><b>Docker Container:</b> Runs the command inside a lightweight container (like the one defined in <code>codex-cli/Dockerfile</code>). This container has only specific tools installed and can have network rules applied (using <code>iptables</code>/<code>ipset</code> via <code>init_firewall.sh</code>) to limit internet access.</li>
</ul>
</li>
<li><b>When:</b> Typically used automatically in <code>full-auto</code> mode (as decided by the <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy &amp; Security</a> check), or potentially if a specific command is flagged as needing extra caution.</li>
<li><b>Pros:</b> Significantly reduces the risk of accidental damage from faulty or malicious commands suggested by the AI.</li>
<li><b>Cons:</b> Might prevent a command from working if it legitimately needs access to something the sandbox blocks (like a specific system file or network resource). The setup can be more complex.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md1311"></a>
How It Works: From Approval to Execution</h2>
<p>The Command Execution system doesn't decide <em>whether</em> to run a command – that's the job of the <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy &amp; Security</a>. This system comes into play <em>after</em> the approval check.</p>
<p>Remember the <code>handleExecCommand</code> function from the <a class="el" href="../../d0/dbd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_203__agent__loop.html">Agent Loop</a> chapter? It first calls <code>canAutoApprove</code> (<a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy &amp; Security</a>). If the command is approved (either by policy or by you), <code>canAutoApprove</code> tells <code>handleExecCommand</code> <em>whether</em> sandboxing is needed (<code>runInSandbox: true</code> or <code>runInSandbox: false</code>).</p>
<div class="fragment"><div class="line">// File: codex-cli/src/utils/agent/handle-exec-command.ts (Simplified Snippet)</div>
<div class="line"> </div>
<div class="line">import { execCommand } from &quot;./exec-command-helper&quot;; // (Conceptual helper name)</div>
<div class="line">import { getSandbox } from &quot;./sandbox-selector&quot;; // (Conceptual helper name)</div>
<div class="line">// ... other imports: canAutoApprove, config, policy types ...</div>
<div class="line"> </div>
<div class="line">async function handleExecCommand(</div>
<div class="line">  args: ExecInput, // Contains { cmd: [&quot;git&quot;, &quot;status&quot;], ... }</div>
<div class="line">  config: AppConfig,</div>
<div class="line">  policy: ApprovalPolicy,</div>
<div class="line">  getCommandConfirmation: (/*...*/) =&gt; Promise&lt;CommandConfirmation&gt;,</div>
<div class="line">  // ... abortSignal ...</div>
<div class="line">): Promise&lt;HandleExecCommandResult&gt; {</div>
<div class="line"> </div>
<div class="line">  // 1. Check policy (calls canAutoApprove)</div>
<div class="line">  const safety = canAutoApprove(command, policy, [process.cwd()]);</div>
<div class="line">  let runInSandbox: boolean;</div>
<div class="line"> </div>
<div class="line">  // 2. Determine if approved and if sandbox needed</div>
<div class="line">  switch (safety.type) {</div>
<div class="line">    case &quot;ask-user&quot;:</div>
<div class="line">      // Ask user via getCommandConfirmation...</div>
<div class="line">      // If approved, runInSandbox = false;</div>
<div class="line">      break;</div>
<div class="line">    case &quot;auto-approve&quot;:</div>
<div class="line">      runInSandbox = safety.runInSandbox; // Get sandbox flag from policy check</div>
<div class="line">      break;</div>
<div class="line">    // ... handle reject ...</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // 3. *** Execute the command! ***</div>
<div class="line">  // Determine the actual sandbox mechanism (Seatbelt, Docker, None)</div>
<div class="line">  const sandboxType = await getSandbox(runInSandbox);</div>
<div class="line">  // Call the function that handles execution</div>
<div class="line">  const summary = await execCommand(</div>
<div class="line">    args,</div>
<div class="line">    applyPatch, // (if it was an apply_patch command)</div>
<div class="line">    sandboxType,</div>
<div class="line">    abortSignal,</div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  // 4. Format and return results</div>
<div class="line">  return convertSummaryToResult(summary);</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Steps 1 &amp; 2:</b> Approval policy is checked, maybe the user is asked. We get the <code>runInSandbox</code> boolean.</li>
<li><b>Step 3:</b> A helper (<code>getSandbox</code>) determines the specific <code>SandboxType</code> (e.g., <code>MACOS_SEATBELT</code> or <code>NONE</code>) based on <code>runInSandbox</code> and the operating system. Then, the core execution function (<code>execCommand</code>) is called, passing the command details and the chosen <code>sandboxType</code>.</li>
<li><b>Step 4:</b> The results (stdout, stderr, exit code) from <code>execCommand</code> are packaged up.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1312"></a>
Under the Hood: Running the Command</h2>
<p>Let's trace the execution flow:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant HEC as handleExecCommand</div>
<div class="line">    participant EC as execCommand (Helper)</div>
<div class="line">    participant Exec as exec (exec.ts)</div>
<div class="line">    participant Raw as rawExec (raw-exec.ts)</div>
<div class="line">    participant SB as execWithSeatbelt (macos-seatbelt.ts)</div>
<div class="line"> </div>
<div class="line">    HEC-&gt;&gt;EC: Run `git status`, sandboxType=NONE</div>
<div class="line">    EC-&gt;&gt;Exec: Calls exec({cmd: [&quot;git&quot;, &quot;status&quot;], ...}, SandboxType.NONE)</div>
<div class="line">    Exec-&gt;&gt;Exec: Selects rawExec based on sandboxType</div>
<div class="line">    Exec-&gt;&gt;Raw: Calls rawExec([&quot;git&quot;, &quot;status&quot;], ...)</div>
<div class="line">    Raw-&gt;&gt;NodeJS: Uses child_process.spawn(&quot;git&quot;, [&quot;status&quot;], ...)</div>
<div class="line">    NodeJS--&gt;&gt;Raw: Command finishes (stdout, stderr, code)</div>
<div class="line">    Raw--&gt;&gt;Exec: Returns result</div>
<div class="line">    Exec--&gt;&gt;EC: Returns result</div>
<div class="line">    EC--&gt;&gt;HEC: Returns final summary</div>
<div class="line"> </div>
<div class="line">    %% Example with Sandbox %%</div>
<div class="line">    HEC-&gt;&gt;EC: Run `dangerous_script.sh`, sandboxType=MACOS_SEATBELT</div>
<div class="line">    EC-&gt;&gt;Exec: Calls exec({cmd: [&quot;dangerous...&quot;], ...}, SandboxType.MACOS_SEATBELT)</div>
<div class="line">    Exec-&gt;&gt;Exec: Selects execWithSeatbelt based on sandboxType</div>
<div class="line">    Exec-&gt;&gt;SB: Calls execWithSeatbelt([&quot;dangerous...&quot;], ...)</div>
<div class="line">    SB-&gt;&gt;SB: Constructs `sandbox-exec` command with policy</div>
<div class="line">    SB-&gt;&gt;Raw: Calls rawExec([&quot;sandbox-exec&quot;, &quot;-p&quot;, policy, &quot;--&quot;, &quot;dangerous...&quot;], ...)</div>
<div class="line">    Raw-&gt;&gt;NodeJS: Uses child_process.spawn(&quot;sandbox-exec&quot;, [...])</div>
<div class="line">    NodeJS--&gt;&gt;Raw: Sandboxed command finishes (stdout, stderr, code)</div>
<div class="line">    Raw--&gt;&gt;SB: Returns result</div>
<div class="line">    SB--&gt;&gt;Exec: Returns result</div>
<div class="line">    Exec--&gt;&gt;EC: Returns result</div>
<div class="line">    EC--&gt;&gt;HEC: Returns final summary</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1313"></a>
The Entry Point: <code>exec.ts</code></h3>
<p>This file acts as a router. It takes the command and the desired <code>SandboxType</code> and calls the appropriate execution function.</p>
<div class="fragment"><div class="line">// File: codex-cli/src/utils/agent/exec.ts (Simplified)</div>
<div class="line">import type { ExecInput, ExecResult, SandboxType } from &quot;./sandbox/interface.js&quot;;</div>
<div class="line">import { execWithSeatbelt } from &quot;./sandbox/macos-seatbelt.js&quot;;</div>
<div class="line">import { exec as rawExec } from &quot;./sandbox/raw-exec.js&quot;;</div>
<div class="line">// ... other imports like process_patch for apply_patch ...</div>
<div class="line"> </div>
<div class="line">// Never rejects, maps errors to non-zero exit code / stderr</div>
<div class="line">export function exec(</div>
<div class="line">  { cmd, workdir, timeoutInMillis }: ExecInput,</div>
<div class="line">  sandbox: SandboxType, // e.g., NONE, MACOS_SEATBELT</div>
<div class="line">  abortSignal?: AbortSignal,</div>
<div class="line">): Promise&lt;ExecResult&gt; {</div>
<div class="line"> </div>
<div class="line">  // Decide which execution function to use</div>
<div class="line">  const execFunction =</div>
<div class="line">    sandbox === SandboxType.MACOS_SEATBELT ? execWithSeatbelt : rawExec;</div>
<div class="line"> </div>
<div class="line">  const opts: SpawnOptions = { /* ... set timeout, workdir ... */ };</div>
<div class="line">  const writableRoots = [process.cwd(), os.tmpdir()]; // Basic allowed paths</div>
<div class="line"> </div>
<div class="line">  // Call the chosen function (either raw or sandboxed)</div>
<div class="line">  return execFunction(cmd, opts, writableRoots, abortSignal);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Special handler for apply_patch pseudo-command</div>
<div class="line">export function execApplyPatch(patchText: string): ExecResult {</div>
<div class="line">  try {</div>
<div class="line">    // Use file system operations directly (fs.writeFileSync etc.)</div>
<div class="line">    const result = process_patch(/* ... patchText, fs functions ... */);</div>
<div class="line">    return { stdout: result, stderr: &quot;&quot;, exitCode: 0 };</div>
<div class="line">  } catch (error: unknown) {</div>
<div class="line">    // Handle errors during patching</div>
<div class="line">    return { stdout: &quot;&quot;, stderr: String(error), exitCode: 1 };</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>It receives the command (<code>cmd</code>), options (<code>workdir</code>, <code>timeout</code>), and the <code>sandbox</code> type.</li>
<li>It checks the <code>sandbox</code> type and chooses either <code>execWithSeatbelt</code> (for macOS sandbox) or <code>rawExec</code> (for direct execution).</li>
<li>It calls the selected function.</li>
<li>Note: <code>apply_patch</code> is handled specially by <code>execApplyPatch</code>, which directly uses Node.js file system functions instead of spawning a shell command.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1314"></a>
Raw Execution: <code>raw-exec.ts</code></h3>
<p>This function runs the command directly using Node.js's built-in <code>child_process.spawn</code>.</p>
<div class="fragment"><div class="line">// File: codex-cli/src/utils/agent/sandbox/raw-exec.ts (Simplified)</div>
<div class="line">import type { ExecResult } from &quot;./interface&quot;;</div>
<div class="line">import { spawn, type SpawnOptions } from &quot;child_process&quot;;</div>
<div class="line">import { log, isLoggingEnabled } from &quot;../log.js&quot;;</div>
<div class="line"> </div>
<div class="line">const MAX_BUFFER = 1024 * 100; // 100 KB limit for stdout/stderr</div>
<div class="line"> </div>
<div class="line">// Never rejects, maps errors to non-zero exit code / stderr</div>
<div class="line">export function exec(</div>
<div class="line">  command: Array&lt;string&gt;, // e.g., [&quot;git&quot;, &quot;status&quot;]</div>
<div class="line">  options: SpawnOptions,</div>
<div class="line">  _writableRoots: Array&lt;string&gt;, // Not used in raw exec</div>
<div class="line">  abortSignal?: AbortSignal,</div>
<div class="line">): Promise&lt;ExecResult&gt; {</div>
<div class="line">  const prog = command[0];</div>
<div class="line">  const args = command.slice(1);</div>
<div class="line"> </div>
<div class="line">  return new Promise&lt;ExecResult&gt;((resolve) =&gt; {</div>
<div class="line">    // Spawn the child process</div>
<div class="line">    const child = spawn(prog, args, {</div>
<div class="line">      ...options,</div>
<div class="line">      stdio: [&quot;ignore&quot;, &quot;pipe&quot;, &quot;pipe&quot;], // Don&#39;t wait for stdin, capture stdout/err</div>
<div class="line">      detached: true, // Allows killing process group on abort</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    // Handle abort signal if provided</div>
<div class="line">    if (abortSignal) {</div>
<div class="line">       // Add listener to kill child process if aborted</div>
<div class="line">       // ... abort handling logic ...</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    let stdout = &quot;&quot;;</div>
<div class="line">    let stderr = &quot;&quot;;</div>
<div class="line">    // Capture stdout/stderr, respecting MAX_BUFFER limit</div>
<div class="line">    child.stdout?.on(&quot;data&quot;, (data) =&gt; { /* append to stdout if under limit */ });</div>
<div class="line">    child.stderr?.on(&quot;data&quot;, (data) =&gt; { /* append to stderr if under limit */ });</div>
<div class="line"> </div>
<div class="line">    // Handle process exit</div>
<div class="line">    child.on(&quot;exit&quot;, (code, signal) =&gt; {</div>
<div class="line">      resolve({ stdout, stderr, exitCode: code ?? 1 });</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    // Handle errors like &quot;command not found&quot;</div>
<div class="line">    child.on(&quot;error&quot;, (err) =&gt; {</div>
<div class="line">      resolve({ stdout: &quot;&quot;, stderr: String(err), exitCode: 1 });</div>
<div class="line">    });</div>
<div class="line">  });</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>It uses <code>child_process.spawn</code> to run the command. <code>spawn</code> is generally safer than <code>exec</code> as it doesn't involve an intermediate shell unless explicitly requested.</li>
<li>It captures <code>stdout</code> and <code>stderr</code> data, enforcing a maximum buffer size to prevent memory issues.</li>
<li>It listens for the <code>exit</code> event to get the exit code.</li>
<li>It listens for the <code>error</code> event (e.g., if the command executable doesn't exist).</li>
<li>It includes logic to kill the child process if the <code>abortSignal</code> is triggered (e.g., user presses Ctrl+C).</li>
<li>Crucially, it always <code>resolve</code>s the promise, even on errors, packaging the error into the <code>ExecResult</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1315"></a>
Sandboxing on macOS: <code>macos-seatbelt.ts</code></h3>
<p>This function wraps the command execution using macOS's <code>sandbox-exec</code> tool.</p>
<div class="fragment"><div class="line">// File: codex-cli/src/utils/agent/sandbox/macos-seatbelt.ts (Simplified)</div>
<div class="line">import type { ExecResult } from &quot;./interface.js&quot;;</div>
<div class="line">import { exec as rawExec } from &quot;./raw-exec.js&quot;; // Uses raw exec internally!</div>
<div class="line">import { log } from &quot;../log.js&quot;;</div>
<div class="line"> </div>
<div class="line">const READ_ONLY_POLICY_BASE = `</div>
<div class="line">(version 1)</div>
<div class="line">(deny default)</div>
<div class="line">(allow file-read*) ; Allow reading most things</div>
<div class="line">(allow process-exec process-fork signal) ; Allow running/forking</div>
<div class="line">(allow sysctl-read) ; Allow reading system info</div>
<div class="line">; ... more base rules ...</div>
<div class="line">`;</div>
<div class="line"> </div>
<div class="line">// Runs command inside macOS Seatbelt sandbox</div>
<div class="line">export function execWithSeatbelt(</div>
<div class="line">  cmd: Array&lt;string&gt;, // The original command e.g., [&quot;python&quot;, &quot;script.py&quot;]</div>
<div class="line">  opts: SpawnOptions,</div>
<div class="line">  writableRoots: Array&lt;string&gt;, // Dirs allowed for writing, e.g., project root</div>
<div class="line">  abortSignal?: AbortSignal,</div>
<div class="line">): Promise&lt;ExecResult&gt; {</div>
<div class="line"> </div>
<div class="line">  // 1. Build the sandbox policy string</div>
<div class="line">  let policy = READ_ONLY_POLICY_BASE;</div>
<div class="line">  let policyParams: Array&lt;string&gt; = [];</div>
<div class="line">  if (writableRoots.length &gt; 0) {</div>
<div class="line">    // Add rules to allow writing ONLY within specified roots</div>
<div class="line">    const writeRules = writableRoots.map(</div>
<div class="line">      (root, i) =&gt; `(allow file-write* (subpath (param &quot;WR_${i}&quot;)))`</div>
<div class="line">    ).join(&quot;\n&quot;);</div>
<div class="line">    policy += `\n${writeRules}`;</div>
<div class="line">    // Create parameters for sandbox-exec</div>
<div class="line">    policyParams = writableRoots.map((root, i) =&gt; `-DWR_${i}=${root}`);</div>
<div class="line">  }</div>
<div class="line">  log(`Seatbelt Policy: ${policy}`);</div>
<div class="line"> </div>
<div class="line">  // 2. Construct the actual command to run: sandbox-exec + policy + original command</div>
<div class="line">  const fullCommand = [</div>
<div class="line">    &quot;sandbox-exec&quot;,</div>
<div class="line">    &quot;-p&quot;, policy, // Pass the policy string</div>
<div class="line">    ...policyParams, // Pass parameters like -DWR_0=/path/to/project</div>
<div class="line">    &quot;--&quot;, // End of sandbox-exec options</div>
<div class="line">    ...cmd, // The original command and arguments</div>
<div class="line">  ];</div>
<div class="line"> </div>
<div class="line">  // 3. Execute the `sandbox-exec` command using rawExec</div>
<div class="line">  return rawExec(fullCommand, opts, [], abortSignal); // writableRoots not needed by rawExec here</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li>It defines a base Seatbelt policy (<code>.sb</code> file format) that denies most actions by default but allows basic read operations and process execution.</li>
<li>It dynamically adds <code>allow file-write*</code> rules for the specific <code>writableRoots</code> provided (usually the project directory and temp directories).</li>
<li>It constructs a new command line that starts with <code>sandbox-exec</code>, passes the generated policy (<code>-p</code>), passes parameters defining the writable roots (<code>-D</code>), and finally appends the original command.</li>
<li>It then calls <code>rawExec</code> to run this <em>entire</em> <code>sandbox-exec ... -- original-command ...</code> line. The operating system handles enforcing the sandbox rules.</li>
</ul>
<h3><a class="anchor" id="autotoc_md1316"></a>
Sandboxing with Docker: <code>Dockerfile</code></h3>
<p>Another approach, often used on Linux or as a fallback, is Docker. The <code>Dockerfile</code> defines the restricted environment.</p>
<div class="fragment"><div class="line"><span class="preprocessor"># File: codex-cli/Dockerfile (Simplified Snippets)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Start from a basic Node.js image</span></div>
<div class="line">FROM node:20</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor"># Install only necessary tools (git, jq, rg, maybe python/bash, etc.)</span></div>
<div class="line"><span class="preprocessor"># Avoid installing powerful tools unless absolutely needed.</span></div>
<div class="line">RUN apt update &amp;&amp; apt install -y \</div>
<div class="line">  git jq ripgrep sudo iproute2 iptables ipset \</div>
<div class="line"><span class="preprocessor">  # ... other minimal tools ...</span></div>
<div class="line">  &amp;&amp; apt-<a class="code hl_function" href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get</a> clean &amp;&amp; rm -rf /var/lib/apt/lists<span class="comment">/*</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"># Copy codex itself into the container</span></div>
<div class="line"><span class="comment">COPY dist/codex.tgz codex.tgz</span></div>
<div class="line"><span class="comment">RUN npm install -g codex.tgz</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"># Setup non-root user</span></div>
<div class="line"><span class="comment">USER node</span></div>
<div class="line"><span class="comment">WORKDIR /home/node/workspace # Work happens here</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"># Copy and set up firewall script (runs via sudo)</span></div>
<div class="line"><span class="comment"># This script uses iptables/ipset to block network access by default,</span></div>
<div class="line"><span class="comment"># potentially allowing only specific domains if configured.</span></div>
<div class="line"><span class="comment">COPY scripts/init_firewall.sh /usr/local/bin/</span></div>
<div class="line"><span class="comment">USER root</span></div>
<div class="line"><span class="comment">RUN chmod +x /usr/local/bin/init_firewall.sh &amp;&amp; \</span></div>
<div class="line"><span class="comment">  # Allow &#39;node&#39; user to run firewall script via sudo without password</span></div>
<div class="line"><span class="comment">  echo &quot;node ALL=(root) NOPASSWD: /usr/local/bin/init_firewall.sh&quot; &gt; /etc/sudoers.d/node-firewall</span></div>
<div class="line"><span class="comment">USER node</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment"># Default command when container starts (might be codex or just a shell)</span></div>
<div class="line"><span class="comment"># ENTRYPOINT [&quot;codex&quot;]</span></div>
<div class="ttc" id="apybind__kv__service_8cpp_html_abe6524afb3a69dc9a4c314e11f96f29f"><div class="ttname"><a href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get</a></div><div class="ttdeci">std::string get(std::string key, std::string config_path)</div><div class="ttdef"><b>Definition</b> <a href="../../d7/da6/pybind__kv__service_8cpp_source.html#l00039">pybind_kv_service.cpp:39</a></div></div>
</div><!-- fragment --><ul>
<li><b>Minimal Tools:</b> The Docker image includes only a limited set of command-line tools, reducing the potential attack surface.</li>
<li><b>Non-Root User:</b> Commands run as a non-privileged user (<code>node</code>) inside the container.</li>
<li><b>Workspace:</b> Work typically happens in a specific directory (e.g., <code>/home/node/workspace</code>), often mapped to your project directory on the host machine.</li>
<li><b>Network Firewall:</b> An <code>init_firewall.sh</code> script (run via <code>sudo</code> at startup or when needed) configures <code>iptables</code> to restrict network access. This prevents sandboxed commands from easily calling out to arbitrary internet addresses.</li>
<li><b>Usage:</b> Codex might be run <em>entirely</em> within this container, or it might invoke commands <em>inside</em> this container from the outside using <code>docker exec</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1317"></a>
Conclusion</h2>
<p>You've reached the end of the workshop tour! The <b>Command Execution &amp; Sandboxing</b> system is Codex's way of actually <em>doing</em> things on the command line when instructed by the AI. It carefully considers the safety level decided by the <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy &amp; Security</a> and chooses the right execution method: direct "raw" execution for trusted commands, or running inside a protective "sandbox" (like macOS Seatbelt or a Docker container) for potentially riskier operations, especially in <code>full-auto</code> mode. This layered approach allows Codex to be powerful while providing crucial safety mechanisms against unintended consequences.</p>
<p>We've seen how Codex handles input, talks to the AI, checks policies, and executes commands. But how does Codex know <em>which</em> AI model to use, what your API key is, or which approval mode you prefer? All these settings need to be managed.</p>
<p>Next up: <a class="el" href="../../d2/d53/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_207__configuration__management.html">Configuration Management</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
