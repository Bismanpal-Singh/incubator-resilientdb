#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_a2a_client_implementation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('dd/d41/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_205__a2a__client__implementation.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_a2a_client_implementation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1999"></a>
autotoc_md1999</h2>
<p>layout: default title: "A2A Client Implementation" parent: "Google A2A" </p>
<h2><a class="anchor" id="autotoc_md2000"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md2001"></a>
Chapter 5: A2A Client Implementation</h1>
<p>In the <a class="el" href="../../d6/dcb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_204__a2a__server__implementation.html">previous chapter</a>, we learned how to build the "embassy" for our AI agent â€“ the <b>A2A Server</b>. This server listens for incoming requests, acting as the official entry point for our agent according to the A2A protocol rules.</p>
<p>But how does someone actually <em>visit</em> this embassy and make a request? If you build a fantastic translation agent server, how does your chat application, or another AI agent, actually <em>use</em> it to translate text?</p>
<p>This chapter tackles that problem: <b>How do we build the component that <em>initiates</em> communication with an A2A agent server?</b></p>
<p>This is the job of the <b>A2A Client Implementation</b>.</p>
<h2><a class="anchor" id="autotoc_md2002"></a>
What is an A2A Client? The Agent's Customer</h2>
<p>Think about how you use the web:</p>
<ul>
<li>You want to visit a website (like <code>google.com</code>).</li>
<li>You open your <b>web browser</b> (like Chrome or Firefox).</li>
<li>You type the website's address into the browser.</li>
<li>The browser sends a request to the website's server.</li>
<li>The server sends back the webpage content.</li>
<li>Your browser receives the content and displays it to you.</li>
</ul>
<p>In this scenario, your <b>web browser</b> is the <b>client</b>. It <em>starts</em> the conversation, knows how to format the request (using HTTP), sends it to the right address, and understands the server's response.</p>
<p>Similarly, an <b>A2A Client</b> is the software component that acts like that web browser, but specifically for talking to A2A agents:</p>
<ol type="1">
<li><b>Knows the Agent's Address:</b> It needs the URL of the agent's A2A server (which it might get from the agent's <a class="el" href="../../d7/d4e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_201__agent__card.html">Agent Card</a>).</li>
<li><b>Speaks the Language:</b> It knows how to format requests according to the <a class="el" href="../../d8/d90/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_203__a2a__protocol______core__types.html">A2A Protocol &amp; Core Types</a>, using JSON-RPC for commands like <code>tasks/send</code>.</li>
<li><b>Initiates the Call:</b> It sends these requests over the network (usually via HTTP POST) to the agent's server.</li>
<li><b>Understands the Reply:</b> It receives the server's JSON-RPC response, checks for success or errors, and parses the results (like the initial <code>Task</code> object or streaming updates).</li>
</ol>
<p>Essentially, the A2A Client is the part of your application (or another agent) that <em>consumes</em> the services offered by an A2A agent server.</p>
<h2><a class="anchor" id="autotoc_md2003"></a>
Why Do We Need It?</h2>
<p>Your application's core logic (e.g., the chat interface, the document summarizer UI) shouldn't need to worry about the messy details of JSON-RPC formatting, HTTP headers, or handling network connections.</p>
<p>The A2A Client acts as an <b>intermediary</b> or <b>adapter</b>. It provides a cleaner, simpler way for your application code to interact with a remote A2A agent. Your application can just say, "Client, please send this message to the agent," and the client handles all the protocol details.</p>
<h2><a class="anchor" id="autotoc_md2004"></a>
Using an A2A Client Library</h2>
<p>Just like we used <code>A2AServer</code> libraries to simplify building the server in <a class="el" href="../../d6/dcb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_204__a2a__server__implementation.html">Chapter 4</a>, the <code>Google A2A</code> project provides <code>A2AClient</code> libraries to make building the client side easier.</p>
<p>Let's see how we might use these libraries in JavaScript and Python to talk to the "Echo Agent" server we discussed previously.</p>
<h3><a class="anchor" id="autotoc_md2005"></a>
JavaScript Example (using <code>A2AClient</code> from the library)</h3>
<p>Imagine we're building a simple command-line tool (<code>cli.ts</code>) that lets a user chat with our Echo Agent running at <code><a href="http://localhost:4000">http://localhost:4000</a></code>.</p>
<div class="fragment"><div class="line">// File: samples/js/src/cli.ts (Simplified Snippet)</div>
<div class="line">import { A2AClient } from &quot;./client/client.js&quot;; // The client library</div>
<div class="line">import { TaskSendParams } from &quot;./schema.js&quot;; // Types for request parameters</div>
<div class="line">import crypto from &quot;node:crypto&quot;; // To generate IDs</div>
<div class="line"> </div>
<div class="line">// Agent&#39;s address (replace with your agent&#39;s URL)</div>
<div class="line">const serverUrl = &quot;http://localhost:4000&quot;;</div>
<div class="line"> </div>
<div class="line">// 1. Create a client instance pointing to the agent&#39;s server</div>
<div class="line">const client = new A2AClient(serverUrl);</div>
<div class="line"> </div>
<div class="line">// User input from the command line</div>
<div class="line">const userInput = &quot;Hello Echo Agent!&quot;;</div>
<div class="line"> </div>
<div class="line">// 2. Prepare the parameters for the &#39;tasks/sendSubscribe&#39; request</div>
<div class="line">const taskId = crypto.randomUUID(); // Generate a unique ID for this task</div>
<div class="line">const params: TaskSendParams = {</div>
<div class="line">  id: taskId,</div>
<div class="line">  message: {</div>
<div class="line">    role: &quot;user&quot;,</div>
<div class="line">    parts: [{ type: &quot;text&quot;, text: userInput }], // The user&#39;s message</div>
<div class="line">  },</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">// 3. Send the request and handle the streaming response</div>
<div class="line">async function sendMessage() {</div>
<div class="line">  console.log(`Sending task ${taskId} to ${serverUrl}...`);</div>
<div class="line">  try {</div>
<div class="line">    // Use sendTaskSubscribe for agents that support streaming</div>
<div class="line">    const stream = client.sendTaskSubscribe(params);</div>
<div class="line"> </div>
<div class="line">    // Loop through the events received from the server</div>
<div class="line">    for await (const event of stream) {</div>
<div class="line">      console.log(&quot;Received Agent Event:&quot;, event);</div>
<div class="line">      // (In a real app, you&#39;d parse &#39;event&#39; which could be</div>
<div class="line">      // TaskStatusUpdateEvent or TaskArtifactUpdateEvent)</div>
<div class="line">    }</div>
<div class="line">    console.log(&quot;Agent stream finished.&quot;);</div>
<div class="line"> </div>
<div class="line">  } catch (error: any) {</div>
<div class="line">    console.error(&quot;Error talking to agent:&quot;, error.message || error);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">sendMessage();</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Create Client:</b> We import <code>A2AClient</code> and create an instance, telling it the URL of the agent server we want to talk to.</li>
<li><b>Prepare Request:</b> We gather the necessary information for our request: a unique <code>taskId</code> and the <code>message</code> containing the user's input, formatted according to the A2A <code>TaskSendParams</code> structure (<a class="el" href="../../d8/d90/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_203__a2a__protocol______core__types.html">Chapter 3</a>).</li>
<li><b>Send &amp; Handle Stream:</b> We call <code>client.sendTaskSubscribe(params)</code>. This method handles formatting the JSON-RPC request, sending the HTTP POST, and processing the Server-Sent Events (SSE) stream from the server (<a class="el" href="../../d0/d60/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_207__streaming__communication____sse__.html">Chapter 7: Streaming Communication (SSE)</a>). We use a <code>for await...of</code> loop to process each event as it arrives from the agent.</li>
</ol>
<p><b>Example Output (Conceptual):</b></p>
<div class="fragment"><div class="line">Sending task abc-123 to http://localhost:4000...</div>
<div class="line">Received Agent Event: { status: { state: &#39;working&#39;, message: { role: &#39;agent&#39;, parts: [ { text: &#39;Echoing...&#39; } ] } } }</div>
<div class="line">Received Agent Event: { status: { state: &#39;completed&#39;, message: { role: &#39;agent&#39;, parts: [ { text: &#39;You said: Hello Echo Agent!&#39; } ] } } }</div>
<div class="line">Agent stream finished.</div>
</div><!-- fragment --><p>The client library takes care of the underlying network communication and event parsing.</p>
<h3><a class="anchor" id="autotoc_md2006"></a>
Python Example (using <code>A2AClient</code> from the library)</h3>
<p>Let's create a similar command-line tool in Python (<code>cli/__main__.py</code>) talking to an agent at <code><a href="http://localhost:5000">http://localhost:5000</a></code>.</p>
<div class="fragment"><div class="line"><span class="comment"># File: samples/python/hosts/cli/__main__.py (Simplified Snippet)</span></div>
<div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"><span class="keyword">from</span> uuid <span class="keyword">import</span> uuid4</div>
<div class="line"><span class="keyword">from</span> common.client <span class="keyword">import</span> A2AClient <span class="comment"># The client library</span></div>
<div class="line"><span class="comment"># Assume &#39;card&#39; is the AgentCard fetched previously (see Chapter 1)</span></div>
<div class="line"><span class="comment"># card = A2ACardResolver(&quot;http://localhost:5000&quot;).get_agent_card()</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 1. Create a client instance using the agent&#39;s card or URL</span></div>
<div class="line"><span class="comment"># client = A2AClient(agent_card=card)</span></div>
<div class="line">client = A2AClient(url=<span class="stringliteral">&quot;http://localhost:5000&quot;</span>) <span class="comment"># Or directly use URL</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># User input</span></div>
<div class="line">user_input = <span class="stringliteral">&quot;Hi Python Agent!&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 2. Prepare the payload (parameters) for the request</span></div>
<div class="line">task_id = uuid4().hex <span class="comment"># Generate a unique Task ID</span></div>
<div class="line">payload = {</div>
<div class="line">    <span class="stringliteral">&quot;id&quot;</span>: task_id,</div>
<div class="line">    <span class="stringliteral">&quot;message&quot;</span>: {</div>
<div class="line">        <span class="stringliteral">&quot;role&quot;</span>: <span class="stringliteral">&quot;user&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;parts&quot;</span>: [{<span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;text&quot;</span>, <span class="stringliteral">&quot;text&quot;</span>: user_input}],</div>
<div class="line">    },</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 3. Send the request and handle the response</span></div>
<div class="line"><span class="keyword">async def </span>send_message():</div>
<div class="line">    print(f<span class="stringliteral">&quot;Sending task {task_id} to {client.url}...&quot;</span>)</div>
<div class="line">    <span class="keywordflow">try</span>:</div>
<div class="line">        <span class="comment"># Use send_task_streaming if agent supports it (check card.capabilities.streaming)</span></div>
<div class="line">        <span class="comment"># Assuming streaming is supported here:</span></div>
<div class="line">        response_stream = client.send_task_streaming(payload)</div>
<div class="line">        <span class="keyword">async</span> <span class="keywordflow">for</span> result <span class="keywordflow">in</span> response_stream:</div>
<div class="line">             <span class="comment"># result is already parsed SendTaskStreamingResponse object</span></div>
<div class="line">            print(f<span class="stringliteral">&quot;Received Agent Event: {result.model_dump_json(exclude_none=True)}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        print(<span class="stringliteral">&quot;Agent stream finished.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># If NOT streaming, you&#39;d use send_task:</span></div>
<div class="line">        <span class="comment"># task_result = await client.send_task(payload)</span></div>
<div class="line">        <span class="comment"># print(f&quot;Received Agent Response: {task_result.model_dump_json(exclude_none=True)}&quot;)</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">        print(f<span class="stringliteral">&quot;Error talking to agent: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">asyncio.run(send_message())</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Create Client:</b> We import <code>A2AClient</code> and create an instance, providing the agent's <code>url</code>.</li>
<li><b>Prepare Payload:</b> We create a Python dictionary <code>payload</code> containing the <code>id</code> and <code>message</code> parameters for the <code>tasks/send</code> or <code>tasks/sendSubscribe</code> method.</li>
<li><b>Send &amp; Handle Stream:</b> We call <code>client.send_task_streaming(payload)</code>. Similar to the JS version, this handles the JSON-RPC formatting, HTTP POST, and returns an asynchronous iterator. We loop through it using <code>async for</code> to get parsed response objects (like <code>SendTaskStreamingResponse</code>) for each event. The library hides the complexity of parsing the SSE stream. If the agent didn't support streaming, we would call <code>client.send_task(payload)</code> instead, which would return the final <code>Task</code> object directly after the agent finishes.</li>
</ol>
<p><b>Example Output (Conceptual, streaming):</b></p>
<div class="fragment"><div class="line">Sending task def-456 to http://localhost:5000...</div>
<div class="line">Received Agent Event: {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: {&quot;status&quot;: {&quot;state&quot;: &quot;working&quot;, &quot;message&quot;: {&quot;role&quot;: &quot;agent&quot;, &quot;parts&quot;: [{&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;Echoing...&quot;}]}}}}</div>
<div class="line">Received Agent Event: {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: {&quot;status&quot;: {&quot;state&quot;: &quot;completed&quot;, &quot;message&quot;: {&quot;role&quot;: &quot;agent&quot;, &quot;parts&quot;: [{&quot;type&quot;: &quot;text&quot;, &quot;text&quot;: &quot;You said: Hi Python Agent!&quot;}]}}}}</div>
<div class="line">Agent stream finished.</div>
</div><!-- fragment --><p>In both examples, the <code>A2AClient</code> library provides a high-level interface (<code>sendTaskSubscribe</code>, <code>send_task_streaming</code>, <code>sendTask</code>, <code>send_task</code>) that simplifies the process of communicating with an A2A server.</p>
<h2><a class="anchor" id="autotoc_md2007"></a>
Under the Hood: How the Client Works</h2>
<p>What's happening inside the <code>A2AClient</code> library when you call a method like <code>sendTaskSubscribe</code>?</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant App as Your Application (e.g., CLI)</div>
<div class="line">    participant Lib as A2AClient Library</div>
<div class="line">    participant Net as Network (HTTP)</div>
<div class="line">    participant Srv as A2A Agent Server</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;Lib: Call client.sendTaskSubscribe(params)</div>
<div class="line">    Note right of Lib: Generates JSON-RPC ID, Method=&#39;tasks/sendSubscribe&#39;</div>
<div class="line">    Lib-&gt;&gt;Lib: Format JSON-RPC Request Body (using params)</div>
<div class="line">    Note right of Lib: {jsonrpc:&quot;2.0&quot;, id:&quot;req-1&quot;, method:&quot;...&quot;, params:{...}}</div>
<div class="line"> </div>
<div class="line">    Lib-&gt;&gt;Net: Send HTTP POST Request to Agent URL</div>
<div class="line">    Note over Net,Srv: Request travels over the internet</div>
<div class="line"> </div>
<div class="line">    Net-&gt;&gt;Srv: Delivers HTTP POST Request</div>
<div class="line">    Note right of Srv: Server receives request, parses JSON-RPC</div>
<div class="line"> </div>
<div class="line">    Srv-&gt;&gt;Srv: Processes Task (Starts internal logic)</div>
<div class="line">    Note right of Srv: Switches to streaming mode (SSE)</div>
<div class="line"> </div>
<div class="line">    Srv--&gt;&gt;Net: Send HTTP Response (Status 200 OK, Content-Type: text/event-stream)</div>
<div class="line">    Srv--&gt;&gt;Net: Send SSE Event 1 (e.g., &#39;working&#39; status)</div>
<div class="line">    Srv--&gt;&gt;Net: Send SSE Event 2 (e.g., &#39;completed&#39; status)</div>
<div class="line">    Note right of Srv: Stream ends</div>
<div class="line"> </div>
<div class="line">    Net--&gt;&gt;Lib: Delivers HTTP Response &amp; SSE Events</div>
<div class="line">    Note right of Lib: Receives streaming response</div>
<div class="line"> </div>
<div class="line">    Lib-&gt;&gt;Lib: Parse SSE Events (Extract JSON data from &#39;data:&#39; lines)</div>
<div class="line">    Lib--&gt;&gt;App: Yield Parsed Event 1 (as object)</div>
<div class="line">    Lib--&gt;&gt;App: Yield Parsed Event 2 (as object)</div>
<div class="line">    Note left of App: Application processes each event in the loop</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;App: Loop finishes when stream ends</div>
</div><!-- fragment --><p><b>Steps:</b></p>
<ol type="1">
<li><b>Application Call:</b> Your code calls a method on the <code>A2AClient</code> instance (e.g., <code>sendTaskSubscribe</code>).</li>
<li><b>Format Request:</b> The library takes your parameters (<code>params</code>), generates a unique request ID, and constructs the full JSON-RPC request payload (a JSON object).</li>
<li><b>Send HTTP Request:</b> The library uses an underlying HTTP client (like <code>fetch</code> in browsers/Node.js or <code>httpx</code> in Python) to send an HTTP POST request to the agent server's URL. It sets the correct headers (<code>Content-Type: application/json</code>, <code>Accept: text/event-stream</code> for streaming).</li>
<li><b>Server Processing:</b> The A2A server receives the request, processes it (as described in <a class="el" href="../../d6/dcb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_204__a2a__server__implementation.html">Chapter 4</a>), and starts sending back a response. For streaming, this is an HTTP response with a <code>text/event-stream</code> content type, followed by individual Server-Sent Events (SSE).</li>
<li><b>Receive Response:</b> The client library's HTTP client receives the response.</li>
<li><b>Parse Response/Stream:</b><ul>
<li><b>Non-streaming (<code>sendTask</code>):</b> It waits for the full response, parses the JSON body, checks for JSON-RPC level errors, and extracts the <code>result</code> field (e.g., the final <code>Task</code> object).</li>
<li><b>Streaming (<code>sendTaskSubscribe</code>):</b> It processes the incoming SSE stream, parsing the <code>data:</code> lines from each event, converting the JSON text into objects, and yielding these objects back to your application code via the async iterator.</li>
</ul>
</li>
<li><b>Return/Yield Result:</b> The library returns the parsed result (for non-streaming) or yields the parsed events (for streaming) to your application code.</li>
</ol>
<p>The client libraries (like <code>samples/js/src/client/client.ts</code> and <code>samples/python/common/client/client.py</code>) contain internal helper functions (e.g., <code>_makeHttpRequest</code>, <code>_handleJsonResponse</code>, <code>_handleStreamingResponse</code> in the JS client; <code>_send_request</code> in the Python client) to manage these steps.</p>
<h2><a class="anchor" id="autotoc_md2008"></a>
Conclusion</h2>
<p>The <b>A2A Client</b> is the component that <em>initiates</em> conversations with A2A agent servers. It acts on behalf of your application or another agent, translating simple method calls (like "send this message") into correctly formatted A2A protocol requests (JSON-RPC over HTTP).</p>
<p>It handles the complexities of:</p>
<ul>
<li>Knowing the agent's address (<code>url</code>).</li>
<li>Formatting requests (<code>tasks/send</code>, <code>tasks/sendSubscribe</code>).</li>
<li>Sending them over the network.</li>
<li>Parsing responses (JSON results or streaming SSE events).</li>
<li>Handling errors.</li>
</ul>
<p>By using the provided <code>A2AClient</code> libraries, you can easily integrate A2A communication into your applications without needing deep knowledge of the underlying protocol mechanics. You create a client, prepare your data, and call the appropriate method.</p>
<p>Now that we've seen both the server (<a class="el" href="../../d6/dcb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_204__a2a__server__implementation.html">Chapter 4</a>) and the client side of the A2A interaction, let's dive deeper into how the <em>server</em> actually processes the tasks it receives from the client.</p>
<p><b>Next:</b> <a class="el" href="../../d7/d27/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Google_01A2A_206__task__handling__logic____server__side__.html">Chapter 6: Task Handling Logic (Server-side)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
