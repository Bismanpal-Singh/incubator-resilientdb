#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 07_transport_adapters</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/d83/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_207__transport__adapters.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">07_transport_adapters</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2975"></a>
autotoc_md2975</h2>
<p>layout: default title: "Transport Adapters" parent: "Requests" </p>
<h2><a class="anchor" id="autotoc_md2976"></a>
nav_order: 7</h2>
<h1><a class="anchor" id="autotoc_md2977"></a>
Chapter 7: Transport Adapters - Custom Delivery Routes</h1>
<p>In the previous chapter, <a class="el" href="../../d0/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_206__exception__hierarchy.html">Chapter 6: Exception Hierarchy</a>, we learned how <code>requests</code> signals problems like network errors or bad responses. Most of the time, we rely on the default way <code>requests</code> handles sending our requests and managing connections.</p>
<p>But what if the default way isn't quite right for a specific website or service? What if you need to tell <code>requests</code> <em>exactly</em> how to handle connections or retries for URLs starting with <code><a href="http://">http://</a></code> or <code><a href="https://">https://</a></code>, or maybe even for a completely custom scheme like <code>myprotocol://</code>?</p>
<h2><a class="anchor" id="autotoc_md2978"></a>
The Problem: Needing Special Handling</h2>
<p>Imagine you're interacting with an API that's known to be a bit unreliable. Sometimes requests to it fail temporarily, but succeed if you just try again a second later. The default <code>requests</code> behavior might not retry enough times, or maybe you want to retry only on specific error codes.</p>
<p>Or perhaps you need to connect to a server using very specific security settings (SSL/TLS versions or ciphers) that aren't the default.</p>
<p>How can you customize <em>how</em> <code>requests</code> sends requests and manages connections for specific types of URLs?</p>
<h2><a class="anchor" id="autotoc_md2979"></a>
Meet Transport Adapters: The Delivery Services</h2>
<p>This is where <b>Transport Adapters</b> come in!</p>
<p>Think of a <code>requests</code> <a class="el" href="../../dd/d2f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_203__session.html">Session</a> object like a customer ordering packages online. The customer (Session) wants to send a package (a web request) to a specific address (a URL).</p>
<p><b>Transport Adapters</b> are like the different <b>delivery services</b> (like FedEx, UPS, USPS, or maybe a specialized local courier) that the customer can choose from.</p>
<ul>
<li>Each delivery service specializes in certain types of addresses or delivery methods.</li>
<li>When the customer has a package for a specific address (e.g., starting with <code><a href="https://">https://</a></code>), they pick the appropriate delivery service registered for that address type.</li>
<li>That delivery service then handles all the details of picking up, transporting, and delivering the package (sending the request, managing connections, handling retries, etc.).</li>
</ul>
<p>In <code>requests</code>, a Transport Adapter defines <em>how</em> requests are actually sent and connections are managed for specific <b>URL schemes</b> (like <code><a href="http://">http://</a></code> or <code><a href="https://">https://</a></code>).</p>
<h2><a class="anchor" id="autotoc_md2980"></a>
The Default Delivery Service: <code>HTTPAdapter</code></h2>
<p>By default, when you create a <code>Session</code> object, it automatically sets up the standard "delivery services" for web addresses:</p>
<ul>
<li>For URLs starting with <code><a href="https://">https://</a></code>, it uses the built-in <code>requests.adapters.HTTPAdapter</code>.</li>
<li>For URLs starting with <code><a href="http://">http://</a></code>, it also uses the <code>requests.adapters.HTTPAdapter</code>.</li>
</ul>
<p>This <code>HTTPAdapter</code> is the workhorse. It doesn't handle the network sockets directly; instead, it uses another powerful library called <code>urllib3</code> under the hood.</p>
<p>The <code>HTTPAdapter</code> (via <code>urllib3</code>) is responsible for:</p>
<ol type="1">
<li><b>Connection Pooling:</b> Reusing existing network connections to the same host for better performance (like the delivery service keeping its trucks warm and ready for the next delivery to the same neighborhood). We saw the benefits of this in <a class="el" href="../../dd/d2f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_203__session.html">Chapter 3: Session</a>.</li>
<li><b>HTTP/HTTPS Details:</b> Handling the specifics of the HTTP and HTTPS protocols.</li>
<li><b>SSL Verification:</b> Making sure the website's security certificate is valid for HTTPS connections.</li>
<li><b>Basic Retries:</b> Handling some low-level connection retries (though often you might want more control).</li>
</ol>
<p>So, when you use a <code>Session</code> and make a <code>GET</code> request to <code><a href="https://example.com">https://example.com</a></code>, the Session looks up the adapter for <code><a href="https://">https://</a></code>, finds the default <code>HTTPAdapter</code>, and hands the request off to it for delivery.</p>
<h2><a class="anchor" id="autotoc_md2981"></a>
Mounting Adapters: Choosing Your Delivery Service</h2>
<p>How does a <code>Session</code> know which adapter to use for which URL prefix? It uses a mechanism called <b>mounting</b>.</p>
<p>Think of it like telling your <code>Session</code> customer: "For any address starting with `https://`, use this specific delivery service (adapter)."</p>
<p>A <code>Session</code> object has an <code>adapters</code> attribute, which is an ordered dictionary. You use the <code>session.mount(prefix, adapter)</code> method to register an adapter for a given URL prefix.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> requests</div>
<div class="line"><span class="keyword">from</span> requests.adapters <span class="keyword">import</span> HTTPAdapter</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a session</span></div>
<div class="line">s = requests.Session()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># See the default adapters that are already mounted</span></div>
<div class="line">print(<span class="stringliteral">&quot;Default Adapters:&quot;</span>)</div>
<div class="line">print(s.adapters)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a *new* instance of the default HTTPAdapter</span></div>
<div class="line"><span class="comment"># (Maybe we&#39;ll configure it later)</span></div>
<div class="line">custom_adapter = HTTPAdapter()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Mount this adapter for a specific website</span></div>
<div class="line"><span class="comment"># Now, any request to this specific host via HTTPS will use our custom_adapter</span></div>
<div class="line">print(<span class="stringliteral">&quot;\nMounting custom adapter for https://httpbin.org&quot;</span>)</div>
<div class="line">s.mount(<span class="stringliteral">&#39;https://httpbin.org&#39;</span>, custom_adapter)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Let&#39;s mount another one for all HTTP traffic</span></div>
<div class="line">plain_http_adapter = HTTPAdapter()</div>
<div class="line">print(<span class="stringliteral">&quot;Mounting another adapter for all http://&quot;</span>)</div>
<div class="line">s.mount(<span class="stringliteral">&#39;http://&#39;</span>, plain_http_adapter)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Check the adapters again (they are ordered by prefix length, longest first)</span></div>
<div class="line">print(<span class="stringliteral">&quot;\nAdapters after mounting:&quot;</span>)</div>
<div class="line">print(s.adapters)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># When we make a request, the session finds the best matching prefix</span></div>
<div class="line">print(f<span class="stringliteral">&quot;\nAdapter for &#39;https://httpbin.org/get&#39;: {s.get_adapter(&#39;https://httpbin.org/get&#39;)}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Adapter for &#39;http://example.com&#39;: {s.get_adapter(&#39;http://example.com&#39;)}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Adapter for &#39;https://google.com&#39;: {s.get_adapter(&#39;https://google.com&#39;)}&quot;</span>) <span class="comment"># Uses default https://</span></div>
</div><!-- fragment --><p><b>Output:</b></p>
<div class="fragment"><div class="line">Default Adapters:</div>
<div class="line">OrderedDict([(&#39;https://&#39;, &lt;requests.adapters.HTTPAdapter object at 0x...&gt;), (&#39;http://&#39;, &lt;requests.adapters.HTTPAdapter object at 0x...&gt;)])</div>
<div class="line"> </div>
<div class="line">Mounting custom adapter for https://httpbin.org</div>
<div class="line">Mounting another adapter for all http://</div>
<div class="line"> </div>
<div class="line">Adapters after mounting:</div>
<div class="line">OrderedDict([(&#39;https://httpbin.org&#39;, &lt;requests.adapters.HTTPAdapter object at 0x...&gt;), (&#39;https://&#39;, &lt;requests.adapters.HTTPAdapter object at 0x...&gt;), (&#39;http://&#39;, &lt;requests.adapters.HTTPAdapter object at 0x...&gt;)])</div>
<div class="line"> </div>
<div class="line">Adapter for &#39;https://httpbin.org/get&#39;: &lt;requests.adapters.HTTPAdapter object at 0x...&gt;</div>
<div class="line">Adapter for &#39;http://example.com&#39;: &lt;requests.adapters.HTTPAdapter object at 0x...&gt;</div>
<div class="line">Adapter for &#39;https://google.com&#39;: &lt;requests.adapters.HTTPAdapter object at 0x...&gt;</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>Initially, the session has default <code>HTTPAdapter</code> instances mounted for <code><a href="https://">https://</a></code> and <code><a href="http://">http://</a></code>.</li>
<li>We created new <code>HTTPAdapter</code> instances.</li>
<li>We used &lsquo;s.mount('<a href="https://httpbin.org&rsquo;">https://httpbin.org&amp;rsquo;</a>, custom_adapter)<code>. Now, requests to</code><a href="https://httpbin.org/anything">https://httpbin.org/anything</a><code>will use</code>custom_adapter<code>.</code></li>
<li><code> We used</code>s.mount('<a href="http://'">http://'</a>, plain_http_adapter)<code>. This *replaced* the original default adapter for</code><a href="http://">http://</a><code>.</code></li>
<li><code> Requests to other HTTPS sites like</code><a href="https://google.com">https://google.com</a><code>will still use the original default adapter mounted for the shorter</code><a href="https://">https://</a><code>prefix.</code></li>
<li><code> The</code>s.get_adapter(url)` method shows how the session selects the adapter based on the longest matching prefix.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2982"></a>
Use Case: Customizing Retries</h2>
<p>Let's go back to the unreliable API example. We want to configure <code>requests</code> to automatically retry requests to <code><a href="https://flaky-api.example.com">https://flaky-api.example.com</a></code> up to 5 times if certain errors occur (like temporary server errors or connection issues).</p>
<p>The <code>HTTPAdapter</code>'s retry logic is controlled by a <code>Retry</code> object from the underlying <code>urllib3</code> library. We can create our own <code>Retry</code> object with custom settings and pass it to a <em>new</em> <code>HTTPAdapter</code> instance.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> requests</div>
<div class="line"><span class="keyword">from</span> requests.adapters <span class="keyword">import</span> HTTPAdapter</div>
<div class="line"><span class="keyword">from</span> urllib3.util.retry <span class="keyword">import</span> Retry <span class="comment"># Import the Retry class</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 1. Configure the retry strategy</span></div>
<div class="line"><span class="comment">#    - total=5: Try up to 5 times in total</span></div>
<div class="line"><span class="comment">#    - backoff_factor=0.5: Wait 0.5s, 1s, 2s, 4s between retries</span></div>
<div class="line"><span class="comment">#    - status_forcelist=[500, 502, 503, 504]: Only retry on these HTTP status codes</span></div>
<div class="line"><span class="comment">#    - allowed_methods=False: Retry for all methods (GET, POST, etc.) by default. Use [&quot;GET&quot;, &quot;POST&quot;] to restrict.</span></div>
<div class="line">retry_strategy = Retry(</div>
<div class="line">    total=5,</div>
<div class="line">    backoff_factor=0.5,</div>
<div class="line">    status_forcelist=[500, 502, 503, 504],</div>
<div class="line">    <span class="comment"># allowed_methods=False # Default includes most common methods</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 2. Create an HTTPAdapter with this retry strategy</span></div>
<div class="line"><span class="comment">#    The &#39;max_retries&#39; argument accepts a Retry object</span></div>
<div class="line">adapter_with_retries = HTTPAdapter(max_retries=retry_strategy)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 3. Create a Session</span></div>
<div class="line">session = requests.Session()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 4. Mount the adapter for the specific API prefix</span></div>
<div class="line">api_base_url = <span class="stringliteral">&#39;https://flaky-api.example.com/&#39;</span> <span class="comment"># Use the base URL prefix</span></div>
<div class="line">session.mount(api_base_url, adapter_with_retries)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 5. Now, use the session to make requests to the flaky API</span></div>
<div class="line">api_endpoint = f<span class="stringliteral">&quot;{api_base_url}data&quot;</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Making request to {api_endpoint} with custom retries...&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    <span class="comment"># Imagine this API sometimes returns 503 Service Unavailable</span></div>
<div class="line">    response = session.get(api_endpoint)</div>
<div class="line">    response.raise_for_status() <span class="comment"># Check for HTTP errors</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Success!&quot;</span>)</div>
<div class="line">    <span class="comment"># print(response.json()) # Process the successful response</span></div>
<div class="line"><span class="keywordflow">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Request failed after retries: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Requests to other domains will use the default adapter/retries</span></div>
<div class="line">print(<span class="stringliteral">&quot;\nMaking request to a different site (default retries)...&quot;</span>)</div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    response_other = session.get(<span class="stringliteral">&#39;https://httpbin.org/get&#39;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Status for httpbin: {response_other.status_code}&quot;</span>)</div>
<div class="line"><span class="keywordflow">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Httpbin request failed: {e}&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>We defined our desired retry behavior using <code>urllib3.util.retry.Retry</code>.</li>
<li>We created a <em>new</em> <code>HTTPAdapter</code>, passing our <code>retry_strategy</code> to its <code>max_retries</code> parameter during initialization.</li>
<li>We created a <code>Session</code>.</li>
<li>Crucially, we <code>mount</code>ed our <code>adapter_with_retries</code> specifically to the base URL of the flaky API (<code><a href="https://flaky-api.example.com/">https://flaky-api.example.com/</a></code>).</li>
<li>When <code>session.get(api_endpoint)</code> is called, the Session sees that the URL starts with the mounted prefix, so it uses our <code>adapter_with_retries</code>. If the server returns a <code>503</code> error, this adapter (using the <code>Retry</code> object) will automatically wait and try again, up to 5 times.</li>
<li>Requests to <code><a href="https://httpbin.org">https://httpbin.org</a></code> don't match the specific prefix, so they fall back to the default adapter mounted for <code><a href="https://">https://</a></code>, which has default retry behavior.</li>
</ol>
<p>This allows fine-grained control over connection handling for different destinations.</p>
<h2><a class="anchor" id="autotoc_md2983"></a>
How It Works Internally: The Session-Adapter Dance</h2>
<p>Let's trace the steps when you call <code>session.get(url)</code>:</p>
<ol type="1">
<li><b><code>Session.request</code>:</b> Your <code>session.get(url, ...)</code> call ends up in the main <code>Session.request</code> method.</li>
<li><b>Prepare Request:</b> <code>Session.request</code> creates a <code>Request</code> object and calls <code>self.prepare_request(req)</code> to turn it into a <code>PreparedRequest</code>, merging session-level settings like headers and cookies (as seen in <a class="el" href="../../dd/d2f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_203__session.html">Chapter 3: Session</a>).</li>
<li><b>Merge Environment Settings:</b> <code>Session.request</code> calls <code>self.merge_environment_settings(...)</code> to figure out final settings for proxies, SSL verification (<code>verify</code>), etc.</li>
<li><b><code>Session.send</code>:</b> The prepared request (<code>prep</code>) and final settings (<code>send_kwargs</code>) are passed to <code>self.send(prep, **send_kwargs)</code>.</li>
<li><b><code>get_adapter</code>:</b> Inside <code>Session.send</code>, the first crucial step is <code>adapter = self.get_adapter(url=request.url)</code>. This method looks through the <code>self.adapters</code> dictionary (which is ordered from longest prefix to shortest) and returns the <em>first</em> adapter whose mounted prefix matches the beginning of the request's URL.</li>
<li><b><code>adapter.send</code>:</b> The <code>Session</code> then calls the <code>send</code> method <em>on the chosen adapter</em>: <code>r = adapter.send(request, **kwargs)</code>. <b>This is the handover!</b> The Session delegates the actual sending to the Transport Adapter.</li>
<li><b>Adapter Does the Work:</b> The adapter (e.g., <code>HTTPAdapter</code>) takes over.<ul>
<li>It interacts with its <code>urllib3.PoolManager</code> to get a connection from the pool (or create one).</li>
<li>It configures SSL/TLS context based on <code>verify</code> and <code>cert</code> parameters.</li>
<li>It uses <code>urllib3</code> to send the actual HTTP request bytes over the network.</li>
<li>It applies retry logic (using the <code>Retry</code> object if configured) if <code>urllib3</code> reports certain connection errors or status codes.</li>
<li>It receives the raw HTTP response bytes from <code>urllib3</code>.</li>
</ul>
</li>
<li><b><code>adapter.build_response</code>:</b> The adapter takes the raw response data from <code>urllib3</code> and constructs a <code>requests.Response</code> object using its <code>build_response(request, raw_urllib3_response)</code> method. This involves parsing status codes, headers, and making the response body available.</li>
<li><b>Return Response:</b> The <code>adapter.send</code> method returns the fully formed <code>Response</code> object back to the <code>Session.send</code> method.</li>
<li><b>Post-Processing:</b> <code>Session.send</code> does some final steps, like extracting cookies from the response into the session's <a class="el" href="../../d1/df9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_204__cookie__jar.html">Cookie Jar</a> and handling redirects (which might involve calling <code>send</code> again).</li>
<li><b>Final Return:</b> The final <code>Response</code> object is returned to your original <code>session.get(url)</code> call.</li>
</ol>
<p>Here's a simplified diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant UserCode as Your Code</div>
<div class="line">    participant Session as Session Object</div>
<div class="line">    participant Adapter as Transport Adapter</div>
<div class="line">    participant Urllib3 as urllib3 Library</div>
<div class="line">    participant Server</div>
<div class="line"> </div>
<div class="line">    UserCode-&gt;&gt;Session: session.get(url)</div>
<div class="line">    Session-&gt;&gt;Session: prepare_request(req) -&gt; PreparedRequest (prep)</div>
<div class="line">    Session-&gt;&gt;Session: merge_environment_settings() -&gt; send_kwargs</div>
<div class="line">    Session-&gt;&gt;Session: get_adapter(url) -&gt; adapter_instance</div>
<div class="line">    Session-&gt;&gt;Adapter: adapter_instance.send(prep, **send_kwargs)</div>
<div class="line">    activate Adapter</div>
<div class="line">    Adapter-&gt;&gt;Urllib3: Get connection from PoolManager</div>
<div class="line">    Adapter-&gt;&gt;Urllib3: urlopen(prep.method, url, ..., retries=..., timeout=...)</div>
<div class="line">    activate Urllib3</div>
<div class="line">    Urllib3-&gt;&gt;Server: Send HTTP Request Bytes</div>
<div class="line">    Server--&gt;&gt;Urllib3: Receive HTTP Response Bytes</div>
<div class="line">    Urllib3--&gt;&gt;Adapter: Return raw urllib3 response</div>
<div class="line">    deactivate Urllib3</div>
<div class="line">    Adapter-&gt;&gt;Adapter: build_response(prep, raw_response) -&gt; Response (r)</div>
<div class="line">    Adapter--&gt;&gt;Session: Return Response (r)</div>
<div class="line">    deactivate Adapter</div>
<div class="line">    Session-&gt;&gt;Session: Extract cookies, handle redirects...</div>
<div class="line">    Session--&gt;&gt;UserCode: Return final Response</div>
</div><!-- fragment --><p>Let's peek at the relevant code snippets:</p>
<div class="fragment"><div class="line"><span class="comment"># File: requests/sessions.py (Simplified View)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Session:</div>
<div class="line">    <span class="keyword">def </span>__init__(self):</div>
<div class="line">        <span class="comment"># ... other defaults ...</span></div>
<div class="line">        self.adapters = OrderedDict() <span class="comment"># The mounted adapters</span></div>
<div class="line">        self.mount(<span class="stringliteral">&#39;https://&#39;</span>, HTTPAdapter()) <span class="comment"># Mount default HTTPS adapter</span></div>
<div class="line">        self.mount(<span class="stringliteral">&#39;http://&#39;</span>, HTTPAdapter())  <span class="comment"># Mount default HTTP adapter</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>get_adapter(self, url):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Returns the appropriate connection adapter for the given URL.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">for</span> prefix, adapter <span class="keywordflow">in</span> self.adapters.items():</div>
<div class="line">            <span class="comment"># Find the longest prefix that matches the URL</span></div>
<div class="line">            <span class="keywordflow">if</span> url.lower().startswith(prefix.lower()):</div>
<div class="line">                <span class="keywordflow">return</span> adapter</div>
<div class="line">        <span class="comment"># No match found</span></div>
<div class="line">        <span class="keywordflow">raise</span> InvalidSchema(f<span class="stringliteral">&quot;No connection adapters were found for {url!r}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>mount(self, prefix, adapter):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Registers a connection adapter to a prefix.&quot;&quot;&quot;</span></div>
<div class="line">        self.adapters[prefix] = adapter</div>
<div class="line">        <span class="comment"># Sort adapters by prefix length, descending (longest first)</span></div>
<div class="line">        <span class="comment"># Simplified: Real code sorts keys and rebuilds OrderedDict</span></div>
<div class="line">        keys_to_move = [k <span class="keywordflow">for</span> k <span class="keywordflow">in</span> self.adapters <span class="keywordflow">if</span> len(k) &lt; len(prefix)]</div>
<div class="line">        <span class="keywordflow">for</span> key <span class="keywordflow">in</span> keys_to_move:</div>
<div class="line">             self.adapters[key] = self.adapters.pop(key)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>send(self, request, **kwargs):</div>
<div class="line">        <span class="comment"># ... setup kwargs (stream, verify, cert, proxies) ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># === GET THE ADAPTER ===</span></div>
<div class="line">        adapter = self.get_adapter(url=request.url)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># === DELEGATE TO THE ADAPTER ===</span></div>
<div class="line">        <span class="comment"># Start timer</span></div>
<div class="line">        start = preferred_clock()</div>
<div class="line">        <span class="comment"># Call the adapter&#39;s send method</span></div>
<div class="line">        r = adapter.send(request, **kwargs)</div>
<div class="line">        <span class="comment"># Stop timer</span></div>
<div class="line">        elapsed = preferred_clock() - start</div>
<div class="line">        r.elapsed = timedelta(seconds=elapsed)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># ... dispatch response hooks ...</span></div>
<div class="line">        <span class="comment"># ... persist cookies (extract_cookies_to_jar) ...</span></div>
<div class="line">        <span class="comment"># ... handle redirects (resolve_redirects, might call send again) ...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># ... maybe read content if stream=False ...</span></div>
<div class="line">        <span class="keywordflow">return</span> r</div>
<div class="line"> </div>
<div class="line"><span class="comment"># File: requests/adapters.py (Simplified View)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> urllib3.util.retry <span class="keyword">import</span> Retry</div>
<div class="line"><span class="keyword">from</span> urllib3.poolmanager <span class="keyword">import</span> PoolManager <span class="comment"># Used internally by HTTPAdapter</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>BaseAdapter:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;The Base Transport Adapter&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):</span></div>
<div class="line"><span class="stringliteral">        raise NotImplementedError</span></div>
<div class="line"><span class="stringliteral">    def close(self):</span></div>
<div class="line"><span class="stringliteral">        raise NotImplementedError</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">class HTTPAdapter(BaseAdapter):</span></div>
<div class="line"><span class="stringliteral">    def __init__(self, pool_connections=10, pool_maxsize=10, max_retries=0, pool_block=False):</span></div>
<div class="line"><span class="stringliteral">        # === STORE RETRY CONFIGURATION ===</span></div>
<div class="line"><span class="stringliteral">        if isinstance(max_retries, Retry):</span></div>
<div class="line"><span class="stringliteral">            self.max_retries = max_retries</span></div>
<div class="line"><span class="stringliteral">        else:</span></div>
<div class="line"><span class="stringliteral">            # Convert integer retries to a basic Retry object</span></div>
<div class="line"><span class="stringliteral">            self.max_retries = Retry(total=max_retries, read=False, connect=max_retries)</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        # ... configure pooling options ...</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">        # === INITIALIZE URLIB3 POOL MANAGER ===</span></div>
<div class="line"><span class="stringliteral">        # This object manages connections using urllib3</span></div>
<div class="line"><span class="stringliteral">        self.poolmanager = PoolManager(num_pools=pool_connections, maxsize=pool_maxsize, block=pool_block)</span></div>
<div class="line"><span class="stringliteral">        self.proxy_manager = {} # For handling proxies</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">    def send(self, request, stream=False, timeout=None, verify=True, cert=None, proxies=None):</span></div>
<div class="line"><span class="stringliteral">        &quot;&quot;&quot;</span>Sends PreparedRequest object using urllib3.&quot;&quot;&quot;</div>
<div class="line">        # ... determine connection pool (conn) based on URL, proxies, SSL context ...</div>
<div class="line">        conn = self.get_connection_with_tls_context(request, verify, proxies=proxies, cert=cert)</div>
<div class="line">        # ... determine URL to use (might be different for proxies) ...</div>
<div class="line">        url = self.request_url(request, proxies)</div>
<div class="line">        # ... configure timeout object for urllib3 ...</div>
<div class="line">        timeout_obj = self._build_timeout(timeout)</div>
<div class="line"> </div>
<div class="line">        try:</div>
<div class="line">            # === CALL URLIB3 ===</div>
<div class="line">            # This is the core network call</div>
<div class="line">            resp = conn.urlopen(</div>
<div class="line">                method=request.method,</div>
<div class="line">                url=url,</div>
<div class="line">                body=request.body,</div>
<div class="line">                headers=request.headers,</div>
<div class="line">                redirect=False, # Requests handles redirects</div>
<div class="line">                assert_same_host=False,</div>
<div class="line">                preload_content=False, # Requests streams content</div>
<div class="line">                decode_content=False, # Requests handles decoding</div>
<div class="line">                retries=self.max_retries, # Pass configured retries</div>
<div class="line">                timeout=timeout_obj,     # Pass configured timeout</div>
<div class="line">                chunked=... # Determine if chunked encoding is needed</div>
<div class="line">            )</div>
<div class="line"> </div>
<div class="line">        except (urllib3_exceptions...) as err:</div>
<div class="line">            # === WRAP URLIB3 EXCEPTIONS ===</div>
<div class="line">            # Catch exceptions from urllib3 and raise corresponding</div>
<div class="line">            # requests.exceptions (ConnectionError, Timeout, SSLError, etc.)</div>
<div class="line">            # See Chapter 6 for details.</div>
<div class="line">            raise MappedRequestsException(err, request=request)</div>
<div class="line"> </div>
<div class="line">        # === BUILD RESPONSE OBJECT ===</div>
<div class="line">        # Convert the raw urllib3 response into a requests.Response</div>
<div class="line">        response = self.build_response(request, resp)</div>
<div class="line"> </div>
<div class="line">        return response</div>
<div class="line"> </div>
<div class="line">    def build_response(self, req, resp):</div>
<div class="line">        &quot;&quot;&quot;Builds a requests.Response from a urllib3 response.&quot;&quot;&quot;</div>
<div class="line">        response = Response()</div>
<div class="line">        response.status_code = getattr(resp, &#39;status&#39;, None)</div>
<div class="line">        response.headers = CaseInsensitiveDict(getattr(resp, &#39;headers&#39;, {}))</div>
<div class="line">        response.raw = resp # The raw urllib3 response object</div>
<div class="line">        response.reason = response.raw.reason</div>
<div class="line">        response.url = req.url</div>
<div class="line">        # ... extract cookies, set encoding, link request ...</div>
<div class="line">        response.request = req</div>
<div class="line">        response.connection = self # Link back to this adapter</div>
<div class="line">        return response</div>
<div class="line"> </div>
<div class="line">    def close(self):</div>
<div class="line">        &quot;&quot;&quot;Close the underlying PoolManager.&quot;&quot;&quot;</div>
<div class="line">        self.poolmanager.clear()</div>
<div class="line">        # ... close proxy managers ...</div>
<div class="line"> </div>
<div class="line">    # ... other helper methods (cert_verify, proxy_manager_for, request_url) ...</div>
</div><!-- fragment --><p>The key idea is that the <code>Session</code> finds the right <code>Adapter</code> using <code>mount</code> prefixes, and then the <code>Adapter</code> uses <code>urllib3</code> to handle the low-level details of connection pooling, retries, and HTTP communication.</p>
<h2><a class="anchor" id="autotoc_md2984"></a>
Other Use Cases</h2>
<p>Besides custom retries, you might use Transport Adapters for:</p>
<ul>
<li><b>Custom SSL/TLS Contexts:</b> Create an <code>HTTPAdapter</code> and initialize its <code>PoolManager</code> with a custom <code>ssl.SSLContext</code> for fine-grained control over TLS versions, ciphers, or certificate verification logic.</li>
<li><b>SOCKS Proxies:</b> While <code>requests</code> doesn't support SOCKS natively, you can install a third-party library (like <code>requests-socks</code>) which provides a <code>SOCKSAdapter</code> that you can mount onto a session.</li>
<li><b>Testing:</b> You could create a custom adapter that doesn't actually make network requests but returns predefined responses, useful for testing your application without hitting real servers.</li>
<li><b>Custom Protocols:</b> If you needed to interact with a non-HTTP protocol, you could theoretically write a custom <code>BaseAdapter</code> subclass to handle it.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2985"></a>
Conclusion</h2>
<p>You've learned about <b>Transport Adapters</b>, the pluggable backends that <code>requests</code> uses to handle the actual sending of requests and management of connections for different URL schemes (<code><a href="http://">http://</a></code>, <code><a href="https://">https://</a></code>, etc.).</p>
<ul>
<li>You saw the default adapter is <code>HTTPAdapter</code>, which uses <code>urllib3</code> for connection pooling, retries, and SSL.</li>
<li>You learned how <code>Session</code> objects <code>mount</code> adapters to specific URL prefixes.</li>
<li>You practiced customizing retry behavior by creating a new <code>HTTPAdapter</code> with a <code>urllib3.util.retry.Retry</code> object and mounting it to a session.</li>
<li>You traced how a <code>Session</code> finds and delegates work to the appropriate adapter via <code>adapter.send</code>.</li>
</ul>
<p>Transport Adapters give you powerful, low-level control over how <code>requests</code> interacts with the network, allowing you to tailor its behavior for specific needs.</p>
<p>Adapters let you customize <em>how</em> requests are sent. What if you want to simply <em>react</em> to a request being sent or a response being received, perhaps to log it or modify it slightly on the fly? <code>Requests</code> has another mechanism for that.</p>
<p><b>Next:</b> <a class="el" href="../../d6/d3d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Requests_208__hook__system.html">Chapter 8: The Hook System</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
