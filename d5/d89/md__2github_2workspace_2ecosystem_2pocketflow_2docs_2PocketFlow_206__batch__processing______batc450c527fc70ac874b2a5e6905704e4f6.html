#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_batch_processing___batchnode____batchflow____asyncparallelbatchnode___</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/d89/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_206__batch__processing______batc450c527fc70ac874b2a5e6905704e4f6.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_batch_processing___batchnode____batchflow____asyncparallelbatchnode___</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2787"></a>
autotoc_md2787</h2>
<p>layout: default title: "Batch Processing (BatchNode, BatchFlow, AsyncParallelBatchNode)" parent: "PocketFlow" </p>
<h2><a class="anchor" id="autotoc_md2788"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md2789"></a>
Chapter 6: Batch Processing (<code>BatchNode</code>, <code>BatchFlow</code>, <code>AsyncParallelBatchNode</code>)</h1>
<p>In <a class="el" href="../../d7/d6d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2PocketFlow_205__asynchronous__processing___dbf1dc61cb3bcd98d46655d3ab8e2dd9.html">Chapter 5: Asynchronous Processing (<code>AsyncNode</code>, <code>AsyncFlow</code>)</a>, we explored how <code>AsyncNode</code> and <code>AsyncFlow</code> help build responsive applications that can handle waiting for tasks like API calls. Now, what if you need to perform a similar operation on <em>many</em> different items? For example, imagine you have a document, and you want to translate it into ten different languages. Doing this one by one, or even coordinating many asynchronous calls manually, can be cumbersome. PocketFlow provides specialized tools for exactly this: <b>Batch Processing</b>.</p>
<p>Batch processing in PocketFlow allows you to efficiently apply a piece of logic to a collection of items, simplifying the code and often improving performance, especially with parallel execution.</p>
<p>Our main use case for this chapter will be: <b>Translating a single document into multiple target languages.</b></p>
<p>Let's explore the tools PocketFlow offers for this:</p>
<h2><a class="anchor" id="autotoc_md2790"></a>
1. <code>BatchNode</code>: The Sequential Worker for Batches</h2>
<p>A <code>BatchNode</code> is designed to process a list of items one after the other (sequentially). It's like a meticulous librarian who takes a stack of books and processes each one individually before moving to the next.</p>
<p><b>How it Works:</b></p><ol type="1">
<li><b><code>prep(self, shared)</code></b>: This method is responsible for preparing your list of individual items to be processed. It should return an iterable (like a list) where each element is a single item for processing.</li>
<li><b><code>exec(self, item)</code></b>: This method is called <em>for each individual item</em> returned by <code>prep</code>. It contains the logic to process that single <code>item</code>.</li>
<li><b><code>post(self, shared, prep_res, exec_res_list)</code></b>: After all items have been processed by <code>exec</code>, this method is called. <code>exec_res_list</code> will be a list containing the results from each call to <code>exec</code>, in the same order as the input items.</li>
</ol>
<p><b>Example: Processing a Large CSV in Chunks</b></p>
<p>Let's look at <code>CSVProcessor</code> from <code>cookbook/pocketflow-batch-node/nodes.py</code>. It reads a large CSV file not all at once, but in smaller "chunks" (batches of rows).</p>
<div class="fragment"><div class="line"><span class="comment"># cookbook/pocketflow-batch-node/nodes.py</span></div>
<div class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</div>
<div class="line"><span class="keyword">from</span> pocketflow <span class="keyword">import</span> BatchNode</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>CSVProcessor(BatchNode):</div>
<div class="line">    <span class="keyword">def </span>__init__(self, chunk_size=1000):</div>
<div class="line">        super().__init__()</div>
<div class="line">        self.chunk_size = chunk_size</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">def </span>prep(self, shared):</div>
<div class="line">        <span class="comment"># Returns an iterator of DataFrame chunks</span></div>
<div class="line">        chunks = pd.read_csv(</div>
<div class="line">            shared[<span class="stringliteral">&quot;input_file&quot;</span>], chunksize=self.chunk_size</div>
<div class="line">        )</div>
<div class="line">        <span class="keywordflow">return</span> chunks <span class="comment"># Each &#39;chunk&#39; is an item</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>exec(self, chunk): <span class="comment"># Called for each chunk</span></div>
<div class="line">        <span class="comment"># Process one chunk (a pandas DataFrame)</span></div>
<div class="line">        <span class="keywordflow">return</span> { <span class="stringliteral">&quot;total_sales&quot;</span>: chunk[<span class="stringliteral">&quot;amount&quot;</span>].sum(), <span class="comment"># ... more stats ... </span></div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>post(self, shared, prep_res, exec_res_list):</div>
<div class="line">        <span class="comment"># exec_res_list contains results from all chunks</span></div>
<div class="line">        <span class="comment"># ... (combine statistics from all chunks) ...</span></div>
<div class="line">        shared[<span class="stringliteral">&quot;statistics&quot;</span>] = { <span class="comment"># ... final aggregated stats ... </span></div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;show_stats&quot;</span></div>
</div><!-- fragment --><ul>
<li><code>prep</code>: Reads the CSV specified in <code>shared["input_file"]</code> and returns an iterator where each item is a <code>DataFrame</code> (a chunk of rows).</li>
<li><code>exec</code>: Takes one <code>chunk</code> (a <code>DataFrame</code>) and calculates some statistics for it. This method will be called multiple times, once for each chunk from <code>prep</code>.</li>
<li><code>post</code>: Receives <code>exec_res_list</code>, which is a list of dictionaries (one from each <code>exec</code> call). It then aggregates these results and stores the final statistics in <code>shared</code>.</li>
</ul>
<p>This <code>BatchNode</code> processes each chunk sequentially.</p>
<h2><a class="anchor" id="autotoc_md2791"></a>
2. <code>AsyncParallelBatchNode</code>: The Concurrent Worker for Batches</h2>
<p>What if processing each item involves waiting (like an API call), and you want to do them concurrently to save time? That's where <code>AsyncParallelBatchNode</code> comes in. It's like <code>BatchNode</code> but for asynchronous operations that can run in parallel. Imagine a team of librarians, each given a book from the stack, processing them all at the same time.</p>
<p><b>How it Works:</b></p><ol type="1">
<li><b><code>async def prep_async(self, shared)</code></b>: Similar to <code>BatchNode.prep</code>, but asynchronous. It returns a list of items to be processed.</li>
<li><b><code>async def exec_async(self, item)</code></b>: This asynchronous method is called for each item. PocketFlow will use <code>asyncio.gather</code> to run these <code>exec_async</code> calls concurrently for all items.</li>
<li><b><code>async def post_async(self, shared, prep_res, exec_res_list)</code></b>: Called after all <code>exec_async</code> calls have completed. <code>exec_res_list</code> contains their results.</li>
</ol>
<p><b>Solving Our Use Case: Translating a Document into Multiple Languages</b></p>
<p>The <code>AsyncParallelBatchNode</code> is perfect for our document translation task. Let's look at <code>TranslateTextNodeParallel</code> from <code>cookbook/pocketflow-parallel-batch/main.py</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># cookbook/pocketflow-parallel-batch/main.py (simplified)</span></div>
<div class="line"><span class="keyword">from</span> pocketflow <span class="keyword">import</span> AsyncFlow, AsyncParallelBatchNode</div>
<div class="line"><span class="comment"># from utils import call_llm # Assumed async LLM call</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>TranslateTextNodeParallel(AsyncParallelBatchNode):</div>
<div class="line">    <span class="keyword">async def </span>prep_async(self, shared):</div>
<div class="line">        text = shared.get(<span class="stringliteral">&quot;text&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)</div>
<div class="line">        languages = shared.get(<span class="stringliteral">&quot;languages&quot;</span>, [])</div>
<div class="line">        <span class="comment"># Create a list of (text_to_translate, target_language) tuples</span></div>
<div class="line">        <span class="keywordflow">return</span> [(text, lang) <span class="keywordflow">for</span> lang <span class="keywordflow">in</span> languages]</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>exec_async(self, data_tuple):</div>
<div class="line">        text, language = data_tuple <span class="comment"># One (text, language) pair</span></div>
<div class="line">        <span class="comment"># prompt = f&quot;Translate &#39;{text}&#39; to {language}...&quot;</span></div>
<div class="line">        <span class="comment"># result = await call_llm(prompt) # Call LLM API</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;Translated to {language}&quot;</span>) <span class="comment"># Simplified</span></div>
<div class="line">        <span class="keywordflow">return</span> {<span class="stringliteral">&quot;language&quot;</span>: language, <span class="stringliteral">&quot;translation&quot;</span>: f<span class="stringliteral">&quot;Translated: {language}&quot;</span>}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>post_async(self, shared, prep_res, exec_res_list):</div>
<div class="line">        <span class="comment"># exec_res_list has all translation results</span></div>
<div class="line">        <span class="comment"># ... (code to save each translation to a file) ...</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;All {len(exec_res_list)} translations processed.&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;default&quot;</span> <span class="comment"># Or some other action</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># To run this, you&#39;d typically wrap it in an AsyncFlow:</span></div>
<div class="line"><span class="comment"># translate_node = TranslateTextNodeParallel()</span></div>
<div class="line"><span class="comment"># translation_flow = AsyncFlow(start=translate_node)</span></div>
<div class="line"><span class="comment"># await translation_flow.run_async(shared_data_with_text_and_languages)</span></div>
</div><!-- fragment --><p> In this example:</p><ul>
<li><code>prep_async</code>: Takes the document <code>text</code> and a list of <code>languages</code> from <code>shared</code>. It returns a list of tuples, e.g., <code>[(original_text, "Spanish"), (original_text, "French"), ...]</code>. Each tuple is an "item" for <code>exec_async</code>.</li>
<li><code>exec_async</code>: Takes one <code>(text, language)</code> tuple, calls an asynchronous LLM function (<code>call_llm</code>) to perform the translation, and returns a dictionary with the result. Because this is an <code>AsyncParallelBatchNode</code>, PocketFlow will try to run these LLM calls for all languages concurrently!</li>
<li><code>post_async</code>: Gets the list of all translation results and, in the full example, saves them to files.</li>
</ul>
<p>This drastically speeds up the overall translation process compared to doing them one by one.</p>
<h2><a class="anchor" id="autotoc_md2792"></a>
3. <code>BatchFlow</code>: Running a Sub-Workflow Multiple Times</h2>
<p>Sometimes, the "logic" you want to apply to a collection isn't just a single <code>exec</code> method, but a whole sub-workflow (which could be a single Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) or a more complex Flow (<code>Flow</code>, <code>AsyncFlow</code>)). You want to run this sub-workflow multiple times, each time with slightly different <em>parameters</em>. This is what <code>BatchFlow</code> is for.</p>
<p>Think of a film director who has a specific scene (the sub-workflow) and wants to shoot it multiple times, but each time with different actors or lighting (the parameters).</p>
<p><b>How it Works:</b></p><ol type="1">
<li>The <code>BatchFlow</code> is initialized with a <code>start</code> component, which is the sub-workflow (a Node (<code>BaseNode</code>, <code>Node</code>, <code>AsyncNode</code>) or Flow (<code>Flow</code>, <code>AsyncFlow</code>)) to be run multiple times.</li>
<li><b><code>prep(self, shared)</code></b>: This method of the <code>BatchFlow</code> itself should return a list of parameter dictionaries. Each dictionary represents one "run" of the sub-workflow.</li>
<li>For each parameter dictionary from <code>prep</code>, the <code>BatchFlow</code> executes its <code>start</code> component (the sub-workflow). The parameters from the dictionary are made available to the sub-workflow for that particular run, usually merged into its <code>shared</code> context or node <code>params</code>.</li>
<li><b><code>post(self, shared, prep_res, exec_res)</code></b>: This is called after all batch executions of the sub-workflow are done. Note: <code>exec_res</code> here is often <code>None</code> because the results of each sub-workflow execution are typically handled within those sub-workflows by writing to <code>shared</code>.</li>
</ol>
<p><b>Example: Applying Different Filters to Multiple Images</b></p>
<p>Consider <code>cookbook/pocketflow-batch-flow/flow.py</code>. We want to process several images, applying a different filter to each (or multiple filters to each image).</p>
<p>First, a base Flow (<code>Flow</code>, <code>AsyncFlow</code>) defines how to process <em>one</em> image with <em>one</em> filter: </p><div class="fragment"><div class="line"><span class="comment"># cookbook/pocketflow-batch-flow/flow.py (simplified base_flow)</span></div>
<div class="line"><span class="comment"># from pocketflow import Flow</span></div>
<div class="line"><span class="comment"># from nodes import LoadImage, ApplyFilter, SaveImage</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>create_base_flow(): <span class="comment"># This is our sub-workflow</span></div>
<div class="line">    load = LoadImage()</div>
<div class="line">    filter_node = ApplyFilter()</div>
<div class="line">    save = SaveImage()</div>
<div class="line">    </div>
<div class="line">    load - <span class="stringliteral">&quot;apply_filter&quot;</span> &gt;&gt; filter_node</div>
<div class="line">    filter_node - <span class="stringliteral">&quot;save&quot;</span> &gt;&gt; save</div>
<div class="line">    <span class="keywordflow">return</span> Flow(start=load) <span class="comment"># Base flow for one image-filter pair</span></div>
</div><!-- fragment --><p>Now, the <code>ImageBatchFlow</code>: </p><div class="fragment"><div class="line"><span class="comment"># cookbook/pocketflow-batch-flow/flow.py (ImageBatchFlow)</span></div>
<div class="line"><span class="comment"># from pocketflow import BatchFlow</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ImageBatchFlow(BatchFlow):</div>
<div class="line">    <span class="keyword">def </span>prep(self, shared):</div>
<div class="line">        images = [<span class="stringliteral">&quot;cat.jpg&quot;</span>, <span class="stringliteral">&quot;dog.jpg&quot;</span>]</div>
<div class="line">        filters = [<span class="stringliteral">&quot;grayscale&quot;</span>, <span class="stringliteral">&quot;blur&quot;</span>]</div>
<div class="line">        params = [] <span class="comment"># List of parameter dictionaries</span></div>
<div class="line">        <span class="keywordflow">for</span> img <span class="keywordflow">in</span> images:</div>
<div class="line">            <span class="keywordflow">for</span> f <span class="keywordflow">in</span> filters:</div>
<div class="line">                <span class="comment"># Each dict is one set of params for the base_flow</span></div>
<div class="line">                params.append({<span class="stringliteral">&quot;input_image_path&quot;</span>: img, <span class="stringliteral">&quot;filter_type&quot;</span>: f})</div>
<div class="line">        <span class="keywordflow">return</span> params</div>
<div class="line"> </div>
<div class="line"><span class="comment"># How to use it:</span></div>
<div class="line"><span class="comment"># base_processing_logic = create_base_flow()</span></div>
<div class="line"><span class="comment"># image_processor = ImageBatchFlow(start=base_processing_logic)</span></div>
<div class="line"><span class="comment"># image_processor.run(initial_shared_data)</span></div>
</div><!-- fragment --><ul>
<li><code>ImageBatchFlow.prep</code>: Generates a list of parameter dictionaries. Each dictionary specifies an input image and a filter type, e.g., <code>[{"input_image_path": "cat.jpg", "filter_type": "grayscale"}, {"input_image_path": "cat.jpg", "filter_type": "blur"}, ...]</code>.</li>
<li>When <code>image_processor.run()</code> is called, the <code>base_processing_logic</code> (Flow (<code>Flow</code>, <code>AsyncFlow</code>)) will be executed for <em>each</em> of these parameter dictionaries. The <code>LoadImage</code> node inside <code>base_processing_logic</code> would then use <code>params["input_image_path"]</code>, and <code>ApplyFilter</code> would use <code>params["filter_type"]</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2793"></a>
4. <code>AsyncParallelBatchFlow</code>: Running Sub-Workflows in Parallel</h2>
<p>Just as <code>AsyncParallelBatchNode</code> is the concurrent version of <code>BatchNode</code>, <code>AsyncParallelBatchFlow</code> is the concurrent version of <code>BatchFlow</code>. It runs the multiple executions of its sub-workflow <em>in parallel</em>.</p>
<p>This is like having multiple film crews, each with their own set, shooting different variations of the same scene (sub-workflow with different parameters) all at the same time.</p>
<p><b>How it Works:</b> Similar to <code>BatchFlow</code>, but:</p><ol type="1">
<li>Uses <code>async def prep_async(self, shared)</code> to generate the list of parameter dictionaries.</li>
<li>When run with <code>await my_flow.run_async()</code>, it executes the sub-workflow for each parameter set concurrently using <code>asyncio.gather</code>.</li>
</ol>
<p><b>Example: Parallel Image Processing with Filters</b> The <code>cookbook/pocketflow-parallel-batch-flow/flow.py</code> shows an <code>ImageParallelBatchFlow</code>. </p><div class="fragment"><div class="line"><span class="comment"># cookbook/pocketflow-parallel-batch-flow/flow.py (Conceptual)</span></div>
<div class="line"><span class="comment"># from pocketflow import AsyncParallelBatchFlow</span></div>
<div class="line"><span class="comment"># from nodes import LoadImageAsync, ApplyFilterAsync, SaveImageAsync </span></div>
<div class="line"><span class="comment"># (assuming async versions of nodes for the base async flow)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># def create_async_base_flow(): ... returns an AsyncFlow ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ImageParallelBatchFlow(AsyncParallelBatchFlow):</div>
<div class="line">    <span class="keyword">async def </span>prep_async(self, shared):</div>
<div class="line">        <span class="comment"># ... (generates list of param dicts like before) ...</span></div>
<div class="line">        <span class="comment"># params.append({&quot;image_path&quot;: img, &quot;filter&quot;: f_type})</span></div>
<div class="line">        <span class="keywordflow">return</span> params</div>
<div class="line"> </div>
<div class="line"><span class="comment"># How to use it:</span></div>
<div class="line"><span class="comment"># async_base_logic = create_async_base_flow() # An AsyncFlow</span></div>
<div class="line"><span class="comment"># parallel_processor = ImageParallelBatchFlow(start=async_base_logic)</span></div>
<div class="line"><span class="comment"># await parallel_processor.run_async(initial_shared_data)</span></div>
</div><!-- fragment --><p> This would run the <code>async_base_logic</code> for each image-filter combination in parallel, potentially speeding up processing if the sub-workflow involves <code>await</code>able operations.</p>
<h2><a class="anchor" id="autotoc_md2794"></a>
Under the Hood: A Glimpse</h2>
<p>Let's briefly see how these batch components achieve their magic, using simplified logic.</p>
<p><b><code>BatchNode</code></b> Its <code>_exec</code> method essentially loops through the items from <code>prep</code> and calls its parent's <code>_exec</code> (which eventually calls your <code>exec</code> method) for each one. </p><div class="fragment"><div class="line"><span class="comment"># pocketflow/__init__.py (BatchNode simplified)</span></div>
<div class="line"><span class="keyword">class </span>BatchNode(Node):</div>
<div class="line">    <span class="keyword">def </span>_exec(self, items_from_prep):</div>
<div class="line">        results = []</div>
<div class="line">        <span class="keywordflow">for</span> item <span class="keywordflow">in</span> (items_from_prep <span class="keywordflow">or</span> []):</div>
<div class="line">            <span class="comment"># Calls Node._exec(item), which calls self.exec(item)</span></div>
<div class="line">            result_for_item = super(BatchNode, self)._exec(item)</div>
<div class="line">            results.append(result_for_item)</div>
<div class="line">        <span class="keywordflow">return</span> results <span class="comment"># This list becomes exec_res_list in post()</span></div>
</div><!-- fragment --><p><b><code>AsyncParallelBatchNode</code></b> Its <code>_exec</code> method uses <code>asyncio.gather</code> to run the processing of all items concurrently. </p><div class="fragment"><div class="line"><span class="comment"># pocketflow/__init__.py (AsyncParallelBatchNode simplified)</span></div>
<div class="line"><span class="keyword">class </span>AsyncParallelBatchNode(AsyncNode, BatchNode): <span class="comment"># Inherits from AsyncNode</span></div>
<div class="line">    <span class="keyword">async def </span>_exec(self, items_from_prep_async):</div>
<div class="line">        tasks = []</div>
<div class="line">        <span class="keywordflow">for</span> item <span class="keywordflow">in</span> items_from_prep_async:</div>
<div class="line">            <span class="comment"># Create a task for super()._exec(item)</span></div>
<div class="line">            <span class="comment"># super()._exec eventually calls self.exec_async(item)</span></div>
<div class="line">            task = super(AsyncParallelBatchNode, self)._exec(item)</div>
<div class="line">            tasks.append(task)</div>
<div class="line">        <span class="keywordflow">return</span> await asyncio.gather(*tasks) <span class="comment"># Run all tasks concurrently</span></div>
</div><!-- fragment --> <div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant UserApp</div>
<div class="line">    participant APBN as AsyncParallelBatchNode</div>
<div class="line">    participant Item1Proc as exec_async(item1)</div>
<div class="line">    participant Item2Proc as exec_async(item2)</div>
<div class="line">    participant EventLoop</div>
<div class="line"> </div>
<div class="line">    UserApp-&gt;&gt;APBN: await node.run_async(shared)</div>
<div class="line">    APBN-&gt;&gt;APBN: await self.prep_async(shared)</div>
<div class="line">    Note right of APBN: Returns [item1, item2]</div>
<div class="line">    APBN-&gt;&gt;APBN: await self._exec([item1, item2])</div>
<div class="line">    APBN-&gt;&gt;EventLoop: asyncio.gather(exec_async(item1), exec_async(item2))</div>
<div class="line">    EventLoop--&gt;&gt;Item1Proc: Start</div>
<div class="line">    EventLoop--&gt;&gt;Item2Proc: Start</div>
<div class="line">    Note over Item1Proc, Item2Proc: Both run concurrently</div>
<div class="line">    Item1Proc--&gt;&gt;EventLoop: Done (result1)</div>
<div class="line">    Item2Proc--&gt;&gt;EventLoop: Done (result2)</div>
<div class="line">    EventLoop--&gt;&gt;APBN: Returns [result1, result2]</div>
<div class="line">    APBN-&gt;&gt;APBN: await self.post_async(shared, ..., [result1, result2])</div>
<div class="line">    APBN--&gt;&gt;UserApp: Final action</div>
</div><!-- fragment --><p><b><code>BatchFlow</code></b> Its <code>_run</code> method iterates through the parameter dictionaries from <code>prep</code> and, for each one, calls <code>_orch</code> (the standard Flow (<code>Flow</code>, <code>AsyncFlow</code>) orchestration method) to run its <code>start</code> component with those parameters. </p><div class="fragment"><div class="line"><span class="comment"># pocketflow/__init__.py (BatchFlow simplified)</span></div>
<div class="line"><span class="keyword">class </span>BatchFlow(Flow):</div>
<div class="line">    <span class="keyword">def </span>_run(self, shared):</div>
<div class="line">        param_list = self.prep(shared) <span class="keywordflow">or</span> []</div>
<div class="line">        <span class="keywordflow">for</span> param_set <span class="keywordflow">in</span> param_list:</div>
<div class="line">            <span class="comment"># Run the entire sub-workflow (self.start_node)</span></div>
<div class="line">            <span class="comment"># with current param_set merged.</span></div>
<div class="line">            <span class="comment"># self.params are the BatchFlow&#39;s own params.</span></div>
<div class="line">            merged_params = {**self.params, **param_set}</div>
<div class="line">            self._orch(shared, merged_params) <span class="comment"># _orch runs the sub-flow</span></div>
<div class="line">        <span class="keywordflow">return</span> self.post(shared, param_list, <span class="keywordtype">None</span>)</div>
</div><!-- fragment --> <div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant UserApp</div>
<div class="line">    participant BF as BatchFlow</div>
<div class="line">    participant SubFlowOrch as Sub-Workflow Orchestration (_orch)</div>
<div class="line">    </div>
<div class="line">    UserApp-&gt;&gt;BF: flow.run(shared)</div>
<div class="line">    BF-&gt;&gt;BF: self.prep(shared)</div>
<div class="line">    Note right of BF: Returns [params1, params2]</div>
<div class="line">    BF-&gt;&gt;SubFlowOrch: _orch(shared, params1)</div>
<div class="line">    Note right of SubFlowOrch: Sub-workflow runs with params1</div>
<div class="line">    SubFlowOrch--&gt;&gt;BF: Completes</div>
<div class="line">    BF-&gt;&gt;SubFlowOrch: _orch(shared, params2)</div>
<div class="line">    Note right of SubFlowOrch: Sub-workflow runs with params2</div>
<div class="line">    SubFlowOrch--&gt;&gt;BF: Completes</div>
<div class="line">    BF-&gt;&gt;BF: self.post(shared, ...)</div>
<div class="line">    BF--&gt;&gt;UserApp: Final action</div>
</div><!-- fragment --><p><b><code>AsyncParallelBatchFlow</code></b> Its <code>_run_async</code> method is similar to <code>BatchFlow._run</code> but uses <code>asyncio.gather</code> to run all the <code>_orch_async</code> calls (for its sub-workflow) in parallel. </p><div class="fragment"><div class="line"><span class="comment"># pocketflow/__init__.py (AsyncParallelBatchFlow simplified)</span></div>
<div class="line"><span class="keyword">class </span>AsyncParallelBatchFlow(AsyncFlow, BatchFlow):</div>
<div class="line">    <span class="keyword">async def </span>_run_async(self, shared):</div>
<div class="line">        param_list = await self.prep_async(shared) <span class="keywordflow">or</span> []</div>
<div class="line">        tasks = []</div>
<div class="line">        <span class="keywordflow">for</span> param_set <span class="keywordflow">in</span> param_list:</div>
<div class="line">            merged_params = {**self.params, **param_set}</div>
<div class="line">            <span class="comment"># Create a task for each sub-workflow run</span></div>
<div class="line">            task = self._orch_async(shared, merged_params)</div>
<div class="line">            tasks.append(task)</div>
<div class="line">        await asyncio.gather(*tasks) <span class="comment"># Run all sub-workflow instances concurrently</span></div>
<div class="line">        <span class="keywordflow">return</span> await self.post_async(shared, param_list, <span class="keywordtype">None</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2795"></a>
Conclusion</h2>
<p>Batch processing tools in PocketFlow—<code>BatchNode</code>, <code>AsyncParallelBatchNode</code>, <code>BatchFlow</code>, and <code>AsyncParallelBatchFlow</code>—provide powerful and convenient ways to handle collections of items or run workflows multiple times with varying parameters.</p><ul>
<li>Use <b><code>BatchNode</code></b> for sequential processing of a list of items where <code>exec</code> defines the logic for one item.</li>
<li>Use <b><code>AsyncParallelBatchNode</code></b> for concurrent processing of items, ideal for I/O-bound tasks like multiple API calls (our translation example).</li>
<li>Use <b><code>BatchFlow</code></b> when you have a sub-workflow that needs to be run multiple times sequentially, each time with different parameters.</li>
<li>Use <b><code>AsyncParallelBatchFlow</code></b> to run instances of a sub-workflow concurrently with different parameters.</li>
</ul>
<p>These abstractions help keep your code clean, manage complexity, and leverage concurrency for better performance.</p>
<p>So far, we've seen how individual agents or flows can be constructed. But what if you need multiple, distinct AI agents to collaborate and communicate with each other?</p>
<p>Next up: Chapter 7: A2A (Agent-to-Agent) Communication Framework</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
