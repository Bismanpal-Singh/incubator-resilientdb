#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_fastmcp_prompts___prompt____promptmanager__</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/de9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_205__fastmcp__prompts___e380d8fca08b641e7632fcc5814680b7.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_fastmcp_prompts___prompt____promptmanager__</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2398"></a>
autotoc_md2398</h2>
<p>layout: default title: "FastMCP Prompts (Prompt, PromptManager)" parent: "MCP Python SDK" </p>
<h2><a class="anchor" id="autotoc_md2399"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md2400"></a>
Chapter 5: Reusable Chat Starters - FastMCP Prompts (<code>Prompt</code>, <code>PromptManager</code>)</h1>
<p>In <a class="el" href="../../dc/df6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_204__fastmcp__tools______tool________toolmanager____.html">Chapter 4: FastMCP Tools (<code>Tool</code>, <code>ToolManager</code>)</a>, we learned how to give our server specific <em>actions</em> it can perform, like a calculator tool. But modern AI often involves conversations, especially with Large Language Models (LLMs). How do we manage the instructions and conversation starters we send to these models?</p>
<p>Imagine you want to build an AI assistant tool that can summarize text. You'll need to tell the underlying LLM <em>what</em> to do (summarize) and <em>what</em> text to summarize. You might also want to provide specific instructions like "Keep the summary under 50 words." You'll probably need variations of this prompt for different tasks. Writing this message structure over and over again in your tool code would be repetitive and hard to manage.</p>
<p>This is where <b>FastMCP Prompts</b> come in. They provide a way to create reusable templates for generating sequences of messages, perfect for starting conversations with LLMs or structuring requests.</p>
<h2><a class="anchor" id="autotoc_md2401"></a>
The Mad Libs Analogy: Prompts and the Prompt Manager</h2>
<p>Think of a <b><code>Prompt</code></b> like a <b>Mad Libs story template</b>. A Mad Libs template has a pre-written story with blanks (like <code>___(noun)___</code> or <code>___(verb)___</code>). You define the structure and the blanks.</p>
<ul>
<li><b><code>Prompt</code></b>: The Mad Libs template itself. It has a name (like "Vacation Story") and defined blanks. In FastMCP, the "story" is a sequence of messages (usually for an LLM), and the blanks are <b><code>PromptArgument</code></b> objects.</li>
<li><b><code>PromptArgument</code></b>: Represents a blank in the template. It defines the name of the blank (e.g., <code>text_to_summarize</code>), maybe a description, and whether it's required.</li>
<li><b>Rendering</b>: The act of filling in the blanks. You provide values (arguments) for the blanks (<code>text_to_summarize = "Once upon a time..."</code>), and the template generates the complete story. In FastMCP, rendering a <code>Prompt</code> with arguments produces a list of <b><code>PromptMessage</code></b> objects (like <code>UserMessage</code> or <code>AssistantMessage</code>). These messages have roles (<code>user</code>, <code>assistant</code>) and content, ready to be sent to an LLM.</li>
<li><b><code>PromptManager</code></b>: Like a folder or binder holding all your different Mad Libs templates. It's the part of <code>FastMCP</code> that stores and helps you find and use (<code>render</code>) your defined <code>Prompt</code> templates.</li>
</ul>
<p>Clients (like an AI application) can ask the <code>PromptManager</code> (via <code>FastMCP</code>) to list available prompt templates (<code>listPrompts</code>) and then request a specific, filled-in prompt sequence using its name and arguments (<code>getPrompt</code>).</p>
<h2><a class="anchor" id="autotoc_md2402"></a>
Creating Your First Prompt Template: Using <code>@server.prompt()</code></h2>
<p>Just like <code>@server.tool()</code> and <code>@server.resource()</code>, <code>FastMCP</code> provides a simple decorator, <code>@server.prompt()</code>, to easily define these message templates using Python functions.</p>
<p>Let's create a prompt template for our text summarization task.</p>
<p><b>File: <code>summarizer_server.py</code></b></p>
<div class="fragment"><div class="line"><span class="comment"># 1. Import FastMCP and message types</span></div>
<div class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</div>
<div class="line"><span class="keyword">from</span> mcp.server.fastmcp.prompts <span class="keyword">import</span> UserMessage <span class="comment"># We&#39;ll use this</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 2. Create the server instance</span></div>
<div class="line">server = FastMCP(name=<span class="stringliteral">&quot;SummarizerServer&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 3. Use the @server.prompt() decorator to define our template</span></div>
<div class="line"><span class="preprocessor">@server.prompt(name=&quot;summarize_text&quot;, description=&quot;Generates messages to ask an LLM to summarize text.&quot;)</span></div>
<div class="line"><span class="keyword">def </span>create_summary_prompt(text_to_summarize: str) -&gt; list[UserMessage]:</div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">  This function defines the &#39;summarize_text&#39; prompt template.</span></div>
<div class="line"><span class="stringliteral">  &#39;text_to_summarize: str&#39; defines a required argument (a blank).</span></div>
<div class="line"><span class="stringliteral">  &#39;-&gt; list[UserMessage]&#39; indicates it returns a list of messages.</span></div>
<div class="line"><span class="stringliteral">  &quot;&quot;&quot;</span></div>
<div class="line">  print(f<span class="stringliteral">&quot;Rendering prompt &#39;summarize_text&#39; with text: {text_to_summarize[:30]}...&quot;</span>) <span class="comment"># Log</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment"># 4. Construct the message(s) based on the arguments</span></div>
<div class="line">  <span class="comment"># Here, we create a single user message containing instructions and the text.</span></div>
<div class="line">  prompt_content = f<span class="stringliteral">&quot;Please summarize the following text concisely:\n\n{text_to_summarize}&quot;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment"># Return a list containing one UserMessage object</span></div>
<div class="line">  <span class="keywordflow">return</span> [UserMessage(content=prompt_content)]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># 5. Standard run block (optional: add a tool that uses this prompt later)</span></div>
<div class="line"><span class="keywordflow">if</span> __name__ == <span class="stringliteral">&quot;__main__&quot;</span>:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Starting {server.name}...&quot;</span>)</div>
<div class="line">    server.run()</div>
<div class="line">    print(f<span class="stringliteral">&quot;{server.name} finished.&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Imports</b>: We import <code>FastMCP</code> and <code>UserMessage</code> (a specific type of <code>PromptMessage</code>). <code>AssistantMessage</code> is also available.</li>
<li><b><code>server = FastMCP(...)</code></b>: Creates our server. Internally, this also creates a <code>PromptManager</code>.</li>
<li>**<code>@server.prompt(...)</code>**: This decorator registers our function as a prompt template.<ul>
<li><code>name="summarize_text"</code>: The name clients will use to request this template.</li>
<li><code>description="..."</code>: A helpful description.</li>
</ul>
</li>
<li><b><code>def create_summary_prompt(...)</code></b>: This Python function <em>builds</em> the message list when the prompt is rendered.<ul>
<li><code>text_to_summarize: str</code>: The type hint defines a required <code>PromptArgument</code> named <code>text_to_summarize</code>. This is the blank in our Mad Libs.</li>
<li><code>-&gt; list[UserMessage]</code>: The type hint tells <code>FastMCP</code> that this function will return a list containing <code>UserMessage</code> objects (or compatible types like plain strings or dicts that look like messages).</li>
<li>The function body uses the input argument (<code>text_to_summarize</code>) to construct the desired message content.</li>
<li>It returns a list containing a single <code>UserMessage</code>. You could return multiple messages (e.g., alternating user/assistant roles) to set up a conversation history.</li>
</ul>
</li>
<li><b><code>server.run()</code></b>: Starts the server. The <code>PromptManager</code> now knows about the <code>summarize_text</code> prompt template.</li>
</ol>
<p><b>What happens when a client uses this prompt?</b></p>
<ol type="1">
<li><b>Discovery (Optional):</b> A client might call <code>listPrompts</code>. The server (using <code>PromptManager</code>) would respond with information about the <code>summarize_text</code> prompt, including its name, description, and the required argument <code>text_to_summarize</code> (string).</li>
<li><b>Rendering Request:</b> The client wants to generate the messages for summarizing a specific text. It sends an MCP request: <code>getPrompt</code> with <code>name="summarize_text"</code> and <code>arguments={"text_to_summarize": "This is the text..."}</code>.</li>
<li><b>Server-Side Rendering:</b><ul>
<li><code>FastMCP</code> receives the request and asks its <code>PromptManager</code> to render the prompt.</li>
<li><code>PromptManager</code> finds the <code>Prompt</code> object associated with <code>summarize_text</code>.</li>
<li>It calls the <code>render</code> method on the <code>Prompt</code> object, which in turn calls your Python function <code>create_summary_prompt(text_to_summarize="This is the text...")</code>.</li>
<li>Your function runs, builds the <code>prompt_content</code> string, and returns <code>[UserMessage(content="Please summarize...")]</code>.</li>
<li><code>FastMCP</code> takes this list of <code>Message</code> objects.</li>
</ul>
</li>
<li><b>Response:</b> <code>FastMCP</code> sends the generated message list back to the client in the <code>getPrompt</code> response. The client now has the structured message(s) ready to be sent to an LLM.</li>
</ol>
<div class="fragment"><div class="line">// Example Client Request (Simplified MCP format)</div>
<div class="line">{</div>
<div class="line">  &quot;method&quot;: &quot;getPrompt&quot;,</div>
<div class="line">  &quot;params&quot;: {</div>
<div class="line">    &quot;name&quot;: &quot;summarize_text&quot;,</div>
<div class="line">    &quot;arguments&quot;: {</div>
<div class="line">      &quot;text_to_summarize&quot;: &quot;The quick brown fox jumps over the lazy dog.&quot;</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Example Server Response (Simplified MCP format)</div>
<div class="line">{</div>
<div class="line">  &quot;result&quot;: {</div>
<div class="line">    &quot;messages&quot;: [</div>
<div class="line">      {</div>
<div class="line">        &quot;role&quot;: &quot;user&quot;,</div>
<div class="line">        &quot;content&quot;: {</div>
<div class="line">          &quot;type&quot;: &quot;text&quot;,</div>
<div class="line">          &quot;text&quot;: &quot;Please summarize the following text concisely:\n\nThe quick brown fox jumps over the lazy dog.&quot;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    ]</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p>This makes it easy for client applications to get consistently formatted prompts for various tasks without needing to know the exact text structure themselves.</p>
<h2><a class="anchor" id="autotoc_md2403"></a>
Returning Different Message Types</h2>
<p>Your prompt function can return various things, and <code>FastMCP</code> will try to convert them into the standard <code>Message</code> format (like <code>UserMessage</code> or <code>AssistantMessage</code>):</p>
<ul>
<li><b>A single string:</b> Automatically converted to <code>UserMessage(content=TextContent(type="text", text=your_string))</code>.</li>
<li><b>A <code>Message</code> object (e.g., <code>UserMessage</code>, <code>AssistantMessage</code>):</b> Used directly.</li>
<li><b>A dictionary matching the <code>Message</code> structure:</b> e.g., <code>{"role": "user", "content": "Hello!"}</code>. Validated and converted.</li>
<li><b>A list containing any mix of the above:</b> Each item is converted/validated.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">from</span> mcp.server.fastmcp <span class="keyword">import</span> FastMCP</div>
<div class="line"><span class="comment"># Import both message types</span></div>
<div class="line"><span class="keyword">from</span> mcp.server.fastmcp.prompts <span class="keyword">import</span> UserMessage, AssistantMessage</div>
<div class="line"> </div>
<div class="line">server = FastMCP(name=<span class="stringliteral">&quot;MultiMessageServer&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@server.prompt(name=&quot;greet_user&quot;, description=&quot;Starts a simple conversation.&quot;)</span></div>
<div class="line"><span class="keyword">def </span>greeting_prompt(user_name: str): <span class="comment"># -&gt; returns list of mixed types</span></div>
<div class="line">  <span class="stringliteral">&quot;&quot;&quot;Generates a multi-turn conversation starter.&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment"># We can return a list containing different types:</span></div>
<div class="line">  <span class="keywordflow">return</span> [</div>
<div class="line">      <span class="comment"># A UserMessage object</span></div>
<div class="line">      UserMessage(f<span class="stringliteral">&quot;Hello {user_name}, tell me about your day.&quot;</span>),</div>
<div class="line">      <span class="comment"># A dictionary that looks like an AssistantMessage</span></div>
<div class="line">      {<span class="stringliteral">&quot;role&quot;</span>: <span class="stringliteral">&quot;assistant&quot;</span>, <span class="stringliteral">&quot;content&quot;</span>: <span class="stringliteral">&quot;I&#39;m ready to listen!&quot;</span>},</div>
<div class="line">      <span class="comment"># A simple string (becomes a UserMessage)</span></div>
<div class="line">      <span class="stringliteral">&quot;Start whenever you&#39;re ready.&quot;</span>,</div>
<div class="line">  ]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># ... (run block) ...</span></div>
</div><!-- fragment --><p>This flexibility lets you structure complex conversational prompts easily.</p>
<h2><a class="anchor" id="autotoc_md2404"></a>
How Prompts Work Under the Hood</h2>
<p>Using <code>@server.prompt()</code> is straightforward, but what's happening inside <code>FastMCP</code> and its <code>PromptManager</code>?</p>
<p><b>1. Registration (When the server code loads):</b></p>
<ul>
<li>Python executes your <code>summarizer_server.py</code>.</li>
<li>It reaches the <code>@server.prompt(name="summarize_text", ...)</code> line above <code>def create_summary_prompt(...)</code>.</li>
<li>This calls the <code>server.prompt()</code> method (in <code>server/fastmcp/server.py</code>). This method returns a decorator function that is immediately applied to <code>create_summary_prompt</code>.</li>
<li>The decorator function calls <code>server.add_prompt()</code>.</li>
<li><code>server.add_prompt()</code> calls <code>self._prompt_manager.add_prompt()</code>.</li>
<li>Inside <code>PromptManager.add_prompt</code> (in <code>server/fastmcp/prompts/manager.py</code>):<ul>
<li>It calls <code>Prompt.from_function(create_summary_prompt, name="summarize_text", ...)</code> (see <code>server/fastmcp/prompts/base.py</code>).</li>
<li><code>Prompt.from_function</code> inspects the <code>create_summary_prompt</code> function:<ul>
<li>Gets its name (<code>summarize_text</code>).</li>
<li>Gets its description (from decorator or docstring).</li>
<li>Looks at the parameters (<code>text_to_summarize: str</code>) using Python's introspection to determine the required <code>PromptArgument</code>s.</li>
<li>Creates a <code>Prompt</code> object storing the function itself (<code>fn</code>), its name, description, and the list of arguments.</li>
</ul>
</li>
<li>The <code>PromptManager</code> stores this <code>Prompt</code> object in its internal dictionary, keyed by the name <code>"summarize_text"</code>.</li>
</ul>
</li>
</ul>
<p><b>2. Rendering (When a client calls <code>getPrompt</code>):</b></p>
<ul>
<li>A client sends the MCP <code>getPrompt</code> request we saw earlier.</li>
<li><code>FastMCP</code> receives this and calls its internal <code>get_prompt</code> handler method (defined in <code>server/fastmcp/server.py</code>).</li>
<li>This handler calls <code>self._prompt_manager.render_prompt("summarize_text", {"text_to_summarize": "..."})</code>.</li>
<li>Inside <code>PromptManager.render_prompt</code>:<ul>
<li>It looks up <code>"summarize_text"</code> in its dictionary and finds the corresponding <code>Prompt</code> object.</li>
<li>It calls the <code>Prompt</code> object's <code>render</code> method: <code>prompt.render(arguments={"text_to_summarize": "..."})</code>.</li>
</ul>
</li>
<li>Inside <code>Prompt.render</code> (in <code>server/fastmcp/prompts/base.py</code>):<ul>
<li>It validates that all required arguments (like <code>text_to_summarize</code>) were provided.</li>
<li>It calls the original Python function stored in <code>prompt.fn</code>: <code>create_summary_prompt(text_to_summarize="...")</code>.</li>
<li>Your function executes and returns the list <code>[UserMessage(...)]</code>.</li>
<li>The <code>render</code> method takes this result, validates that each item is (or can be converted to) a <code>Message</code> object, and ensures the final output is a list of <code>Message</code>s.</li>
</ul>
</li>
<li>The <code>PromptManager</code> receives this validated list of <code>Message</code> objects.</li>
<li><code>FastMCP</code> takes the result, packages it into the standard MCP <code>GetPromptResult</code> format (which contains the <code>messages</code> list), and sends it back to the client.</li>
</ul>
<p><b>Simplified Sequence Diagram (<code>getPrompt</code> for <code>summarize_text</code>):</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client</div>
<div class="line">    participant FastMCP_Server as FastMCP (server.py)</div>
<div class="line">    participant PromptMgr as PromptManager (_prompt_manager)</div>
<div class="line">    participant SummaryPrompt as Prompt (wraps create_summary_prompt)</div>
<div class="line">    participant PromptFunc as create_summary_prompt()</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;+FastMCP_Server: Send MCP Request: getPrompt(name=&quot;summarize_text&quot;, args={&quot;text&quot;: &quot;...&quot;})</div>
<div class="line">    FastMCP_Server-&gt;&gt;+PromptMgr: render_prompt(name=&quot;summarize_text&quot;, args={...})</div>
<div class="line">    PromptMgr-&gt;&gt;PromptMgr: Find Prompt object for &quot;summarize_text&quot;</div>
<div class="line">    PromptMgr-&gt;&gt;+SummaryPrompt: prompt.render(arguments={...})</div>
<div class="line">    SummaryPrompt-&gt;&gt;+PromptFunc: Call create_summary_prompt(text_to_summarize=&quot;...&quot;)</div>
<div class="line">    PromptFunc--&gt;&gt;-SummaryPrompt: Return [UserMessage(content=&quot;Summarize: ...&quot;)]</div>
<div class="line">    SummaryPrompt-&gt;&gt;SummaryPrompt: Validate &amp; format message list</div>
<div class="line">    SummaryPrompt--&gt;&gt;-PromptMgr: Return validated [UserMessage(...)]</div>
<div class="line">    PromptMgr--&gt;&gt;-FastMCP_Server: Return [UserMessage(...)]</div>
<div class="line">    FastMCP_Server-&gt;&gt;-Client: Send MCP Response: result={messages: [{...}]}</div>
</div><!-- fragment --><p><b>Looking at the Code (Briefly):</b></p>
<p>You don't need to memorize the internal details, but seeing where things happen can clarify the process:</p>
<ul>
<li><p class="startli">**Registration (<code>@server.prompt</code> -&gt; <code>add_prompt</code> -&gt; <code>PromptManager.add_prompt</code>)**:</p><ul>
<li><code>server.py</code>: <code>FastMCP.prompt</code> decorator calls <code>self.add_prompt</code>.</li>
<li><code>server.py</code>: <code>FastMCP.add_prompt</code> calls <code>self._prompt_manager.add_prompt</code>.</li>
<li><code>manager.py</code>: <code>PromptManager.add_prompt</code> calls <code>Prompt.from_function</code> and stores the result.</li>
</ul>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2405"></a>
Inside server/fastmcp/prompts/manager.py (Simplified PromptManager.add_prompt)</h1>
<p>from .base import Prompt</p>
<p>class PromptManager: </p>
<h1><a class="anchor" id="autotoc_md2406"></a>
... (init, get_prompt, list_prompts) ...</h1>
<p>def add_prompt(self, prompt: Prompt) -&gt; Prompt: </p>
<h1><a class="anchor" id="autotoc_md2407"></a>
Check for duplicates...</h1>
<p>if prompt.name in self._prompts: </p>
<h1><a class="anchor" id="autotoc_md2408"></a>
... handle duplicate ...</h1>
<p>pass </p>
<h1><a class="anchor" id="autotoc_md2409"></a>
Store the Prompt object</h1>
<p>self._prompts[prompt.name] = prompt return prompt</p>
<h1><a class="anchor" id="autotoc_md2410"></a>
Note: Prompt.from_function (in base.py) does the function inspection.</h1>
<p>```</p>
<ul>
<li><p class="startli"><b>Rendering (<code>FastMCP.get_prompt</code> -&gt; <code>PromptManager.render_prompt</code> -&gt; <code>Prompt.render</code>)</b>:</p><ul>
<li><code>server.py</code>: <code>FastMCP.get_prompt</code> handles incoming requests and calls <code>self._prompt_manager.render_prompt</code>.</li>
</ul>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2411"></a>
Inside server/fastmcp/prompts/manager.py (Simplified PromptManager.render_prompt)</h1>
<p>class PromptManager: </p>
<h1><a class="anchor" id="autotoc_md2412"></a>
... (other methods) ...</h1>
<p>async def render_prompt(self, name, arguments=None): </p>
<h1><a class="anchor" id="autotoc_md2413"></a>
1. Find the prompt object by name</h1>
<p>prompt = self.get_prompt(name) if not prompt: raise ValueError(f"Unknown prompt: {name}")</p>
<h1><a class="anchor" id="autotoc_md2414"></a>
2. Tell the Prompt object to render itself</h1>
<p>return await prompt.render(arguments) ```</p>
<ul>
<li><code>base.py</code>: <code>Prompt.render</code> validates arguments and calls the stored function (<code>self.fn</code>). It then processes the function's return value into a list of <code>Message</code> objects.</li>
</ul>
<p>```python </p>
<h1><a class="anchor" id="autotoc_md2415"></a>
Inside server/fastmcp/prompts/base.py (Simplified Prompt.render)</h1>
<p>class Prompt: </p>
<h1><a class="anchor" id="autotoc_md2416"></a>
... (init, from_function, PromptArgument) ...</h1>
<p>async def render(self, arguments=None): </p>
<h1><a class="anchor" id="autotoc_md2417"></a>
Validate required arguments...</h1>
<h1><a class="anchor" id="autotoc_md2418"></a>
...</h1>
<p>try: </p>
<h1><a class="anchor" id="autotoc_md2419"></a>
Call the original decorated function</h1>
<p>result = self.fn(**(arguments or {})) if inspect.iscoroutine(result): # Handle async functions result = await result</p>
<h1><a class="anchor" id="autotoc_md2420"></a>
Convert result to list of Message objects</h1>
<h1><a class="anchor" id="autotoc_md2421"></a>
(Handles strings, dicts, Message objects, lists)</h1>
<p>messages: list[Message] = [] </p>
<h1><a class="anchor" id="autotoc_md2422"></a>
... (conversion logic using message_validator) ...</h1>
<p>return messages except Exception as e: raise ValueError(f"Error rendering prompt {self.name}: {e}") ```</p>
<h2><a class="anchor" id="autotoc_md2423"></a>
Conclusion</h2>
<p>You've learned about FastMCP Prompts, a powerful way to manage reusable message templates, especially useful for interacting with language models.</p>
<ul>
<li><b>Prompts (<code>Prompt</code>)</b> are like Mad Libs templates for creating sequences of <code>UserMessage</code>s and <code>AssistantMessage</code>s.</li>
<li>They use <b><code>PromptArgument</code>**s to define the "blanks" that need filling.</b></li>
<li><b> The **<code>PromptManager</code></b> keeps track of all defined prompts.</li>
<li>The **<code>@server.prompt()</code>** decorator provides an easy way to define a prompt template using a Python function. The function's parameters become arguments, and its return value (string, dict, Message object, or list thereof) defines the generated message sequence.</li>
<li>Clients use <code>listPrompts</code> to discover templates and <code>getPrompt</code> to render a specific template with arguments, receiving the generated messages back.</li>
</ul>
<p>Prompts help keep your LLM interaction logic organized, reusable, and separate from your main tool code.</p>
<p>In the next chapter, we'll explore a concept that ties tools, resources, and potentially prompts together during a request: <a class="el" href="../../d2/de0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_206__fastmcp__context______context____.html">Chapter 6: FastMCP Context (<code>Context</code>)</a>. This allows your tools and resources to access server capabilities like logging and progress reporting.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
