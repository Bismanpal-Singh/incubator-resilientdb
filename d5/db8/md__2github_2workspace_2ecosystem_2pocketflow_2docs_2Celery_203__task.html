#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_task</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/db8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_203__task.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_task</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md988"></a>
autotoc_md988</h2>
<p>layout: default title: "Task" parent: "Celery" </p>
<h2><a class="anchor" id="autotoc_md989"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md990"></a>
Chapter 3: Task - The Job Description</h1>
<p>In <a class="el" href="../../d3/d58/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_201__celery__app.html">Chapter 1: The Celery App</a>, we set up our Celery headquarters, and in <a class="el" href="../../d7/df5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_202__configuration.html">Chapter 2: Configuration</a>, we learned how to give it instructions. Now, we need to define the <em>actual work</em> we want Celery to do. This is where <b>Tasks</b> come in.</p>
<h2><a class="anchor" id="autotoc_md991"></a>
What Problem Does a Task Solve?</h2>
<p>Imagine you have a specific job that needs doing, like "Resize this image to thumbnail size" or "Send a welcome email to this new user." In Celery, each of these specific jobs is represented by a <b>Task</b>.</p>
<p>A Task is like a <b>job description</b> or a <b>recipe</b>. It contains the exact steps (the code) needed to complete a specific piece of work. You write this recipe once as a Python function, and then you can tell Celery to follow that recipe whenever you need that job done, potentially many times with different inputs (like resizing different images or sending emails to different users).</p>
<p>The key benefit is that you don't run the recipe immediately yourself. You hand the recipe (the Task) and the ingredients (the arguments, like the image file or the user's email) over to Celery. Celery then finds an available helper (a <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a>) who knows how to follow that specific recipe and lets them do the work in the background. This keeps your main application free to do other things.</p>
<h2><a class="anchor" id="autotoc_md992"></a>
Defining Your First Task</h2>
<p>Defining a task in Celery is surprisingly simple. You just take a regular Python function and "decorate" it using <code>@app.task</code>. Remember our <code>app</code> object from <a class="el" href="../../d3/d58/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_201__celery__app.html">Chapter 1</a>? We use its <code>task</code> decorator.</p>
<p>Let's create a file, perhaps named <code>tasks.py</code>, to hold our task definitions:</p>
<div class="fragment"><div class="line"><span class="comment"># tasks.py</span></div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"><span class="keyword">from</span> celery_app <span class="keyword">import</span> app <span class="comment"># Import the app instance we created</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>add(x, y):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;A simple task that adds two numbers.&quot;&quot;&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Task &#39;add&#39; starting with ({x}, {y})&quot;</span>)</div>
<div class="line">    <span class="comment"># Simulate some work taking time</span></div>
<div class="line">    time.sleep(5)</div>
<div class="line">    result = x + y</div>
<div class="line">    print(f<span class="stringliteral">&quot;Task &#39;add&#39; finished with result: {result}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> result</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.task</span></div>
<div class="line"><span class="keyword">def </span>send_welcome_email(user_id):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;A task simulating sending a welcome email.&quot;&quot;&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Task &#39;send_welcome_email&#39; starting for user {user_id}&quot;</span>)</div>
<div class="line">    <span class="comment"># Simulate email sending process</span></div>
<div class="line">    time.sleep(3)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Welcome email supposedly sent to user {user_id}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> f<span class="stringliteral">&quot;Email sent to {user_id}&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># You can have many tasks in one file!</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b><code>from celery_app import app</code></b>: We import the <code>Celery</code> app instance we configured earlier. This instance holds the knowledge about our broker and backend.</li>
<li>**<code>@app.task</code>**: This is the magic decorator! When Celery sees this above a function (<code>add</code> or <code>send_welcome_email</code>), it says, "Ah! This isn't just a regular function; it's a job description that my workers need to know about."</li>
<li><b>The Function (<code>add</code>, <code>send_welcome_email</code>)</b>: This is the actual Python code that performs the work. It's the core of the task â€“ the steps in the recipe. It can take arguments (like <code>x</code>, <code>y</code>, or <code>user_id</code>) and can return a value.</li>
<li><b>Registration</b>: The <code>@app.task</code> decorator automatically <em>registers</em> this function with our Celery <code>app</code>. Now, <code>app</code> knows about a task named <code>tasks.add</code> and another named <code>tasks.send_welcome_email</code> (Celery creates the name from <code>module_name.function_name</code>). Workers connected to this <code>app</code> will be able to find and execute this code when requested.</li>
</ol>
<p><em>Self-Host Note:</em> If you are running this code, make sure you have a <code>celery_app.py</code> file containing your Celery app instance as shown in previous chapters, and that the <code>tasks.py</code> file can import <code>app</code> from it.</p>
<h2><a class="anchor" id="autotoc_md993"></a>
Sending a Task for Execution</h2>
<p>Okay, we've written our recipes (<code>add</code> and <code>send_welcome_email</code>). How do we tell Celery, "Please run the `add` recipe with the numbers 5 and 7"?</p>
<p>We <b>don't call the function directly</b> like <code>add(5, 7)</code>. If we did that, it would just run immediately in our current program, which defeats the purpose of using Celery!</p>
<p>Instead, we use special methods on the task object itself, most commonly <code>.delay()</code> or <code>.apply_async()</code>.</p>
<p>Let's try this in a separate Python script or an interactive Python session:</p>
<div class="fragment"><div class="line"><span class="comment"># run_tasks.py</span></div>
<div class="line"><span class="keyword">from</span> tasks <span class="keyword">import</span> add, send_welcome_email</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;Let&#39;s send some tasks!&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Using .delay() ---</span></div>
<div class="line"><span class="comment"># Tell Celery to run add(5, 7) in the background</span></div>
<div class="line">result_promise_add = add.delay(5, 7)</div>
<div class="line">print(f<span class="stringliteral">&quot;Sent task add(5, 7). Task ID: {result_promise_add.id}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Tell Celery to run send_welcome_email(123) in the background</span></div>
<div class="line">result_promise_email = send_welcome_email.delay(123)</div>
<div class="line">print(f<span class="stringliteral">&quot;Sent task send_welcome_email(123). Task ID: {result_promise_email.id}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Using .apply_async() ---</span></div>
<div class="line"><span class="comment"># Does the same thing as .delay() but allows more options</span></div>
<div class="line">result_promise_add_later = add.apply_async(args=(10, 20), countdown=10) <span class="comment"># Run after 10s</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Sent task add(10, 20) to run in 10s. Task ID: {result_promise_add_later.id}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;Tasks have been sent to the broker!&quot;</span>)</div>
<div class="line">print(<span class="stringliteral">&quot;A Celery worker needs to be running to pick them up.&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b><code>from tasks import add, send_welcome_email</code></b>: We import our <em>task functions</em>. Because they were decorated with <code>@app.task</code>, they are now special Celery Task objects.</li>
<li><b><code>add.delay(5, 7)</code></b>: This is the simplest way to send a task.<ul>
<li>It <em>doesn't</em> run <code>add(5, 7)</code> right now.</li>
<li>It takes the arguments <code>(5, 7)</code>.</li>
<li>It packages them up into a <b>message</b> along with the task's name (<code>tasks.add</code>).</li>
<li>It sends this message to the <b>message broker</b> (like Redis or RabbitMQ) that we configured in our <code>celery_app.py</code>. Think of it like dropping a request slip into a mailbox.</li>
</ul>
</li>
<li><b><code>send_welcome_email.delay(123)</code></b>: Same idea, but for our email task. A message with <code>tasks.send_welcome_email</code> and the argument <code>123</code> is sent to the broker.</li>
<li><b><code>add.apply_async(args=(10, 20), countdown=10)</code></b>: This is a more powerful way to send tasks.<ul>
<li>It does the same fundamental thing: sends a message to the broker.</li>
<li>It allows for more options, like <code>args</code> (positional arguments as a tuple), <code>kwargs</code> (keyword arguments as a dict), <code>countdown</code> (delay execution by seconds), <code>eta</code> (run at a specific future time), and many others.</li>
<li><code>.delay(*args, **kwargs)</code> is just a convenient shortcut for <code>.apply_async(args=args, kwargs=kwargs)</code>.</li>
</ul>
</li>
<li><b><code>result_promise_... = ...</code></b>: Both <code>.delay()</code> and <code>apply_async()</code> return an <code>AsyncResult</code> object immediately. This is <em>not</em> the actual result of the task (like <code>12</code> for <code>add(5, 7)</code>). It's more like a receipt or a tracking number (notice the <code>.id</code> attribute). You can use this object later to check if the task finished and what its result was, but only if you've set up a <a class="el" href="../../d3/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_206__result__backend.html">Result Backend</a> (Chapter 6).</li>
<li><b>The Worker</b>: Sending the task only puts the message on the queue. A separate process, the Celery <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a> (Chapter 5), needs to be running. The worker constantly watches the queue, picks up messages, finds the corresponding task function (using the name like <code>tasks.add</code>), and executes it with the provided arguments.</li>
</ol>
<h2><a class="anchor" id="autotoc_md994"></a>
How It Works Internally (Simplified)</h2>
<p>Let's trace the journey of defining and sending our <code>add</code> task:</p>
<ol type="1">
<li>**Definition (<code>@app.task</code> in <code>tasks.py</code>)**:<ul>
<li>Python defines the <code>add</code> function.</li>
<li>The <code>@app.task</code> decorator sees this function.</li>
<li>It tells the <code>Celery</code> instance (<code>app</code>) about this function, registering it under the name <code>tasks.add</code> in an internal dictionary (<code>app.tasks</code>). The <code>app</code> instance knows the broker/backend settings.</li>
</ul>
</li>
<li><b>Sending (<code>add.delay(5, 7)</code> in <code>run_tasks.py</code>)</b>:<ul>
<li>You call <code>.delay()</code> on the <code>add</code> task object.</li>
<li><code>.delay()</code> (or <code>.apply_async()</code>) internally uses the <code>app</code> the task is bound to.</li>
<li>It asks the <code>app</code> for the configured broker URL.</li>
<li>It creates a message containing:<ul>
<li>Task Name: <code>tasks.add</code></li>
<li>Arguments: <code>(5, 7)</code></li>
<li>Other options (like a unique Task ID).</li>
</ul>
</li>
<li>It connects to the <b>Broker</b> (e.g., Redis) using the broker URL.</li>
<li>It sends the message to a specific queue (usually named 'celery' by default) on the broker.</li>
<li>It returns an <code>AsyncResult</code> object referencing the Task ID.</li>
</ul>
</li>
<li><b>Waiting</b>: The message sits in the queue on the broker, waiting.</li>
<li><b>Execution (by a <a class="el" href="../../dc/d91/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_205__worker.html">Worker</a>)</b>:<ul>
<li>A separate Celery Worker process is running, connected to the same broker and <code>app</code>.</li>
<li>The Worker fetches the message from the queue.</li>
<li>It reads the task name: <code>tasks.add</code>.</li>
<li>It looks up <code>tasks.add</code> in its copy of the <code>app.tasks</code> registry to find the actual <code>add</code> function code.</li>
<li>It calls the <code>add</code> function with the arguments from the message: <code>add(5, 7)</code>.</li>
<li>The function runs (prints logs, sleeps, calculates <code>12</code>).</li>
<li>If a <a class="el" href="../../d3/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_206__result__backend.html">Result Backend</a> is configured, the Worker takes the return value (<code>12</code>) and stores it in the backend, associated with the Task ID.</li>
<li>The Worker acknowledges the message to the broker, removing it from the queue.</li>
</ul>
</li>
</ol>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client as Your Code (run_tasks.py)</div>
<div class="line">    participant TaskDef as @app.task def add()</div>
<div class="line">    participant App as Celery App Instance</div>
<div class="line">    participant Broker as Message Broker (e.g., Redis)</div>
<div class="line">    participant Worker as Celery Worker (separate process)</div>
<div class="line"> </div>
<div class="line">    Note over TaskDef, App: 1. @app.task registers &#39;add&#39; function with App&#39;s task registry</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;TaskDef: 2. Call add.delay(5, 7)</div>
<div class="line">    TaskDef-&gt;&gt;App: 3. Get broker config</div>
<div class="line">    App--&gt;&gt;TaskDef: Broker URL</div>
<div class="line">    TaskDef-&gt;&gt;Broker: 4. Send message (&#39;tasks.add&#39;, (5, 7), task_id, ...)</div>
<div class="line">    Broker--&gt;&gt;TaskDef: Ack (Message Queued)</div>
<div class="line">    TaskDef--&gt;&gt;Client: 5. Return AsyncResult(task_id)</div>
<div class="line"> </div>
<div class="line">    Worker-&gt;&gt;Broker: 6. Fetch next message</div>
<div class="line">    Broker--&gt;&gt;Worker: Message (&#39;tasks.add&#39;, (5, 7), task_id)</div>
<div class="line">    Worker-&gt;&gt;App: 7. Lookup &#39;tasks.add&#39; in registry</div>
<div class="line">    App--&gt;&gt;Worker: add function code</div>
<div class="line">    Worker-&gt;&gt;Worker: 8. Execute add(5, 7) -&gt; returns 12</div>
<div class="line">    Note over Worker: (Optionally store result in Backend)</div>
<div class="line">    Worker-&gt;&gt;Broker: 9. Acknowledge message completion</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md995"></a>
Code Dive: Task Creation and Sending</h2>
<ul>
<li><p class="startli">**Task Definition (<code>@app.task</code>)**: This decorator is defined in <code>celery/app/base.py</code> within the <code>Celery</code> class method <code>task</code>. It ultimately calls <code>_task_from_fun</code>.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md996"></a>
Simplified from celery/app/base.py</h1>
<p>class Celery: </p>
<h1><a class="anchor" id="autotoc_md997"></a>
...</h1>
<p>def task(self, *args, **opts): </p>
<h1><a class="anchor" id="autotoc_md998"></a>
... handles decorator arguments ...</h1>
<p>def _create_task_cls(fun): </p>
<h1><a class="anchor" id="autotoc_md999"></a>
Returns a Task instance or a Proxy that creates one later</h1>
<p>ret = self._task_from_fun(fun, **opts) return ret return _create_task_cls</p>
<p>def _task_from_fun(self, fun, name=None, base=None, bind=False, **options): </p>
<h1><a class="anchor" id="autotoc_md1000"></a>
Generate name like 'tasks.add' if not given</h1>
<p>name = name or self.gen_task_name(fun.__name__, fun.__module__) base = base or self.Task # The base Task class (from celery.app.task)</p>
<p>if name not in self._tasks: # If not already registered... </p>
<h1><a class="anchor" id="autotoc_md1001"></a>
Dynamically create a Task class wrapping the function</h1>
<p>task = type(fun.__name__, (base,), { 'app': self, # Link task back to this app instance! 'name': name, 'run': staticmethod(fun), # The actual function to run '<b>doc</b>': fun.__doc__, '<b>module</b>': fun.__module__, </p>
<h1><a class="anchor" id="autotoc_md1002"></a>
... other options ...</h1>
<p>})() # Instantiate the new Task class self._tasks[task.name] = task # Add to app's registry! task.bind(self) # Perform binding steps else: task = self._tasks[name] # Task already exists return task ``<code> This shows how the decorator essentially creates a specialized object (an instance of a class derived from</code>celery.app.task.Task<code>) that wraps your original function and registers it with the</code>app` under a specific name.</p>
<ul>
<li><p class="startli"><b>Task Sending (<code>.delay</code>)</b>: The <code>.delay()</code> method is defined on the <code>Task</code> class itself in <code>celery/app/task.py</code>. It's a simple shortcut.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md1003"></a>
Simplified from celery/app/task.py</h1>
<p>class Task: </p>
<h1><a class="anchor" id="autotoc_md1004"></a>
...</h1>
<p>def delay(self, *args, **kwargs): """Shortcut for apply_async(args, kwargs)""" return self.apply_async(args, kwargs)</p>
<p>def apply_async(self, args=None, kwargs=None, ..., **options): </p>
<h1><a class="anchor" id="autotoc_md1005"></a>
... argument checking, option processing ...</h1>
<h1><a class="anchor" id="autotoc_md1006"></a>
Get the app associated with this task instance</h1>
<p>app = self._get_app()</p>
<h1><a class="anchor" id="autotoc_md1007"></a>
If always_eager is set, run locally instead of sending</h1>
<p>if app.conf.task_always_eager: return self.apply(args, kwargs, ...) # Runs inline</p>
<h1><a class="anchor" id="autotoc_md1008"></a>
The main path: tell the app to send the task message</h1>
<p>return app.send_task( self.name, args, kwargs, task_type=self, **options # Includes things like countdown, eta, queue etc. ) ``<code> You can see how</code>.delay<code>just calls</code>.apply_async<code>, which then (usually) delegates the actual message sending to the</code>app.send_task<code>method we saw briefly in [Chapter 1](<a class="el" href="../../d3/d90/01__celery__app_8md.html">01_celery_app.md</a>). The</code>app` uses its configuration to know <em>how</em> and <em>where</em> to send the message.</p>
<h2><a class="anchor" id="autotoc_md1009"></a>
Conclusion</h2>
<p>You've learned the core concept of a Celery <b>Task</b>:</p>
<ul>
<li>It represents a single, well-defined <b>unit of work</b> or <b>job description</b>.</li>
<li>You define a task by decorating a normal Python function with <code>@app.task</code>. This <b>registers</b> the task with your Celery application.</li>
<li>You <b>send</b> a task request (not run it directly) using <code>.delay()</code> or <code>.apply_async()</code>.</li>
<li>Sending a task puts a <b>message</b> onto a queue managed by a <b>message broker</b>.</li>
<li>A separate <b>Worker</b> process picks up the message and executes the corresponding task function.</li>
</ul>
<p>Tasks are the fundamental building blocks of work in Celery. Now that you know how to define a task and request its execution, let's look more closely at the crucial component that handles passing these requests around: the message broker.</p>
<p><b>Next:</b> <a class="el" href="../../d3/dd5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Celery_204__broker__connection____amqp__.html">Chapter 4: Broker Connection (AMQP)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
