#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_request_and_response_objects</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/d48/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_203__request__and__response__objects.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_request_and_response_objects</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1883"></a>
autotoc_md1883</h2>
<p>layout: default title: "Request and Response Objects" parent: "Flask" </p>
<h2><a class="anchor" id="autotoc_md1884"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md1885"></a>
Chapter 3: Request and Response Objects</h1>
<p>Welcome back! In <a class="el" href="../../d0/d63/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_202__routing__system.html">Chapter 2: Routing System</a>, we learned how Flask uses routes (<code>@app.route(...)</code>) to direct incoming web requests to the correct Python view functions. We saw how to create static routes like <code>/about</code> and dynamic routes like <code>/user/&lt;username&gt;</code>.</p>
<p>But what exactly <em>is</em> a "web request"? And how do we send back something more sophisticated than just a plain string like &lsquo;'Hello, World!&rsquo;`? That's where <b>Request</b> and <b>Response</b> objects come into play.</p>
<h2><a class="anchor" id="autotoc_md1886"></a>
What Problem Do They Solve? The Need for Envelopes</h2>
<p>Think about sending and receiving mail. When you receive a letter, it's not just the message inside that matters. The envelope has important information: the sender's address, the recipient's address, maybe a stamp indicating priority. When you send a letter back, you also need an envelope to put your message in, address it correctly, and maybe specify if it's regular mail or express.</p>
<p>In the world of web applications (specifically HTTP, the language browsers and servers speak):</p>
<ul>
<li>The <b>Request</b> object is like the <em>incoming mail</em>. It contains everything the client (usually a web browser) sent to your server: the URL they requested, any data they submitted (like in a search box or login form), special instructions (HTTP headers), the method they used (like GET for fetching data or POST for submitting data), and more.</li>
<li>The <b>Response</b> object is like the <em>outgoing mail</em> you send back. It contains the content you want to show the user (like an HTML page), the status of the request (like "OK" or "Not Found"), and any special instructions for the browser (HTTP headers, like instructions on how to cache the page).</li>
</ul>
<p>Flask provides easy-to-use objects to represent these two sides of the communication.</p>
<h2><a class="anchor" id="autotoc_md1887"></a>
The Request Object: Unpacking the Incoming Mail</h2>
<p>Inside your view functions, Flask makes a special object called <code>request</code> available. You need to import it from the <code>flask</code> library first. This object holds all the information about the incoming request that triggered your view function.</p>
<div class="fragment"><div class="line"><span class="comment"># hello.py (continued)</span></div>
<div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request <span class="comment"># Import request</span></div>
<div class="line"> </div>
<div class="line">app = Flask(__name__)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.route(&#39;/&#39;)</span></div>
<div class="line"><span class="keyword">def </span>index():</div>
<div class="line">  <span class="comment"># Access the HTTP method (GET, POST, etc.)</span></div>
<div class="line">  method = request.method</div>
<div class="line">  <span class="comment"># Access the browser&#39;s user agent string (an HTTP header)</span></div>
<div class="line">  user_agent = request.headers.get(<span class="stringliteral">&#39;User-Agent&#39;</span>)</div>
<div class="line">  <span class="keywordflow">return</span> f<span class="stringliteral">&#39;Hello! You used the {method} method. Your browser is: {user_agent}&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># ... (rest of the app, including if __name__ == &#39;__main__&#39;: ...)</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>from flask import request</code>: We import the <code>request</code> object.</li>
<li><code>request.method</code>: This attribute tells you <em>how</em> the user made the request (e.g., 'GET', 'POST'). Visiting a page normally uses GET.</li>
<li><code>request.headers</code>: This is a dictionary-like object containing HTTP headers sent by the browser. We use &lsquo;.get('User-Agent&rsquo;)` to safely get the browser identification string.</li>
</ul>
<p><b>Running this:</b></p>
<ol type="1">
<li>Save and run <code>hello.py</code>.</li>
<li>Visit <code><a href="http://127.0.0.1:5000/">http://127.0.0.1:5000/</a></code> in your browser.</li>
<li>You'll see something like: "Hello! You used the GET method. Your browser is: Mozilla/5.0 (..." (your specific browser details will vary).</li>
</ol>
<h3><a class="anchor" id="autotoc_md1888"></a>
Getting Data from the URL (Query Parameters)</h3>
<p>Often, data is included directly in the URL after a <code>?</code>, like <code><a href="http://127.0.0.1:5000/search?query=flask">http://127.0.0.1:5000/search?query=flask</a></code>. These are called query parameters. The <code>request</code> object provides the <code>args</code> attribute to access them.</p>
<div class="fragment"><div class="line"><span class="comment"># hello.py (continued)</span></div>
<div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request</div>
<div class="line"> </div>
<div class="line">app = Flask(__name__)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.route(&#39;/search&#39;)</span></div>
<div class="line"><span class="keyword">def </span>search():</div>
<div class="line">  <span class="comment"># Get the value of the &#39;query&#39; parameter from the URL</span></div>
<div class="line">  <span class="comment"># request.args.get() is safer than request.args[] as it returns None if the key doesn&#39;t exist</span></div>
<div class="line">  search_term = request.args.get(<span class="stringliteral">&#39;query&#39;</span>)</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> search_term:</div>
<div class="line">    <span class="keywordflow">return</span> f<span class="stringliteral">&#39;You searched for: {search_term}&#39;</span></div>
<div class="line">  <span class="keywordflow">else</span>:</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;Please provide a search term using ?query=...&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># ... (rest of the app)</span></div>
</div><!-- fragment --><p><b>Running this:</b></p>
<ol type="1">
<li>Save and run <code>hello.py</code>.</li>
<li>Visit <code><a href="http://127.0.0.1:5000/search?query=python+web+framework">http://127.0.0.1:5000/search?query=python+web+framework</a></code>.</li>
<li>You should see: "You searched for: python web framework".</li>
<li>Visit <code><a href="http://127.0.0.1:5000/search">http://127.0.0.1:5000/search</a></code>.</li>
<li>You should see: "Please provide a search term using ?query=..."</li>
</ol>
<h3><a class="anchor" id="autotoc_md1889"></a>
Getting Data from Forms (POST Requests)</h3>
<p>When a user submits an HTML form, the browser usually sends the data using the POST method. This data isn't in the URL; it's in the body of the request. The <code>request</code> object provides the <code>form</code> attribute to access this data.</p>
<p>Let's create a simple login page (we won't actually log anyone in yet).</p>
<p>First, a route to <em>show</em> the form (using GET):</p>
<div class="fragment"><div class="line"><span class="comment"># hello.py (continued)</span></div>
<div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, make_response <span class="comment"># Import make_response</span></div>
<div class="line"> </div>
<div class="line">app = Flask(__name__)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.route(&#39;/login&#39;, methods=[&#39;GET&#39;])</span> <span class="comment"># Only allow GET for this view</span></div>
<div class="line"><span class="keyword">def </span>show_login_form():</div>
<div class="line">  <span class="comment"># Just return the raw HTML for the form</span></div>
<div class="line">  <span class="keywordflow">return</span> <span class="stringliteral">&#39;&#39;&#39;</span></div>
<div class="line"><span class="stringliteral">      &lt;form method=&quot;POST&quot;&gt;</span></div>
<div class="line"><span class="stringliteral">          Username: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt;</span></div>
<div class="line"><span class="stringliteral">          Password: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt;</span></div>
<div class="line"><span class="stringliteral">          &lt;input type=&quot;submit&quot; value=&quot;Log In&quot;&gt;</span></div>
<div class="line"><span class="stringliteral">      &lt;/form&gt;</span></div>
<div class="line"><span class="stringliteral">  &#39;&#39;&#39;</span></div>
<div class="line"><span class="comment"># ... (add the next route below)</span></div>
</div><!-- fragment --><p>Now, a route to <em>handle</em> the form submission (using POST):</p>
<div class="fragment"><div class="line"><span class="comment"># hello.py (continued)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.route(&#39;/login&#39;, methods=[&#39;POST&#39;])</span> <span class="comment"># Only allow POST for this view</span></div>
<div class="line"><span class="keyword">def </span>process_login():</div>
<div class="line">  <span class="comment"># Access form data using request.form</span></div>
<div class="line">  username = request.form.get(<span class="stringliteral">&#39;username&#39;</span>)</div>
<div class="line">  password = request.form.get(<span class="stringliteral">&#39;password&#39;</span>) <span class="comment"># In a real app, NEVER just display a password!</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> username <span class="keywordflow">and</span> password:</div>
<div class="line">    <span class="keywordflow">return</span> f<span class="stringliteral">&#39;Attempting login for username: {username}&#39;</span></div>
<div class="line">  <span class="keywordflow">else</span>:</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&#39;Missing username or password&#39;</span>, 400 <span class="comment"># Return an error status code</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># ... (rest of the app, including if __name__ == &#39;__main__&#39;: ...)</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>&lsquo;@app.route(&rsquo;/login', methods=['GET'])<code>: We specify that</code>show_login_form<code>only handles GET requests. *</code>@app.route('/login', methods=['POST'])<code>: We specify that</code>process_login<code>only handles POST requests. This allows the same URL (</code>/login<code>) to do different things based on the HTTP method. *</code>&lt;form method="POST"&gt;<code>: The HTML form is set to use the POST method when submitted. *</code>request.form.get('username')<code>: Inside</code>process_login<code>, we access the submitted form data using the</code>name<code>attributes of the input fields (</code>name="username"<code>). *</code>return 'Missing...', 400<code>: Here we return not just a string, but also a number. Flask understands this as</code>(body, status_code)<code>.</code>400` means "Bad Request".</li>
</ul>
<p><b>Running this:</b></p>
<ol type="1">
<li>Save and run <code>hello.py</code>.</li>
<li>Visit <code><a href="http://127.0.0.1:5000/login">http://127.0.0.1:5000/login</a></code>. You'll see the simple login form.</li>
<li>Enter a username and password and click "Log In".</li>
<li>The browser will send a POST request to <code>/login</code>. The <code>process_login</code> function will handle it, and you'll see: "Attempting login for username: [your username]".</li>
</ol>
<p>The <code>request</code> object is your window into the data sent by the client. You'll use <code>request.args</code> for URL parameters (GET) and <code>request.form</code> for form data (POST) most often.</p>
<h2><a class="anchor" id="autotoc_md1890"></a>
The Response Object: Crafting the Outgoing Mail</h2>
<p>We've seen that Flask takes the return value of your view function and turns it into the HTTP response sent back to the browser.</p>
<ul>
<li>Returning a string: Flask creates a Response with that string as the body, a <code>200 OK</code> status code, and a <code>text/html</code> content type.</li>
<li>Returning a tuple <code>(body, status)</code>: Flask uses the <code>body</code> (string) and the specified <code>status</code> code (integer).</li>
<li>Returning a tuple <code>(body, status, headers)</code>: Flask uses the body, status, and adds the specified <code>headers</code> (a dictionary or list of tuples).</li>
</ul>
<p>For more control, you can explicitly create a Response object using the <code>make_response</code> helper function.</p>
<div class="fragment"><div class="line"><span class="comment"># hello.py (continued)</span></div>
<div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, make_response <span class="comment"># Import make_response</span></div>
<div class="line"> </div>
<div class="line">app = Flask(__name__)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.route(&#39;/custom&#39;)</span></div>
<div class="line"><span class="keyword">def </span>custom_response():</div>
<div class="line">  <span class="comment"># Create a response object from a string</span></div>
<div class="line">  response = make_response(<span class="stringliteral">&quot;This response has custom headers!&quot;</span>)</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># Set a custom header</span></div>
<div class="line">  response.headers[<span class="stringliteral">&#39;X-My-Custom-Header&#39;</span>] = <span class="stringliteral">&#39;Flask is Fun!&#39;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment"># Set a cookie (we&#39;ll learn more about sessions/cookies later)</span></div>
<div class="line">  response.set_cookie(<span class="stringliteral">&#39;mycookie&#39;</span>, <span class="stringliteral">&#39;some_value&#39;</span>)</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># Set a specific status code (optional, defaults to 200)</span></div>
<div class="line">  response.status_code = 201 <span class="comment"># 201 means &quot;Created&quot;</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> response <span class="comment"># Return the fully configured response object</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># ... (rest of the app)</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>from flask import make_response</code>: We import the helper function.</li>
<li><code>response = make_response(...)</code>: Creates a Response object. You can pass the body content here.</li>
<li>&lsquo;response.headers[&rsquo;...'] = '...'<code>: Allows setting custom HTTP headers. Browsers might use these for caching, security, or other purposes. Your own JavaScript code could also read them. *</code>response.set_cookie(...)<code>: A convenient way to set a cookie to be stored by the browser. *</code>response.status_code = 201<code>: Sets the HTTP status code. While</code>200<code>means "OK", other codes have specific meanings (</code>404<code>Not Found,</code>403<code>Forbidden,</code>500<code>Server Error,</code>201<code>Created,</code>302<code>Redirect, etc.). *</code>return response`: We return the response object we manually configured.</li>
</ul>
<p>Using <code>make_response</code> gives you fine-grained control over exactly what gets sent back to the client.</p>
<h2><a class="anchor" id="autotoc_md1891"></a>
Under the Hood: Werkzeug and the Request/Response Cycle</h2>
<p>Flask doesn't reinvent the wheel for handling low-level HTTP details. It uses another excellent Python library called <b>Werkzeug</b> (pronounced "verk-zoyg", German for "tool"). Flask's <code>Request</code> and <code>Response</code> objects are actually subclasses of Werkzeug's base <code>Request</code> and <code>Response</code> classes, adding some Flask-specific conveniences.</p>
<p>Here's a simplified view of what happens when a request comes in:</p>
<ol type="1">
<li><b>Incoming Request:</b> Your web server (like the Flask development server, or a production server like Gunicorn/uWSGI) receives the raw HTTP request from the browser.</li>
<li><b>WSGI Environment:</b> The server translates this raw request into a standard Python dictionary called the WSGI <code>environ</code>. This dictionary contains all the request details (path, method, headers, input stream, etc.).</li>
<li><b>Flask App Called:</b> The server calls your Flask application object (<code>app</code>) as a WSGI application, passing it the <code>environ</code>. (See <code>app.wsgi_app</code> in <code><a class="el" href="../../de/d0e/app_8py.html">app.py</a></code>).</li>
<li><b>Request Context:</b> Flask creates a <b>Request Context</b>. This involves:<ul>
<li>Creating a <code>Request</code> object (usually <code>flask.wrappers.Request</code>) by feeding it the <code>environ</code>. Werkzeug does the heavy lifting of parsing the environment. (See <code>app.request_context</code> in <code><a class="el" href="../../de/d0e/app_8py.html">app.py</a></code> which uses <code>app.request_class</code>).</li>
<li>Making this <code>request</code> object (and other context-specific things like <code>session</code>) easily accessible. (We'll cover contexts in detail in <a class="el" href="../../d2/d15/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_205__context__globals______current__a0f66e55a619b85550f70ee0df6dbdc86.html">Chapter 5</a> and <a class="el" href="../../d6/da8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_207__application__and__request__contexts.html">Chapter 7</a>).</li>
</ul>
</li>
<li><b>Routing:</b> Flask's routing system (<a class="el" href="../../d0/d63/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_202__routing__system.html">Chapter 2</a>) uses <code>request.path</code> and <code>request.method</code> to find the correct view function via the <code>app.url_map</code>.</li>
<li><b>View Function Call:</b> Flask calls your view function, possibly passing arguments extracted from the URL (like <code>username</code> in <code>/user/&lt;username&gt;</code>).</li>
<li><b>Accessing Request Data:</b> Inside your view function, you access data using the <code>request</code> object (e.g., <code>request.args</code>, <code>request.form</code>).</li>
<li><b>View Return Value:</b> Your view function returns a value (string, tuple, Response object).</li>
<li><b>Response Creation:</b> Flask calls <code>app.make_response()</code> (see <code><a class="el" href="../../de/d0e/app_8py.html">app.py</a></code>) on the return value. This either uses the Response object you returned directly, or constructs a new one (<code>flask.wrappers.Response</code> or <code>app.response_class</code>) based on the string/tuple you returned. Werkzeug's <code>Response</code> handles formatting the body, status, and headers correctly.</li>
<li><b>Response Sent:</b> Flask returns the Response object's details (status, headers, body) back to the WSGI server.</li>
<li><b>Outgoing Response:</b> The server transmits the HTTP response back to the browser.</li>
<li><b>Context Teardown:</b> The Request Context is cleaned up.</li>
</ol>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Browser</div>
<div class="line">    participant WSGIServer as WSGI Server</div>
<div class="line">    participant FlaskApp as Flask App (wsgi_app)</div>
<div class="line">    participant RequestCtx as Request Context</div>
<div class="line">    participant ReqObj as Request Object</div>
<div class="line">    participant Routing</div>
<div class="line">    participant ViewFunc as Your View Function</div>
<div class="line">    participant RespObj as Response Object</div>
<div class="line"> </div>
<div class="line">    Browser-&gt;&gt;+WSGIServer: Sends HTTP Request (e.g., GET /search?query=flask)</div>
<div class="line">    WSGIServer-&gt;&gt;+FlaskApp: Calls app(environ, start_response)</div>
<div class="line">    FlaskApp-&gt;&gt;+RequestCtx: Creates Request Context(environ)</div>
<div class="line">    RequestCtx-&gt;&gt;+ReqObj: Creates Request(environ)</div>
<div class="line">    RequestCtx--&gt;&gt;-FlaskApp: Request Context ready (request is now available)</div>
<div class="line">    FlaskApp-&gt;&gt;+Routing: Matches request.path, request.method</div>
<div class="line">    Routing--&gt;&gt;-FlaskApp: Finds view_func=search, args={}</div>
<div class="line">    FlaskApp-&gt;&gt;+ViewFunc: Calls search()</div>
<div class="line">    ViewFunc-&gt;&gt;ReqObj: Accesses request.args.get(&#39;query&#39;)</div>
<div class="line">    ViewFunc--&gt;&gt;-FlaskApp: Returns &quot;You searched for: flask&quot; (string)</div>
<div class="line">    FlaskApp-&gt;&gt;+RespObj: Calls make_response(&quot;...&quot;)</div>
<div class="line">    RespObj--&gt;&gt;-FlaskApp: Response object created (status=200, body=&quot;...&quot;, headers={...})</div>
<div class="line">    FlaskApp--&gt;&gt;-WSGIServer: Returns Response (via start_response, iterable body)</div>
<div class="line">    WSGIServer--&gt;&gt;-Browser: Sends HTTP Response</div>
<div class="line">    Note right of FlaskApp: Request Context is torn down</div>
</div><!-- fragment --><p>The key takeaway is that Flask uses Werkzeug to wrap the raw incoming request data into a convenient <code>Request</code> object and helps you format your return value into a proper <code>Response</code> object to send back.</p>
<h2><a class="anchor" id="autotoc_md1892"></a>
Conclusion</h2>
<p>In this chapter, we explored the fundamental Request and Response objects in Flask.</p>
<ul>
<li>The <b><code>request</code> object</b> (imported from <code>flask</code>) gives you access to incoming data within your view functions, like URL parameters (<code>request.args</code>), form data (<code>request.form</code>), HTTP methods (<code>request.method</code>), and headers (<code>request.headers</code>). It's like opening the incoming mail.</li>
<li>Flask automatically converts the return value of your view functions into a <b>Response object</b>. You can return strings, tuples <code>(body, status)</code> or <code>(body, status, headers)</code>, or use <code>make_response</code> to create and customize a <code>Response</code> object directly (setting status codes, headers, cookies). This is like preparing your outgoing mail.</li>
<li>These objects are built upon Werkzeug's robust foundation.</li>
</ul>
<p>Now you know how to receive data from the user and how to send back customized responses. But writing HTML directly inside Python strings (like in our form example) gets messy very quickly. How can we separate our presentation logic (HTML) from our application logic (Python)? That's where templating comes in!</p>
<p>Let's move on to <a class="el" href="../../d1/d39/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_204__templating____jinja2__integration__.html">Chapter 4: Templating (Jinja2 Integration)</a> to see how Flask makes generating HTML much easier.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
