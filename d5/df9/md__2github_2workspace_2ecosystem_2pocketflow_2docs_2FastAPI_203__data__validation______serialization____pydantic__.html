#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_data_validation___serialization__pydantic_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d5/df9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_203__data__validation______serialization____pydantic__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_data_validation___serialization__pydantic_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1731"></a>
autotoc_md1731</h2>
<p>layout: default title: "Data Validation &amp; Serialization (Pydantic)" parent: "FastAPI" </p>
<h2><a class="anchor" id="autotoc_md1732"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md1733"></a>
Chapter 3: Data Validation &amp; Serialization (Pydantic)</h1>
<p>Welcome back! In <a class="el" href="../../d0/d13/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_202__path__operations______parameter__declaration.html">Chapter 2: Path Operations &amp; Parameter Declaration</a>, we learned how FastAPI uses type hints to understand path parameters (like <code>/items/{item_id}</code>) and query parameters (like <code>/?skip=0&amp;limit=10</code>). We even saw a sneak peek of how Pydantic models can define the structure of a JSON request body.</p>
<p>Now, let's dive deep into that magic! How does FastAPI <em>really</em> handle complex data coming into your API and the data you send back?</p>
<p><b>Our Goal Today:</b> Understand how FastAPI uses the powerful <b>Pydantic</b> library to automatically validate incoming data (making sure it's correct) and serialize outgoing data (converting it to JSON).</p>
<h2><a class="anchor" id="autotoc_md1734"></a>
What Problem Does This Solve?</h2>
<p>Imagine you're building the API for an online store, specifically the part where a user can add a new product. They need to send you information like the product's name, price, and maybe an optional description. This information usually comes as JSON in the request body.</p>
<p>You need to make sure:</p>
<ol type="1">
<li><b>The data arrived:</b> Did the user actually send the product details?</li>
<li><b>It has the right shape:</b> Does the JSON contain a <code>name</code> and a <code>price</code>? Is the <code>description</code> there, or is it okay if it's missing?</li>
<li><b>It has the right types:</b> Is the <code>name</code> a string? Is the <code>price</code> a number (like a float or decimal)?</li>
<li><b>It meets certain rules (optional):</b> Maybe the price must be positive? Maybe the name can't be empty?</li>
</ol>
<p>Doing these checks manually for every API endpoint would be tedious and error-prone.</p>
<p>Similarly, when you send data <em>back</em> (like the details of the newly created product), you need to convert your internal Python objects (like dictionaries or custom class instances) into standard JSON that the user's browser or application can understand. You might also want to control <em>which</em> information gets sent back (e.g., maybe hide internal cost fields).</p>
<p><b>FastAPI solves both problems using Pydantic:</b></p>
<ul>
<li><b>Validation (Gatekeeper):</b> Pydantic models act like strict blueprints or forms. You define the expected structure and types of incoming data using a Pydantic model. FastAPI uses this model to automatically parse the incoming JSON, check if it matches the blueprint (validate it), and provide you with a clean Python object. If the data doesn't match, FastAPI automatically sends back a clear error message saying exactly what's wrong. Think of it as a meticulous gatekeeper checking IDs and forms at the entrance.</li>
<li><b>Serialization (Translator):</b> When you return data from your API function, FastAPI can use a Pydantic model (specified as a <code>response_model</code>) or its built-in <code>jsonable_encoder</code> to convert your Python objects (Pydantic models, database objects, dictionaries, etc.) into JSON format. Think of it as a helpful translator converting your application's internal language into the common language of JSON for the outside world.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1735"></a>
Your First Pydantic Model</h2>
<p>Pydantic models are simply Python classes that inherit from <code>pydantic.BaseModel</code>. You define the "fields" of your data as class attributes with type hints.</p>
<p>Let's define a model for our product item:</p>
<ol type="1">
<li><b>Create a file (optional but good practice):</b> You could put this in a file like <code><a class="el" href="../../d3/da2/models_8py.html">models.py</a></code>.</li>
<li><b>Write the model:</b></li>
</ol>
<div class="fragment"><div class="line"><span class="comment"># models.py (or within your main.py/routers/items.py)</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Item(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    description: str | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>  <span class="comment"># Optional field with a default of None</span></div>
<div class="line">    price: float</div>
<div class="line">    tax: float | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>        <span class="comment"># Optional field with a default of None</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>from pydantic import BaseModel</code>: We import the necessary <code>BaseModel</code> from Pydantic.</li>
<li><code>class Item(BaseModel):</code>: We define our model class <code>Item</code>, inheriting from <code>BaseModel</code>.</li>
<li><code>name: str</code>: We declare a field named <code>name</code>. The type hint <code>: str</code> tells Pydantic that this field is <b>required</b> and must be a string.</li>
<li><code>description: str | None = None</code>:<ul>
<li><code>str | None</code>: This type hint (using the pipe <code>|</code> operator for Union) means <code>description</code> can be either a string OR <code>None</code>.</li>
<li><code>= None</code>: This sets the <b>default value</b> to <code>None</code>. Because it has a default value, this field is <b>optional</b>. If the incoming data doesn't include <code>description</code>, Pydantic will automatically set it to <code>None</code>.</li>
</ul>
</li>
<li><code>price: float</code>: A required field that must be a floating-point number.</li>
<li><code>tax: float | None = None</code>: An optional field that can be a float or <code>None</code>, defaulting to <code>None</code>.</li>
</ul>
<p>This simple class definition now acts as our data blueprint!</p>
<h2><a class="anchor" id="autotoc_md1736"></a>
Using Pydantic for Request Body Validation</h2>
<p>Now, let's use this <code>Item</code> model in a <code>POST</code> request to create a new item. We saw this briefly in Chapter 2.</p>
<div class="fragment"><div class="line"><span class="comment"># main.py (or routers/items.py)</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</div>
<div class="line"><span class="comment"># Assume &#39;Item&#39; model is defined above or imported: from models import Item</span></div>
<div class="line"> </div>
<div class="line">app = FastAPI() <span class="comment"># Or use your APIRouter</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.post(&quot;/items/&quot;)</span></div>
<div class="line"><span class="comment"># Declare &#39;item&#39; parameter with type hint &#39;Item&#39;</span></div>
<div class="line"><span class="keyword">async def </span>create_item(item: Item):</div>
<div class="line">    <span class="comment"># If the code reaches here, FastAPI + Pydantic already did:</span></div>
<div class="line">    <span class="comment"># 1. Read the request body (as JSON bytes).</span></div>
<div class="line">    <span class="comment"># 2. Parsed the JSON into a Python dict.</span></div>
<div class="line">    <span class="comment"># 3. Validated the dict against the &#39;Item&#39; model.</span></div>
<div class="line">    <span class="comment">#    - Checked required fields (&#39;name&#39;, &#39;price&#39;).</span></div>
<div class="line">    <span class="comment">#    - Checked types (name is str, price is float, etc.).</span></div>
<div class="line">    <span class="comment">#    - Assigned default values for optional fields if missing.</span></div>
<div class="line">    <span class="comment"># 4. Created an &#39;Item&#39; instance from the valid data.</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># &#39;item&#39; is now a Pydantic &#39;Item&#39; object with validated data!</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Received item name: {item.name}&quot;</span>)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Received item price: {item.price}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">if</span> item.description:</div>
<div class="line">        print(f<span class="stringliteral">&quot;Received item description: {item.description}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">if</span> item.tax:</div>
<div class="line">        print(f<span class="stringliteral">&quot;Received item tax: {item.tax}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># You can easily convert the Pydantic model back to a dict if needed</span></div>
<div class="line">    item_dict = item.model_dump() <span class="comment"># Pydantic v2 method</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... here you would typically save the item to a database ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Return the created item&#39;s data</span></div>
<div class="line">    <span class="keywordflow">return</span> item_dict</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>async def create_item(item: Item)</code>: By declaring the function parameter <code>item</code> with the type hint <code>Item</code> (our Pydantic model), FastAPI automatically knows it should:<ul>
<li>Expect JSON in the request body.</li>
<li>Validate that JSON against the <code>Item</code> model.</li>
</ul>
</li>
<li><b>Automatic Validation:</b> If the client sends JSON like <code>{"name": "Thingamajig", "price": 49.99}</code>, FastAPI/Pydantic validates it, creates an <code>Item</code> object (<code>item</code>), and passes it to your function. Inside your function, <code>item.name</code> will be <code>"Thingamajig"</code>, <code>item.price</code> will be <code>49.99</code>, and <code>item.description</code> and <code>item.tax</code> will be <code>None</code> (their defaults).</li>
<li><b>Automatic Errors:</b> If the client sends invalid JSON, like <code>{"name": "Gadget"}</code> (missing <code>price</code>) or <code>{"name": "Gizmo", "price": "expensive"}</code> (<code>price</code> is not a float), FastAPI will <b>not</b> call your <code>create_item</code> function. Instead, it will automatically send back a <code>422 Unprocessable Entity</code> HTTP error response with a detailed JSON body explaining the validation errors.</li>
</ul>
<p><b>Example 422 Error Response (if <code>price</code> was missing):</b></p>
<div class="fragment"><div class="line">{</div>
<div class="line">  &quot;detail&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;type&quot;: &quot;missing&quot;,</div>
<div class="line">      &quot;loc&quot;: [</div>
<div class="line">        &quot;body&quot;,</div>
<div class="line">        &quot;price&quot;</div>
<div class="line">      ],</div>
<div class="line">      &quot;msg&quot;: &quot;Field required&quot;,</div>
<div class="line">      &quot;input&quot;: { // The invalid data received</div>
<div class="line">        &quot;name&quot;: &quot;Gadget&quot;</div>
<div class="line">      },</div>
<div class="line">      &quot;url&quot;: &quot;...&quot; // Pydantic v2 URL to error details</div>
<div class="line">    }</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><p>This automatic validation saves you a <em>ton</em> of boilerplate code and provides clear feedback to API consumers.</p>
<h2><a class="anchor" id="autotoc_md1737"></a>
Using Pydantic for Response Serialization (<code>response_model</code>)</h2>
<p>We just saw how Pydantic validates <em>incoming</em> data. It's also incredibly useful for shaping <em>outgoing</em> data.</p>
<p>Let's say when we create an item, we want to return the item's data, but maybe we have some internal fields in our Pydantic model that we <em>don't</em> want to expose in the API response. Or, we just want to be absolutely sure the response <em>always</em> conforms to the <code>Item</code> structure.</p>
<p>We can use the <code>response_model</code> parameter in the path operation decorator:</p>
<div class="fragment"><div class="line"><span class="comment"># main.py (or routers/items.py, modified version)</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel <span class="comment"># Assuming Item is defined here or imported</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Let&#39;s add an internal field to our model for demonstration</span></div>
<div class="line"><span class="keyword">class </span>Item(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    description: str | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line">    price: float</div>
<div class="line">    tax: float | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line">    internal_cost: float = 0.0 <span class="comment"># Field we DON&#39;T want in the response</span></div>
<div class="line"> </div>
<div class="line">app = FastAPI() <span class="comment"># Or use your APIRouter</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Add response_model=Item to the decorator</span></div>
<div class="line"><span class="preprocessor">@app.post(&quot;/items/&quot;, response_model=Item)</span></div>
<div class="line"><span class="keyword">async def </span>create_item(item: Item):</div>
<div class="line">    <span class="comment"># item is the validated input Item object</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Processing item: {item.name} with internal cost {item.internal_cost}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... save item to database ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Let&#39;s imagine we return the same item object we received</span></div>
<div class="line">    <span class="comment"># (in reality, you might return an object fetched from the DB)</span></div>
<div class="line">    <span class="keywordflow">return</span> item <span class="comment"># FastAPI will handle serialization based on response_model</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>@app.post("/items/", response_model=Item)</code>: By adding <code>response_model=Item</code>, we tell FastAPI:<ol type="1">
<li><b>Filter:</b> Whatever data is returned by the <code>create_item</code> function, filter it so that only the fields defined in the <code>Item</code> model (<code>name</code>, <code>description</code>, <code>price</code>, <code>tax</code>, <code>internal_cost</code>) are included in the final JSON response. <b>Wait!</b> Actually, Pydantic V2 by default includes all fields from the returned object <em>that are also in the response model</em>. In this case, since we return <code>item</code> which <em>is</em> an <code>Item</code> instance, all fields (<code>name</code>, <code>description</code>, <code>price</code>, <code>tax</code>, <code>internal_cost</code>) would be included <em>if</em> the returned object <em>was</em> an <code>Item</code> instance. <em>Correction:</em> Let's refine the example to show filtering. Let's define a <em>different</em> response model.</li>
</ol>
</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># models.py</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Input model (can include internal fields)</span></div>
<div class="line"><span class="keyword">class </span>ItemCreate(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    description: str | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line">    price: float</div>
<div class="line">    tax: float | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line">    internal_cost: float <span class="comment"># Required input, but we won&#39;t return it</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Output model (defines what the client sees)</span></div>
<div class="line"><span class="keyword">class </span>ItemPublic(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    description: str | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line">    price: float</div>
<div class="line">    tax: float | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line">    <span class="comment"># Note: internal_cost is NOT defined here</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># ---- In main.py or routers/items.py ----</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</div>
<div class="line"><span class="keyword">from</span> models <span class="keyword">import</span> ItemCreate, ItemPublic <span class="comment"># Import both models</span></div>
<div class="line"> </div>
<div class="line">app = FastAPI()</div>
<div class="line"> </div>
<div class="line">items_db = [] <span class="comment"># Simple in-memory &quot;database&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.post(&quot;/items/&quot;, response_model=ItemPublic)</span> <span class="comment"># Use ItemPublic for response</span></div>
<div class="line"><span class="keyword">async def </span>create_item(item_input: ItemCreate): <span class="comment"># Use ItemCreate for input</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Received internal cost: {item_input.internal_cost}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Convert input model to a dict (or create DB model instance)</span></div>
<div class="line">    item_data = item_input.model_dump()</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Simulate saving to DB and getting back the saved data</span></div>
<div class="line">    <span class="comment"># In a real app, the DB might assign an ID, etc.</span></div>
<div class="line">    saved_item_data = item_data.copy()</div>
<div class="line">    saved_item_data[<span class="stringliteral">&quot;id&quot;</span>] = len(items_db) + 1 <span class="comment"># Add a simulated ID</span></div>
<div class="line">    items_db.append(saved_item_data)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Return the *dictionary* of saved data. FastAPI will use response_model</span></div>
<div class="line">    <span class="comment"># ItemPublic to filter and serialize this dictionary.</span></div>
<div class="line">    <span class="keywordflow">return</span> saved_item_data</div>
</div><!-- fragment --><p><b>Explanation (Revised):</b></p>
<ul>
<li><code>ItemCreate</code>: Defines the structure we expect for <em>creating</em> an item, including <code>internal_cost</code>.</li>
<li><code>ItemPublic</code>: Defines the structure we want to <em>return</em> to the client, notably <em>excluding</em> <code>internal_cost</code>.</li>
<li><code>create_item(item_input: ItemCreate)</code>: We accept the full <code>ItemCreate</code> model as input.</li>
<li><code>@app.post("/items/", response_model=ItemPublic)</code>: We declare that the response should conform to the <code>ItemPublic</code> model.</li>
<li><code>return saved_item_data</code>: We return a Python dictionary containing all fields (including <code>internal_cost</code> and the simulated <code>id</code>).</li>
<li><b>Automatic Filtering &amp; Serialization:</b> FastAPI takes the returned dictionary (<code>saved_item_data</code>). Because <code>response_model=ItemPublic</code> is set, it does the following <em>before</em> sending the response:<ol type="1">
<li>It looks at the fields defined in <code>ItemPublic</code> (<code>name</code>, <code>description</code>, <code>price</code>, <code>tax</code>).</li>
<li>It takes only those fields from the <code>saved_item_data</code> dictionary. The <code>internal_cost</code> and <code>id</code> fields are automatically dropped because they are not in <code>ItemPublic</code>.</li>
<li>It ensures the values for the included fields match the types expected by <code>ItemPublic</code> (this also provides some output validation).</li>
<li>It converts the resulting filtered data into a JSON string using <code>jsonable_encoder</code> internally.</li>
</ol>
</li>
</ul>
<p><b>Example Interaction:</b></p>
<ol type="1">
<li><b>Client sends <code>POST /items/</code> with body:</b> <code>json { "name": "Super Gadget", "price": 120.50, "internal_cost": 55.25, "description": "The best gadget ever!" } </code></li>
<li><b>FastAPI:</b> Validates this against <code>ItemCreate</code> (Success).</li>
<li><b><code>create_item</code> function:</b> Runs, prints <code>internal_cost</code>, prepares <code>saved_item_data</code> dictionary.</li>
<li><b>FastAPI (Response processing):</b> Takes the returned dictionary, filters it using <code>ItemPublic</code>.</li>
<li><b>Client receives <code>200 OK</code> with body:</b> <code>json { "name": "Super Gadget", "description": "The best gadget ever!", "price": 120.50, "tax": null } </code> Notice <code>internal_cost</code> and <code>id</code> are gone!</li>
</ol>
<p>The <code>response_model</code> gives you precise control over your API's output contract, enhancing security and clarity.</p>
<h2><a class="anchor" id="autotoc_md1738"></a>
How it Works Under the Hood (Simplified)</h2>
<p>Let's trace the journey of a <code>POST /items/</code> request using our <code>ItemCreate</code> input model and <code>ItemPublic</code> response model.</p>
<ol type="1">
<li><b>Request In:</b> Client sends <code>POST /items/</code> with JSON body to the Uvicorn server.</li>
<li><b>FastAPI Routing:</b> Uvicorn passes the request to FastAPI. FastAPI matches the path and method to our <code>create_item</code> function.</li>
<li><b>Parameter Analysis:</b> FastAPI inspects <code>create_item(item_input: ItemCreate)</code>. It sees <code>item_input</code> is type-hinted with a Pydantic model (<code>ItemCreate</code>), so it knows to look for the data in the request body.</li>
<li><b>Body Reading &amp; Parsing:</b> FastAPI reads the raw bytes from the request body and attempts to parse them as JSON into a Python dictionary. If JSON parsing fails, an error is returned.</li>
<li><b>Pydantic Validation:</b> FastAPI passes the parsed dictionary to Pydantic, essentially calling <code>ItemCreate.model_validate(parsed_dict)</code>.<ul>
<li><b>Success:</b> Pydantic checks types, required fields, etc. If valid, it returns a populated <code>ItemCreate</code> instance.</li>
<li><b>Failure:</b> Pydantic raises a <code>ValidationError</code>. FastAPI catches this.</li>
</ul>
</li>
<li><b>Error Handling (if validation failed):</b> FastAPI converts the Pydantic <code>ValidationError</code> into a user-friendly JSON response (status code 422) and sends it back immediately. The <code>create_item</code> function is <em>never called</em>.</li>
<li><b>Function Execution (if validation succeeded):</b> FastAPI calls <code>create_item(item_input=&lt;ItemCreate instance&gt;)</code>. Your function logic runs.</li>
<li><b>Return Value:</b> Your function returns a value (e.g., the <code>saved_item_data</code> dictionary).</li>
<li><b>Response Model Processing:</b> FastAPI sees <code>response_model=ItemPublic</code> in the decorator.</li>
<li><b>Filtering/Validation:</b> FastAPI uses the <code>ItemPublic</code> model to filter the returned dictionary (<code>saved_item_data</code>), keeping only fields defined in <code>ItemPublic</code>. It may also perform type coercion/validation based on <code>ItemPublic</code>.</li>
<li><b>Serialization (<code>jsonable_encoder</code>):</b> FastAPI passes the filtered data to <code>jsonable_encoder</code>. This function recursively walks through the data, converting Pydantic models, <code>datetime</code> objects, <code>UUID</code>s, Decimals, etc., into basic JSON-compatible types (strings, numbers, booleans, lists, dicts, null).</li>
<li><b>Response Out:</b> FastAPI creates the final HTTP response with the correct status code, headers (<code>Content-Type: application/json</code>), and the JSON string body. Uvicorn sends this back to the client.</li>
</ol>
<p>Here's a diagram summarizing the flow:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client</div>
<div class="line">    participant ASGI Server (Uvicorn)</div>
<div class="line">    participant FastAPI App</div>
<div class="line">    participant Pydantic Validator</div>
<div class="line">    participant Route Handler (create_item)</div>
<div class="line">    participant Pydantic Serializer (via response_model)</div>
<div class="line">    participant JsonableEncoder</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;ASGI Server (Uvicorn): POST /items/ (with JSON body)</div>
<div class="line">    ASGI Server (Uvicorn)-&gt;&gt;FastAPI App: Pass Request</div>
<div class="line">    FastAPI App-&gt;&gt;FastAPI App: Find route, see param `item_input: ItemCreate`</div>
<div class="line">    FastAPI App-&gt;&gt;FastAPI App: Read &amp; Parse JSON body</div>
<div class="line">    FastAPI App-&gt;&gt;Pydantic Validator: Validate data with ItemCreate model</div>
<div class="line">    alt Validation Fails</div>
<div class="line">        Pydantic Validator--&gt;&gt;FastAPI App: Raise ValidationError</div>
<div class="line">        FastAPI App-&gt;&gt;FastAPI App: Format 422 Error Response</div>
<div class="line">        FastAPI App--&gt;&gt;ASGI Server (Uvicorn): Send 422 Response</div>
<div class="line">        ASGI Server (Uvicorn)--&gt;&gt;Client: HTTP 422 Response</div>
<div class="line">    else Validation Succeeds</div>
<div class="line">        Pydantic Validator--&gt;&gt;FastAPI App: Return ItemCreate instance</div>
<div class="line">        FastAPI App-&gt;&gt;Route Handler (create_item): Call create_item(item_input=...)</div>
<div class="line">        Route Handler (create_item)--&gt;&gt;FastAPI App: Return result (e.g., dict)</div>
<div class="line">        FastAPI App-&gt;&gt;FastAPI App: Check response_model=ItemPublic</div>
<div class="line">        FastAPI App-&gt;&gt;Pydantic Serializer (via response_model): Filter/Validate result using ItemPublic</div>
<div class="line">        Pydantic Serializer (via response_model)--&gt;&gt;FastAPI App: Return filtered data</div>
<div class="line">        FastAPI App-&gt;&gt;JsonableEncoder: Convert filtered data to JSON types</div>
<div class="line">        JsonableEncoder--&gt;&gt;FastAPI App: Return JSON-compatible data</div>
<div class="line">        FastAPI App-&gt;&gt;FastAPI App: Create 200 OK JSON Response</div>
<div class="line">        FastAPI App--&gt;&gt;ASGI Server (Uvicorn): Send 200 Response</div>
<div class="line">        ASGI Server (Uvicorn)--&gt;&gt;Client: HTTP 200 OK Response</div>
<div class="line">    end</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1739"></a>
Internal Code Connections</h2>
<p>While FastAPI hides the complexity, here's roughly where things happen:</p>
<ul>
<li><b>Model Definition:</b> You use <code>pydantic.BaseModel</code>.</li>
<li><b>Parameter Analysis:</b> FastAPI's <code>fastapi.dependencies.utils.analyze_param</code> identifies parameters type-hinted with Pydantic models as potential body parameters.</li>
<li><b>Request Body Handling:</b> <code>fastapi.dependencies.utils.request_body_to_args</code> coordinates reading, parsing, and validation (using Pydantic's validation methods internally, like <code>model_validate</code> in v2).</li>
<li><b>Validation Errors:</b> Pydantic raises <code>pydantic.ValidationError</code>, which FastAPI catches and handles using default exception handlers (see <code>fastapi.exception_handlers</code>) to create the 422 response.</li>
<li><b>Response Serialization:</b> The <code>fastapi.routing.APIRoute</code> class handles the <code>response_model</code>. If present, it uses it to process the return value before passing it to <code>fastapi.encoders.jsonable_encoder</code>.</li>
<li><b>JSON Conversion:</b> <code>fastapi.encoders.jsonable_encoder</code> is the workhorse that converts various Python types into JSON-compatible formats. It knows how to handle Pydantic models (calling their &lsquo;.model_dump(mode='json&rsquo;)` method in v2), datetimes, UUIDs, etc.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1740"></a>
Conclusion</h2>
<p>You've unlocked one of FastAPI's superpowers: seamless data validation and serialization powered by Pydantic!</p>
<ul>
<li>You learned to define data shapes using <b>Pydantic models</b> (<code>BaseModel</code>).</li>
<li>You saw how FastAPI <b>automatically validates</b> incoming request bodies against these models using simple type hints in your function parameters (<code>item: Item</code>).</li>
<li>You learned how to use the <code>response_model</code> parameter in path operation decorators to <b>filter and serialize</b> outgoing data, ensuring your API responses have a consistent and predictable structure.</li>
<li>You understood the basic flow: FastAPI acts as the orchestrator, using Pydantic as the expert validator and <code>jsonable_encoder</code> as the expert translator.</li>
</ul>
<p>This automatic handling drastically reduces boilerplate code, prevents common errors, and makes your API development faster and more robust.</p>
<p>But there's another huge benefit to defining your data with Pydantic models: FastAPI uses them to generate interactive API documentation automatically! Let's see how that works in the next chapter.</p>
<p>Ready to see your API document itself? Let's move on to <a class="el" href="../../d9/d03/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_204__openapi______automatic__docs.html">Chapter 4: OpenAPI &amp; Automatic Docs</a>!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
