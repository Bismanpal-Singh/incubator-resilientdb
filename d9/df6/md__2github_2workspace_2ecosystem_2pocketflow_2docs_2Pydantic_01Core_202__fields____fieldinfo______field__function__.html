#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 02_fields__fieldinfo___field_function_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d9/df6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_202__fields____fieldinfo______field__function__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">02_fields__fieldinfo___field_function_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2807"></a>
autotoc_md2807</h2>
<p>layout: default title: "Fields (FieldInfo &amp; Field function)" parent: "Pydantic Core" </p>
<h2><a class="anchor" id="autotoc_md2808"></a>
nav_order: 2</h2>
<h1><a class="anchor" id="autotoc_md2809"></a>
Chapter 2: Customizing Your Blueprint's Rooms - Fields</h1>
<p>In <a class="el" href="../../d7/d22/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_201__basemodel.html">Chapter 1: BaseModel - Your Data Blueprint</a>, we learned how <code>BaseModel</code> acts like a blueprint for our data, defining the expected structure and types using simple Python type hints. We saw how Pydantic uses this blueprint to parse, validate, and serialize data.</p>
<p>But what if we need more specific instructions for certain parts of our blueprint? What if a room needs a specific paint color (a default value)? Or what if the blueprint uses one name for a room ("Lounge"), but the construction crew knows it by another name ("Living Room") (an alias)?</p>
<p>This is where Pydantic's <b>Fields</b> come in. They allow us to add these extra details and constraints to the attributes within our models.</p>
<h2><a class="anchor" id="autotoc_md2810"></a>
Why Customize Fields?</h2>
<p>Let's go back to our <code>User</code> model:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>User(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    age: int</div>
</div><!-- fragment --><p>This is great, but real-world data often has quirks:</p>
<ol type="1">
<li><b>Missing Data:</b> What if <code>age</code> isn't always provided? Should it default to something sensible, like <code>18</code>?</li>
<li><b>Naming Conflicts:</b> What if the incoming data (e.g., JSON from a JavaScript frontend) uses <code>userName</code> instead of <code>name</code> (camelCase vs. snake_case)?</li>
<li><b>Basic Rules:</b> What if we know <code>age</code> must always be a positive number?</li>
</ol>
<p>Simply using type hints (<code>str</code>, <code>int</code>) doesn't cover these cases. We need a way to add more <em>metadata</em> (extra information) to our fields.</p>
<h2><a class="anchor" id="autotoc_md2811"></a>
Introducing <code>Field()</code>: Adding Notes to the Blueprint</h2>
<p>Pydantic provides the <code>Field()</code> function precisely for this purpose. You use it as the <em>default value</em> when defining an attribute on your model, and pass arguments to it to specify the extra details.</p>
<p>Think of it like adding specific notes or requirements to a room on your building blueprint.</p>
<div class="fragment"><div class="line"><span class="comment"># Import Field along with BaseModel</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Our User model, now with customizations using Field()</span></div>
<div class="line"><span class="keyword">class </span>User(BaseModel):</div>
<div class="line">    name: str = Field(</div>
<div class="line">        default=<span class="stringliteral">&#39;Guest&#39;</span>,       <span class="comment"># Note 1: Default name is &#39;Guest&#39;</span></div>
<div class="line">        alias=<span class="stringliteral">&#39;userName&#39;</span>,      <span class="comment"># Note 2: Expect &#39;userName&#39; in input data</span></div>
<div class="line">        min_length=3           <span class="comment"># Note 3: Name must be at least 3 characters</span></div>
<div class="line">    )</div>
<div class="line">    age: int = Field(</div>
<div class="line">        default=18,            <span class="comment"># Note 1: Default age is 18</span></div>
<div class="line">        gt=0                   <span class="comment"># Note 2: Age must be greater than 0</span></div>
<div class="line">    )</div>
<div class="line">    email: str | <span class="keywordtype">None</span> = Field(</div>
<div class="line">        default=<span class="keywordtype">None</span>,          <span class="comment"># Note 3: Email is optional (defaults to None)</span></div>
<div class="line">        description=<span class="stringliteral">&#39;The user email address&#39;</span> <span class="comment"># Note 4: Add a description</span></div>
<div class="line">    )</div>
</div><!-- fragment --><p>Let's break down how we use <code>Field()</code>:</p>
<ol type="1">
<li><b>Import:</b> You need to import <code>Field</code> from <code>pydantic</code>.</li>
<li><b>Assignment:</b> Instead of just <code>name: str</code>, you write <code>name: str = Field(...)</code>. The <code>Field()</code> call replaces a simple default value (though <code>Field()</code> <em>can</em> specify a default).</li>
<li><b>Arguments:</b> You pass keyword arguments to <code>Field()</code> to specify the metadata:<ul>
<li><code>default</code>: Sets a default value if the field isn't provided in the input data. If you <em>only</em> need a default, you can often just write &lsquo;name: str = 'Guest&rsquo;<code>or</code>age: int = 18<code>, but</code>Field(default=...)<code>is useful when combined with other options. Use</code>...<code>(Ellipsis) or omit</code>default<code>entirely to mark a field as required. *</code>alias<code>: Tells Pydantic to look for this name (</code>'userName'<code>) in the input data (like a dictionary or JSON) when parsing, and use this alias when serializing (e.g., in</code>model_dump(by_alias=True)<code>). *</code>gt&lt;tt&gt;(greater than),</li>
</ul>
</li>
</ol>
<p>ge&lt;tt&gt;(greater than or equal),lt&lt;tt&gt;(less than),le&lt;tt&gt;(less than or equal): Basic numeric constraints. *min_length<code>,</code>max_length<code>: Constraints for strings, lists, etc. *</code>description`: A human-readable description, often used for generating documentation or schemas.</p><ul>
<li>...and many more!</li>
</ul>
<h2><a class="anchor" id="autotoc_md2812"></a>
Using Models with <code>Field()</code></h2>
<p>Let's see how our customized <code>User</code> model behaves:</p>
<p><b>1. Using Defaults:</b></p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>User(BaseModel):</div>
<div class="line">    name: str = Field(default=<span class="stringliteral">&#39;Guest&#39;</span>, alias=<span class="stringliteral">&#39;userName&#39;</span>, min_length=3)</div>
<div class="line">    age: int = Field(default=18, gt=0)</div>
<div class="line">    email: str | <span class="keywordtype">None</span> = Field(default=<span class="keywordtype">None</span>, description=<span class="stringliteral">&#39;The user email address&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Input data missing name and age</span></div>
<div class="line">input_data_1 = {<span class="stringliteral">&#39;email&#39;</span>: <span class="stringliteral">&#39;new@example.com&#39;</span>}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Pydantic uses the defaults!</span></div>
<div class="line">user1 = User(**input_data_1)</div>
<div class="line">print(user1)</div>
<div class="line"><span class="comment"># Expected Output: name=&#39;Guest&#39; age=18 email=&#39;new@example.com&#39;</span></div>
</div><!-- fragment --><p>Pydantic automatically filled in <code>name</code> and <code>age</code> using the <code>default</code> values we specified in <code>Field()</code>.</p>
<p><b>2. Using Aliases:</b></p>
<div class="fragment"><div class="line"><span class="comment"># Continuing from above...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Input data using the alias &#39;userName&#39;</span></div>
<div class="line">input_data_2 = {<span class="stringliteral">&#39;userName&#39;</span>: <span class="stringliteral">&#39;Alice&#39;</span>, <span class="stringliteral">&#39;age&#39;</span>: 30}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Pydantic correctly uses the alias to populate &#39;name&#39;</span></div>
<div class="line">user2 = User(**input_data_2)</div>
<div class="line">print(user2)</div>
<div class="line"><span class="comment"># Expected Output: name=&#39;Alice&#39; age=30 email=None</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Dumping the model back, using the alias</span></div>
<div class="line">print(user2.model_dump(by_alias=<span class="keyword">True</span>))</div>
<div class="line"><span class="comment"># Expected Output: {&#39;userName&#39;: &#39;Alice&#39;, &#39;age&#39;: 30, &#39;email&#39;: None}</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Dumping without by_alias uses the actual field names</span></div>
<div class="line">print(user2.model_dump())</div>
<div class="line"><span class="comment"># Expected Output: {&#39;name&#39;: &#39;Alice&#39;, &#39;age&#39;: 30, &#39;email&#39;: None}</span></div>
</div><!-- fragment --><p>Pydantic successfully read the <code>userName</code> key from the input thanks to &lsquo;alias='userName&rsquo;<code>. When dumping *with*</code>by_alias=True`, it uses the alias again.</p>
<p><b>3. Using Validation Constraints:</b></p>
<div class="fragment"><div class="line"><span class="comment"># Continuing from above...</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> ValidationError</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Input data with invalid values</span></div>
<div class="line">invalid_data_1 = {<span class="stringliteral">&#39;userName&#39;</span>: <span class="stringliteral">&#39;Bo&#39;</span>, <span class="stringliteral">&#39;age&#39;</span>: 30} <span class="comment"># Name too short</span></div>
<div class="line">invalid_data_2 = {<span class="stringliteral">&#39;userName&#39;</span>: <span class="stringliteral">&#39;Charlie&#39;</span>, <span class="stringliteral">&#39;age&#39;</span>: -5} <span class="comment"># Age not &gt; 0</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    User(**invalid_data_1)</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Error 1:\n{e}&quot;</span>)</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Expected Output (simplified):</span></div>
<div class="line"><span class="stringliteral">    Error 1:</span></div>
<div class="line"><span class="stringliteral">    1 validation error for User</span></div>
<div class="line"><span class="stringliteral">    name</span></div>
<div class="line"><span class="stringliteral">      String should have at least 3 characters [type=string_too_short, context={&#39;min_length&#39;: 3}, ...]</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    User(**invalid_data_2)</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Error 2:\n{e}&quot;</span>)</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    Expected Output (simplified):</span></div>
<div class="line"><span class="stringliteral">    Error 2:</span></div>
<div class="line"><span class="stringliteral">    1 validation error for User</span></div>
<div class="line"><span class="stringliteral">    age</span></div>
<div class="line"><span class="stringliteral">      Input should be greater than 0 [type=greater_than, context={&#39;gt&#39;: 0}, ...]</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
</div><!-- fragment --><p>Pydantic enforced the <code>min_length=3</code> and <code>gt=0</code> constraints we added via <code>Field()</code>, giving helpful errors when the rules were violated.</p>
<h2><a class="anchor" id="autotoc_md2813"></a>
What is <code>FieldInfo</code>? The Architect's Specification</h2>
<p>So, you use the <code>Field()</code> function to add notes to your blueprint. But how does Pydantic <em>store</em> and <em>use</em> this information internally?</p>
<p>When Pydantic processes your model definition, it takes the information you provided in <code>Field()</code> (and the type hint) and bundles it all up into an internal object called <code>FieldInfo</code>.</p>
<p><b>Analogy:</b> <code>Field()</code> is the sticky note you put on the blueprint ("Living Room - Must have fireplace"). <code>FieldInfo</code> is the formal entry in the architect's detailed specification document that captures this requirement along with the room's dimensions (type hint), default paint color (default value), etc.</p>
<p>You don't usually create <code>FieldInfo</code> objects directly. You use the convenient <code>Field()</code> function, and Pydantic creates the <code>FieldInfo</code> for you.</p>
<p>Every Pydantic model has a special attribute called <code>model_fields</code> which is a dictionary mapping field names to their corresponding <code>FieldInfo</code> objects.</p>
<div class="fragment"><div class="line"><span class="comment"># Continuing from the User model above</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Access the internal FieldInfo objects</span></div>
<div class="line">print(User.model_fields[<span class="stringliteral">&#39;name&#39;</span>])</div>
<div class="line"><span class="comment"># Expected Output (representation may vary slightly):</span></div>
<div class="line"><span class="comment"># FieldInfo(annotation=str, required=False, default=&#39;Guest&#39;, alias=&#39;userName&#39;, alias_priority=2, validation_alias=&#39;userName&#39;, serialization_alias=&#39;userName&#39;, metadata=[MinLen(min_length=3)])</span></div>
<div class="line"> </div>
<div class="line">print(User.model_fields[<span class="stringliteral">&#39;age&#39;</span>])</div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># FieldInfo(annotation=int, required=False, default=18, metadata=[Gt(gt=0)])</span></div>
<div class="line"> </div>
<div class="line">print(User.model_fields[<span class="stringliteral">&#39;email&#39;</span>])</div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># FieldInfo(annotation=Union[str, NoneType], required=False, default=None, description=&#39;The user email address&#39;)</span></div>
</div><!-- fragment --><p>You can see how the <code>FieldInfo</code> object holds all the details: the <code>annotation</code> (type), <code>default</code>, <code>alias</code>, <code>description</code>, and even the constraints like <code>MinLen(min_length=3)</code> and <code>Gt(gt=0)</code> stored in its <code>metadata</code> attribute.</p>
<h2><a class="anchor" id="autotoc_md2814"></a>
Under the Hood: From <code>Field()</code> to <code>FieldInfo</code></h2>
<p>Let's revisit the model creation process from Chapter 1, now including <code>Field()</code>.</p>
<p><b>High-Level Steps:</b></p>
<p>When Python creates your <code>User</code> class:</p>
<ol type="1">
<li><b>Inspection:</b> Pydantic's <code>ModelMetaclass</code> inspects the class definition. It finds &lsquo;name: str = Field(alias='userName&rsquo;, ...)<code>,</code>age: int = Field(default=18, ...)<code>, etc.</code></li>
<li><code> **</code>FieldInfo<code>Creation:** For each attribute defined with</code>Field()<code>, Pydantic calls internal logic (like</code>FieldInfo.from_annotated_attribute<code>) using the type hint (</code>str<code>,</code>int<code>) and the result of the</code>Field(...)<code>call. This creates the</code>FieldInfo<code>object containing all the configuration (type, default, alias, constraints, etc.).</code></li>
<li><code> **Storage:** These</code>FieldInfo<code>objects are stored in an internal dictionary, which becomes accessible via</code>YourModel.model_fields<code>.</code></li>
<li><code> **Schema Generation:** Pydantic uses these comprehensive</code>FieldInfo` objects (along with model-level <a class="el" href="../../d0/d6f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_203__configuration____configdict______configwrapper__.html">Configuration</a>) to generate the internal <a class="el" href="../../d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html">Core Schema</a>. This schema is the detailed instruction set for the fast validation and serialization engine.</li>
</ol>
<p><b>Sequence Diagram:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Dev as Developer</div>
<div class="line">    participant Py as Python</div>
<div class="line">    participant Meta as ModelMetaclass</div>
<div class="line">    participant FInfo as FieldInfo</div>
<div class="line"> </div>
<div class="line">    Dev-&gt;&gt;Py: Define `class User(BaseModel): name: str = Field(alias=&#39;userName&#39;)`</div>
<div class="line">    Py-&gt;&gt;Meta: Ask to create the `User` class</div>
<div class="line">    Meta-&gt;&gt;Meta: Inspect `name` attribute: finds `str` and `Field(alias=&#39;userName&#39;)` assignment</div>
<div class="line">    Meta-&gt;&gt;FInfo: Create `FieldInfo` using `str` and the `Field()` arguments</div>
<div class="line">    FInfo--&gt;&gt;Meta: Return `FieldInfo(annotation=str, alias=&#39;userName&#39;, default=PydanticUndefined, ...)`</div>
<div class="line">    Meta-&gt;&gt;Meta: Store this `FieldInfo` instance in `cls.__pydantic_fields__[&#39;name&#39;]`</div>
<div class="line">    Meta-&gt;&gt;Meta: (Repeat for other fields like &#39;age&#39;, &#39;email&#39;)</div>
<div class="line">    Meta--&gt;&gt;Py: Return the fully prepared `User` class (with `model_fields` populated)</div>
<div class="line">    Py--&gt;&gt;Dev: `User` class is ready</div>
</div><!-- fragment --><p><b>Code Location:</b></p>
<ul>
<li>The <code>Field()</code> function itself is defined in <code>pydantic/fields.py</code>. It's a relatively simple function that just captures its arguments and returns a <code>FieldInfo</code> instance.</li>
<li>The <code>FieldInfo</code> class is also defined in <code>pydantic/fields.py</code>. It holds attributes like <code>annotation</code>, <code>default</code>, <code>alias</code>, <code>metadata</code>, etc.</li>
<li>The logic that finds fields in a class definition, handles the <code>Field()</code> assignments, and creates the <code>FieldInfo</code> objects primarily happens within the <code>collect_model_fields</code> function (in <code>pydantic._internal._fields.py</code>), which is called by the <code>ModelMetaclass</code> (in <code>pydantic._internal._model_construction.py</code>) during class creation.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># Simplified view from pydantic/fields.py</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># The user-facing function</span></div>
<div class="line"><span class="keyword">def </span>Field(</div>
<div class="line">    default: Any = PydanticUndefined,</div>
<div class="line">    *,</div>
<div class="line">    alias: str | <span class="keywordtype">None</span> = _Unset,</div>
<div class="line">    description: str | <span class="keywordtype">None</span> = _Unset,</div>
<div class="line">    gt: float | <span class="keywordtype">None</span> = _Unset,</div>
<div class="line">    <span class="comment"># ... many other arguments</span></div>
<div class="line">) -&gt; Any: <span class="comment"># Returns Any for type checker convenience</span></div>
<div class="line">    <span class="comment"># It captures all arguments and passes them to create a FieldInfo instance</span></div>
<div class="line">    field_info = FieldInfo.from_field(</div>
<div class="line">        default,</div>
<div class="line">        alias=alias,</div>
<div class="line">        description=description,</div>
<div class="line">        gt=gt,</div>
<div class="line">        <span class="comment"># ... passing all arguments through</span></div>
<div class="line">    )</div>
<div class="line">    <span class="keywordflow">return</span> field_info <span class="comment"># Actually returns a FieldInfo instance at runtime</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># The internal storage class</span></div>
<div class="line"><span class="keyword">class </span>FieldInfo:</div>
<div class="line">    <span class="comment"># Attributes to store all the configuration</span></div>
<div class="line">    annotation: type[Any] | <span class="keywordtype">None</span></div>
<div class="line">    default: Any</div>
<div class="line">    alias: str | <span class="keywordtype">None</span></div>
<div class="line">    description: str | <span class="keywordtype">None</span></div>
<div class="line">    metadata: list[Any] <span class="comment"># Stores constraints like Gt, MinLen, etc.</span></div>
<div class="line">    <span class="comment"># ... other attributes</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self, **kwargs) -&gt; None:</div>
<div class="line">        <span class="comment"># Simplified: Assigns kwargs to attributes</span></div>
<div class="line">        self.annotation = kwargs.get(<span class="stringliteral">&#39;annotation&#39;</span>)</div>
<div class="line">        self.default = kwargs.get(<span class="stringliteral">&#39;default&#39;</span>, PydanticUndefined)</div>
<div class="line">        self.alias = kwargs.get(<span class="stringliteral">&#39;alias&#39;</span>)</div>
<div class="line">        self.description = kwargs.get(<span class="stringliteral">&#39;description&#39;</span>)</div>
<div class="line">        <span class="comment"># ... and collects constraints into self.metadata</span></div>
<div class="line">        self.metadata = self._collect_metadata(kwargs)</div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@staticmethod</span></div>
<div class="line">    <span class="keyword">def </span>from_field(default: Any = PydanticUndefined, **kwargs) -&gt; <span class="stringliteral">&#39;FieldInfo&#39;</span>:</div>
<div class="line">        <span class="comment"># Creates an instance, handling the default value logic</span></div>
<div class="line">        <span class="comment"># ... implementation ...</span></div>
<div class="line">        <span class="keywordflow">return</span> FieldInfo(default=default, **kwargs)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>_collect_metadata(self, kwargs: dict[str, Any]) -&gt; list[Any]:</div>
<div class="line">        <span class="comment"># Simplified: Takes kwargs like &#39;gt=0&#39; and converts them</span></div>
<div class="line">        <span class="comment"># to internal metadata objects like &#39;annotated_types.Gt(0)&#39;</span></div>
<div class="line">        metadata = []</div>
<div class="line">        <span class="keywordflow">if</span> <span class="stringliteral">&#39;gt&#39;</span> <span class="keywordflow">in</span> kwargs:</div>
<div class="line">             <span class="comment"># metadata.append(annotated_types.Gt(kwargs.pop(&#39;gt&#39;))) # Real code is more complex</span></div>
<div class="line">             <span class="keywordflow">pass</span> <span class="comment"># Simplified</span></div>
<div class="line">        <span class="comment"># ... handles other constraint kwargs ...</span></div>
<div class="line">        <span class="keywordflow">return</span> metadata</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Simplified view from pydantic._internal._fields.py ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>collect_model_fields(cls, config_wrapper, ns_resolver, *, typevars_map=None):</div>
<div class="line">    fields: dict[str, FieldInfo] = {}</div>
<div class="line">    type_hints = get_model_type_hints(cls, ns_resolver=ns_resolver) <span class="comment"># Get {&#39;name&#39;: str, &#39;age&#39;: int, ...}</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> ann_name, (ann_type, evaluated) <span class="keywordflow">in</span> type_hints.items():</div>
<div class="line">        <span class="keywordflow">if</span> is_valid_field_name(ann_name):</div>
<div class="line">            assigned_value = getattr(cls, ann_name, PydanticUndefined) <span class="comment"># Check if Field() was used</span></div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">if</span> isinstance(assigned_value, FieldInfo): <span class="comment"># If name = Field(...) was used</span></div>
<div class="line">                <span class="comment"># Create FieldInfo using the type hint AND the assigned FieldInfo object</span></div>
<div class="line">                field_info = FieldInfo.from_annotated_attribute(ann_type, assigned_value)</div>
<div class="line">            <span class="keywordflow">elif</span> assigned_value <span class="keywordflow">is</span> PydanticUndefined: <span class="comment"># If only name: str was used</span></div>
<div class="line">                <span class="comment"># Create FieldInfo just from the type hint</span></div>
<div class="line">                field_info = FieldInfo.from_annotation(ann_type)</div>
<div class="line">            <span class="keywordflow">else</span>: <span class="comment"># If name: str = &#39;some_default&#39; was used</span></div>
<div class="line">                <span class="comment"># Create FieldInfo from type hint and simple default</span></div>
<div class="line">                field_info = FieldInfo.from_annotated_attribute(ann_type, assigned_value)</div>
<div class="line"> </div>
<div class="line">            fields[ann_name] = field_info</div>
<div class="line">            <span class="comment"># ... more logic for inheritance, docstrings, etc. ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> fields, <a class="code hl_function" href="../../d7/da6/pybind__kv__service_8cpp.html#a26ae8807a2b3217bb2339bd18aaaa4e6">set</a>() <span class="comment"># Returns dict of field names to FieldInfo objects</span></div>
<div class="ttc" id="apybind__kv__service_8cpp_html_a26ae8807a2b3217bb2339bd18aaaa4e6"><div class="ttname"><a href="../../d7/da6/pybind__kv__service_8cpp.html#a26ae8807a2b3217bb2339bd18aaaa4e6">set</a></div><div class="ttdeci">bool set(std::string key, std::string value, std::string config_path)</div><div class="ttdef"><b>Definition</b> <a href="../../d7/da6/pybind__kv__service_8cpp_source.html#l00051">pybind_kv_service.cpp:51</a></div></div>
</div><!-- fragment --><p>This process ensures that all the configuration you provide via <code>Field()</code> is captured systematically in <code>FieldInfo</code> objects, ready to be used for generating the validation/serialization schema.</p>
<h2><a class="anchor" id="autotoc_md2815"></a>
Conclusion</h2>
<p>You've now learned how to add detailed configuration to your <code>BaseModel</code> fields using the <code>Field()</code> function:</p>
<ul>
<li><code>Field()</code> allows you to specify <b>defaults</b>, <b>aliases</b>, basic <b>validation constraints</b> (like <code>gt</code>, <code>max_length</code>), <b>descriptions</b>, and more.</li>
<li>It acts like adding specific <b>notes or requirements</b> to the rooms in your data blueprint.</li>
<li>Internally, Pydantic captures this information in <code>FieldInfo</code> objects.</li>
<li><code>FieldInfo</code> holds the complete specification for a field (type, default, alias, constraints, etc.) and is stored in the model's <code>model_fields</code> attribute.</li>
<li>This detailed <code>FieldInfo</code> is crucial for Pydantic's powerful validation and serialization capabilities.</li>
</ul>
<p>You now have more control over individual fields. But what about configuring the overall behavior of the <em>entire</em> model? For example, how can we tell Pydantic to <em>always</em> use aliases when serializing, or to forbid extra fields not defined in the model? That's where model configuration comes in.</p>
<p>Next: <a class="el" href="../../d0/d6f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_203__configuration____configdict______configwrapper__.html">Chapter 3: Configuration (ConfigDict / ConfigWrapper)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
