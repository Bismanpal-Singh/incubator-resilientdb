#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 07_security_utilities</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d9/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_207__security__utilities.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">07_security_utilities</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1838"></a>
autotoc_md1838</h2>
<p>layout: default title: "Security Utilities" parent: "FastAPI" </p>
<h2><a class="anchor" id="autotoc_md1839"></a>
nav_order: 7</h2>
<h1><a class="anchor" id="autotoc_md1840"></a>
Chapter 7: Security Utilities</h1>
<p>Hi there! ðŸ‘‹ In <a class="el" href="../../dc/d8a/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_206__error__handling.html">Chapter 6: Error Handling</a>, we learned how to handle situations where things go wrong in our API, like when a user requests an item that doesn't exist. Now, let's talk about protecting our API endpoints.</p>
<p>Imagine our online store API. Anyone should be able to browse items (<code>GET /items/</code>). But maybe only registered, logged-in users should be allowed to <em>create</em> new items (<code>POST /items/</code>) or view their own profile (<code>GET /users/me</code>). How do we ensure only the right people can access certain parts of our API?</p>
<p>That's where <b>Security Utilities</b> come in!</p>
<p><b>Our Goal Today:</b> Learn how FastAPI provides ready-made tools to implement common security mechanisms like username/password checks or API keys, making it easy to protect your endpoints.</p>
<h2><a class="anchor" id="autotoc_md1841"></a>
What Problem Does This Solve?</h2>
<p>When you build an API, some parts might be public, but others need protection. You need a way to:</p>
<ol type="1">
<li><b>Identify the User:</b> Figure out <em>who</em> is making the request. Are they logged in? Do they have a valid API key? This process is called <b>Authentication</b> (AuthN - proving who you are).</li>
<li><b>Check Permissions (Optional but related):</b> Once you know who the user is, you might need to check if they have permission to do what they're asking. Can user "Alice" delete user "Bob"? This is called <b>Authorization</b> (AuthZ - checking what you're allowed to do). (We'll focus mainly on Authentication in this beginner chapter).</li>
<li><b>Ask for Credentials:</b> How does the user provide their identity? Common ways include:<ul>
<li><b>HTTP Basic Authentication:</b> Sending a username and password directly (encoded) in the request headers. Simple, but less secure over plain HTTP.</li>
<li><b>API Keys:</b> Sending a secret key (a long string) in the headers, query parameters, or cookies. Common for server-to-server communication.</li>
<li><b>OAuth2 Bearer Tokens:</b> Sending a temporary token (obtained after logging in) in the headers. Very common for web and mobile apps.</li>
</ul>
</li>
<li><b>Document Security:</b> How do you tell users of your API (in the <code>/docs</code>) that certain endpoints require authentication and how to provide it?</li>
</ol>
<p>Implementing these security schemes from scratch can be complex and tricky. FastAPI gives you pre-built components (like different types of locks and keys) that handle the common patterns for asking for and receiving credentials.</p>
<h2><a class="anchor" id="autotoc_md1842"></a>
Key Concepts</h2>
<ol type="1">
<li><b>Security Schemes:</b> These are the standard protocols or methods used for authentication, like HTTP Basic, API Keys (in different locations), and OAuth2. FastAPI provides classes that represent these schemes (e.g., <code>HTTPBasic</code>, <code>APIKeyHeader</code>, <code>OAuth2PasswordBearer</code>). Think of these as the <em>type</em> of lock mechanism you want to install on your door.</li>
<li><b><code>fastapi.security</code> Module:</b> This module contains all the pre-built security scheme classes. You'll import things like <code>HTTPBasic</code>, <code>APIKeyHeader</code>, <code>APIKeyQuery</code>, <code>APIKeyCookie</code>, <code>OAuth2PasswordBearer</code> from here.</li>
<li><b>Credentials:</b> The actual "secret" information the user provides to prove their identity (username/password, the API key string, the OAuth2 token string).</li>
<li><b>Verifier Dependency:</b> A function you write (a dependency, like we learned about in <a class="el" href="../../dd/dd7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_205__dependency__injection.html">Chapter 5: Dependency Injection</a>) that takes the credentials extracted by the security scheme and checks if they are valid. It might check a username/password against a database or validate an API key. This function decides if the "key" fits the "lock".</li>
<li><b><code>Security()</code> Function:</b> This is a special function imported from <code>fastapi</code> (<code>from fastapi import Security</code>). It works almost exactly like <code>Depends()</code>, but it's specifically designed for security dependencies. You use it like this: <code>user: Annotated[UserType, Security(your_verifier_dependency)]</code>.<ul>
<li><b>Main Difference from <code>Depends()</code>:</b> Using <code>Security()</code> tells FastAPI to automatically add the corresponding security requirements to your OpenAPI documentation (<code>/docs</code>). This means <code>/docs</code> will show a little lock icon on protected endpoints and provide UI elements for users to enter their credentials (like username/password or a token) when trying out the API.</li>
</ul>
</li>
</ol>
<p><b>Analogy:</b></p><ul>
<li><b>Security Scheme (<code>HTTPBasic</code>, <code>APIKeyHeader</code>):</b> The type of lock on the door (e.g., a key lock, a combination lock).</li>
<li><b>Scheme Instance (<code>security = HTTPBasic()</code>):</b> Installing that specific lock on a particular door frame.</li>
<li><b>Credentials (<code>username/password</code>, <code>API key</code>):</b> The key or combination provided by the person trying to open the door.</li>
<li><b>Verifier Dependency (<code>get_current_user</code>):</b> The person or mechanism that takes the key/combination, checks if it's correct, and decides whether to let the person in.</li>
<li><b><code>Security(get_current_user)</code>:</b> Declaring that the door requires the verifier to check the key/combination before allowing entry, and also putting a "Lock" sign on the door in the building map (<code>/docs</code>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md1843"></a>
Using Security Utilities: HTTP Basic Auth Example</h2>
<p>Let's protect an endpoint using the simplest method: HTTP Basic Authentication. We'll create an endpoint <code>/users/me</code> that requires a valid username and password.</p>
<p><b>Step 1: Import necessary tools</b></p>
<p>We need <code>HTTPBasic</code> (the scheme), <code>HTTPBasicCredentials</code> (a Pydantic model to hold the extracted username/password), <code>Security</code> (to declare the dependency), <code>Annotated</code>, and <code>HTTPException</code> (for errors).</p>
<div class="fragment"><div class="line"><span class="comment"># main.py (or your router file)</span></div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated</div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> Depends, FastAPI, HTTPException, status</div>
<div class="line"><span class="keyword">from</span> fastapi.security <span class="keyword">import</span> HTTPBasic, HTTPBasicCredentials</div>
</div><!-- fragment --><p><b>Step 2: Create an instance of the security scheme</b></p>
<p>We create an instance of <code>HTTPBasic</code>. This object knows <em>how</em> to ask the browser/client for username/password via standard HTTP mechanisms.</p>
<div class="fragment"><div class="line"><span class="comment"># Right after imports</span></div>
<div class="line">security = HTTPBasic()</div>
<div class="line"> </div>
<div class="line">app = FastAPI() <span class="comment"># Or use your APIRouter</span></div>
</div><!-- fragment --><p><b>Step 3: Define the "Verifier" Dependency Function</b></p>
<p>This function will receive the credentials extracted by <code>security</code> and check if they are valid. For this beginner example, we'll use hardcoded values. In a real app, you'd check against a database.</p>
<div class="fragment"><div class="line"><span class="comment"># Our &quot;verifier&quot; function</span></div>
<div class="line"><span class="keyword">def </span>get_current_username(credentials: Annotated[HTTPBasicCredentials, Depends(security)]):</div>
<div class="line">    <span class="comment"># NOTE: In a real app, NEVER hardcode credentials like this!</span></div>
<div class="line">    <span class="comment">#       Always use secure password hashing (e.g., with passlib)</span></div>
<div class="line">    <span class="comment">#       and check against a database.</span></div>
<div class="line">    correct_username = <span class="stringliteral">&quot;stanley&quot;</span></div>
<div class="line">    correct_password = <span class="stringliteral">&quot;password123&quot;</span> <span class="comment"># Don&#39;t do this in production!</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Basic check (insecure comparison for demonstration)</span></div>
<div class="line">    is_correct_username = credentials.username == correct_username</div>
<div class="line">    is_correct_password = credentials.password == correct_password <span class="comment"># Insecure!</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> <span class="keywordflow">not</span> (is_correct_username <span class="keywordflow">and</span> is_correct_password):</div>
<div class="line">        <span class="comment"># If credentials are bad, raise an exception</span></div>
<div class="line">        <span class="keywordflow">raise</span> HTTPException(</div>
<div class="line">            status_code=status.HTTP_401_UNAUTHORIZED,</div>
<div class="line">            detail=<span class="stringliteral">&quot;Incorrect email or password&quot;</span>,</div>
<div class="line">            headers={<span class="stringliteral">&quot;WWW-Authenticate&quot;</span>: <span class="stringliteral">&quot;Basic&quot;</span>}, <span class="comment"># Required header for 401 Basic Auth</span></div>
<div class="line">        )</div>
<div class="line">    <span class="comment"># If credentials are okay, return the username</span></div>
<div class="line">    <span class="keywordflow">return</span> credentials.username</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>get_current_username</code> is our dependency function.</li>
<li><code>credentials: Annotated[HTTPBasicCredentials, Depends(security)]</code>: It depends on our <code>security</code> object (<code>HTTPBasic</code>). FastAPI will run <code>security</code> first. <code>security</code> will extract the username and password from the <code>Authorization: Basic ...</code> header and provide them as an <code>HTTPBasicCredentials</code> object to this function.</li>
<li>Inside, we perform a (very insecure, for demo only!) check against hardcoded values.</li>
<li>If the check fails, we <code>raise HTTPException</code> with status <code>401 Unauthorized</code>. The <code>headers={"WWW-Authenticate": "Basic"}</code> part is important; it tells the browser <em>how</em> it should ask for credentials (using the Basic scheme).</li>
<li>If the check passes, we return the validated username.</li>
</ul>
<p><b>Step 4: Use <code>Security()</code> in the Path Operation</b></p>
<p>Now, let's create our protected endpoint <code>/users/me</code>. Instead of <code>Depends</code>, we use <code>Security</code> with our verifier function.</p>
<div class="fragment"><div class="line"><span class="preprocessor">@app.get(&quot;/users/me&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>read_current_user(</div>
<div class="line">    <span class="comment"># Use Security() with the verifier function</span></div>
<div class="line">    username: Annotated[str, Security(get_current_username)]</div>
<div class="line">):</div>
<div class="line">    <span class="comment"># If the code reaches here, get_current_username ran successfully</span></div>
<div class="line">    <span class="comment"># and returned the validated username.</span></div>
<div class="line">    <span class="comment"># &#39;username&#39; variable now holds the result from get_current_username.</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;username&quot;</span>: username}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>username: Annotated[str, Security(get_current_username)]</code>: We declare that this path operation requires the <code>get_current_username</code> dependency, using <code>Security</code>.<ul>
<li>FastAPI will first run <code>get_current_username</code>.</li>
<li><code>get_current_username</code> will, in turn, trigger <code>security</code> (<code>HTTPBasic</code>) to get the credentials.</li>
<li>If <code>get_current_username</code> succeeds (doesn't raise an exception), its return value (the username string) will be injected into the <code>username</code> parameter of <code>read_current_user</code>.</li>
<li>If <code>get_current_username</code> (or the underlying <code>HTTPBasic</code>) raises an <code>HTTPException</code>, the request stops, the error response is sent, and <code>read_current_user</code> is never called.</li>
<li>Crucially, <code>Security()</code> also adds the HTTP Basic security requirement to the OpenAPI schema for this endpoint.</li>
</ul>
</li>
</ul>
<p><b>How it Behaves:</b></p>
<ol type="1">
<li><b>Run the App:</b> <code>uvicorn main:app --reload</code></li>
<li><b>Visit <code>/docs</code>:</b> Go to <code><a href="http://127.0.0.1:8000/docs">http://127.0.0.1:8000/docs</a></code>.<ul>
<li>You'll see the <code>/users/me</code> endpoint now has a <b>padlock icon</b> ðŸ”’ next to it.</li>
<li>Click the "Authorize" button (usually near the top right). A popup will appear asking for Username and Password for the "HTTPBasic" scheme.</li>
<li>Enter <code>stanley</code> and <code>password123</code> and click Authorize.</li>
<li>Now, try out the <code>/users/me</code> endpoint. Click "Try it out", then "Execute". It should work and return <code>{"username": "stanley"}</code>. The browser automatically added the correct <code>Authorization</code> header because you authorized in the UI.</li>
<li>Click "Authorize" again and "Logout". Now try executing <code>/users/me</code> again. You'll get a <code>401 Unauthorized</code> error with <code>{"detail": "Not authenticated"}</code> (this default comes from <code>HTTPBasic</code> when no credentials are provided).</li>
</ul>
</li>
<li><b>Use <code>curl</code> (Command Line):</b><ul>
<li><code>curl <a href="http://127.0.0.1:8000/users/me">http://127.0.0.1:8000/users/me</a></code> -&gt; Returns <code>{"detail":"Not authenticated"}</code> (401).</li>
<li><code>curl -u wronguser:wrongpass <a href="http://127.0.0.1:8000/users/me">http://127.0.0.1:8000/users/me</a></code> -&gt; Returns <code>{"detail":"Incorrect email or password"}</code> (401). The <code>-u</code> flag makes <code>curl</code> use HTTP Basic Auth.</li>
<li><code>curl -u stanley:password123 <a href="http://127.0.0.1:8000/users/me">http://127.0.0.1:8000/users/me</a></code> -&gt; Returns <code>{"username": "stanley"}</code> (200 OK).</li>
</ul>
</li>
</ol>
<p>You've successfully protected an endpoint using HTTP Basic Auth!</p>
<h2><a class="anchor" id="autotoc_md1844"></a>
Other Common Schemes (Briefly)</h2>
<p>The pattern is very similar for other schemes.</p>
<h3><a class="anchor" id="autotoc_md1845"></a>
API Key in Header</h3>
<div class="fragment"><div class="line"><span class="comment"># --- Imports ---</span></div>
<div class="line"><span class="keyword">from</span> fastapi.security <span class="keyword">import</span> APIKeyHeader</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Scheme Instance ---</span></div>
<div class="line">api_key_header_scheme = APIKeyHeader(name=<span class="stringliteral">&quot;X-API-KEY&quot;</span>) <span class="comment"># Expect key in X-API-KEY header</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Verifier Dependency (Example) ---</span></div>
<div class="line"><span class="keyword">async def </span>get_api_key(</div>
<div class="line">    api_key: Annotated[str, Security(api_key_header_scheme)] <span class="comment"># Use Security() with the SCHEME instance here</span></div>
<div class="line">):</div>
<div class="line">    <span class="keywordflow">if</span> api_key == <span class="stringliteral">&quot;SECRET_API_KEY&quot;</span>: <span class="comment"># Check the key (use a secure way in real apps!)</span></div>
<div class="line">        <span class="keywordflow">return</span> api_key</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        <span class="keywordflow">raise</span> HTTPException(</div>
<div class="line">            status_code=status.HTTP_403_FORBIDDEN, detail=<span class="stringliteral">&quot;Could not validate API KEY&quot;</span></div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Path Operation ---</span></div>
<div class="line"><span class="preprocessor">@app.get(&quot;/secure-data&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>get_secure_data(</div>
<div class="line">    <span class="comment"># Inject the VALIDATED key using Depends() - no need for Security() again</span></div>
<div class="line">    <span class="comment"># if the get_api_key dependency already uses Security() internally.</span></div>
<div class="line">    <span class="comment"># Alternatively, if get_api_key just returned the key without raising errors,</span></div>
<div class="line">    <span class="comment"># you could use Security(get_api_key) here. Let&#39;s stick to the pattern:</span></div>
<div class="line">    <span class="comment"># the verifier dependency uses Security(scheme), the endpoint uses Depends(verifier)</span></div>
<div class="line">    <span class="comment"># or directly uses Security(verifier) if the verifier handles errors.</span></div>
<div class="line">    <span class="comment"># Let&#39;s adjust get_api_key to make it cleaner:</span></div>
<div class="line">    api_key: Annotated[str, Security(api_key_header_scheme)] <span class="comment"># Scheme extracts the key</span></div>
<div class="line">):</div>
<div class="line">    <span class="comment"># Now, a separate check or use the key</span></div>
<div class="line">    <span class="keywordflow">if</span> api_key == <span class="stringliteral">&quot;SECRET_API_KEY&quot;</span>: <span class="comment"># Re-checking here for simplicity, ideally done in a dependent function</span></div>
<div class="line">         <span class="keywordflow">return</span> {<span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;sensitive data&quot;</span>, <span class="stringliteral">&quot;api_key_used&quot;</span>: api_key}</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">         <span class="comment"># This path might not be reachable if auto_error=True in APIKeyHeader</span></div>
<div class="line">         <span class="keywordflow">raise</span> HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=<span class="stringliteral">&quot;Invalid API Key provided&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Let&#39;s refine the API Key example pattern to match the Basic Auth pattern:</span></div>
<div class="line"><span class="comment"># Scheme Instance</span></div>
<div class="line">api_key_header_scheme = APIKeyHeader(name=<span class="stringliteral">&quot;X-API-KEY&quot;</span>, auto_error=<span class="keyword">False</span>) <span class="comment"># auto_error=False lets verifier handle missing key</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Verifier Dependency</span></div>
<div class="line"><span class="keyword">async def </span>verify_api_key(api_key: Annotated[str | <span class="keywordtype">None</span>, Security(api_key_header_scheme)]):</div>
<div class="line">    <span class="keywordflow">if</span> api_key <span class="keywordflow">is</span> <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="keywordflow">raise</span> HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=<span class="stringliteral">&quot;X-API-KEY header missing&quot;</span>)</div>
<div class="line">    <span class="keywordflow">if</span> api_key == <span class="stringliteral">&quot;SECRET_API_KEY&quot;</span>:</div>
<div class="line">        <span class="keywordflow">return</span> api_key <span class="comment"># Return key or user info associated with the key</span></div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        <span class="keywordflow">raise</span> HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail=<span class="stringliteral">&quot;Invalid API Key&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Path Operation using the verifier</span></div>
<div class="line"><span class="preprocessor">@app.get(&quot;/secure-data&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>get_secure_data_v2(</div>
<div class="line">    <span class="comment"># Use Security() with the VERIFIER function</span></div>
<div class="line">    verified_key: Annotated[str, Security(verify_api_key)]</div>
<div class="line">):</div>
<div class="line">    <span class="comment"># verified_key holds the result from verify_api_key (the validated key)</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;data&quot;</span>: <span class="stringliteral">&quot;sensitive data&quot;</span>, <span class="stringliteral">&quot;key&quot;</span>: verified_key}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md1846"></a>
OAuth2 Password Bearer Flow</h3>
<p>This is common for user logins in web apps. It usually involves two endpoints: one to exchange username/password for a token (<code>/token</code>), and protected endpoints that require the token.</p>
<div class="fragment"><div class="line"><span class="comment"># --- Imports ---</span></div>
<div class="line"><span class="keyword">from</span> fastapi.security <span class="keyword">import</span> OAuth2PasswordBearer, OAuth2PasswordRequestForm</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Scheme Instance ---</span></div>
<div class="line"><span class="comment"># The &#39;tokenUrl&#39; points to the path operation where users get the token</span></div>
<div class="line">oauth2_scheme = OAuth2PasswordBearer(tokenUrl=<span class="stringliteral">&quot;token&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Token Endpoint (Example) ---</span></div>
<div class="line"><span class="preprocessor">@app.post(&quot;/token&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>login_for_access_token(</div>
<div class="line">    form_data: Annotated[OAuth2PasswordRequestForm, Depends()]</div>
<div class="line">):</div>
<div class="line">    <span class="comment"># 1. Verify form_data.username and form_data.password (check DB)</span></div>
<div class="line">    <span class="comment"># 2. If valid, create an access token (e.g., a JWT)</span></div>
<div class="line">    <span class="comment"># 3. Return the token</span></div>
<div class="line">    <span class="comment"># (Skipping implementation details for brevity)</span></div>
<div class="line">    access_token = f<span class="stringliteral">&quot;token_for_{form_data.username}&quot;</span> <span class="comment"># Fake token</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;access_token&quot;</span>: access_token, <span class="stringliteral">&quot;token_type&quot;</span>: <span class="stringliteral">&quot;bearer&quot;</span>}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Verifier Dependency (Example: decode token and get user) ---</span></div>
<div class="line"><span class="keyword">async def </span>get_current_user(token: Annotated[str, Security(oauth2_scheme)]):</div>
<div class="line">    <span class="comment"># In a real app:</span></div>
<div class="line">    <span class="comment"># 1. Decode the token (e.g., JWT)</span></div>
<div class="line">    <span class="comment"># 2. Validate the token (check expiry, signature)</span></div>
<div class="line">    <span class="comment"># 3. Extract user identifier from token payload</span></div>
<div class="line">    <span class="comment"># 4. Fetch user from database</span></div>
<div class="line">    <span class="comment"># 5. Raise HTTPException if token is invalid or user doesn&#39;t exist</span></div>
<div class="line">    <span class="keywordflow">if</span> token == <span class="stringliteral">&quot;token_for_stanley&quot;</span>: <span class="comment"># Fake check</span></div>
<div class="line">        <span class="keywordflow">return</span> {<span class="stringliteral">&quot;username&quot;</span>: <span class="stringliteral">&quot;stanley&quot;</span>, <span class="stringliteral">&quot;email&quot;</span>: <span class="stringliteral">&quot;stanley@example.com&quot;</span>}</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        <span class="keywordflow">raise</span> HTTPException(</div>
<div class="line">            status_code=status.HTTP_401_UNAUTHORIZED,</div>
<div class="line">            detail=<span class="stringliteral">&quot;Invalid authentication credentials&quot;</span>,</div>
<div class="line">            headers={<span class="stringliteral">&quot;WWW-Authenticate&quot;</span>: <span class="stringliteral">&quot;Bearer&quot;</span>},</div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Protected Path Operation ---</span></div>
<div class="line"><span class="preprocessor">@app.get(&quot;/users/me/oauth&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>read_users_me_oauth(</div>
<div class="line">    <span class="comment"># Use Security() with the user verifier function</span></div>
<div class="line">    current_user: Annotated[dict, Security(get_current_user)]</div>
<div class="line">):</div>
<div class="line">    <span class="comment"># current_user holds the dict returned by get_current_user</span></div>
<div class="line">    <span class="keywordflow">return</span> current_user</div>
</div><!-- fragment --><p>The core pattern remains: Instantiate the scheme -&gt; Define a verifier dependency that uses the scheme -&gt; Protect endpoints using <code>Security(verifier_dependency)</code>.</p>
<h2><a class="anchor" id="autotoc_md1847"></a>
How it Works Under the Hood (Simplified)</h2>
<p>Let's trace the HTTP Basic Auth example (<code>GET /users/me</code> requiring <code>stanley</code>/<code>password123</code>):</p>
<ol type="1">
<li><b>Request:</b> Client sends <code>GET /users/me</code> with header <code>Authorization: Basic c3RhbmxleTpwYXNzd29yZDEyMw==</code> (where <code>c3Rh...</code> is base64("stanley:password123")).</li>
<li><b>Routing:</b> FastAPI matches the request to <code>read_current_user</code>.</li>
<li><b>Dependency Analysis:</b> FastAPI sees <code>username: Annotated[str, Security(get_current_username)]</code>. It knows it needs to resolve the <code>get_current_username</code> dependency using the <code>Security</code> mechanism.</li>
<li><b>Security Dependency Resolution:</b><ul>
<li>FastAPI looks inside <code>get_current_username</code> and sees its dependency: <code>credentials: Annotated[HTTPBasicCredentials, Depends(security)]</code>.</li>
<li>It needs to resolve <code>security</code> (our <code>HTTPBasic()</code> instance).</li>
</ul>
</li>
<li><b>Scheme Execution (<code>HTTPBasic.__call__</code>)</b>:<ul>
<li>FastAPI calls the <code>security</code> object (which is callable).</li>
<li>The <code>HTTPBasic</code> object's <code>__call__</code> method executes. It reads the <code>Authorization</code> header from the request.</li>
<li>It finds the <code>Basic</code> scheme and the parameter <code>c3RhbmxleTpwYXNzd29yZDEyMw==</code>.</li>
<li>It base64-decodes the parameter to get <code>stanley:password123</code>.</li>
<li>It splits this into username (<code>stanley</code>) and password (<code>password123</code>).</li>
<li>It creates and returns an <code>HTTPBasicCredentials(username="stanley", password="password123")</code> object.</li>
<li><em>(If the header was missing or malformed, <code>HTTPBasic.__call__</code> would raise <code>HTTPException(401)</code> here, stopping the process).</em></li>
</ul>
</li>
<li><b>Verifier Execution (<code>get_current_username</code>)</b>:<ul>
<li>FastAPI now has the result from <code>security</code>. It calls <code>get_current_username(credentials=&lt;HTTPBasicCredentials object&gt;)</code>.</li>
<li>Your verifier code runs. It compares the credentials. They match the hardcoded values.</li>
<li>The function returns the username <code>"stanley"</code>.</li>
<li><em>(If the credentials didn't match, your code would raise <code>HTTPException(401)</code> here, stopping the process).</em></li>
</ul>
</li>
<li><b>Path Operation Execution (<code>read_current_user</code>)</b>:<ul>
<li>FastAPI now has the result from <code>get_current_username</code>. It calls <code>read_current_user(username="stanley")</code>.</li>
<li>Your path operation function runs and returns <code>{"username": "stanley"}</code>.</li>
</ul>
</li>
<li><b>Response:</b> FastAPI sends the 200 OK JSON response back to the client.</li>
<li><b>OpenAPI Generation:</b> Separately, when generating <code>/openapi.json</code>, FastAPI sees <code>Security(get_current_username)</code> -&gt; <code>Depends(security)</code> -&gt; <code>security</code> is <code>HTTPBasic</code>. It adds the "HTTPBasic" security requirement definition to the global <code>components.securitySchemes</code> and references it in the security requirements for the <code>/users/me</code> path operation. This is what makes the lock icon appear in <code>/docs</code>.</li>
</ol>
<p>Here's a simplified diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client</div>
<div class="line">    participant FastAPIApp as FastAPI App</div>
<div class="line">    participant HTTPBasicInst as security (HTTPBasic Instance)</div>
<div class="line">    participant VerifierFunc as get_current_username</div>
<div class="line">    participant PathOpFunc as read_current_user</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;+FastAPIApp: GET /users/me (Authorization: Basic ...)</div>
<div class="line">    FastAPIApp-&gt;&gt;FastAPIApp: Match route, see Security(get_current_username)</div>
<div class="line">    FastAPIApp-&gt;&gt;FastAPIApp: Resolve get_current_username dependencies: Depends(security)</div>
<div class="line">    FastAPIApp-&gt;&gt;+HTTPBasicInst: Call security(request)</div>
<div class="line">    HTTPBasicInst-&gt;&gt;HTTPBasicInst: Read header, decode base64, split user/pass</div>
<div class="line">    HTTPBasicInst--&gt;&gt;-FastAPIApp: Return HTTPBasicCredentials(user=&quot;stanley&quot;, pass=&quot;...&quot;)</div>
<div class="line">    FastAPIApp-&gt;&gt;+VerifierFunc: Call get_current_username(credentials=...)</div>
<div class="line">    VerifierFunc-&gt;&gt;VerifierFunc: Check credentials -&gt; OK</div>
<div class="line">    VerifierFunc--&gt;&gt;-FastAPIApp: Return username &quot;stanley&quot;</div>
<div class="line">    FastAPIApp-&gt;&gt;+PathOpFunc: Call read_current_user(username=&quot;stanley&quot;)</div>
<div class="line">    PathOpFunc--&gt;&gt;-FastAPIApp: Return {&quot;username&quot;: &quot;stanley&quot;}</div>
<div class="line">    FastAPIApp--&gt;&gt;-Client: Send 200 OK JSON Response</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1848"></a>
Code Connections</h2>
<ul>
<li><b><code>fastapi.Security</code></b>: The function you import and use. It's a thin wrapper around <code>fastapi.params.Security</code>. (<code>fastapi/param_functions.py</code>)</li>
<li><b><code>fastapi.params.Security</code></b>: The class that signals a security dependency, inheriting from <code>Depends</code> but adding the <code>scopes</code> parameter. (<code>fastapi/params.py</code>)</li>
<li><b><code>fastapi.security.*</code></b>: This package contains the scheme implementations:<ul>
<li><code>fastapi.security.http</code>: Contains <code>HTTPBase</code>, <code>HTTPBasic</code>, <code>HTTPBearer</code>, <code>HTTPDigest</code>, and the <code>HTTPBasicCredentials</code>, <code>HTTPAuthorizationCredentials</code> models.</li>
<li><code>fastapi.security.api_key</code>: Contains <code>APIKeyHeader</code>, <code>APIKeyQuery</code>, <code>APIKeyCookie</code>.</li>
<li><code>fastapi.security.oauth2</code>: Contains <code>OAuth2</code>, <code>OAuth2PasswordBearer</code>, <code>OAuth2AuthorizationCodeBearer</code>, <code>OAuth2PasswordRequestForm</code>, <code>SecurityScopes</code>.</li>
</ul>
</li>
<li><b>Scheme <code>__call__</code> methods</b>: Each scheme class (e.g., <code>HTTPBasic</code>, <code>APIKeyHeader</code>, <code>OAuth2PasswordBearer</code>) implements <code>async def __call__(self, request: Request)</code> which contains the logic to extract credentials from the specific request location (headers, query, etc.).</li>
<li><b>Dependency Injection System</b>: The core system described in <a class="el" href="../../dd/dd7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_205__dependency__injection.html">Chapter 5: Dependency Injection</a> resolves the dependencies, calling the scheme instance and then your verifier function.</li>
<li><b>OpenAPI Integration</b>: FastAPI's OpenAPI generation logic specifically checks for <code>Security</code> dependencies and uses the associated scheme model (<code>security.model</code>) to add the correct security requirements to the schema.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1849"></a>
Conclusion</h2>
<p>You've now learned the basics of securing your FastAPI endpoints!</p>
<ul>
<li>You understand the need for <b>authentication</b> (who is the user?).</li>
<li>You know about common <b>security schemes</b> like HTTP Basic, API Keys, and OAuth2 Bearer tokens.</li>
<li>You learned that FastAPI provides <b>utility classes</b> (e.g., <code>HTTPBasic</code>, <code>APIKeyHeader</code>, <code>OAuth2PasswordBearer</code>) in the <code>fastapi.security</code> module to handle these schemes.</li>
<li>You saw how to use the <b><code>Security()</code></b> function (similar to <code>Depends()</code>) to integrate these schemes into your path operations via <b>verifier dependencies</b>.</li>
<li>You understand that <code>Security()</code> automatically adds security requirements to your <b>OpenAPI documentation</b> (<code>/docs</code>).</li>
<li>You grasped the core pattern: <b>Scheme Instance -&gt; Verifier Dependency -&gt; <code>Security(verifier)</code></b>.</li>
</ul>
<p>Using these tools allows you to easily add robust security layers to your API without reinventing the wheel.</p>
<p>Sometimes, after handling a request and sending a response, you might need to perform some follow-up actions, like sending a notification email or processing some data, without making the user wait. How can we do that?</p>
<p>Ready to run tasks in the background? Let's move on to <a class="el" href="../../db/d43/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_208__background__tasks.html">Chapter 8: Background Tasks</a>!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
