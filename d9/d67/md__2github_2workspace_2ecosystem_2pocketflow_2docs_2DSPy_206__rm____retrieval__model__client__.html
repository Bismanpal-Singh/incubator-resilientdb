#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_rm__retrieval_model_client_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d9/d67/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_206__rm____retrieval__model__client__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_rm__retrieval_model_client_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1669"></a>
autotoc_md1669</h2>
<p>layout: default title: "RM (Retrieval Model Client)" parent: "DSPy" </p>
<h2><a class="anchor" id="autotoc_md1670"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md1671"></a>
Chapter 6: RM (Retrieval Model Client) - Your Program's Librarian</h1>
<p>In <a class="el" href="../../d9/db7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_205__lm____language__model__client__.html">Chapter 5: LM (Language Model Client)</a>, we learned how to connect our DSPy programs to the powerful "brain" of a Language Model (LM) using the LM Client. The LM is great at generating creative text, answering questions based on its vast training data, and reasoning.</p>
<p>But what if your program needs information that the LM wasn't trained on?</p><ul>
<li>Maybe it's very recent news (LMs often have knowledge cut-offs).</li>
<li>Maybe it's private information from your company's documents.</li>
<li>Maybe it's specific details from a large technical manual.</li>
</ul>
<p>LMs can't know <em>everything</em>. Sometimes, your program needs to <b>look things up</b> in an external knowledge source before it can generate an answer.</p>
<p>Imagine you're building a chatbot that answers questions about your company's latest product manuals. The LM itself probably hasn't read them. Your program needs a way to:</p><ol type="1">
<li>Receive the user's question (e.g., "How do I reset the Frobozz device?").</li>
<li><b>Search</b> through the product manuals for relevant sections about resetting the Frobozz.</li>
<li>Give those relevant sections to the LM as <b>context</b>.</li>
<li>Ask the LM to generate a final answer based on the user's question <em>and</em> the context it just found.</li>
</ol>
<p>This "search" step is where the <b>RM (Retrieval Model Client)</b> comes in!</p>
<p>Think of the RM as:</p>
<ul>
<li><b>A Specialized Librarian:</b> Your program asks it to find relevant information on a topic (the query).</li>
<li><b>A Search Engine Interface:</b> It connects your DSPy program to an external search system or database.</li>
<li><b>The Knowledge Fetcher:</b> It retrieves relevant text snippets (passages) to help the LM.</li>
</ul>
<p>In this chapter, you'll learn:</p>
<ul>
<li>What an RM Client does and why it's essential for knowledge-intensive tasks.</li>
<li>How to configure DSPy to use a specific Retrieval Model.</li>
<li>How DSPy modules can use the configured RM to find information.</li>
<li>A glimpse into how the RM fetches data behind the scenes.</li>
</ul>
<p>Let's give our program access to external knowledge!</p>
<h2><a class="anchor" id="autotoc_md1672"></a>
What Does the RM Client Do?</h2>
<p>The RM Client acts as a bridge between your DSPy program and an external knowledge source. Its main job is to:</p>
<ol type="1">
<li><b>Receive a Search Query:</b> Your program gives it a text query (e.g., "reset Frobozz device").</li>
<li><b>Interface with a Retrieval System:</b> It talks to the actual search engine or database. This could be:<ul>
<li>A <b>Vector Database:</b> Like Pinecone, Weaviate, Chroma, Milvus (great for searching based on meaning).</li>
<li>A <b>Specialized Retrieval API:</b> Like ColBERTv2 (a powerful neural search model), You.com Search API, or a custom company search API.</li>
<li>A <b>Local Index:</b> A search index built over your own files (e.g., using ColBERT locally).</li>
</ul>
</li>
<li><b>Fetch Relevant Passages:</b> It asks the retrieval system to find the top <code>k</code> most relevant text documents or passages based on the query.</li>
<li><b>Return the Passages:</b> It gives these retrieved passages back to your DSPy program, usually as a list of text strings or structured objects.</li>
</ol>
<p>The key goal is to provide <b>relevant context</b> that the <a class="el" href="../../d9/db7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_205__lm____language__model__client__.html">LM (Language Model Client)</a> can then use to perform its task more accurately, often within a structure called Retrieval-Augmented Generation (RAG).</p>
<h2><a class="anchor" id="autotoc_md1673"></a>
Configuring Which RM to Use</h2>
<p>Just like we configured the LM in the previous chapter, we need to tell DSPy which RM to use. This is done using <code>dspy.settings.configure</code>.</p>
<p>First, you import and create an instance of the specific RM client you want to use. DSPy has built-in clients for several common retrieval systems.</p>
<p><b>Example: Configuring ColBERTv2 (a hosted endpoint)</b></p>
<p>ColBERTv2 is a powerful retrieval model. Let's imagine there's a public server running ColBERTv2 that has indexed Wikipedia.</p>
<ol type="1">
<li><b>Import the client:</b> <code>python import dspy </code> <em>(For many RMs like ColBERTv2, Pinecone, Weaviate, the client is directly available under <code>dspy</code> or <code>dspy.retrieve</code>)</em></li>
<li><p class="startli"><b>Create an instance:</b> You need to provide the URL and port (if applicable) of the ColBERTv2 server.</p>
<p class="startli"><code>python @section autotoc_md1674 Assume a ColBERTv2 server is running at this URL indexing Wikipedia colbertv2_wiki = dspy.ColBERTv2(url='<a href="http://your-colbertv2-endpoint.com:8893'">http://your-colbertv2-endpoint.com:8893'</a>, port=None) </code> This creates an object <code>colbertv2_wiki</code> that knows how to talk to that specific ColBERTv2 server.</p>
</li>
<li><p class="startli"><b>Configure DSPy settings:</b> Tell DSPy globally that this is the RM to use.</p>
<p class="startli"><code>python dspy.settings.configure(rm=colbertv2_wiki) </code> Now, any DSPy module that needs to retrieve information will automatically use the <code>colbertv2_wiki</code> instance.</p>
</li>
</ol>
<p><b>Using Other RMs (e.g., Pinecone, Weaviate)</b></p>
<p>Configuring other RMs follows a similar pattern. You'll typically need to provide details like index names, API keys (often via environment variables), and the client object for that specific service.</p>
<div class="fragment"><div class="line"><span class="comment"># Example: Configuring Pinecone (Conceptual - requires setup)</span></div>
<div class="line"><span class="comment"># from dspy.retrieve.pinecone_rm import PineconeRM</span></div>
<div class="line"><span class="comment"># Assumes PINECONE_API_KEY and PINECONE_ENVIRONMENT are set in environment</span></div>
<div class="line"><span class="comment"># pinecone_retriever = PineconeRM(</span></div>
<div class="line"><span class="comment">#     pinecone_index_name=&#39;my-company-docs-index&#39;,</span></div>
<div class="line"><span class="comment">#     # Assuming embeddings are done via OpenAI&#39;s model</span></div>
<div class="line"><span class="comment">#     openai_embed_model=&#39;text-embedding-ada-002&#39;</span></div>
<div class="line"><span class="comment"># )</span></div>
<div class="line"><span class="comment"># dspy.settings.configure(rm=pinecone_retriever)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Example: Configuring Weaviate (Conceptual - requires setup)</span></div>
<div class="line"><span class="comment"># import weaviate</span></div>
<div class="line"><span class="comment"># from dspy.retrieve.weaviate_rm import WeaviateRM</span></div>
<div class="line"><span class="comment"># weaviate_client = weaviate.connect_to_local() # Or connect_to_wcs, etc.</span></div>
<div class="line"><span class="comment"># weaviate_retriever = WeaviateRM(</span></div>
<div class="line"><span class="comment">#     weaviate_collection_name=&#39;my_manuals&#39;,</span></div>
<div class="line"><span class="comment">#     weaviate_client=weaviate_client</span></div>
<div class="line"><span class="comment"># )</span></div>
<div class="line"><span class="comment"># dspy.settings.configure(rm=weaviate_retriever)</span></div>
</div><!-- fragment --><p> <em>(Don't worry about the specifics of connecting to Pinecone or Weaviate here; the key takeaway is the <code>dspy.settings.configure(rm=...)</code> pattern.)</em></p>
<h2><a class="anchor" id="autotoc_md1675"></a>
How Modules Use the Configured RM: <code>dspy.Retrieve</code></h2>
<p>Usually, you don't call <code>dspy.settings.rm(...)</code> directly in your main program logic. Instead, you use a DSPy module designed for retrieval. The most basic one is <code>dspy.Retrieve</code>.</p>
<p>The <code>dspy.Retrieve</code> module is a simple <a class="el" href="../../d8/d9f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_201__module______program.html">Module</a> whose job is to:</p><ol type="1">
<li>Take a query as input.</li>
<li>Call the currently configured RM (<code>dspy.settings.rm</code>).</li>
<li>Return the retrieved passages.</li>
</ol>
<p>Here's how you typically use it within a DSPy <code>Program</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> dspy</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Assume RM is already configured (e.g., colbertv2_wiki from before)</span></div>
<div class="line"><span class="comment"># dspy.settings.configure(rm=colbertv2_wiki)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>SimpleRAG(dspy.Module):</div>
<div class="line">    <span class="keyword">def </span>__init__(self, num_passages=3):</div>
<div class="line">        super().__init__()</div>
<div class="line">        <span class="comment"># Initialize the Retrieve module, asking for top 3 passages</span></div>
<div class="line">        self.retrieve = dspy.Retrieve(k=num_passages)</div>
<div class="line">        <span class="comment"># Initialize a Predict module to generate the answer</span></div>
<div class="line">        self.generate_answer = dspy.Predict(<span class="stringliteral">&#39;context, question -&gt; answer&#39;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>forward(self, question):</div>
<div class="line">        <span class="comment"># 1. Retrieve relevant context using the configured RM</span></div>
<div class="line">        context = self.retrieve(query=question).passages <span class="comment"># Note: Pass query=...</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 2. Generate the answer using the LM, providing context</span></div>
<div class="line">        prediction = self.generate_answer(context=context, question=question)</div>
<div class="line">        <span class="keywordflow">return</span> prediction</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Let&#39;s try it ---</span></div>
<div class="line"><span class="comment"># Assume LM is also configured (e.g., gpt3_turbo from Chapter 5)</span></div>
<div class="line"><span class="comment"># dspy.settings.configure(lm=gpt3_turbo)</span></div>
<div class="line"> </div>
<div class="line">rag_program = SimpleRAG()</div>
<div class="line">question = <span class="stringliteral">&quot;What is the largest rodent?&quot;</span></div>
<div class="line">result = rag_program(question=question)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Question: {question}&quot;</span>)</div>
<div class="line"><span class="comment"># The retrieve module would fetch passages about rodents...</span></div>
<div class="line"><span class="comment"># print(f&quot;Context: {context}&quot;) # (Would show passages about capybaras, etc.)</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Answer: {result.answer}&quot;</span>)</div>
</div><!-- fragment --><p><b>What's happening?</b></p>
<ol type="1">
<li><code>self.retrieve = dspy.Retrieve(k=3)</code>: Inside our <code>SimpleRAG</code> program, we create an instance of <code>dspy.Retrieve</code>. We tell it we want the top <code>k=3</code> passages.</li>
<li><code>context = self.retrieve(query=question).passages</code>: In the <code>forward</code> method, we call the <code>retrieve</code> module with the input <code>question</code> as the <code>query</code>.<ul>
<li><b>Crucially:</b> The <code>dspy.Retrieve</code> module automatically looks up <code>dspy.settings.rm</code> (our configured <code>colbertv2_wiki</code>).</li>
<li>It calls <code>colbertv2_wiki(question, k=3)</code>.</li>
<li>The RM client fetches the passages.</li>
<li><code>dspy.Retrieve</code> returns a <code>dspy.Prediction</code> object, and we access the list of passage texts using <code>.passages</code>.</li>
</ul>
</li>
<li><code>self.generate_answer(context=context, question=question)</code>: We then pass the fetched <code>context</code> (along with the original <code>question</code>) to our <code>generate_answer</code> module (a <code>dspy.Predict</code> instance), which uses the configured <a class="el" href="../../d9/db7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_205__lm____language__model__client__.html">LM</a> to produce the final answer.</li>
</ol>
<p><b>Expected Output (using a Wikipedia RM and a capable LM):</b></p>
<div class="fragment"><div class="line">Question: What is the largest rodent?</div>
<div class="line">Answer: The largest rodent is the capybara.</div>
</div><!-- fragment --><p>The <code>dspy.Retrieve</code> module handles the interaction with the configured RM seamlessly.</p>
<h2><a class="anchor" id="autotoc_md1676"></a>
Calling the RM Directly (for Testing)</h2>
<p>While <code>dspy.Retrieve</code> is the standard way, you <em>can</em> call the configured RM directly if you want to quickly test it or see what it returns.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> dspy</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Assume colbertv2_wiki is configured as the RM</span></div>
<div class="line"><span class="comment"># dspy.settings.configure(rm=colbertv2_wiki)</span></div>
<div class="line"> </div>
<div class="line">query = <span class="stringliteral">&quot;Stanford University mascot&quot;</span></div>
<div class="line">k = 2 <span class="comment"># Ask for top 2 passages</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Call the configured RM directly</span></div>
<div class="line">retrieved_passages = dspy.settings.rm(query, k=k)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Print the results</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Query: {query}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Retrieved Passages (Top {k}):&quot;</span>)</div>
<div class="line"><span class="keywordflow">for</span> i, passage <span class="keywordflow">in</span> enumerate(retrieved_passages):</div>
<div class="line">    <span class="comment"># RM clients often return dotdict objects with &#39;long_text&#39;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;--- Passage {i+1} ---&quot;</span>)</div>
<div class="line">    print(passage.long_text) <span class="comment"># Access the text content</span></div>
</div><!-- fragment --><p><b>Expected Output (might vary depending on the RM and its index):</b></p>
<div class="fragment"><div class="line">Query: Stanford University mascot</div>
<div class="line">Retrieved Passages (Top 2):</div>
<div class="line">--- Passage 1 ---</div>
<div class="line">Stanford Tree | Stanford University Athletics The Stanford Tree is the Stanford Band&#39;s mascot and the unofficial mascot of Stanford University. Stanford&#39;s team name is &quot;Cardinal&quot;, referring to the vivid red color (not the bird as at several other schools). The Tree, in various versions, has been called one of America&#39;s most bizarre and controversial college mascots. The tree costume is created anew by the Band member selected to be the Tree each year. The Tree appears at football games, basketball games, and other Stanford Athletic events. Any current student may petition to become the Tree for the following year....</div>
<div class="line">--- Passage 2 ---</div>
<div class="line">Stanford Cardinal | The Official Site of Stanford Athletics Stanford University is home to 36 varsity sports programs, 20 for women and 16 for men. Stanford participates in the NCAA&#39;s Division I (Football Bowl Subdivision subdivision for football). Stanford is a member of the Pac-12 Conference in most sports; the men&#39;s and women&#39;s water polo teams are members of the Mountain Pacific Sports Federation, the men&#39;s volleyball team is a member of the Mountain Pacific Sports Federation, the field hockey team is a member of the America East Conference, and the sailing team competes in the Pacific Coast Collegiate Sailing Conference....</div>
</div><!-- fragment --><p>This shows how you can directly interact with the RM client configured in <code>dspy.settings</code>. Notice the output is often a list of <code>dspy.dsp.utils.dotdict</code> objects, where the actual text is usually in the <code>long_text</code> attribute. <code>dspy.Retrieve</code> conveniently extracts just the text into its <code>.passages</code> list.</p>
<h2><a class="anchor" id="autotoc_md1677"></a>
How It Works Under the Hood</h2>
<p>Let's trace the journey of a query when using <code>dspy.Retrieve</code> within our <code>SimpleRAG</code> program:</p>
<ol type="1">
<li><b>Module Call:</b> The <code>SimpleRAG</code> program's <code>forward</code> method calls <code>self.retrieve(query="What is the largest rodent?")</code>.</li>
<li><b>Get RM Client:</b> The <code>dspy.Retrieve</code> module (<code>self.retrieve</code>) needs an RM. It looks up <code>dspy.settings.rm</code>. This returns the configured RM client object (e.g., our <code>colbertv2_wiki</code> instance).</li>
<li><b>RM Client Call:</b> The <code>Retrieve</code> module calls the RM client object's <code>forward</code> (or <code>__call__</code>) method, passing the query and <code>k</code> (e.g., <code>colbertv2_wiki("What is the largest rodent?", k=3)</code>).</li>
<li><b>External Interaction (Inside RM Client):</b><ul>
<li>The <code>colbertv2_wiki</code> object (an instance of <code>dspy.ColBERTv2</code>) constructs an HTTP request to the ColBERTv2 server URL (<code><a href="http://your-colbertv2-endpoint.com:8893">http://your-colbertv2-endpoint.com:8893</a></code>). The request includes the query and <code>k</code>.</li>
<li>It sends the request over the network.</li>
<li>The external ColBERTv2 server receives the request, searches its index (e.g., Wikipedia), and finds the top 3 relevant passages.</li>
<li>The server sends the passages back in the HTTP response (often as JSON).</li>
</ul>
</li>
<li><b>Parse Response (Inside RM Client):</b> The <code>colbertv2_wiki</code> client receives the response, parses the JSON, and converts the passages into a list of <code>dspy.dsp.utils.dotdict</code> objects (each containing <code>long_text</code>, potentially <code>pid</code>, <code>score</code>, etc.).</li>
<li><b>Return to Module:</b> The RM client returns this list of <code>dotdict</code> passages back to the <code>dspy.Retrieve</code> module.</li>
<li><b>Extract Text:</b> The <code>Retrieve</code> module takes the list of <code>dotdict</code> objects and extracts the <code>long_text</code> from each, creating a simple list of strings.</li>
<li><b>Return Prediction:</b> It packages this list of strings into a <code>dspy.Prediction</code> object under the <code>passages</code> key and returns it to the <code>SimpleRAG</code> program.</li>
</ol>
<p>Here's a simplified sequence diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant RAGProgram as SimpleRAG (forward)</div>
<div class="line">    participant RetrieveMod as dspy.Retrieve</div>
<div class="line">    participant Settings as dspy.settings</div>
<div class="line">    participant RMClient as RM Client (e.g., ColBERTv2)</div>
<div class="line">    participant ExtSearch as External Search (e.g., ColBERT Server)</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;RAGProgram: Call with question=&quot;...&quot;</div>
<div class="line">    RAGProgram-&gt;&gt;RetrieveMod: Call retrieve(query=question)</div>
<div class="line">    RetrieveMod-&gt;&gt;Settings: Get configured rm</div>
<div class="line">    Settings--&gt;&gt;RetrieveMod: Return RMClient instance</div>
<div class="line">    RetrieveMod-&gt;&gt;RMClient: __call__(query, k=3)</div>
<div class="line">    RMClient-&gt;&gt;ExtSearch: Send Search Request (query, k)</div>
<div class="line">    ExtSearch--&gt;&gt;RMClient: Return Found Passages</div>
<div class="line">    RMClient-&gt;&gt;RMClient: Parse Response into dotdicts</div>
<div class="line">    RMClient--&gt;&gt;RetrieveMod: Return list[dotdict]</div>
<div class="line">    RetrieveMod-&gt;&gt;RetrieveMod: Extract &#39;long_text&#39; into list[str]</div>
<div class="line">    RetrieveMod--&gt;&gt;RAGProgram: Return Prediction(passages=list[str])</div>
<div class="line">    RAGProgram-&gt;&gt;RAGProgram: Use context for LM call...</div>
<div class="line">    RAGProgram--&gt;&gt;User: Return final answer</div>
</div><!-- fragment --><p><b>Relevant Code Files:</b></p>
<ul>
<li><code>dspy/retrieve/retrieve.py</code>: Defines the <code>dspy.Retrieve</code> module. Its <code>forward</code> method gets the query, retrieves the RM from <code>dspy.settings</code>, calls the RM, and processes the results into a <code>Prediction</code>.</li>
<li><code>dspy/dsp/colbertv2.py</code>: Defines the <code>dspy.ColBERTv2</code> client. Its <code>__call__</code> method makes HTTP requests (<code>requests.get</code> or <code>requests.post</code>) to a ColBERTv2 endpoint and parses the JSON response. (Other clients like <code>dspy/retrieve/pinecone_rm.py</code> or <code>dspy/retrieve/weaviate_rm.py</code> contain logic specific to those services).</li>
<li><code>dspy/dsp/utils/settings.py</code>: Where the configured <code>rm</code> instance is stored and accessed globally (as seen in <a class="el" href="../../d9/db7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_205__lm____language__model__client__.html">Chapter 5: LM (Language Model Client)</a>).</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># Simplified view from dspy/retrieve/retrieve.py</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> dspy</div>
<div class="line"><span class="keyword">from</span> dspy.primitives.prediction <span class="keyword">import</span> Prediction</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Retrieve(dspy.Module):</div>
<div class="line">    <span class="keyword">def </span>__init__(self, k=3):</div>
<div class="line">        super().__init__()</div>
<div class="line">        self.k = k</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>forward(self, query: str, k: Optional[int] = <span class="keywordtype">None</span>) -&gt; Prediction:</div>
<div class="line">        <span class="comment"># Determine how many passages to retrieve</span></div>
<div class="line">        k = k <span class="keywordflow">if</span> k <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span> <span class="keywordflow">else</span> self.k</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Get the configured RM client from global settings</span></div>
<div class="line">        rm_client = dspy.settings.rm</div>
<div class="line">        <span class="keywordflow">if</span> <span class="keywordflow">not</span> rm_client:</div>
<div class="line">            <span class="keywordflow">raise</span> AssertionError(<span class="stringliteral">&quot;No RM is loaded. Configure with dspy.settings.configure(rm=...).&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Call the RM client instance</span></div>
<div class="line">        <span class="comment"># The RM client handles communication with the actual search system</span></div>
<div class="line">        passages_or_dotdicts = rm_client(query, k=k) <span class="comment"># e.g., calls colbertv2_wiki(query, k=k)</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Ensure output is iterable and extract text</span></div>
<div class="line">        <span class="comment"># (Simplified - handles different return types from RMs)</span></div>
<div class="line">        <span class="keywordflow">if</span> isinstance(passages_or_dotdicts, list) <span class="keywordflow">and</span> hasattr(passages_or_dotdicts[0], <span class="stringliteral">&#39;long_text&#39;</span>):</div>
<div class="line">            passages = [psg.long_text <span class="keywordflow">for</span> psg <span class="keywordflow">in</span> passages_or_dotdicts]</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">             <span class="comment"># Assume it&#39;s already a list of strings or handle other cases</span></div>
<div class="line">             passages = list(passages_or_dotdicts)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Return passages wrapped in a Prediction object</span></div>
<div class="line">        <span class="keywordflow">return</span> Prediction(passages=passages)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Simplified view from dspy/dsp/colbertv2.py</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> requests</div>
<div class="line"><span class="keyword">from</span> dspy.dsp.utils <span class="keyword">import</span> dotdict</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ColBERTv2:</div>
<div class="line">    <span class="keyword">def </span>__init__(self, url: str, port: Optional[int] = <span class="keywordtype">None</span>, **kwargs):</div>
<div class="line">        self.url = f<span class="stringliteral">&quot;{url}:{port}&quot;</span> <span class="keywordflow">if</span> port <span class="keywordflow">else</span> url</div>
<div class="line">        <span class="comment"># ... other init ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__call__(self, query: str, k: int = 10, **kwargs) -&gt; list[dotdict]:</div>
<div class="line">        <span class="comment"># Construct the payload for the API request</span></div>
<div class="line">        payload = {<span class="stringliteral">&quot;query&quot;</span>: query, <span class="stringliteral">&quot;k&quot;</span>: k}</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="comment"># Make the HTTP GET request to the ColBERTv2 server</span></div>
<div class="line">            res = requests.get(self.url, params=payload, timeout=10)</div>
<div class="line">            res.raise_for_status() <span class="comment"># Raise an exception for bad status codes</span></div>
<div class="line"> </div>
<div class="line">            <span class="comment"># Parse the JSON response</span></div>
<div class="line">            json_response = res.json()</div>
<div class="line">            topk = json_response.get(<span class="stringliteral">&quot;topk&quot;</span>, [])[:k]</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># Convert results into dotdict objects for consistency</span></div>
<div class="line">            passages = [dotdict({**d, <span class="stringliteral">&quot;long_text&quot;</span>: d.get(<span class="stringliteral">&quot;text&quot;</span>, <span class="stringliteral">&quot;&quot;</span>)}) <span class="keywordflow">for</span> d <span class="keywordflow">in</span> topk]</div>
<div class="line">            <span class="keywordflow">return</span> passages</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">except</span> requests.exceptions.RequestException <span class="keyword">as</span> e:</div>
<div class="line">            print(f<span class="stringliteral">&quot;Error calling ColBERTv2 server: {e}&quot;</span>)</div>
<div class="line">            <span class="keywordflow">return</span> [] <span class="comment"># Return empty list on error</span></div>
</div><!-- fragment --><p>The key idea is abstraction: <code>dspy.Retrieve</code> uses whatever RM is configured in <code>dspy.settings</code>, and the specific RM client hides the details of talking to its particular backend search system.</p>
<h2><a class="anchor" id="autotoc_md1678"></a>
Conclusion</h2>
<p>You've now met the <b>RM (Retrieval Model Client)</b>, your DSPy program's connection to external knowledge sources!</p>
<ul>
<li>An RM acts like a <b>librarian</b> or <b>search engine interface</b>.</li>
<li>It takes a <b>query</b> and fetches <b>relevant text passages</b> from systems like vector databases (Pinecone, Weaviate) or APIs (ColBERTv2).</li>
<li>It provides crucial <b>context</b> for LMs, enabling tasks like answering questions about recent events or private documents (Retrieval-Augmented Generation - RAG).</li>
<li>You configure it globally using <code>dspy.settings.configure(rm=...)</code>.</li>
<li>The <code>dspy.Retrieve</code> module is the standard way to use the configured RM within your programs.</li>
</ul>
<p>With LMs providing reasoning and RMs providing knowledge, we can build powerful DSPy programs. But how do we know if our program is actually working well? How do we measure its performance? That's where evaluation comes in!</p>
<p><b>Next:</b> <a class="el" href="../../d5/daa/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2DSPy_207__evaluate.html">Chapter 7: Evaluate</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
