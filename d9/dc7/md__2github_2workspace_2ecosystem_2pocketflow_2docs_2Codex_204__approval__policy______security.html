#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_approval_policy___security</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_approval_policy___security</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1309"></a>
autotoc_md1309</h2>
<p>layout: default title: "Approval Policy &amp; Security" parent: "Codex" </p>
<h2><a class="anchor" id="autotoc_md1310"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md1311"></a>
Chapter 4: Approval Policy &amp; Security</h1>
<p>In the <a class="el" href="../../d0/dbd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_203__agent__loop.html">previous chapter</a>, we saw how the <b>Agent Loop</b> acts like Codex's brain, talking to the AI and figuring out what steps to take. Sometimes, the AI might suggest actions that could change things on your computer, like modifying a file or running a command in your terminal (e.g., <code>git commit</code>, <code>npm install</code>, or even <code>rm important_file.txt</code>!).</p>
<p>This sounds powerful, but also a little scary, right? What if the AI misunderstands and suggests deleting the wrong file? We need a way to control how much power Codex has.</p>
<p>That's exactly what the <b>Approval Policy &amp; Security</b> system does. It's like a security guard standing between the AI's suggestions and your actual computer.</p>
<h2><a class="anchor" id="autotoc_md1312"></a>
What's the Big Idea? The Security Guard</h2>
<p>Imagine you're visiting a secure building. Depending on your pass, you have different levels of access:</p>
<ul>
<li><b>Guest Pass (<code>suggest</code> mode):</b> You can look around (read files), but if you want to open a door (modify a file) or use special equipment (run a command), you need to ask the guard for permission every single time.</li>
<li><b>Employee Badge (<code>auto-edit</code> mode):</b> You can open regular office doors (modify files in the project) without asking each time, but you still need permission for restricted areas like the server room (running commands).</li>
<li><b>Full Access Badge (<code>full-auto</code> mode):</b> You can go almost anywhere (modify files, run commands), but for potentially sensitive actions (like running commands), the guard might escort you to a special monitored room (a "sandbox") to ensure safety.</li>
</ul>
<p>The Approval Policy in Codex works just like these passes. It lets <em>you</em> choose how much autonomy Codex has when it suggests potentially risky actions.</p>
<h2><a class="anchor" id="autotoc_md1313"></a>
Key Concepts: The Approval Modes</h2>
<p>Codex offers different levels of autonomy, which you can usually set with a command-line flag like <code>--approval-mode</code> or when you first configure it. These are the main modes:</p>
<ol type="1">
<li><b><code>suggest</code> (Default):</b><ul>
<li><b>What it is:</b> The most cautious mode. Like the Guest Pass.</li>
<li><b>What it does:</b> Codex can read files to understand your project, but before it <em>modifies</em> any file or <em>runs</em> any command, it will always stop and ask for your explicit permission through the <a class="el" href="../../dd/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_201__terminal__ui____ink__components__.html">Terminal UI</a>.</li>
<li><b>Use when:</b> You want maximum control and want to review every single change or command.</li>
</ul>
</li>
<li><b><code>auto-edit</code>:</b><ul>
<li><b>What it is:</b> Allows automatic file edits, but still requires approval for commands. Like the Employee Badge.</li>
<li><b>What it does:</b> Codex can automatically apply changes (patches) to files within your project directory. However, if it wants to run a shell command (like <code>npm install</code>, <code>git commit</code>, <code>python script.py</code>), it will still stop and ask for your permission.</li>
<li><b>Use when:</b> You trust the AI to make code changes but still want to manually approve any commands it tries to run.</li>
</ul>
</li>
<li><b><code>full-auto</code>:</b><ul>
<li><b>What it is:</b> The most autonomous mode, allowing file edits and command execution, but with safeguards. Like the Full Access Badge with escort.</li>
<li><b>What it does:</b> Codex can automatically apply file changes <em>and</em> run shell commands without asking you first. Crucially, to prevent accidental damage, commands run in this mode are typically executed inside a <b>sandbox</b> â€“ a restricted environment that limits what the command can do (e.g., blocking network access, limiting file access to the project directory). We'll learn more about this in the <a class="el" href="../../dd/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_206__command__execution______sandboxing.html">Command Execution &amp; Sandboxing</a> chapter.</li>
<li><b>Use when:</b> You want Codex to work as independently as possible, understanding that potentially risky commands are run with safety restrictions.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md1314"></a>
How it Works in Practice</h2>
<p>When the <a class="el" href="../../d0/dbd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_203__agent__loop.html">Agent Loop</a> receives a suggestion from the AI to perform an action (like applying a patch or running a shell command), it doesn't just blindly execute it. Instead, it checks the current Approval Policy you've set.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant AgentLoop as Agent Loop</div>
<div class="line">    participant ApprovalCheck as Approval Policy Check</div>
<div class="line">    participant UserUI as Terminal UI</div>
<div class="line">    participant CmdExec as Command Execution</div>
<div class="line"> </div>
<div class="line">    AgentLoop-&gt;&gt;AgentLoop: AI suggests action (e.g., run `npm install`)</div>
<div class="line">    AgentLoop-&gt;&gt;ApprovalCheck: Check action against policy (`auto-edit`)</div>
<div class="line">    ApprovalCheck-&gt;&gt;ApprovalCheck: Action is `npm install` (command)</div>
<div class="line">    ApprovalCheck-&gt;&gt;ApprovalCheck: Policy is `auto-edit` (commands need approval)</div>
<div class="line">    ApprovalCheck--&gt;&gt;AgentLoop: Decision: `ask-user`</div>
<div class="line">    AgentLoop-&gt;&gt;UserUI: Request confirmation for `npm install`</div>
<div class="line">    UserUI-&gt;&gt;UserUI: Display &quot;Allow command `npm install`? [Y/n]&quot;</div>
<div class="line">    UserUI--&gt;&gt;AgentLoop: User response (e.g., Yes)</div>
<div class="line">    AgentLoop-&gt;&gt;CmdExec: Execute `npm install`</div>
</div><!-- fragment --><ol type="1">
<li><b>Suggestion:</b> The AI tells the Agent Loop it wants to run <code>npm install</code>.</li>
<li><b>Check Policy:</b> The Agent Loop asks the Approval Policy system: "The AI wants to run `npm install`. The user set the policy to `auto-edit`. Is this okay?"</li>
<li><b>Decision:</b> The Approval Policy system checks its rules:<ul>
<li>The action is a shell command.</li>
<li>The policy is <code>auto-edit</code>.</li>
<li>Rule: In <code>auto-edit</code> mode, shell commands require user approval.</li>
<li>Result: The decision is <code>ask-user</code>.</li>
</ul>
</li>
<li><b>Ask User:</b> The Agent Loop receives the <code>ask-user</code> decision and uses the <code>getCommandConfirmation</code> callback (provided by the <a class="el" href="../../dd/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_201__terminal__ui____ink__components__.html">Terminal UI</a>) to display the prompt to you.</li>
<li><b>User Response:</b> You see the prompt and respond (e.g., 'Yes').</li>
<li><b>Execute (if approved):</b> The Agent Loop receives your 'Yes' and proceeds to execute the command, potentially using the <a class="el" href="../../dd/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_206__command__execution______sandboxing.html">Command Execution &amp; Sandboxing</a> system.</li>
</ol>
<p>If the policy had been <code>full-auto</code>, the decision in Step 3 might have been <code>auto-approve</code> (with <code>runInSandbox: true</code>), and the Agent Loop would have skipped asking you (Steps 4 &amp; 5) and gone straight to execution (Step 6), but inside the sandbox.</p>
<p>If the action was applying a file patch and the policy was <code>auto-edit</code> or <code>full-auto</code>, the decision might also be <code>auto-approve</code> (checking if the file path is allowed), skipping the user prompt.</p>
<h2><a class="anchor" id="autotoc_md1315"></a>
Under the Hood: The <code>approvals.ts</code> Logic</h2>
<p>The core logic for making these decisions lives in <code>codex-cli/src/approvals.ts</code>. A key function here is <code>canAutoApprove</code>.</p>
<div class="fragment"><div class="line">// File: codex-cli/src/approvals.ts (Simplified)</div>
<div class="line"> </div>
<div class="line">// Represents the different approval modes</div>
<div class="line">export type ApprovalPolicy = &quot;suggest&quot; | &quot;auto-edit&quot; | &quot;full-auto&quot;;</div>
<div class="line"> </div>
<div class="line">// Represents the outcome of the safety check</div>
<div class="line">export type SafetyAssessment =</div>
<div class="line">  | { type: &quot;auto-approve&quot;; runInSandbox: boolean; reason: string; /*...*/ }</div>
<div class="line">  | { type: &quot;ask-user&quot;; applyPatch?: ApplyPatchCommand }</div>
<div class="line">  | { type: &quot;reject&quot;; reason: string };</div>
<div class="line"> </div>
<div class="line">// Input for apply_patch commands</div>
<div class="line">export type ApplyPatchCommand = { patch: string; };</div>
<div class="line"> </div>
<div class="line">/**</div>
<div class="line"> * Checks if a command can be run automatically based on the policy.</div>
<div class="line"> */</div>
<div class="line">export function canAutoApprove(</div>
<div class="line">  command: ReadonlyArray&lt;string&gt;, // e.g., [&quot;git&quot;, &quot;status&quot;] or [&quot;apply_patch&quot;, &quot;...&quot;]</div>
<div class="line">  policy: ApprovalPolicy,</div>
<div class="line">  writableRoots: ReadonlyArray&lt;string&gt;, // Allowed directories for edits</div>
<div class="line">  // ... env ...</div>
<div class="line">): SafetyAssessment {</div>
<div class="line">  // --- Special case: apply_patch ---</div>
<div class="line">  if (command[0] === &quot;apply_patch&quot;) {</div>
<div class="line">    // Check if policy allows auto-editing and if patch only affects allowed files</div>
<div class="line">    const applyPatchArg = command[1] as string;</div>
<div class="line">    const patchDetails = { patch: applyPatchArg };</div>
<div class="line"> </div>
<div class="line">    if (policy === &quot;suggest&quot;) return { type: &quot;ask-user&quot;, applyPatch: patchDetails };</div>
<div class="line"> </div>
<div class="line">    if (isWritePatchConstrainedToWritablePaths(applyPatchArg, writableRoots)) {</div>
<div class="line">       return { type: &quot;auto-approve&quot;, runInSandbox: false, reason: &quot;Patch affects allowed files&quot;, /*...*/ };</div>
<div class="line">    }</div>
<div class="line">    // If policy is auto-edit but patch affects disallowed files, ask user.</div>
<div class="line">    // If policy is full-auto, still approve but mark for sandbox if paths are weird.</div>
<div class="line">    return policy === &quot;full-auto&quot; ?</div>
<div class="line">      { type: &quot;auto-approve&quot;, runInSandbox: true, reason: &quot;Full auto mode&quot;, /*...*/ } :</div>
<div class="line">      { type: &quot;ask-user&quot;, applyPatch: patchDetails };</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // --- Check for known safe, read-only commands ---</div>
<div class="line">  const knownSafe = isSafeCommand(command); // Checks things like &quot;ls&quot;, &quot;pwd&quot;, &quot;git status&quot;</div>
<div class="line">  if (knownSafe != null) {</div>
<div class="line">    return { type: &quot;auto-approve&quot;, runInSandbox: false, reason: knownSafe.reason, /*...*/ };</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // --- Handle shell commands (like &quot;bash -lc &#39;npm install&#39;&quot;) ---</div>
<div class="line">  // (Simplified: assumes any other command needs policy check)</div>
<div class="line"> </div>
<div class="line">  // --- Default: Check policy for general commands ---</div>
<div class="line">  if (policy === &quot;full-auto&quot;) {</div>
<div class="line">    return { type: &quot;auto-approve&quot;, runInSandbox: true, reason: &quot;Full auto mode&quot;, /*...*/ };</div>
<div class="line">  } else {</div>
<div class="line">    // &#39;suggest&#39; and &#39;auto-edit&#39; require asking for commands</div>
<div class="line">    return { type: &quot;ask-user&quot; };</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Helper to check if a command is known to be safe (read-only)</div>
<div class="line">function isSafeCommand(command: ReadonlyArray&lt;string&gt;): { reason: string, group: string } | null {</div>
<div class="line">  const cmd = command[0];</div>
<div class="line">  if ([&quot;ls&quot;, &quot;pwd&quot;, &quot;cat&quot;, &quot;git status&quot;, &quot;git diff&quot;, /*...*/].includes(cmd)) {</div>
<div class="line">     return { reason: `Safe read-only command: ${cmd}`, group: &quot;Reading&quot; };</div>
<div class="line">  }</div>
<div class="line">  return null;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Helper (simplified) to check if patch affects allowed paths</div>
<div class="line">function isWritePatchConstrainedToWritablePaths(</div>
<div class="line">  patch: string,</div>
<div class="line">  writableRoots: ReadonlyArray&lt;string&gt;</div>
<div class="line">): boolean {</div>
<div class="line">  // ... logic to parse patch and check affected file paths ...</div>
<div class="line">  // ... return true if all paths are within writableRoots ...</div>
<div class="line">  return true; // Simplified for example</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Inputs:</b> <code>canAutoApprove</code> takes the command the AI wants to run (as an array of strings, like <code>["npm", "install"]</code>), the current <code>ApprovalPolicy</code> (<code>suggest</code>, <code>auto-edit</code>, or <code>full-auto</code>), and a list of directories where file edits are allowed (<code>writableRoots</code>, usually just your project's main folder).</li>
<li><b>Checks:</b> It first handles special cases like <code>apply_patch</code> (checking the policy and file paths) and known safe, read-only commands using <code>isSafeCommand</code>.</li>
<li><b>Policy Decision:</b> For other commands, it primarily relies on the policy:<ul>
<li>If <code>full-auto</code>, it returns <code>auto-approve</code> but sets <code>runInSandbox</code> to <code>true</code>.</li>
<li>If <code>suggest</code> or <code>auto-edit</code>, it returns <code>ask-user</code>.</li>
</ul>
</li>
<li><b>Output:</b> It returns a <code>SafetyAssessment</code> object telling the <a class="el" href="../../d0/dbd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_203__agent__loop.html">Agent Loop</a> what to do: <code>auto-approve</code> (and whether sandboxing is needed), <code>ask-user</code>, or in rare cases, <code>reject</code> (if the command is fundamentally invalid).</li>
</ul>
<p>This decision is then used back in the Agent Loop, often within a function like <code>handleExecCommand</code> (in <code>handle-exec-command.ts</code>), which we touched on in the previous chapter.</p>
<div class="fragment"><div class="line">// File: codex-cli/src/utils/agent/handle-exec-command.ts (Simplified snippet)</div>
<div class="line"> </div>
<div class="line">import { canAutoApprove } from &quot;../../approvals.js&quot;;</div>
<div class="line">import { ReviewDecision } from &quot;./review.js&quot;;</div>
<div class="line">// ... other imports ...</div>
<div class="line"> </div>
<div class="line">export async function handleExecCommand(</div>
<div class="line">  args: ExecInput, // Contains the command array `cmd`</div>
<div class="line">  config: AppConfig,</div>
<div class="line">  policy: ApprovalPolicy,</div>
<div class="line">  getCommandConfirmation: (/*...*/) =&gt; Promise&lt;CommandConfirmation&gt;, // UI callback</div>
<div class="line">  // ... abortSignal ...</div>
<div class="line">): Promise&lt;HandleExecCommandResult&gt; {</div>
<div class="line"> </div>
<div class="line">  // *** Check the approval policy first! ***</div>
<div class="line">  const safety = canAutoApprove(args.cmd, policy, [process.cwd()]);</div>
<div class="line"> </div>
<div class="line">  let runInSandbox: boolean;</div>
<div class="line">  switch (safety.type) {</div>
<div class="line">    case &quot;ask-user&quot;: {</div>
<div class="line">      // Policy requires asking the user</div>
<div class="line">      const { review: decision } = await getCommandConfirmation(args.cmd, safety.applyPatch);</div>
<div class="line">      if (decision !== ReviewDecision.YES &amp;&amp; decision !== ReviewDecision.ALWAYS) {</div>
<div class="line">        // User said No or provided feedback to stop</div>
<div class="line">        return { outputText: &quot;aborted&quot;, metadata: { /*...*/ } };</div>
<div class="line">      }</div>
<div class="line">      // User approved! Proceed without sandbox (unless policy changes later).</div>
<div class="line">      runInSandbox = false;</div>
<div class="line">      break;</div>
<div class="line">    }</div>
<div class="line">    case &quot;auto-approve&quot;: {</div>
<div class="line">      // Policy allows auto-approval</div>
<div class="line">      runInSandbox = safety.runInSandbox; // Respect sandbox flag from canAutoApprove</div>
<div class="line">      break;</div>
<div class="line">    }</div>
<div class="line">    case &quot;reject&quot;: {</div>
<div class="line">      // Policy outright rejected the command</div>
<div class="line">      return { outputText: &quot;aborted&quot;, metadata: { reason: safety.reason } };</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // *** If approved (either automatically or by user), execute the command ***</div>
<div class="line">  const summary = await execCommand(args, safety.applyPatch, runInSandbox, /*...*/);</div>
<div class="line">  // ... handle results ...</div>
<div class="line">  return convertSummaryToResult(summary);</div>
<div class="line">}</div>
</div><!-- fragment --><p>This shows how <code>canAutoApprove</code> is called first. If it returns <code>ask-user</code>, the <code>getCommandConfirmation</code> callback (which triggers the UI prompt) is invoked. Only if the assessment is <code>auto-approve</code> or the user explicitly approves does the code proceed to actually execute the command using <code>execCommand</code>, passing the <code>runInSandbox</code> flag determined by the policy check.</p>
<h2><a class="anchor" id="autotoc_md1316"></a>
Conclusion</h2>
<p>The Approval Policy &amp; Security system is Codex's safety net. It puts you in control, letting you choose the balance between letting the AI work autonomously and requiring manual confirmation for actions that could affect your system. By understanding the <code>suggest</code>, <code>auto-edit</code>, and <code>full-auto</code> modes, you can configure Codex to operate in a way that matches your comfort level with automation and risk. This system works hand-in-hand with the <a class="el" href="../../d0/dbd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_203__agent__loop.html">Agent Loop</a> to intercept potentially risky actions and enforce the rules you've set, sometimes using sandboxing (as we'll see later) for an extra layer of protection.</p>
<p>Now that we know how Codex decides <em>whether</em> to perform an action, how does it actually understand the AI's response, especially when the AI wants to use a tool like running a command or applying a patch?</p>
<p>Next up: <a class="el" href="../../dc/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_205__response______tool__call__handling.html">Response &amp; Tool Call Handling</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
