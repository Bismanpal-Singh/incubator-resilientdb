#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_context_globals___current_app____request____session____g__</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/d15/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_205__context__globals______current__a0f66e55a619b85550f70ee0df6dbdc86.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_context_globals___current_app____request____session____g__</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1907"></a>
autotoc_md1907</h2>
<p>layout: default title: "Context Globals" parent: "Flask" </p>
<h2><a class="anchor" id="autotoc_md1908"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md1909"></a>
Chapter 5: Context Globals (<code>current_app</code>, <code>request</code>, <code>session</code>, <code>g</code>)</h1>
<p>Welcome back! In <a class="el" href="../../d1/d39/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_204__templating____jinja2__integration__.html">Chapter 4: Templating (Jinja2 Integration)</a>, we learned how to separate our HTML structure from our Python code using templates and the <code>render_template</code> function. We saw how variables like <code>request</code> and functions like <code>url_for</code> seemed to be magically available in our templates.</p>
<p>But how does that work? And more importantly, how can we easily access important information like the current application instance or the details of the incoming web request <em>inside</em> our Python view functions without passing these objects around manually to every single function? Imagine having to add <code>app</code> and <code>request</code> as arguments to all your helper functions – it would be very repetitive!</p>
<p>This chapter introduces Flask's solution: <b>Context Globals</b>.</p>
<h2><a class="anchor" id="autotoc_md1910"></a>
What Problem Do They Solve? Avoiding Tedious Parameter Passing</h2>
<p>Think about working on a team project. There are certain tools or pieces of information everyone on the team needs access to frequently: the project plan, the shared calendar, the main contact person. It would be inefficient if every time someone needed the project plan, they had to specifically ask someone else to pass it to them. Instead, you might have a central place or a well-known name (like "The Plan") that everyone knows how to find.</p>
<p>Similarly, in a Flask application, several objects are very commonly needed while handling a web request:</p>
<ul>
<li>The application instance itself (to access configuration, loggers, etc.).</li>
<li>The incoming request object (to get form data, query parameters, headers, etc.).</li>
<li>A way to store temporary information related to the current user across multiple requests (the session).</li>
<li>A temporary storage space just for the <em>current</em> request.</li>
</ul>
<p>Passing these objects explicitly as parameters to every function that might need them (especially view functions, <code>before_request</code> functions, <code>after_request</code> functions, template context processors) would make our code cluttered and harder to manage.</p>
<p>Flask provides special "global" variables – <b><code>current_app</code></b>, <b><code>request</code></b>, <b><code>session</code></b>, and <b><code>g</code></b> – that act like smart pointers. They automatically find and give you access to the <em>correct</em> object relevant to the specific request you are currently handling, without you needing to pass anything around. They feel like magic variables!</p>
<h2><a class="anchor" id="autotoc_md1911"></a>
Meet the Context Globals</h2>
<p>These special variables are technically called <b>proxies</b>. Think of a proxy as a stand-in or an agent. When you talk to the <code>request</code> proxy, it secretly finds the <em>actual</em> request object for the HTTP request that is currently being processed and acts on its behalf. This magic happens using Flask's "context" system, which we'll touch on later and explore more in <a class="el" href="../../d6/da8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_207__application__and__request__contexts.html">Chapter 7</a>.</p>
<p>Let's meet the main context globals:</p>
<ol type="1">
<li><b><code>request</code></b>: Represents the incoming HTTP request from the client (browser). It contains all the data the client sent, like form data, URL parameters, HTTP headers, the requested URL, etc. We already used this in <a class="el" href="../../d5/d48/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_203__request__and__response__objects.html">Chapter 3: Request and Response Objects</a>.</li>
<li><b><code>session</code></b>: A dictionary-like object that lets you store information specific to a user <em>across multiple requests</em>. It's commonly used for things like remembering if a user is logged in, or storing items in a shopping cart. Flask typically uses secure cookies to handle this.</li>
<li><b><code>current_app</code></b>: Represents the <em>instance</em> of your Flask application that is handling the current request. This is useful for accessing application-wide configurations, resources, or extensions. It points to the same object you created with <code>app = Flask(__name__)</code> in <a class="el" href="../../df/d69/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_201__application__object______flask____.html">Chapter 1</a>, but you can access it from anywhere <em>during</em> a request without needing the <code>app</code> variable directly.</li>
<li><b><code>g</code></b>: A simple namespace object (think of it like an empty box or scratchpad) that is available only for the duration of the <em>current request</em>. You can use it to store temporary data that multiple functions within the same request cycle might need access to, without passing it around. For example, you might store the current logged-in user object or a database connection here. It gets reset for every new request. The 'g' stands for "global", but it's global <em>only within the request context</em>.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1912"></a>
Using the Context Globals</h2>
<p>First, you usually need to import them from the <code>flask</code> package:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, request, session, current_app, g, render_template</div>
<div class="line"><span class="keyword">import</span> os <span class="comment"># For generating a secret key</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the application object</span></div>
<div class="line">app = Flask(__name__)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># !! IMPORTANT !! Sessions require a secret key for security.</span></div>
<div class="line"><span class="comment"># In a real app, set this from an environment variable or config file!</span></div>
<div class="line"><span class="comment"># Never hardcode it like this in production.</span></div>
<div class="line">app.config[<span class="stringliteral">&#39;SECRET_KEY&#39;</span>] = os.urandom(24)</div>
<div class="line"><span class="comment"># We&#39;ll learn more about config in Chapter 6: Configuration (Config)</span></div>
</div><!-- fragment --><p>Now let's see how to use them.</p>
<h3><a class="anchor" id="autotoc_md1913"></a>
<code>request</code>: Accessing Incoming Data</h3>
<p>We saw this in Chapter 3. Notice how the <code>index</code> function can use <code>request</code> directly without it being passed as an argument.</p>
<div class="fragment"><div class="line"><span class="comment"># hello.py (continued)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.route(&#39;/&#39;)</span></div>
<div class="line"><span class="keyword">def </span>index():</div>
<div class="line">  user_agent = request.headers.get(<span class="stringliteral">&#39;User-Agent&#39;</span>, <span class="stringliteral">&#39;Unknown&#39;</span>)</div>
<div class="line">  method = request.method</div>
<div class="line">  <span class="keywordflow">return</span> f<span class="stringliteral">&#39;Welcome! Method: {method}, Browser: {user_agent}&#39;</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>request.headers.get(...)</code>: Accesses the HTTP headers from the incoming request.</li>
<li><code>request.method</code>: Gets the HTTP method used (e.g., 'GET', 'POST').</li>
</ul>
<p>Flask automatically makes the correct <code>request</code> object available here when the <code>/</code> route is visited.</p>
<h3><a class="anchor" id="autotoc_md1914"></a>
<code>current_app</code>: Accessing Application Settings</h3>
<p>Imagine you want to log something using the application's logger or access a configuration value.</p>
<div class="fragment"><div class="line"><span class="comment"># hello.py (continued)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Add another config value for demonstration</span></div>
<div class="line">app.config[<span class="stringliteral">&#39;MY_SETTING&#39;</span>] = <span class="stringliteral">&#39;Flask is Cool&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.route(&#39;/app-info&#39;)</span></div>
<div class="line"><span class="keyword">def </span>app_info():</div>
<div class="line">  <span class="comment"># Access the application&#39;s logger</span></div>
<div class="line">  current_app.logger.info(<span class="stringliteral">&#39;Someone accessed the app-info page.&#39;</span>)</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># Access a configuration value</span></div>
<div class="line">  setting = current_app.config.get(<span class="stringliteral">&#39;MY_SETTING&#39;</span>, <span class="stringliteral">&#39;Default Value&#39;</span>)</div>
<div class="line">  debug_mode = current_app.config[<span class="stringliteral">&#39;DEBUG&#39;</span>] <span class="comment"># Accessing debug status</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> f<span class="stringliteral">&#39;My Setting: {setting}&lt;br&gt;Debug Mode: {debug_mode}&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Make sure debug is enabled for the logger example to show easily</span></div>
<div class="line"><span class="comment"># if __name__ == &#39;__main__&#39;:</span></div>
<div class="line"><span class="comment">#   app.run(debug=True)</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>current_app.logger.info(...)</code>: Uses the logger configured on the <code>app</code> object.</li>
<li><code>current_app.config.get(...)</code>: Accesses the application's configuration dictionary.</li>
</ul>
<p>Again, <code>app_info</code> doesn't need <code>app</code> passed in; <code>current_app</code> provides access to it within the request context.</p>
<h3><a class="anchor" id="autotoc_md1915"></a>
<code>session</code>: Remembering Things Across Requests</h3>
<p>Sessions allow you to store data associated with a specific user's browser session. Flask uses a secret key (<code>app.secret_key</code> or &lsquo;app.config['SECRET_KEY&rsquo;]`) to cryptographically sign the session cookie, preventing users from modifying it. <b>Always set a strong, random secret key!</b></p>
<p>Let's create a simple view counter that increments each time the <em>same</em> user visits the page.</p>
<div class="fragment"><div class="line"><span class="comment"># hello.py (continued)</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.route(&#39;/counter&#39;)</span></div>
<div class="line"><span class="keyword">def </span>counter():</div>
<div class="line">  <span class="comment"># Get the current count from the session, default to 0 if not found</span></div>
<div class="line">  count = session.get(<span class="stringliteral">&#39;view_count&#39;</span>, 0)</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># Increment the count</span></div>
<div class="line">  count += 1</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># Store the new count back in the session</span></div>
<div class="line">  session[<span class="stringliteral">&#39;view_count&#39;</span>] = count</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># Log the session content (for demonstration)</span></div>
<div class="line">  current_app.logger.info(f<span class="stringliteral">&quot;Session data: {session}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> f<span class="stringliteral">&#39;You have visited this page {count} times during this session.&#39;</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>&lsquo;session.get('view_count&rsquo;, 0)<code>: Reads the</code>view_count<code>value from the session. If it's the first visit, it doesn't exist yet, so we default to</code>0<code>. *</code>session['view_count'] = count`: Stores the updated count back into the session.</li>
<li>Flask handles sending the updated session data back to the browser in a secure cookie behind the scenes.</li>
</ul>
<p><b>Running this:</b></p>
<ol type="1">
<li>Make sure &lsquo;app.config['SECRET_KEY&rsquo;]<code>is set in your</code>hello.py<code>.</code></li>
<li><code> Run</code>python hello.py<code>.</code></li>
<li><code> Visit</code><a href="http://127.0.0.1:5000/counter">http://127.0.0.1:5000/counter</a>`. You'll see "You have visited this page 1 times...".</li>
<li>Refresh the page. You'll see "You have visited this page 2 times...".</li>
<li>Refresh again. It will become 3, and so on.</li>
<li>If you close your browser completely and reopen it (or use a private/incognito window), the count will reset to 1 because the session cookie is typically cleared or different.</li>
</ol>
<h3><a class="anchor" id="autotoc_md1916"></a>
<code>g</code>: Temporary Storage for a Single Request</h3>
<p>The <code>g</code> object is useful for storing data that needs to be accessed by multiple functions <em>within the same request cycle</em>. A common example is loading the current user's information from a database or verifying an API key. You might do this in a <code>@app.before_request</code> function and then access the result in your view function using <code>g</code>.</p>
<p>Let's simulate loading some data before the request and accessing it in the view.</p>
<div class="fragment"><div class="line"><span class="comment"># hello.py (continued)</span></div>
<div class="line"><span class="keyword">import</span> time</div>
<div class="line"> </div>
<div class="line"><span class="comment"># This function runs BEFORE every request</span></div>
<div class="line"><span class="preprocessor">@app.before_request</span></div>
<div class="line"><span class="keyword">def </span>load_request_data():</div>
<div class="line">  <span class="comment"># Imagine loading data from a database or external source here</span></div>
<div class="line">  g.request_time = time.time()</div>
<div class="line">  g.user = <span class="stringliteral">&#39;Guest&#39;</span> <span class="comment"># Default user</span></div>
<div class="line">  <span class="comment"># Maybe check for an API key or user session here and set g.user accordingly</span></div>
<div class="line">  <span class="comment"># For example: if session.get(&#39;logged_in_user&#39;): g.user = session[&#39;logged_in_user&#39;]</span></div>
<div class="line">  current_app.logger.info(f<span class="stringliteral">&quot;Before request: Set g.user to {g.user}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.route(&#39;/show-g&#39;)</span></div>
<div class="line"><span class="keyword">def </span>show_g():</div>
<div class="line">  <span class="comment"># Access the data stored in &#39;g&#39; by the before_request handler</span></div>
<div class="line">  req_time = g.get(<span class="stringliteral">&#39;request_time&#39;</span>, <span class="stringliteral">&#39;Not Set&#39;</span>)</div>
<div class="line">  current_user = g.get(<span class="stringliteral">&#39;user&#39;</span>, <span class="stringliteral">&#39;Unknown&#39;</span>)</div>
<div class="line"> </div>
<div class="line">  <span class="comment"># Check if it&#39;s still there after the request (it shouldn&#39;t be for the *next* request)</span></div>
<div class="line">  <span class="comment"># We can&#39;t easily show this here, but g is cleared between requests.</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> f<span class="stringliteral">&#39;Data from g:&lt;br&gt;Request Time: {req_time}&lt;br&gt;User: {current_user}&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># This function runs AFTER every request, even if errors occur</span></div>
<div class="line"><span class="comment"># It receives the response object</span></div>
<div class="line"><span class="preprocessor">@app.teardown_request</span></div>
<div class="line"><span class="keyword">def </span>teardown_request_data(exception=None):</div>
<div class="line">    <span class="comment"># This is a good place to clean up resources stored in g, like DB connections</span></div>
<div class="line">    req_time = g.pop(<span class="stringliteral">&#39;request_time&#39;</span>, <span class="keywordtype">None</span>) <span class="comment"># Safely remove request_time</span></div>
<div class="line">    user = g.pop(<span class="stringliteral">&#39;user&#39;</span>, <span class="keywordtype">None</span>) <span class="comment"># Safely remove user</span></div>
<div class="line">    <span class="keywordflow">if</span> req_time:</div>
<div class="line">      duration = time.time() - req_time</div>
<div class="line">      current_app.logger.info(f<span class="stringliteral">&quot;Teardown request: User={user}, Duration={duration:.4f}s&quot;</span>)</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">      current_app.logger.info(<span class="stringliteral">&quot;Teardown request: g values already popped or not set.&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># ... (rest of the app, including if __name__ == &#39;__main__&#39;: app.run(debug=True))</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>@app.before_request</code>: This decorator registers <code>load_request_data</code> to run before each request is processed.</li>
<li><code>g.request_time = ...</code> and <code>g.user = ...</code>: We store arbitrary data on the <code>g</code> object. It acts like a Python object where you can set attributes.</li>
<li>&lsquo;g.get('request_time&rsquo;, ...)<code>: In the view function</code>show_g<code>, we retrieve the data stored on</code>g<code>. Using</code>.<a class="el" href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get()</a><code>is safer as it allows providing a default if the attribute wasn't set. *</code>@app.teardown_request<code>: This decorator registers</code>teardown_request_data<code>to run after the request has been handled and the response sent, even if an exception occurred. It's a good place to clean up resources stored in</code>g<code>.</code>g.pop()` is used to get the value and remove it, preventing potential issues if the teardown runs multiple times in complex scenarios.</li>
</ul>
<p>When you visit <code>/show-g</code>, the <code>before_request</code> function runs first, setting <code>g.user</code> and <code>g.request_time</code>. Then <code>show_g</code> runs and reads those values from <code>g</code>. Finally, <code>teardown_request</code> runs. If you make another request, <code>g</code> will be empty again until <code>before_request</code> runs for that <em>new</em> request.</p>
<h2><a class="anchor" id="autotoc_md1917"></a>
Why "Context"? The Magic Behind the Scenes</h2>
<p>How do these globals always know which <code>request</code> or <code>app</code> to point to, especially if your web server is handling multiple requests at the same time?</p>
<p>Flask manages this using <b>Contexts</b>. There are two main types:</p>
<ol type="1">
<li><b>Application Context:</b> Holds information about the application itself. When an application context is active, <code>current_app</code> and <code>g</code> point to the correct application instance and its request-global storage (<code>g</code>). An application context is automatically created when a request context is pushed, or you can create one manually using <code>with app.app_context():</code>. This is needed for tasks that aren't tied to a specific request but need the application, like running background jobs or initializing database tables via a script.</li>
<li><b>Request Context:</b> Holds information about a single, specific HTTP request. When a request context is active, <code>request</code> and <code>session</code> point to the correct request object and session data for <em>that specific request</em>. Flask automatically creates and activates (pushes) a request context when it receives an incoming HTTP request and removes (pops) it when the request is finished.</li>
</ol>
<p>Think of these contexts like temporary bubbles or environments. When Flask handles a request, it inflates a request context bubble (which automatically includes an application context bubble inside it). Inside this bubble, the names <code>request</code>, <code>session</code>, <code>current_app</code>, and <code>g</code> are set up to point to the objects belonging to <em>that specific bubble</em>. If another request comes in concurrently (in a different thread or process), Flask creates a <em>separate</em> bubble for it, and the context globals inside that second bubble point to <em>its</em> own request, session, app, and g objects.</p>
<p>This system ensures that even with multiple simultaneous requests, <code>request</code> in the code handling request A always refers to request A's data, while <code>request</code> in the code handling request B always refers to request B's data.</p>
<p>We will explore contexts in more detail in <a class="el" href="../../d6/da8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_207__application__and__request__contexts.html">Chapter 7: Application and Request Contexts</a>.</p>
<h2><a class="anchor" id="autotoc_md1918"></a>
Under the Hood: Proxies and <code>contextvars</code></h2>
<p>How do these variables like <code>request</code> actually <em>do</em> the lookup within the current context?</p>
<p>Flask uses a concept called <b>Local Proxies</b>, specifically <code>werkzeug.local.LocalProxy</code>. These proxy objects are essentially clever stand-ins. When you access an attribute or method on a proxy (like <code>request.method</code>), the proxy doesn't have the method itself. Instead, it performs a lookup to find the <em>real</em> object it should be representing <em>at that moment</em> based on the current context.</p>
<p>Under the hood, Flask (since version 1.1, leveraging Werkzeug updates) uses Python's built-in <code>contextvars</code> module (or a backport for older Python versions). <code>contextvars</code> provides special kinds of variables (<code>ContextVar</code>) that can hold different values depending on the current execution context (like the specific request/thread/async task being handled).</p>
<ol type="1">
<li>Flask defines context variables, for example, <code>_cv_request</code> in <code>flask.globals</code>.</li>
<li>When a request context is pushed (<code>RequestContext.push()</code> in <code>ctx.py</code>), Flask stores the actual <code>Request</code> object for the current request into <code>_cv_request</code> <em>for the current context</em>.</li>
<li>The <code>request</code> global variable (defined in <code>flask.globals</code>) is a <code>LocalProxy</code> that is configured to look up the object stored in <code>_cv_request</code>.</li>
<li>When your code uses <code>request.method</code>, the proxy sees it needs the real request object, looks at the current context's value for <code>_cv_request</code>, gets the real <code>Request</code> object stored there, and then calls the <code>.method</code> attribute on <em>that</em> object.</li>
</ol>
<p>A similar process happens for <code>current_app</code>, <code>session</code>, and <code>g</code> using <code>_cv_app</code>.</p>
<p>Here's how <code>request</code> and <code>session</code> are defined in <code>flask/globals.py</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># flask/globals.py (simplified)</span></div>
<div class="line"><span class="keyword">from</span> contextvars <span class="keyword">import</span> ContextVar</div>
<div class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalProxy</div>
<div class="line"><span class="comment"># ... other imports</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Context Variables hold the actual context objects</span></div>
<div class="line">_cv_app: ContextVar[AppContext] = ContextVar(<span class="stringliteral">&quot;flask.app_ctx&quot;</span>)</div>
<div class="line">_cv_request: ContextVar[RequestContext] = ContextVar(<span class="stringliteral">&quot;flask.request_ctx&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Proxies point to objects within the currently active context</span></div>
<div class="line"><span class="comment"># The LocalProxy is told how to find the real object (e.g., via _cv_request)</span></div>
<div class="line"><span class="comment"># and which attribute on that context object to return (e.g., &#39;request&#39;)</span></div>
<div class="line">request: Request = LocalProxy(_cv_request, <span class="stringliteral">&quot;request&quot;</span>) <span class="comment"># type: ignore</span></div>
<div class="line">session: SessionMixin = LocalProxy(_cv_request, <span class="stringliteral">&quot;session&quot;</span>) <span class="comment"># type: ignore</span></div>
<div class="line">current_app: Flask = LocalProxy(_cv_app, <span class="stringliteral">&quot;app&quot;</span>) <span class="comment"># type: ignore</span></div>
<div class="line">g: _AppCtxGlobals = LocalProxy(_cv_app, <span class="stringliteral">&quot;g&quot;</span>) <span class="comment"># type: ignore</span></div>
</div><!-- fragment --><p>This proxy mechanism allows you to write clean code using simple global names, while Flask handles the complexity of ensuring those names point to the correct, context-specific objects behind the scenes.</p>
<p>Here's a diagram showing two concurrent requests and how the <code>request</code> proxy resolves differently in each context:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant UserCodeA as View Func (Req A)</div>
<div class="line">    participant Proxy as request (LocalProxy)</div>
<div class="line">    participant ContextVars as Context Storage</div>
<div class="line">    participant UserCodeB as View Func (Req B)</div>
<div class="line"> </div>
<div class="line">    Note over UserCodeA, UserCodeB: Requests A and B handled concurrently</div>
<div class="line"> </div>
<div class="line">    UserCodeA-&gt;&gt;+Proxy: Access request.method</div>
<div class="line">    Proxy-&gt;&gt;+ContextVars: Get current value of _cv_request</div>
<div class="line">    ContextVars--&gt;&gt;-Proxy: Return RequestContext A</div>
<div class="line">    Proxy-&gt;&gt;RequestContextA: Get &#39;request&#39; attribute (Real Request A)</div>
<div class="line">    RequestContextA--&gt;&gt;Proxy: Return Real Request A</div>
<div class="line">    Proxy-&gt;&gt;RealRequestA: Access &#39;method&#39; attribute</div>
<div class="line">    RealRequestA--&gt;&gt;Proxy: Return &#39;GET&#39;</div>
<div class="line">    Proxy--&gt;&gt;-UserCodeA: Return &#39;GET&#39;</div>
<div class="line"> </div>
<div class="line">    UserCodeB-&gt;&gt;+Proxy: Access request.form[&#39;name&#39;]</div>
<div class="line">    Proxy-&gt;&gt;+ContextVars: Get current value of _cv_request</div>
<div class="line">    ContextVars--&gt;&gt;-Proxy: Return RequestContext B</div>
<div class="line">    Proxy-&gt;&gt;RequestContextB: Get &#39;request&#39; attribute (Real Request B)</div>
<div class="line">    RequestContextB--&gt;&gt;Proxy: Return Real Request B</div>
<div class="line">    Proxy-&gt;&gt;RealRequestB: Access &#39;form&#39; attribute</div>
<div class="line">    RealRequestB--&gt;&gt;Proxy: Return FormDict B</div>
<div class="line">    Proxy-&gt;&gt;FormDictB: Get item &#39;name&#39;</div>
<div class="line">    FormDictB--&gt;&gt;Proxy: Return &#39;Bob&#39;</div>
<div class="line">    Proxy--&gt;&gt;-UserCodeB: Return &#39;Bob&#39;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1919"></a>
Conclusion</h2>
<p>You've learned about Flask's Context Globals: <code>current_app</code>, <code>request</code>, <code>session</code>, and <code>g</code>. These are powerful proxy objects that simplify your code by providing easy access to application- or request-specific information without needing to pass objects around manually.</p>
<ul>
<li><b><code>request</code></b>: Accesses incoming request data.</li>
<li><b><code>session</code></b>: Stores user-specific data across requests (requires <code>SECRET_KEY</code>).</li>
<li><b><code>current_app</code></b>: Accesses the active application instance and its config/resources.</li>
<li><b><code>g</code></b>: A temporary storage space for the duration of a single request.</li>
</ul>
<p>These globals work their magic through Flask's <b>context</b> system (Application Context and Request Context) and <b>proxies</b> that look up the correct object in the currently active context, often powered by Python's <code>contextvars</code>.</p>
<p>Understanding these globals is key to writing idiomatic Flask code. You'll frequently use <code>request</code> to handle user input, <code>session</code> for user state, <code>current_app</code> for configuration, and <code>g</code> for managing request-scoped resources like database connections.</p>
<p>Speaking of configuration, how exactly do we set things like the <code>SECRET_KEY</code>, database URLs, or other settings for our application? That's the topic of our next chapter.</p>
<p>Let's learn how to manage settings effectively in <a class="el" href="../../d9/d88/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Flask_206__configuration______config____.html">Chapter 6: Configuration (<code>Config</code>)</a>.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
