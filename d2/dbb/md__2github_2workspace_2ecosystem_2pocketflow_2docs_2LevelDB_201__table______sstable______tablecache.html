#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 01_table___sstable___tablecache</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">01_table___sstable___tablecache</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2249"></a>
autotoc_md2249</h2>
<p>layout: default title: "Table, SSTable &amp; TableCache" parent: "LevelDB" </p>
<h2><a class="anchor" id="autotoc_md2250"></a>
nav_order: 1</h2>
<h1><a class="anchor" id="autotoc_md2251"></a>
Chapter 1: Table / SSTable &amp; TableCache</h1>
<p>Welcome to your LevelDB journey! This is the first chapter where we'll start exploring the fundamental building blocks of LevelDB.</p>
<p>Imagine you're building a system to store a massive amount of data, like user profiles or product information. You need a way to save this data permanently (so it doesn't disappear when the computer turns off) and retrieve it quickly. How does LevelDB handle this?</p>
<p>The core idea we'll explore in this chapter is how LevelDB stores the bulk of its data on disk in special files and how it accesses them efficiently.</p>
<h2><a class="anchor" id="autotoc_md2252"></a>
What's the Problem? Storing Lots of Data Permanently</h2>
<p>Databases need to store key-value pairs (like <code>user_id</code> -&gt; <code>user_data</code>) persistently. This means writing the data to disk. However, disks are much slower than computer memory (RAM). If we just wrote every tiny change directly to a file, it would be very slow. Also, how do we organize the data on disk so we can find a specific key quickly without reading <em>everything</em>?</p>
<p>LevelDB's solution involves files called <b>SSTables</b> (Sorted String Tables), often just called <b>Tables</b> in the code.</p>
<h2><a class="anchor" id="autotoc_md2253"></a>
SSTable: The Sorted, Immutable Book on the Shelf</h2>
<p>Think of an SSTable as a <b>permanently bound book</b> in a library.</p>
<ol type="1">
<li><b>Stores Key-Value Pairs:</b> Just like a dictionary or an encyclopedia volume, an SSTable contains data entries, specifically key-value pairs.</li>
<li><b>Sorted:</b> The keys inside an SSTable file are always stored in sorted order (like words in a dictionary). This is crucial for finding data quickly later on. If you're looking for the key "zebra", you know you don't need to look in the "A" section.</li>
<li><b>Immutable:</b> Once an SSTable file is written to disk, LevelDB <b>never changes it</b>. It's like a printed book â€“ you can't erase or rewrite a page. If you need to update or delete data, LevelDB writes <em>new</em> information in <em>newer</em> SSTables. (We'll see how this works in later chapters like <a class="el" href="../../df/d5d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_208__compaction.html">Compaction</a>). This immutability makes many things simpler and safer.</li>
<li><b>It's a File:</b> At the end of the day, an SSTable is just a file on your computer's disk. LevelDB gives these files names like <code>000005.ldb</code> or <code>000010.sst</code>.</li>
</ol>
<p>Here's how LevelDB determines the filename for an SSTable:</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: filename.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Creates a filename like &quot;dbname/000005.ldb&quot;</span></div>
<div class="line">std::string TableFileName(<span class="keyword">const</span> std::string&amp; dbname, uint64_t number) {</div>
<div class="line">  assert(number &gt; 0);</div>
<div class="line">  <span class="comment">// Uses a helper to format the number with leading zeros</span></div>
<div class="line">  <span class="comment">// and adds the &#39;.ldb&#39; or &#39;.sst&#39; suffix.</span></div>
<div class="line">  <span class="keywordflow">return</span> MakeFileName(dbname, number, <span class="stringliteral">&quot;ldb&quot;</span>); <span class="comment">// or &quot;sst&quot;</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>This simple function takes the database name (e.g., <code>/path/to/my/db</code>) and a unique number and creates the actual filename used on disk. The <code>.ldb</code> or <code>.sst</code> extension helps identify it as a LevelDB table file.</p>
<h2><a class="anchor" id="autotoc_md2254"></a>
Creating SSTables: <code>BuildTable</code></h2>
<p>How do these sorted, immutable files get created? This happens during processes like "flushing" data from memory or during "compaction" (which we'll cover in later chapters: <a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">MemTable</a> and <a class="el" href="../../df/d5d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_208__compaction.html">Compaction</a>).</p>
<p>The function responsible for writing a new SSTable file is <code>BuildTable</code>. Think of <code>BuildTable</code> as the <b>printing press and binding machine</b> for our book analogy. It takes data (often from memory, represented by an <code>Iterator</code>) and writes it out to a new, sorted SSTable file on disk.</p>
<p>Let's look at a simplified view of <code>BuildTable</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: builder.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Builds an SSTable file from the key/value pairs provided by &#39;iter&#39;.</span></div>
<div class="line">Status BuildTable(<span class="keyword">const</span> std::string&amp; dbname, Env* env, <span class="keyword">const</span> Options&amp; options,</div>
<div class="line">                  TableCache* table_cache, Iterator* iter, FileMetaData* meta) {</div>
<div class="line">  Status s;</div>
<div class="line">  <span class="comment">// ... setup: determine filename, open the file for writing ...</span></div>
<div class="line">  std::string fname = TableFileName(dbname, meta-&gt;number);</div>
<div class="line">  WritableFile* file;</div>
<div class="line">  s = env-&gt;NewWritableFile(fname, &amp;file);</div>
<div class="line">  <span class="comment">// ... handle potential errors ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// TableBuilder does the heavy lifting of formatting the file</span></div>
<div class="line">  TableBuilder* builder = <span class="keyword">new</span> TableBuilder(options, file);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Find the first key to store as the smallest key in metadata</span></div>
<div class="line">  iter-&gt;SeekToFirst();</div>
<div class="line">  meta-&gt;smallest.DecodeFrom(iter-&gt;key());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Loop through all key-value pairs from the input iterator</span></div>
<div class="line">  Slice key;</div>
<div class="line">  <span class="keywordflow">for</span> (; iter-&gt;Valid(); iter-&gt;Next()) {</div>
<div class="line">    key = iter-&gt;key();</div>
<div class="line">    <span class="comment">// Add the key and value to the table being built</span></div>
<div class="line">    builder-&gt;Add(key, iter-&gt;value());</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Store the last key as the largest key in metadata</span></div>
<div class="line">  <span class="keywordflow">if</span> (!key.empty()) {</div>
<div class="line">    meta-&gt;largest.DecodeFrom(key);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Finish writing the file (adds index blocks, etc.)</span></div>
<div class="line">  s = builder-&gt;Finish();</div>
<div class="line">  <span class="comment">// ... more steps: update metadata, sync file to disk, close file ...</span></div>
<div class="line">  <span class="keywordflow">if</span> (s.ok()) {</div>
<div class="line">      meta-&gt;file_size = builder-&gt;FileSize();</div>
<div class="line">      s = <a class="code hl_variable" href="../../d8/dc3/namespaceupdate__mdx__section.html#a2b592aa898cb6a422bc0b4e038f9cebd">file</a>-&gt;Sync(); <span class="comment">// Ensure data is physically written</span></div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (s.ok()) {</div>
<div class="line">      s = <a class="code hl_variable" href="../../d8/dc3/namespaceupdate__mdx__section.html#a2b592aa898cb6a422bc0b4e038f9cebd">file</a>-&gt;Close();</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ... cleanup: delete builder, file; handle errors ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> s;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceupdate__mdx__section_html_a2b592aa898cb6a422bc0b4e038f9cebd"><div class="ttname"><a href="../../d8/dc3/namespaceupdate__mdx__section.html#a2b592aa898cb6a422bc0b4e038f9cebd">update_mdx_section.file</a></div><div class="ttdeci">file</div><div class="ttdef"><b>Definition</b> <a href="../../d2/d91/update__mdx__section_8py_source.html#l00138">update_mdx_section.py:138</a></div></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Input:</b> <code>BuildTable</code> receives data via an <code>Iterator</code>. An iterator is like a cursor that lets you go through key-value pairs one by one, already in sorted order. It also gets other necessary info like the database name (<code>dbname</code>), environment (<code>env</code>), options, the <code>TableCache</code> (we'll see this next!), and a <code>FileMetaData</code> object to store information <em>about</em> the new file (like its number, size, smallest key, and largest key).</li>
<li><b>File Creation:</b> It creates a new, empty file using <code>env-&gt;NewWritableFile</code>.</li>
<li><b>TableBuilder:</b> It uses a helper object called <code>TableBuilder</code> to handle the complex details of formatting the SSTable file structure (data blocks, index blocks, etc.).</li>
<li><b>Iteration &amp; Adding:</b> It loops through the <code>Iterator</code>. For each key-value pair, it calls <code>builder-&gt;Add()</code>. Because the input <code>Iterator</code> provides keys in sorted order, the <code>TableBuilder</code> can write them sequentially to the file.</li>
<li><b>Metadata:</b> It records the very first key (<code>meta-&gt;smallest</code>) and the very last key (<code>meta-&gt;largest</code>) it processes. This is useful later for quickly knowing the range of keys stored in this file without opening it.</li>
<li><b>Finishing Up:</b> It calls <code>builder-&gt;Finish()</code> to write out the final pieces of the SSTable (like the index). Then it <code>Sync</code>s the file to ensure the data is safely on disk and <code>Close</code>s it.</li>
<li><b>Output:</b> If successful, a new <code>.ldb</code> file exists on disk containing the sorted key-value pairs, and the <code>meta</code> object is filled with details about this file.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2255"></a>
Accessing SSTables Efficiently: <code>TableCache</code></h2>
<p>Okay, so we have these SSTable files on disk. But reading from disk is slow. If we need to read from the same SSTable file multiple times (which is common), opening and closing it repeatedly, or re-reading its internal index structure, would be inefficient.</p>
<p>This is where the <code>TableCache</code> comes in. Think of the <code>TableCache</code> as a <b>smart librarian</b>.</p>
<ol type="1">
<li><b>Keeps Files Open:</b> The librarian might keep the most popular books near the front desk instead of running to the far shelves every time someone asks for them. Similarly, the <code>TableCache</code> keeps recently used SSTable files open.</li>
<li><b>Caches Structures:</b> Just opening the file isn't enough. LevelDB needs to read some index information <em>within</em> the SSTable file to find keys quickly. The <code>TableCache</code> also keeps this parsed information in memory (RAM). It uses a specific caching strategy called LRU (Least Recently Used) to decide which table information to keep in memory if the cache gets full.</li>
<li><b>Provides Access:</b> When LevelDB needs to read data from a specific SSTable (identified by its file number), it asks the <code>TableCache</code>. The cache checks if it already has that table open and ready in memory. If yes (a "cache hit"), it returns access quickly. If no (a "cache miss"), it opens the actual file from disk, reads the necessary index info, stores it in the cache for next time, and then returns access.</li>
</ol>
<p>Let's see how the <code>TableCache</code> finds a table:</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: table_cache.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Tries to find the Table structure for a given file number.</span></div>
<div class="line"><span class="comment">// If not in cache, opens the file and loads it.</span></div>
<div class="line">Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,</div>
<div class="line">                             Cache::Handle** handle) {</div>
<div class="line">  Status s;</div>
<div class="line">  <span class="comment">// Create a key for the cache lookup (based on file number)</span></div>
<div class="line">  <span class="keywordtype">char</span> buf[<span class="keyword">sizeof</span>(file_number)];</div>
<div class="line">  EncodeFixed64(buf, file_number);</div>
<div class="line">  Slice key(buf, <span class="keyword">sizeof</span>(buf));</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 1. Try looking up the table in the cache</span></div>
<div class="line">  *handle = cache_-&gt;Lookup(key);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (*handle == <span class="keyword">nullptr</span>) { <span class="comment">// Cache Miss!</span></div>
<div class="line">    <span class="comment">// 2. If not found, open the actual file from disk</span></div>
<div class="line">    std::string fname = TableFileName(dbname_, file_number);</div>
<div class="line">    RandomAccessFile* file = <span class="keyword">nullptr</span>;</div>
<div class="line">    Table* table = <span class="keyword">nullptr</span>;</div>
<div class="line">    s = env_-&gt;NewRandomAccessFile(fname, &amp;file); <span class="comment">// Open the file</span></div>
<div class="line">    <span class="comment">// ... handle errors, potentially check for old .sst filename ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (s.ok()) {</div>
<div class="line">      <span class="comment">// 3. Parse the Table structure (index etc.) from the file</span></div>
<div class="line">      s = Table::Open(options_, file, file_size, &amp;table);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (s.ok()) {</div>
<div class="line">      <span class="comment">// 4. Store the opened file and parsed Table in the cache</span></div>
<div class="line">      TableAndFile* tf = <span class="keyword">new</span> TableAndFile;</div>
<div class="line">      tf-&gt;file = file;</div>
<div class="line">      tf-&gt;table = table;</div>
<div class="line">      *handle = cache_-&gt;Insert(key, tf, 1 <span class="comment">/*charge*/</span>, &amp;DeleteEntry);</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Error occurred, cleanup</span></div>
<div class="line">      <span class="keyword">delete</span> <a class="code hl_variable" href="../../d8/dc3/namespaceupdate__mdx__section.html#a2b592aa898cb6a422bc0b4e038f9cebd">file</a>;</div>
<div class="line">      <span class="comment">// Note: Errors are NOT cached. We&#39;ll retry opening next time.</span></div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// else: Cache Hit! *handle is already valid.</span></div>
<div class="line">  <span class="keywordflow">return</span> s;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Lookup:</b> It first tries <code>cache_-&gt;Lookup</code> using the <code>file_number</code>.</li>
<li><b>Cache Miss:</b> If <code>Lookup</code> returns <code>nullptr</code>, it means the table isn't in the cache. It then proceeds to open the file (<code>env_-&gt;NewRandomAccessFile</code>).</li>
<li><b>Table::Open:</b> It calls <code>Table::Open</code>, which reads the file's footer, parses the index block, and sets up a <code>Table</code> object ready for lookups.</li>
<li><b>Insert:</b> If opening and parsing succeed, it creates a <code>TableAndFile</code> struct (holding both the file handle and the <code>Table</code> object) and inserts it into the cache using <code>cache_-&gt;Insert</code>. Now, the next time <code>FindTable</code> is called for this <code>file_number</code>, it will be a cache hit.</li>
<li><b>Cache Hit:</b> If <code>Lookup</code> initially returned a valid handle, <code>FindTable</code> simply returns <code>Status::OK()</code>, and the caller can use the handle to get the <code>Table</code> object.</li>
</ol>
<p>When LevelDB needs to read data, it often gets an <code>Iterator</code> for a specific SSTable via the <code>TableCache</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: table_cache.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns an iterator for reading the specified SSTable file.</span></div>
<div class="line">Iterator* TableCache::NewIterator(<span class="keyword">const</span> ReadOptions&amp; options,</div>
<div class="line">                                  uint64_t file_number, uint64_t file_size,</div>
<div class="line">                                  Table** tableptr) {</div>
<div class="line">  <span class="comment">// ... setup ...</span></div>
<div class="line">  Cache::Handle* handle = <span class="keyword">nullptr</span>;</div>
<div class="line">  <span class="comment">// Use FindTable to get the Table object (from cache or by opening file)</span></div>
<div class="line">  Status s = FindTable(file_number, file_size, &amp;handle);</div>
<div class="line">  <span class="keywordflow">if</span> (!s.ok()) {</div>
<div class="line">    <span class="keywordflow">return</span> NewErrorIterator(s); <span class="comment">// Return an iterator that yields the error</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Get the Table object from the cache handle</span></div>
<div class="line">  Table* table = <span class="keyword">reinterpret_cast&lt;</span>TableAndFile*<span class="keyword">&gt;</span>(cache_-&gt;Value(handle))-&gt;table;</div>
<div class="line">  <span class="comment">// Ask the Table object to create a new iterator for its data</span></div>
<div class="line">  Iterator* result = table-&gt;NewIterator(options);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Important: Register cleanup to release the cache handle when iterator is done</span></div>
<div class="line">  result-&gt;RegisterCleanup(&amp;UnrefEntry, cache_, handle);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Optionally return the Table object itself</span></div>
<div class="line">  <span class="keywordflow">if</span> (tableptr != <span class="keyword">nullptr</span>) {</div>
<div class="line">    *tableptr = table;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">return</span> <a class="code hl_variable" href="../../da/d34/namespaceutils_1_1crawl__github__files.html#abaeadc4a603ce2c7230819303321ec90">result</a>;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceutils_1_1crawl__github__files_html_abaeadc4a603ce2c7230819303321ec90"><div class="ttname"><a href="../../da/d34/namespaceutils_1_1crawl__github__files.html#abaeadc4a603ce2c7230819303321ec90">utils.crawl_github_files.result</a></div><div class="ttdeci">result</div><div class="ttdef"><b>Definition</b> <a href="../../d8/dd7/crawl__github__files_8py_source.html#l00357">crawl_github_files.py:357</a></div></div>
</div><!-- fragment --><p>This function uses <code>FindTable</code> to get the <code>Table</code> object (either from the cache or by loading it from disk) and then asks that <code>Table</code> object to provide an <code>Iterator</code> to step through its key-value pairs. It also cleverly registers a cleanup function (<code>UnrefEntry</code>) so that when the iterator is no longer needed, the cache handle is released, allowing the cache to potentially evict the table later if needed.</p>
<p>Here's a diagram showing how a read might use the <code>TableCache</code>:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client as Read Operation</div>
<div class="line">    participant TableCache</div>
<div class="line">    participant Cache as LRUCache</div>
<div class="line">    participant OS/FileSystem as FS</div>
<div class="line">    participant TableObject as In-Memory Table Rep</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;TableCache: Get(&quot;some_key&quot;, file_num=5, size=1MB)</div>
<div class="line">    TableCache-&gt;&gt;Cache: Lookup(file_num=5)?</div>
<div class="line">    alt Cache Hit</div>
<div class="line">        Cache--&gt;&gt;TableCache: Return handle for Table 5</div>
<div class="line">        TableCache-&gt;&gt;TableObject: Find &quot;some_key&quot; within Table 5 data</div>
<div class="line">        TableObject--&gt;&gt;TableCache: Return value / not found</div>
<div class="line">        TableCache--&gt;&gt;Client: Return value / not found</div>
<div class="line">    else Cache Miss</div>
<div class="line">        Cache--&gt;&gt;TableCache: Not found (nullptr)</div>
<div class="line">        TableCache-&gt;&gt;FS: Open file &quot;000005.ldb&quot;</div>
<div class="line">        FS--&gt;&gt;TableCache: Return file handle</div>
<div class="line">        TableCache-&gt;&gt;TableObject: Create Table 5 representation from file handle + size</div>
<div class="line">        TableObject--&gt;&gt;TableCache: Return Table 5 object</div>
<div class="line">        TableCache-&gt;&gt;Cache: Insert(file_num=5, Table 5 object)</div>
<div class="line">        Note right of Cache: Table 5 now cached</div>
<div class="line">        TableCache-&gt;&gt;TableObject: Find &quot;some_key&quot; within Table 5 data</div>
<div class="line">        TableObject--&gt;&gt;TableCache: Return value / not found</div>
<div class="line">        TableCache--&gt;&gt;Client: Return value / not found</div>
<div class="line">    end</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2256"></a>
Conclusion</h2>
<p>In this chapter, we learned about two fundamental concepts in LevelDB:</p>
<ol type="1">
<li><b>SSTable (Table):</b> These are the immutable, sorted files on disk where LevelDB stores the bulk of its key-value data. Think of them as sorted, bound books. They are created using <code>BuildTable</code>.</li>
<li><b>TableCache:</b> This acts like an efficient librarian for SSTables. It keeps recently used tables open and their index structures cached in memory (RAM) to speed up access, avoiding slow disk reads whenever possible. It provides access to table data, often via iterators.</li>
</ol>
<p>These two components work together to provide persistent storage and relatively fast access to the data within those files.</p>
<p>But where does the data <em>come from</em> before it gets written into an SSTable? Often, it lives in memory first. In the next chapter, we'll look at the in-memory structure where recent writes are held before being flushed to an SSTable.</p>
<p>Next up: <a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">Chapter 2: MemTable</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
