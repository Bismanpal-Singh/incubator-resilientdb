#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_version___versionset</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_version___versionset</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2279"></a>
autotoc_md2279</h2>
<p>layout: default title: "Version &amp; VersionSet" parent: "LevelDB" </p>
<h2><a class="anchor" id="autotoc_md2280"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md2281"></a>
Chapter 6: Version &amp; VersionSet - The Database Catalog</h1>
<p>In the previous chapter, <a class="el" href="../../d1/dce/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_205__writebatch.html">Chapter 5: WriteBatch</a>, we learned how LevelDB groups multiple <code>Put</code> and <code>Delete</code> operations together to apply them atomically and efficiently. We saw that writes go first to the <a class="el" href="../../df/d85/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_203__write__ahead__log____wal________logwriter__logreader.html">Write-Ahead Log (WAL)</a> for durability, and then to the in-memory <a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">MemTable</a>.</p>
<p>Eventually, the MemTable gets full and is flushed to an <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">SSTable</a> file on disk. Over time, LevelDB also runs compactions, which read data from existing SSTables and write new ones, deleting the old ones afterwards. This means the set of SSTable files that represent the database's current state is constantly changing!</p>
<h2><a class="anchor" id="autotoc_md2282"></a>
What's the Problem? Tracking a Changing Set of Files</h2>
<p>Imagine our library again. Books (SSTables) are constantly being added (from MemTable flushes), removed (after compaction), and sometimes even moved between sections (levels during compaction). How does the librarian know <em>which</em> books are currently part of the official collection and where they are located? If a reader asks for information, the librarian can't just guess which books to look in – they need an accurate, up-to-date catalog.</p>
<p>Similarly, LevelDB needs a system to track:</p>
<ol type="1">
<li>Which SSTable files exist and are currently "live" (contain valid data)?</li>
<li>Which "level" each live SSTable file belongs to? (Levels are important for compaction, see <a class="el" href="../../df/d5d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_208__compaction.html">Chapter 8: Compaction</a>).</li>
<li>What's the overall state of the database, like the next available file number or the sequence number of the last operation?</li>
<li>How can reads see a consistent snapshot of the database, even while background tasks are adding and removing files?</li>
</ol>
<h2><a class="anchor" id="autotoc_md2283"></a>
The Solution: Versions, VersionEdits, and the VersionSet</h2>
<p>LevelDB uses a trio of concepts to manage this state:</p>
<ol type="1">
<li><b>Version:</b> Think of a <code>Version</code> object as <b>one specific edition of the library's catalog</b>. It represents a complete, consistent snapshot of the database state at a single point in time. Specifically, it contains lists of all the live SSTable files for <em>each</em> level. Once created, a <code>Version</code> object is <b>immutable</b> – it never changes, just like a printed catalog edition. Reads (<code>Get</code> operations or <a class="el" href="../../d8/dd9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_207__iterator.html">Iterators</a>) use a specific <code>Version</code> to know which files to consult.</li>
<li><b>VersionEdit:</b> This is like a <b>list of corrections and updates</b> to get from one catalog edition to the next. It describes the <em>changes</em> between two versions. A <code>VersionEdit</code> might say:<ul>
<li>"Add file number 15 to Level-0." (Because a MemTable was flushed).</li>
<li>"Remove files 8 and 9 from Level-1." (Because they were compacted).</li>
<li>"Add file number 25 to Level-2." (The result of the compaction).</li>
<li>"Update the next available file number to 26."</li>
<li>"Update the last sequence number." These edits are small descriptions of changes. They are stored persistently in a special file called the <code>MANIFEST</code>.</li>
</ul>
</li>
<li><b>VersionSet:</b> This is the <b>chief librarian</b> or the <b>cataloguing department</b>. It's the central manager for all database state related to the set of live files. The <code>VersionSet</code> performs several critical tasks:<ul>
<li>Keeps track of the single <code>current</code> Version (the latest catalog edition).</li>
<li>Reads the <code>MANIFEST</code> file during startup to reconstruct the database state.</li>
<li>Applies <code>VersionEdit</code>s to the <code>current</code> Version to create <em>new</em> <code>Version</code>s.</li>
<li>Manages essential metadata like the <code>next_file_number_</code>, <code>log_number_</code>, and <code>last_sequence_</code>.</li>
<li>Decides which compactions are needed (<a class="el" href="../../df/d5d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_208__compaction.html">Chapter 8: Compaction</a>).</li>
<li>Manages the lifecycle of <code>Version</code> objects (using reference counting) so that old versions needed by iterators or snapshots aren't deleted prematurely.</li>
</ul>
</li>
</ol>
<p><b>In short:</b> <code>VersionSet</code> uses <code>VersionEdit</code>s (from the <code>MANIFEST</code>) to create a sequence of immutable <code>Version</code>s, each representing the database state at a point in time. The <code>current</code> <code>Version</code> tells LevelDB which files to read from.</p>
<h2><a class="anchor" id="autotoc_md2284"></a>
How Reads Use Versions</h2>
<p>When you perform a <code>Get(key)</code> operation, the <a class="el" href="../../df/dc9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_204__dbimpl.html">DBImpl</a> needs to know which SSTables to check (after checking the MemTables). It does this by consulting the <code>current</code> <code>Version</code> held by the <code>VersionSet</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/db_impl.cc Get() ---</span></div>
<div class="line"> </div>
<div class="line">Status DBImpl::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</div>
<div class="line">                   std::string* value) {</div>
<div class="line">  <span class="comment">// ... check MemTable, Immutable MemTable first ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If not found in memory, check SSTables:</span></div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    MutexLock l(&amp;mutex_); <span class="comment">// Need lock to get current Version pointer safely</span></div>
<div class="line">    Version* current = versions_-&gt;current(); <span class="comment">// Ask VersionSet for current Version</span></div>
<div class="line">    current-&gt;Ref();       <span class="comment">// Increment ref count (important!)</span></div>
<div class="line">    mutex_.Unlock();      <span class="comment">// Unlock for potentially slow disk I/O</span></div>
<div class="line"> </div>
<div class="line">    LookupKey lkey(key, snapshot_sequence_number); <span class="comment">// Key to search for</span></div>
<div class="line">    Version::GetStats stats;</div>
<div class="line">    <span class="comment">// Ask the Version object to perform the lookup in its files</span></div>
<div class="line">    Status s = current-&gt;Get(options, lkey, value, &amp;stats);</div>
<div class="line"> </div>
<div class="line">    mutex_.Lock();        <span class="comment">// Re-acquire lock for cleanup</span></div>
<div class="line">    current-&gt;Unref();     <span class="comment">// Decrement ref count</span></div>
<div class="line">    <span class="comment">// ... maybe trigger compaction based on stats ...</span></div>
<div class="line">    mutex_.Unlock();</div>
<div class="line">    <span class="keywordflow">return</span> s;</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>The key step is <code>versions_-&gt;current()-&gt;Get(...)</code>. The <code>DBImpl</code> asks the <code>VersionSet</code> (<code>versions_</code>) for the pointer to the <code>current</code> <code>Version</code>. It then calls the <code>Get</code> method <em>on that <code>Version</code> object</em>.</p>
<p>How does <code>Version::Get</code> work?</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/version_set.cc ---</span></div>
<div class="line"> </div>
<div class="line">Status Version::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> LookupKey&amp; k,</div>
<div class="line">                    std::string* value, GetStats* stats) {</div>
<div class="line">  Slice ikey = k.internal_key();</div>
<div class="line">  Slice user_key = k.user_key();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// We search level-by-level</span></div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> level = 0; level &lt; config::kNumLevels; level++) {</div>
<div class="line">    <span class="keyword">const</span> std::vector&lt;FileMetaData*&gt;&amp; files = files_[level]; <span class="comment">// Get list for this level</span></div>
<div class="line">    <span class="keywordflow">if</span> (files.empty()) <span class="keywordflow">continue</span>; <span class="comment">// Skip empty levels</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (level == 0) {</div>
<div class="line">      <span class="comment">// Level-0 files might overlap, search newest-first</span></div>
<div class="line">      std::vector&lt;FileMetaData*&gt; tmp;</div>
<div class="line">      <span class="comment">// Find potentially overlapping files in level 0</span></div>
<div class="line">      <span class="comment">// ... logic to find relevant files ...</span></div>
<div class="line">      <span class="comment">// Sort them newest-first</span></div>
<div class="line">      std::sort(tmp.begin(), tmp.end(), NewestFirst);</div>
<div class="line">      <span class="comment">// Search each relevant file</span></div>
<div class="line">      <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; tmp.size(); i++) {</div>
<div class="line">        FileMetaData* f = tmp[i];</div>
<div class="line">        <span class="comment">// Use TableCache to search the actual SSTable file</span></div>
<div class="line">        Status s = vset_-&gt;table_cache_-&gt;Get(options, f-&gt;number, f-&gt;file_size,</div>
<div class="line">                                           ikey, <span class="comment">/* saver state */</span>, SaveValue);</div>
<div class="line">        <span class="comment">// ... check if found/deleted/error and update stats ...</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="comment">/* found or deleted */</span>) <span class="keywordflow">return</span> s;</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Levels &gt; 0 files are sorted and non-overlapping</span></div>
<div class="line">      <span class="comment">// Binary search to find the single file that might contain the key</span></div>
<div class="line">      uint32_t index = FindFile(vset_-&gt;icmp_, files, ikey);</div>
<div class="line">      <span class="keywordflow">if</span> (index &lt; <a class="code hl_variable" href="../../da/d34/namespaceutils_1_1crawl__github__files.html#a8ee733aa36009051019fc9a811dc42d6">files</a>.size()) {</div>
<div class="line">        FileMetaData* f = <a class="code hl_variable" href="../../da/d34/namespaceutils_1_1crawl__github__files.html#a8ee733aa36009051019fc9a811dc42d6">files</a>[index];</div>
<div class="line">        <span class="comment">// Check if user_key is within the file&#39;s range</span></div>
<div class="line">        <span class="keywordflow">if</span> (<span class="comment">/* user_key is within f-&gt;smallest/f-&gt;largest range */</span>) {</div>
<div class="line">          <span class="comment">// Use TableCache to search the actual SSTable file</span></div>
<div class="line">          Status s = vset_-&gt;table_cache_-&gt;Get(options, f-&gt;number, f-&gt;file_size,</div>
<div class="line">                                             ikey, <span class="comment">/* saver state */</span>, SaveValue);</div>
<div class="line">          <span class="comment">// ... check if found/deleted/error and update stats ...</span></div>
<div class="line">          <span class="keywordflow">if</span> (<span class="comment">/* found or deleted */</span>) <span class="keywordflow">return</span> s;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  } <span class="comment">// End loop over levels</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> Status::NotFound(Slice()); <span class="comment">// Key not found in any SSTable</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceutils_1_1crawl__github__files_html_a8ee733aa36009051019fc9a811dc42d6"><div class="ttname"><a href="../../da/d34/namespaceutils_1_1crawl__github__files.html#a8ee733aa36009051019fc9a811dc42d6">utils.crawl_github_files.files</a></div><div class="ttdeci">files</div><div class="ttdef"><b>Definition</b> <a href="../../d8/dd7/crawl__github__files_8py_source.html#l00365">crawl_github_files.py:365</a></div></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>The <code>Version</code> object has arrays (<code>files_[level]</code>) storing <code>FileMetaData</code> pointers for each level. <code>FileMetaData</code> contains the file number, size, and smallest/largest keys for an SSTable.</li>
<li>It iterates through the levels.</li>
<li><b>Level 0:</b> Files might overlap, so it finds all potentially relevant files, sorts them newest-first (by file number), and checks each one using the <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">Table / SSTable &amp; TableCache</a>.</li>
<li><b>Levels &gt; 0:</b> Files are sorted and non-overlapping. It performs a binary search (<code>FindFile</code>) to quickly locate the <em>single</em> file that <em>might</em> contain the key. It checks that file's key range and then searches it using the <code>TableCache</code>.</li>
<li>The search stops as soon as the key is found (either a value or a deletion marker) in any file. If it searches all relevant files in all levels without finding the key, it returns <code>NotFound</code>.</li>
</ol>
<p>The <code>Version</code> object acts as the map, guiding the search to the correct SSTable files.</p>
<h2><a class="anchor" id="autotoc_md2285"></a>
How State Changes: Applying VersionEdits</h2>
<p>The database state doesn't stand still. MemTables are flushed, compactions happen. How does the <code>VersionSet</code> update the state? By applying <code>VersionEdit</code>s.</p>
<p>When a background task (like flushing the immutable MemTable or running a compaction) finishes, it creates a <code>VersionEdit</code> describing the changes it made (e.g., "add file X, remove file Y"). It then asks the <code>VersionSet</code> to apply this edit.</p>
<p>The core logic is in <code>VersionSet::LogAndApply</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/version_set.cc ---</span></div>
<div class="line"> </div>
<div class="line">Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {</div>
<div class="line">  <span class="comment">// 1. Fill in metadata in the edit (log number, sequence number etc.)</span></div>
<div class="line">  <span class="comment">// ... set edit-&gt;log_number_, edit-&gt;last_sequence_, etc. ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 2. Create a new Version based on the current one + the edit</span></div>
<div class="line">  Version* v = <span class="keyword">new</span> Version(<span class="keyword">this</span>);</div>
<div class="line">  {</div>
<div class="line">    Builder builder(<span class="keyword">this</span>, current_); <span class="comment">// Builder starts with &#39;current_&#39; state</span></div>
<div class="line">    builder.Apply(edit);             <span class="comment">// Apply the changes described by &#39;edit&#39;</span></div>
<div class="line">    builder.SaveTo(v);               <span class="comment">// Save the resulting state into &#39;v&#39;</span></div>
<div class="line">  }</div>
<div class="line">  Finalize(v); <span class="comment">// Calculate compaction score/level for the new version</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 3. Write the edit to the MANIFEST file (for persistence)</span></div>
<div class="line">  std::string record;</div>
<div class="line">  edit-&gt;EncodeTo(&amp;record); <span class="comment">// Serialize the VersionEdit</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Unlock mutex while writing to disk (can be slow)</span></div>
<div class="line">  mu-&gt;Unlock();</div>
<div class="line">  Status s = descriptor_log_-&gt;AddRecord(record); <span class="comment">// Append edit to MANIFEST log</span></div>
<div class="line">  <span class="keywordflow">if</span> (s.ok()) {</div>
<div class="line">    s = descriptor_file_-&gt;Sync(); <span class="comment">// Ensure MANIFEST write is durable</span></div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// ... handle MANIFEST write errors ...</span></div>
<div class="line">  mu-&gt;Lock(); <span class="comment">// Re-lock mutex</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// 4. Install the new version as the &#39;current&#39; one</span></div>
<div class="line">  <span class="keywordflow">if</span> (s.ok()) {</div>
<div class="line">    AppendVersion(v); <span class="comment">// Make &#39;v&#39; the new current_ version</span></div>
<div class="line">    <span class="comment">// Update VersionSet&#39;s metadata based on the edit</span></div>
<div class="line">    log_number_ = edit-&gt;log_number_;</div>
<div class="line">    prev_log_number_ = edit-&gt;prev_log_number_;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="keyword">delete</span> v; <span class="comment">// Discard the new version if MANIFEST write failed</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> s;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b>Prepare Edit:</b> Fills in missing metadata fields in the <code>VersionEdit</code> (like the current log number and last sequence number).</li>
<li><b>Build New Version:</b> Creates a temporary <code>Builder</code> object, initialized with the state of the <code>current_</code> version. It applies the changes from the <code>edit</code> to this builder and then saves the resulting state into a completely <em>new</em> <code>Version</code> object (<code>v</code>).</li>
<li><b>Log to MANIFEST:</b> Serializes the <code>VersionEdit</code> into a string (<code>record</code>) and appends it to the <code>MANIFEST</code> log file (<code>descriptor_log_</code>). This step makes the state change persistent. If the database crashes and restarts, it can replay the <code>MANIFEST</code> file to recover the state.</li>
<li><b>Install New Version:</b> If the <code>MANIFEST</code> write succeeds, it calls <code>AppendVersion(v)</code>. This crucial step updates the <code>current_</code> pointer in the <code>VersionSet</code> to point to the newly created <code>Version</code> <code>v</code>. Future read operations will now use this new version. It also updates the <code>VersionSet</code>'s own metadata (like <code>log_number_</code>).</li>
</ol>
<p>This process ensures that the database state transitions atomically: a new <code>Version</code> only becomes <code>current</code> <em>after</em> the changes it represents have been safely recorded in the <code>MANIFEST</code>.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant BG as Background Task (Flush/Compact)</div>
<div class="line">    participant VE as VersionEdit</div>
<div class="line">    participant VS as VersionSet</div>
<div class="line">    participant VSCur as Current Version</div>
<div class="line">    participant VSBld as VersionSet::Builder</div>
<div class="line">    participant V as New Version</div>
<div class="line">    participant Manifest as MANIFEST Log File</div>
<div class="line"> </div>
<div class="line">    BG -&gt;&gt; VE: Create edit (add file X, remove Y)</div>
<div class="line">    BG -&gt;&gt; VS: LogAndApply(edit)</div>
<div class="line">    VS -&gt;&gt; VSCur: Get current state</div>
<div class="line">    VS -&gt;&gt; VSBld: Create Builder(based on VSCur)</div>
<div class="line">    VSBld -&gt;&gt; VE: Apply(edit)</div>
<div class="line">    VSBld -&gt;&gt; V: Save resulting state to New Version</div>
<div class="line">    VS -&gt;&gt; V: Finalize()</div>
<div class="line">    VE -&gt;&gt; VE: EncodeTo(record)</div>
<div class="line">    VS -&gt;&gt; Manifest: AddRecord(record)</div>
<div class="line">    Manifest --&gt;&gt; VS: Write Status OK</div>
<div class="line">    VS -&gt;&gt; V: AppendVersion(V)  // Make V the new &#39;current&#39;</div>
<div class="line">    VS -&gt;&gt; VS: Update log_number etc.</div>
<div class="line">    VS --&gt;&gt; BG: Return OK</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2286"></a>
Version Lifecycle and Snapshots</h2>
<p>Why keep old <code>Version</code> objects around if we have a <code>current</code> one? Because ongoing read operations or snapshots might still need them!</p>
<ul>
<li><b>Reference Counting:</b> Each <code>Version</code> has a reference count (<code>refs_</code>). When <code>DBImpl::Get</code> uses a version, it calls <code>Ref()</code> (increment count) before starting the lookup and <code>Unref()</code> (decrement count) when finished.</li>
<li><b>Snapshots:</b> When you request a snapshot (<code>db-&gt;GetSnapshot()</code>), LevelDB essentially gives you a pointer to the <code>current</code> <code>Version</code> at that moment and increments its reference count. As long as you hold onto that snapshot, the corresponding <code>Version</code> object (and the SSTable files it refers to) won't be deleted, even if the <code>current</code> version advances due to subsequent writes and compactions. This provides a consistent point-in-time view of the data.</li>
<li><b>Cleanup:</b> When a <code>Version</code>'s reference count drops to zero (meaning no reads or snapshots are using it anymore), it can be safely deleted. The <code>VersionSet</code> also keeps track of which underlying SSTable files are no longer referenced by <em>any</em> active <code>Version</code> and can trigger their deletion from disk (<a class="el" href="../../df/dc9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_204__dbimpl.html">DBImpl::RemoveObsoleteFiles</a>).</li>
</ul>
<h2><a class="anchor" id="autotoc_md2287"></a>
The MANIFEST File</h2>
<p>The <code>MANIFEST</code> file is crucial for durability. It's a log file (like the <a class="el" href="../../df/d85/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_203__write__ahead__log____wal________logwriter__logreader.html">WAL</a>, but for metadata changes) that stores the sequence of <code>VersionEdit</code> records.</p>
<p>When LevelDB starts (<code>DB::Open</code>), the <code>VersionSet::Recover</code> method reads the <code>MANIFEST</code> file from beginning to end. It starts with an empty initial state and applies each <code>VersionEdit</code> it reads, step-by-step, rebuilding the database's file state in memory. This ensures that LevelDB knows exactly which SSTable files were live when it last shut down (or crashed).</p>
<p>Occasionally, the <code>MANIFEST</code> file can grow large. LevelDB might then write a <em>snapshot</em> of the entire current state (all files in all levels) as a single large record into a <em>new</em> <code>MANIFEST</code> file and then switch subsequent edits to that new file. This prevents the recovery process from becoming too slow.</p>
<h2><a class="anchor" id="autotoc_md2288"></a>
Conclusion</h2>
<p><code>Version</code>, <code>VersionEdit</code>, and <code>VersionSet</code> form the core cataloguing system of LevelDB.</p>
<ul>
<li><b>Version:</b> An immutable snapshot of which SSTable files exist at each level. Used by reads to find data.</li>
<li><b>VersionEdit:</b> A description of changes (files added/deleted, metadata updated) between versions. Persisted in the <code>MANIFEST</code> log.</li>
<li><b>VersionSet:</b> Manages the <code>current</code> Version, applies edits to create new versions, handles recovery from the <code>MANIFEST</code>, and manages metadata like file numbers and sequence numbers.</li>
</ul>
<p>Together, they allow LevelDB to manage a constantly changing set of files on disk while providing consistent views for read operations and ensuring the database state can be recovered after a restart.</p>
<p>Now that we understand how LevelDB finds data (checking MemTables, then using the current <code>Version</code> to check SSTables via the <code>TableCache</code>), how does it provide a way to <em>scan</em> through data, not just get single keys?</p>
<p>Next up: <a class="el" href="../../d8/dd9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_207__iterator.html">Chapter 7: Iterator</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
