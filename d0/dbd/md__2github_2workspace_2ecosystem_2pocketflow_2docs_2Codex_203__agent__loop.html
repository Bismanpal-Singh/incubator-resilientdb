#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_agent_loop</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/dbd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_203__agent__loop.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_agent_loop</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1274"></a>
autotoc_md1274</h2>
<p>layout: default title: "Agent Loop" parent: "Codex" </p>
<h2><a class="anchor" id="autotoc_md1275"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md1276"></a>
Chapter 3: Agent Loop</h1>
<p>In the <a class="el" href="../../d3/dac/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_202__input__handling____textbuffer__editor__.html">previous chapter</a>, we saw how Codex captures your commands and messages using a neat multi-line input editor. But once you hit Enter, where does that input <em>go</em>? What part of Codex actually understands your request, talks to the AI, and makes things happen?</p>
<p>Meet the <b>Agent Loop</b>, the heart and brain of the Codex CLI.</p>
<h2><a class="anchor" id="autotoc_md1277"></a>
What's the Big Idea? Like a Helpful Assistant</h2>
<p>Imagine you have a very capable personal assistant. You give them a task, like "Find the latest sales report, summarize it, and email it to the team." Your assistant doesn't just magically do it all at once. They follow a process:</p>
<ol type="1">
<li><b>Understand the Request:</b> Listen carefully to what you asked for.</li>
<li><b>Gather Information:</b> Look for the sales report file.</li>
<li><b>Perform Actions:</b> Read the report, write a summary.</li>
<li><b>Ask for Confirmation (if needed):</b> "I've drafted the summary and email. Should I send it now?"</li>
<li><b>Complete the Task:</b> Send the email after getting your 'yes'.</li>
<li><b>Report Back:</b> Let you know the email has been sent.</li>
</ol>
<p>The <b>Agent Loop</b> in Codex acts much like this assistant. It's the central piece of logic that manages the entire conversation and workflow between you and the AI model (like OpenAI's GPT-4).</p>
<p>Let's take our simple example: You type <code>codex "write a python script that prints hello world and run it"</code>.</p>
<p>The Agent Loop is responsible for:</p>
<ol type="1">
<li>Taking your input ("write a python script...").</li>
<li>Sending this request to the powerful AI model via the OpenAI API.</li>
<li>Getting the AI's response, which might include:<ul>
<li>Text: "Okay, here's the script..."</li>
<li>A request to perform an action (a "function call"): "I need to run this command: `python -c 'print(\"hello world\")'`"</li>
</ul>
</li>
<li>Showing you the text part of the response in the <a class="el" href="../../dd/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_201__terminal__ui____ink__components__.html">Terminal UI</a>.</li>
<li>Handling the "function call":<ul>
<li>Checking if it needs your permission based on the <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy</a>.</li>
<li>If needed, asking you "Allow command?" via the UI.</li>
<li>If approved, actually running the command using the <a class="el" href="../../dd/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_206__command__execution______sandboxing.html">Command Execution &amp; Sandboxing</a> system.</li>
</ul>
</li>
<li>Getting the result of the command (the output "hello world").</li>
<li>Sending that result back to the AI ("I ran the command, and it printed 'hello world'").</li>
<li>Getting the AI's final response (maybe: "Great, the script ran successfully!").</li>
<li>Showing you the final response.</li>
<li>Updating the conversation history with everything that happened.</li>
</ol>
<p>It's called a "loop" because it often goes back and forth between you, the AI, and tools (like the command line) until your request is fully handled.</p>
<h2><a class="anchor" id="autotoc_md1278"></a>
How It Works: The Conversation Cycle</h2>
<p>The Agent Loop orchestrates a cycle:</p>
<div class="fragment"><div class="line">graph TD</div>
<div class="line">    A[User Input] --&gt; B[Agent Loop]</div>
<div class="line">    B --&gt; C{Send to AI Model}</div>
<div class="line">    C --&gt; D[AI Response: Text or Tool Call]</div>
<div class="line">    D --&gt; B</div>
<div class="line">    B --&gt; E{Process Response}</div>
<div class="line">    E -- Text --&gt; F[Show Text in UI]</div>
<div class="line">    E -- Tool Call --&gt; G{Handle Tool Call}</div>
<div class="line">    G --&gt; H{Needs Approval?}</div>
<div class="line">    H -- Yes --&gt; I[Ask User via UI]</div>
<div class="line">    I --&gt; J{User Approves?}</div>
<div class="line">    H -- No --&gt; K[Execute Tool]</div>
<div class="line">    J -- Yes --&gt; K</div>
<div class="line">    J -- No --&gt; L[Report Denial to AI]</div>
<div class="line">    K --&gt; M[Get Tool Result]</div>
<div class="line">    M --&gt; B</div>
<div class="line">    L --&gt; B</div>
<div class="line">    F --&gt; N[Update History]</div>
<div class="line">    M --&gt; N</div>
<div class="line">    L --&gt; N</div>
<div class="line">    N --&gt; O[Ready for next Input/Step]</div>
</div><!-- fragment --><ol type="1">
<li><b>Input:</b> Gets input from you (via the <a class="el" href="../../d3/dac/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_202__input__handling____textbuffer__editor__.html">Input Handling</a>).</li>
<li><b>AI Call:</b> Sends the current conversation state (including your latest input and any previous steps) to the AI model (OpenAI API).</li>
<li><b>Response Processing:</b> Receives the AI's response. This could be simple text, or it could include a request to use a tool (like running a shell command). This is covered more in <a class="el" href="../../dc/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_205__response______tool__call__handling.html">Response &amp; Tool Call Handling</a>.</li>
<li><b>Tool Handling:</b> If the AI requested a tool:<ul>
<li>Check the <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy</a>.</li>
<li>Potentially ask you for confirmation via the <a class="el" href="../../dd/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_201__terminal__ui____ink__components__.html">Terminal UI</a>.</li>
<li>If approved, execute the tool via <a class="el" href="../../dd/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_206__command__execution______sandboxing.html">Command Execution &amp; Sandboxing</a>.</li>
<li>Package the tool's result (e.g., command output) to send back to the AI in the next step.</li>
</ul>
</li>
<li><b>Update State:</b> Adds the AI's message and any tool results to the conversation history. Shows updates in the UI.</li>
<li><b>Loop:</b> If the task isn't finished (e.g., because a tool was used and the AI needs to react to the result), it sends the updated conversation back to the AI (Step 2). If the task <em>is</em> finished, it waits for your next input.</li>
</ol>
<h2><a class="anchor" id="autotoc_md1279"></a>
Using the Agent Loop (From the UI's Perspective)</h2>
<p>You don't directly interact with the <code>AgentLoop</code> class code when <em>using</em> Codex. Instead, the main UI component (<code>TerminalChat</code> in <code>terminal-chat.tsx</code>) creates and manages an <code>AgentLoop</code> instance.</p>
<p>Think of the UI component holding the "remote control" for the Agent Loop assistant.</p>
<div class="fragment"><div class="line">// File: codex-cli/src/components/chat/terminal-chat.tsx (Highly Simplified)</div>
<div class="line">import React, { useState, useEffect, useRef } from &quot;react&quot;;</div>
<div class="line">import { AgentLoop } from &quot;../../utils/agent/agent-loop&quot;;</div>
<div class="line">// ... other imports: UI components, config types ...</div>
<div class="line"> </div>
<div class="line">export default function TerminalChat({ config, approvalPolicy, /* ... */ }) {</div>
<div class="line">  const [items, setItems] = useState([]); // Holds conversation messages</div>
<div class="line">  const [loading, setLoading] = useState(false); // Is the assistant busy?</div>
<div class="line">  const [confirmationPrompt, setConfirmationPrompt] = useState(null); // Command to review?</div>
<div class="line">  const agentRef = useRef&lt;AgentLoop | null&gt;(null); // Holds the assistant instance</div>
<div class="line"> </div>
<div class="line">  // Create the assistant when the component loads or config changes</div>
<div class="line">  useEffect(() =&gt; {</div>
<div class="line">    agentRef.current = new AgentLoop({</div>
<div class="line">      model: config.model,</div>
<div class="line">      config: config,</div>
<div class="line">      approvalPolicy: approvalPolicy,</div>
<div class="line">      // --- Callbacks: How the assistant reports back ---</div>
<div class="line">      onItem: (newItem) =&gt; { // When the assistant has a message/result</div>
<div class="line">        setItems((prev) =&gt; [...prev, newItem]); // Add it to our chat history</div>
<div class="line">      },</div>
<div class="line">      onLoading: (isLoading) =&gt; { // When the assistant starts/stops thinking</div>
<div class="line">        setLoading(isLoading);</div>
<div class="line">      },</div>
<div class="line">      getCommandConfirmation: async (command, /*...*/) =&gt; { // When the assistant needs approval</div>
<div class="line">        // Show the command in the UI and wait for user&#39;s Yes/No</div>
<div class="line">        const userDecision = await showConfirmationUI(command);</div>
<div class="line">        return { review: userDecision /* ... */ };</div>
<div class="line">      },</div>
<div class="line">      // ... other callbacks like onLastResponseId ...</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    return () =&gt; agentRef.current?.terminate(); // Clean up when done</div>
<div class="line">  }, [config, approvalPolicy /* ... */]);</div>
<div class="line"> </div>
<div class="line">  // --- Function to send user input to the assistant ---</div>
<div class="line">  const submitInputToAgent = (userInput) =&gt; {</div>
<div class="line">    if (agentRef.current) {</div>
<div class="line">      // Tell the assistant to process this input</div>
<div class="line">      agentRef.current.run([userInput /* ... */]);</div>
<div class="line">    }</div>
<div class="line">  };</div>
<div class="line"> </div>
<div class="line">  // --- UI Rendering ---</div>
<div class="line">  return (</div>
<div class="line">    &lt;Box&gt;</div>
<div class="line">      {/* Display &#39;items&#39; using TerminalMessageHistory */}</div>
<div class="line">      {/* Display input box (TerminalChatInput) or confirmationPrompt */}</div>
<div class="line">      {/* Pass `submitInputToAgent` to the input box */}</div>
<div class="line">      {/* Pass function to handle confirmation decision */}</div>
<div class="line">    &lt;/Box&gt;</div>
<div class="line">  );</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Initialization:</b> The UI creates an <code>AgentLoop</code>, giving it the necessary configuration (<a class="el" href="../../d2/d53/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_207__configuration__management.html">Configuration Management</a>) and crucial <b>callback functions</b>. These callbacks are how the Agent Loop communicates back to the UI:<ul>
<li><code>onItem</code>: "Here's a new message (from user, AI, or tool) to display."</li>
<li><code>onLoading</code>: "I'm starting/stopping my work."</li>
<li><code>getCommandConfirmation</code>: "I need to run this command. Please ask the user and tell me their decision."</li>
</ul>
</li>
<li><b>Running:</b> When you submit input via the <code>&lt;TerminalChatInput&gt;</code>, the UI calls the <code>agentRef.current.run(...)</code> method, handing off your request to the Agent Loop.</li>
<li><b>Updates:</b> The Agent Loop does its work, calling the <code>onItem</code> and <code>onLoading</code> callbacks whenever something changes. The UI listens to these callbacks and updates the display accordingly (setting state variables like <code>items</code> and <code>loading</code>, which causes React to re-render).</li>
<li><b>Confirmation:</b> If the Agent Loop needs approval, it calls <code>getCommandConfirmation</code>. The UI pauses, shows the command review prompt, waits for your decision, and then returns the decision back to the Agent Loop, which then proceeds or stops based on your choice.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1280"></a>
Under the Hood: A Step-by-Step Flow</h2>
<p>Let's trace our "hello world" example again, focusing on the interactions:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant InkUI as Terminal UI (Ink)</div>
<div class="line">    participant AgentLoop</div>
<div class="line">    participant OpenAI</div>
<div class="line">    participant CmdExec as Command Execution</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;InkUI: Types &quot;write &amp; run hello world&quot;, presses Enter</div>
<div class="line">    InkUI-&gt;&gt;AgentLoop: Calls `run([&quot;write &amp; run...&quot;])`</div>
<div class="line">    AgentLoop-&gt;&gt;AgentLoop: Sets loading=true (calls `onLoading(true)`)</div>
<div class="line">    InkUI-&gt;&gt;User: Shows loading indicator</div>
<div class="line">    AgentLoop-&gt;&gt;OpenAI: Sends request: [&quot;write &amp; run...&quot;]</div>
<div class="line">    OpenAI--&gt;&gt;AgentLoop: Streams response: [Text: &quot;Okay, try:&quot;, ToolCall: `shell(...)`]</div>
<div class="line">    AgentLoop-&gt;&gt;InkUI: Calls `onItem(Text: &quot;Okay, try:&quot;)`</div>
<div class="line">    InkUI-&gt;&gt;User: Displays &quot;Okay, try:&quot;</div>
<div class="line">    AgentLoop-&gt;&gt;AgentLoop: Processes ToolCall `shell(...)`</div>
<div class="line">    Note over AgentLoop: Checks Approval Policy</div>
<div class="line">    AgentLoop-&gt;&gt;InkUI: Calls `getCommandConfirmation([&quot;python&quot;, &quot;-c&quot;, &quot;...&quot;])`</div>
<div class="line">    InkUI-&gt;&gt;User: Displays &quot;Allow command: python -c &#39;...&#39;?&quot; [Yes/No]</div>
<div class="line">    User-&gt;&gt;InkUI: Clicks/Types &#39;Yes&#39;</div>
<div class="line">    InkUI--&gt;&gt;AgentLoop: Returns confirmation result ({ review: YES })</div>
<div class="line">    AgentLoop-&gt;&gt;CmdExec: Executes `python -c &#39;print(&quot;hello world&quot;)&#39;`</div>
<div class="line">    CmdExec--&gt;&gt;AgentLoop: Returns result (stdout: &quot;hello world&quot;, exit code: 0)</div>
<div class="line">    AgentLoop-&gt;&gt;AgentLoop: Creates `function_call_output` item</div>
<div class="line">    AgentLoop-&gt;&gt;OpenAI: Sends request: [..., ToolCall: `shell(...)`, Output: &quot;hello world&quot;]</div>
<div class="line">    OpenAI--&gt;&gt;AgentLoop: Streams response: [Text: &quot;Command ran successfully!&quot;]</div>
<div class="line">    AgentLoop-&gt;&gt;InkUI: Calls `onItem(Text: &quot;Command ran...&quot;)`</div>
<div class="line">    InkUI-&gt;&gt;User: Displays &quot;Command ran successfully!&quot;</div>
<div class="line">    AgentLoop-&gt;&gt;AgentLoop: Sets loading=false (calls `onLoading(false)`)</div>
<div class="line">    InkUI-&gt;&gt;User: Hides loading indicator, shows input prompt</div>
</div><!-- fragment --><p>This diagram shows the back-and-forth orchestration performed by the Agent Loop, coordinating between the UI, the AI model, and the command execution system.</p>
<h2><a class="anchor" id="autotoc_md1281"></a>
Inside <code>agent-loop.ts</code></h2>
<p>The core logic lives in <code>codex-cli/src/utils/agent/agent-loop.ts</code>. Let's peek at a <em>very</em> simplified structure:</p>
<div class="fragment"><div class="line">// File: codex-cli/src/utils/agent/agent-loop.ts (Simplified)</div>
<div class="line">import OpenAI from &quot;openai&quot;;</div>
<div class="line">// ... other imports: types for config, responses, approval ...</div>
<div class="line">import { handleExecCommand } from &quot;./handle-exec-command&quot;; // For tool calls</div>
<div class="line"> </div>
<div class="line">export class AgentLoop {</div>
<div class="line">  private oai: OpenAI; // The OpenAI client instance</div>
<div class="line">  private model: string;</div>
<div class="line">  private config: AppConfig;</div>
<div class="line">  private approvalPolicy: ApprovalPolicy;</div>
<div class="line">  // Callbacks provided by the UI:</div>
<div class="line">  private onItem: (item: ResponseItem) =&gt; void;</div>
<div class="line">  private onLoading: (loading: boolean) =&gt; void;</div>
<div class="line">  private getCommandConfirmation: (/*...*/) =&gt; Promise&lt;CommandConfirmation&gt;;</div>
<div class="line">  // ... other state like current stream, cancellation flags ...</div>
<div class="line"> </div>
<div class="line">  constructor({ model, config, approvalPolicy, onItem, onLoading, getCommandConfirmation, /*...*/ }: AgentLoopParams) {</div>
<div class="line">    this.model = model;</div>
<div class="line">    this.config = config;</div>
<div class="line">    this.approvalPolicy = approvalPolicy;</div>
<div class="line">    this.onItem = onItem;</div>
<div class="line">    this.onLoading = onLoading;</div>
<div class="line">    this.getCommandConfirmation = getCommandConfirmation;</div>
<div class="line">    this.oai = new OpenAI({ /* ... API key, base URL ... */ });</div>
<div class="line">    // ... initialize other state ...</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // The main method called by the UI</div>
<div class="line">  public async run(input: Array&lt;ResponseInputItem&gt;, previousResponseId: string = &quot;&quot;): Promise&lt;void&gt; {</div>
<div class="line">    this.onLoading(true); // Signal start</div>
<div class="line">    let turnInput = input; // Input for this step of the loop</div>
<div class="line">    let lastResponseId = previousResponseId;</div>
<div class="line"> </div>
<div class="line">    try {</div>
<div class="line">      // Keep looping as long as there&#39;s input (initially user msg, later tool results)</div>
<div class="line">      while (turnInput.length &gt; 0) {</div>
<div class="line">        // 1. Send current input history to OpenAI API</div>
<div class="line">        const stream = await this.oai.responses.create({</div>
<div class="line">          model: this.model,</div>
<div class="line">          input: turnInput, // Includes user message or tool results</div>
<div class="line">          previous_response_id: lastResponseId || undefined,</div>
<div class="line">          stream: true,</div>
<div class="line">          // ... other parameters like instructions, tools ...</div>
<div class="line">        });</div>
<div class="line"> </div>
<div class="line">        turnInput = []; // Clear input for the next loop iteration</div>
<div class="line"> </div>
<div class="line">        // 2. Process the stream of events from OpenAI</div>
<div class="line">        for await (const event of stream) {</div>
<div class="line">          if (event.type === &quot;response.output_item.done&quot;) {</div>
<div class="line">            const item = event.item; // Could be text, function_call, etc.</div>
<div class="line">            this.onItem(item as ResponseItem); // Send item to UI to display</div>
<div class="line">          }</div>
<div class="line">          if (event.type === &quot;response.completed&quot;) {</div>
<div class="line">            lastResponseId = event.response.id; // Remember the ID for the next call</div>
<div class="line">            // Check the final output for tool calls</div>
<div class="line">            for (const item of event.response.output) {</div>
<div class="line">              if (item.type === &quot;function_call&quot;) {</div>
<div class="line">                 // Handle the tool call (ask for approval, execute)</div>
<div class="line">                 // This might add a &#39;function_call_output&#39; to `turnInput`</div>
<div class="line">                 const toolResults = await this.handleFunctionCall(item);</div>
<div class="line">                 turnInput.push(...toolResults);</div>
<div class="line">              }</div>
<div class="line">            }</div>
<div class="line">          }</div>
<div class="line">          // ... handle other event types ...</div>
<div class="line">        } // End stream processing</div>
<div class="line">      } // End while loop (no more input for this turn)</div>
<div class="line">    } catch (error) {</div>
<div class="line">      // ... Handle errors (network issues, API errors etc.) ...</div>
<div class="line">      this.onItem(/* Create system error message */);</div>
<div class="line">    } finally {</div>
<div class="line">      this.onLoading(false); // Signal end</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // Helper to handle tool/function calls</div>
<div class="line">  private async handleFunctionCall(item: ResponseFunctionToolCall): Promise&lt;Array&lt;ResponseInputItem&gt;&gt; {</div>
<div class="line">    // ... Parse arguments from &#39;item&#39; ...</div>
<div class="line">    const args = /* ... parse item.arguments ... */;</div>
<div class="line">    let outputText = &quot;Error: Unknown function&quot;;</div>
<div class="line">    let metadata = {};</div>
<div class="line"> </div>
<div class="line">    if (item.name === &quot;shell&quot;) { // Example: handle shell commands</div>
<div class="line">       // This uses the approval policy and getCommandConfirmation callback!</div>
<div class="line">       const result = await handleExecCommand(</div>
<div class="line">         args,</div>
<div class="line">         this.config,</div>
<div class="line">         this.approvalPolicy,</div>
<div class="line">         this.getCommandConfirmation,</div>
<div class="line">         /* ... cancellation signal ... */</div>
<div class="line">       );</div>
<div class="line">       outputText = result.outputText;</div>
<div class="line">       metadata = result.metadata;</div>
<div class="line">    }</div>
<div class="line">    // ... handle other function names ...</div>
<div class="line"> </div>
<div class="line">    // Format the result to send back to OpenAI in the next turn</div>
<div class="line">    const outputItem: ResponseInputItem.FunctionCallOutput = {</div>
<div class="line">      type: &quot;function_call_output&quot;,</div>
<div class="line">      call_id: item.call_id, // Link to the specific function call</div>
<div class="line">      output: JSON.stringify({ output: outputText, metadata }),</div>
<div class="line">    };</div>
<div class="line">    return [outputItem]; // This goes into `turnInput` for the next loop</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  // ... other methods like cancel(), terminate() ...</div>
<div class="line">}</div>
</div><!-- fragment --><ul>
<li><b>Constructor:</b> Sets up the connection to OpenAI and stores the configuration and callbacks passed in by the UI.</li>
<li><b><code>run()</code>:</b> This is the main engine.<ul>
<li>It signals loading starts (<code>onLoading(true)</code>).</li>
<li>It enters a <code>while</code> loop that continues as long as there's something to send to the AI (initially the user's message, later potentially the results from tools).</li>
<li>Inside the loop, it calls <code>this.oai.responses.create()</code> to talk to the AI model, sending the current conversation turn.</li>
<li>It processes the <code>stream</code> of events coming back from the AI.</li>
<li>For each piece of content (<code>response.output_item.done</code>), it calls <code>onItem</code> to show it in the UI.</li>
<li>When the AI's turn is complete (<code>response.completed</code>), it checks if the AI asked to use any tools (<code>function_call</code>).</li>
<li>If a tool call is found, it calls <code>handleFunctionCall</code>.</li>
</ul>
</li>
<li><b><code>handleFunctionCall()</code>:</b><ul>
<li>Parses the details of the tool request (e.g., the command arguments).</li>
<li>Uses <code>handleExecCommand</code> (which contains logic related to <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy</a> and <a class="el" href="../../dd/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_206__command__execution______sandboxing.html">Command Execution</a>) to potentially run the command, using the <code>getCommandConfirmation</code> callback if needed.</li>
<li>Formats the result of the tool execution (e.g., command output) into a specific <code>function_call_output</code> message.</li>
<li>Returns this output message. The <code>run</code> method adds this to <code>turnInput</code>, so the <em>next</em> iteration of the <code>while</code> loop will send this result back to the AI, letting it know what happened.</li>
</ul>
</li>
<li><b>Finally:</b> Once the <code>while</code> loop finishes (meaning the AI didn't request any more tools in its last response), it signals loading is done (<code>onLoading(false)</code>).</li>
</ul>
<p>This loop ensures that the conversation flows logically, handling text, tool requests, user approvals, and tool results in a structured way.</p>
<h2><a class="anchor" id="autotoc_md1282"></a>
Conclusion</h2>
<p>The Agent Loop is the central orchestrator within Codex. It acts like a diligent assistant, taking your requests, interacting with the powerful AI model, managing tools like shell commands, ensuring safety through approvals, and keeping the conversation state updated. It connects the <a class="el" href="../../dd/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_201__terminal__ui____ink__components__.html">Terminal UI</a> where you interact, the <a class="el" href="../../d3/dac/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_202__input__handling____textbuffer__editor__.html">Input Handling</a> that captures your text, the AI model that provides intelligence, and the systems that actually execute actions (<a class="el" href="../../dd/deb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_206__command__execution______sandboxing.html">Command Execution &amp; Sandboxing</a>).</p>
<p>Understanding the Agent Loop helps you see how Codex manages the complex back-and-forth required to turn your natural language requests into concrete actions. But when the Agent Loop wants to run a command suggested by the AI, how does Codex decide whether to ask for your permission first? That crucial safety mechanism is the topic of our next chapter.</p>
<p>Next up: <a class="el" href="../../d9/dc7/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Codex_204__approval__policy______security.html">Approval Policy &amp; Security</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
