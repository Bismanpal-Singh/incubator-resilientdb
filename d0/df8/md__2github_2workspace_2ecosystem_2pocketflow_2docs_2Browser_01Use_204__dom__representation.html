#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_dom_representation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/df8/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_204__dom__representation.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_dom_representation</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md892"></a>
autotoc_md892</h2>
<p>layout: default title: "DOM Representation" parent: "Browser Use" </p>
<h2><a class="anchor" id="autotoc_md893"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md894"></a>
Chapter 4: DOM Representation - Mapping the Webpage</h1>
<p>In the <a class="el" href="../../dd/da5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_203__browsercontext.html">previous chapter</a>, we learned about the <code>BrowserContext</code>, the Agent's private workspace for browsing. We saw that the Agent uses <code>browser_context.get_state()</code> to get a snapshot of the current webpage. But how does the Agent actually <em>understand</em> the content of that snapshot?</p>
<p>Imagine you're looking at the Google homepage. You instantly recognize the logo, the search bar, and the buttons. But a computer program just sees a wall of code (HTML). How can our <code>Agent</code> figure out: "This rectangular box is the search bar I need to type into," or "This specific image link is the first result I should click"?</p>
<p>This is the problem solved by <b>DOM Representation</b>.</p>
<h2><a class="anchor" id="autotoc_md895"></a>
What Problem Does DOM Representation Solve?</h2>
<p>Webpages are built using HTML (HyperText Markup Language), which describes the structure and content. Your browser reads this HTML and creates an internal, structured representation called the <b>Document Object Model (DOM)</b>. It's like the browser builds a detailed blueprint or an outline from the HTML instructions.</p>
<p>However, this raw DOM blueprint is incredibly complex and contains lots of information irrelevant to our Agent's task. The Agent doesn't need to know about every single tiny visual detail; it needs a <em>simplified map</em> focused on what's important for interaction:</p>
<ol type="1">
<li><b>What elements are on the page?</b> (buttons, links, input fields, text)</li>
<li><b>Are they visible to a user?</b> (Hidden elements shouldn't be interacted with)</li>
<li><b>Are they interactive?</b> (Can you click it? Can you type in it?)</li>
<li><b>How can the Agent refer to them?</b> (We need a simple way to say "click *this* button")</li>
</ol>
<p>DOM Representation solves the problem of translating the complex, raw DOM blueprint into a simplified, structured map that highlights the interactive "landmarks" and pathways the Agent can use.</p>
<h2><a class="anchor" id="autotoc_md896"></a>
Meet <code>DomService</code>: The Map Maker</h2>
<p>The component responsible for creating this map is the <code>DomService</code>. Think of it as a cartographer specializing in webpages.</p>
<p>When the <code>Agent</code> (via the <code>BrowserContext</code>) asks for the current state of the page, the <code>BrowserContext</code> employs the <code>DomService</code> to analyze the page's live DOM.</p>
<p>Here's what the <code>DomService</code> does:</p>
<ol type="1">
<li><b>Examines the Live Page:</b> It looks at the current structure rendered in the browser tab, not just the initial HTML source code (because JavaScript can change the page after it loads).</li>
<li><b>Identifies Elements:</b> It finds all the meaningful elements like buttons, links, input fields, and text blocks.</li>
<li><b>Checks Properties:</b> For each element, it determines crucial properties:<ul>
<li><b>Visibility:</b> Is it actually displayed on the screen?</li>
<li><b>Interactivity:</b> Is it something a user can click, type into, or otherwise interact with?</li>
<li><b>Position:</b> Where is it located (roughly)?</li>
</ul>
</li>
<li><b>Assigns Interaction Indices:</b> This is key! For elements deemed interactive and visible, <code>DomService</code> assigns a unique number, called a <code>highlight_index</code> (like <code>[5]</code>, <code>[12]</code>, etc.). This gives the Agent and the LLM a simple, unambiguous way to refer to specific elements.</li>
<li><b>Builds a Structured Tree:</b> It organizes this information into a simplified tree structure (<code>element_tree</code>) that reflects the page layout but is much easier to process than the full DOM.</li>
<li><b>Creates an Index Map:</b> It generates a <code>selector_map</code>, which is like an index in a book, mapping each <code>highlight_index</code> directly to its corresponding element node in the tree.</li>
</ol>
<p>The final output is a <code>DOMState</code> object containing the simplified <code>element_tree</code> and the handy <code>selector_map</code>. This <code>DOMState</code> is then included in the <code>BrowserState</code> that <code>BrowserContext.get_state()</code> returns to the Agent.</p>
<h2><a class="anchor" id="autotoc_md897"></a>
The Output: <code>DOMState</code> - The Agent's Map</h2>
<p>The <code>DOMState</code> object produced by <code>DomService</code> has two main parts:</p>
<ol type="1">
<li><p class="startli"><b><code>element_tree</code>:</b> This is the root of our simplified map, represented as a <code>DOMElementNode</code> object (defined in <code>dom/views.py</code>). Each node in the tree can be either an element (<code>DOMElementNode</code>) or a piece of text (<code>DOMTextNode</code>). <code>DOMElementNode</code>s contain information like the tag name (<code>&lt;button&gt;</code>, <code>&lt;input&gt;</code>), attributes (<code>aria-label="Search"</code>), visibility, interactivity, and importantly, the <code>highlight_index</code> if applicable. The tree structure helps understand the page layout (e.g., this button is inside that section).</p>
<p class="startli"><em>Conceptual Example Tree:</em> <code> &lt;body&gt; [no index] |-- &lt;div&gt; [no index] | |-- &lt;input aria-label="Search"&gt; [highlight_index: 5] | +-- &lt;button&gt; [highlight_index: 6] | +-- "Google Search" (TextNode) +-- &lt;a&gt; href="/images"&gt; [highlight_index: 7] +-- "Images" (TextNode) </code></p>
</li>
<li><p class="startli"><b><code>selector_map</code>:</b> This is a Python dictionary that acts as a quick lookup. It maps the integer <code>highlight_index</code> directly to the corresponding <code>DOMElementNode</code> object in the <code>element_tree</code>.</p>
<p class="startli"><em>Conceptual Example Map:</em> <code>python { 5: &lt;DOMElementNode tag_name='input', attributes={'aria-label':'Search'}, ...&gt;, 6: &lt;DOMElementNode tag_name='button', ...&gt;, 7: &lt;DOMElementNode tag_name='a', attributes={'href':'/images'}, ...&gt; } </code></p>
</li>
</ol>
<p>This <code>selector_map</code> is incredibly useful because when the LLM decides "click element 5", the Agent can instantly find the correct <code>DOMElementNode</code> using <code>selector_map[5]</code> and tell the <a class="el" href="../../de/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_205__action__controller______registry.html">Action Controller &amp; Registry</a> exactly which element to interact with.</p>
<h2><a class="anchor" id="autotoc_md898"></a>
How the Agent Uses the Map</h2>
<p>The <code>Agent</code> takes the <code>DOMState</code> (usually simplifying the <code>element_tree</code> further into a text representation) and includes it in the information sent to the LLM. Remember the JSON response format from <a class="el" href="../../dd/d81/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_202__system__prompt.html">Chapter 2</a>? The LLM uses the <code>highlight_index</code> from this map to specify actions:</p>
<div class="fragment"><div class="line">// LLM might receive a simplified text view like:</div>
<div class="line">// &quot;[5]&lt;input aria-label=&#39;Search&#39;&gt;\n[6]&lt;button&gt;Google Search&lt;/button&gt;\n[7]&lt;a&gt;Images&lt;/a&gt;&quot;</div>
<div class="line"> </div>
<div class="line">// And respond with:</div>
<div class="line">{</div>
<div class="line">  &quot;current_state&quot;: {</div>
<div class="line">    &quot;evaluation_previous_goal&quot;: &quot;...&quot;,</div>
<div class="line">    &quot;memory&quot;: &quot;On Google homepage, need to search for cats.&quot;,</div>
<div class="line">    &quot;next_goal&quot;: &quot;Type &#39;cute cats&#39; into the search bar [5].&quot;</div>
<div class="line">  },</div>
<div class="line">  &quot;action&quot;: [</div>
<div class="line">    {</div>
<div class="line">      &quot;input_text&quot;: {</div>
<div class="line">        &quot;index&quot;: 5, // &lt;-- Uses the highlight_index from the DOM map!</div>
<div class="line">        &quot;text&quot;: &quot;cute cats&quot;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">    // ... maybe press Enter action ...</div>
<div class="line">  ]</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md899"></a>
Code Example: Seeing the Map</h2>
<p>We don't usually interact with <code>DomService</code> directly. Instead, we get its output via the <code>BrowserContext</code>. Let's revisit the example from Chapter 3 and see where the DOM representation fits:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"><span class="keyword">from</span> browser_use <span class="keyword">import</span> Browser, BrowserConfig, BrowserContext, BrowserContextConfig</div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span><a class="code hl_namespace" href="../../d2/dc1/namespacemain.html">main</a>():</div>
<div class="line">    browser_config = BrowserConfig(headless=<span class="keyword">False</span>)</div>
<div class="line">    browser = Browser(config=browser_config)</div>
<div class="line">    context_config = BrowserContextConfig()</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async</span> <span class="keyword">with</span> browser.new_context(config=context_config) <span class="keyword">as</span> browser_context:</div>
<div class="line">        <span class="comment"># Navigate to a page (e.g., Google)</span></div>
<div class="line">        await browser_context.navigate_to(<span class="stringliteral">&quot;https://www.google.com&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        print(<span class="stringliteral">&quot;Getting current page state...&quot;</span>)</div>
<div class="line">        <span class="comment"># This call uses DomService internally to generate the DOM representation</span></div>
<div class="line">        current_state = await browser_context.get_state()</div>
<div class="line"> </div>
<div class="line">        print(f<span class="stringliteral">&quot;\nCurrent Page URL: {current_state.url}&quot;</span>)</div>
<div class="line">        print(f<span class="stringliteral">&quot;Current Page Title: {current_state.title}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># Accessing the DOM Representation parts within the BrowserState</span></div>
<div class="line">        print(<span class="stringliteral">&quot;\n--- DOM Representation Details ---&quot;</span>)</div>
<div class="line">        <span class="comment"># The element_tree is the root node of our simplified DOM map</span></div>
<div class="line">        <span class="keywordflow">if</span> current_state.element_tree:</div>
<div class="line">            print(f<span class="stringliteral">&quot;Root element tag of simplified tree: &lt;{current_state.element_tree.tag_name}&gt;&quot;</span>)</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            print(<span class="stringliteral">&quot;Element tree is empty.&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># The selector_map provides direct access to interactive elements by index</span></div>
<div class="line">        <span class="keywordflow">if</span> current_state.selector_map:</div>
<div class="line">            print(f<span class="stringliteral">&quot;Number of interactive elements found: {len(current_state.selector_map)}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># Let&#39;s try to find the element the LLM might call [5] (often the search bar)</span></div>
<div class="line">            example_index = 5 <span class="comment"># Note: Indices can change depending on the page!</span></div>
<div class="line">            <span class="keywordflow">if</span> example_index <span class="keywordflow">in</span> current_state.selector_map:</div>
<div class="line">                element_node = current_state.selector_map[example_index]</div>
<div class="line">                print(f<span class="stringliteral">&quot;Element [{example_index}]: Tag=&lt;{element_node.tag_name}&gt;, Attributes={element_node.attributes}&quot;</span>)</div>
<div class="line">                <span class="comment"># The Agent uses this node reference to perform actions</span></div>
<div class="line">            <span class="keywordflow">else</span>:</div>
<div class="line">                print(f<span class="stringliteral">&quot;Element [{example_index}] not found in the selector map for this page state.&quot;</span>)</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            print(<span class="stringliteral">&quot;No interactive elements found (selector map is empty).&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># The Agent would typically convert element_tree into a compact text format</span></div>
<div class="line">        <span class="comment"># (using methods like element_tree.clickable_elements_to_string())</span></div>
<div class="line">        <span class="comment"># to send to the LLM along with the task instructions.</span></div>
<div class="line"> </div>
<div class="line">    print(<span class="stringliteral">&quot;\nBrowserContext closed.&quot;</span>)</div>
<div class="line">    await browser.close()</div>
<div class="line">    print(<span class="stringliteral">&quot;Browser closed.&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Run the asynchronous code</span></div>
<div class="line">asyncio.run(<a class="code hl_namespace" href="../../d2/dc1/namespacemain.html">main</a>())</div>
<div class="ttc" id="anamespacemain_html"><div class="ttname"><a href="../../d2/dc1/namespacemain.html">main</a></div><div class="ttdef"><b>Definition</b> <a href="../../dc/dba/main_8py_source.html#l00001">main.py:1</a></div></div>
</div><!-- fragment --><p><b>What happens here?</b></p>
<ol type="1">
<li>We set up the <code>Browser</code> and <code>BrowserContext</code>.</li>
<li>We navigate to Google.</li>
<li><code>browser_context.get_state()</code> is called. <b>Internally</b>, this triggers the <code>DomService</code>.</li>
<li><code>DomService</code> analyzes the Google page, finds interactive elements (like the search bar, buttons), assigns them <code>highlight_index</code> numbers, and builds the <code>element_tree</code> and <code>selector_map</code>.</li>
<li>This <code>DOMState</code> (containing the tree and map) is packaged into the <code>BrowserState</code> object returned by <code>get_state()</code>.</li>
<li>Our code then accesses <code>current_state.element_tree</code> and <code>current_state.selector_map</code> to peek at the map created by <code>DomService</code>.</li>
<li>We demonstrate looking up an element using its potential index (<code>selector_map[5]</code>).</li>
</ol>
<h2><a class="anchor" id="autotoc_md900"></a>
How It Works Under the Hood: <code>DomService</code> in Action</h2>
<p>Let's trace the flow when <code>BrowserContext.get_state()</code> is called:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Agent</div>
<div class="line">    participant BC as BrowserContext</div>
<div class="line">    participant DomService</div>
<div class="line">    participant PlaywrightPage as Browser Page (JS Env)</div>
<div class="line">    participant buildDomTree_js as buildDomTree.js</div>
<div class="line"> </div>
<div class="line">    Agent-&gt;&gt;BC: get_state()</div>
<div class="line">    Note over BC: Needs to analyze the page content</div>
<div class="line">    BC-&gt;&gt;DomService: get_clickable_elements(...)</div>
<div class="line">    Note over DomService: Needs to run analysis script in browser</div>
<div class="line">    DomService-&gt;&gt;PlaywrightPage: evaluate(js_code=&#39;buildDomTree.js&#39;, args={...})</div>
<div class="line">    Note over PlaywrightPage: Execute JavaScript code</div>
<div class="line">    PlaywrightPage-&gt;&gt;buildDomTree_js: Run analysis function</div>
<div class="line">    Note over buildDomTree_js: Analyzes live DOM, finds visible &amp; interactive elements, assigns highlight_index</div>
<div class="line">    buildDomTree_js--&gt;&gt;PlaywrightPage: Return structured data (nodes, indices, map)</div>
<div class="line">    PlaywrightPage--&gt;&gt;DomService: Return JS execution result (JSON-like data)</div>
<div class="line">    Note over DomService: Process the raw data from JS</div>
<div class="line">    DomService-&gt;&gt;DomService: _construct_dom_tree(result)</div>
<div class="line">    Note over DomService: Builds Python DOMElementNode tree and selector_map</div>
<div class="line">    DomService--&gt;&gt;BC: Return DOMState (element_tree, selector_map)</div>
<div class="line">    Note over BC: Combine DOMState with URL, title, screenshot etc.</div>
<div class="line">    BC-&gt;&gt;BC: Create BrowserState object</div>
<div class="line">    BC--&gt;&gt;Agent: Return BrowserState (containing DOM map)</div>
</div><!-- fragment --><p><b>Key Code Points:</b></p>
<ol type="1">
<li><p class="startli"><b><code>BrowserContext</code> calls <code>DomService</code>:</b> Inside <code>browser/context.py</code>, the <code>_update_state</code> method (called by <code>get_state</code>) initializes and uses the <code>DomService</code>:</p>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md901"></a>
&mdash; File: browser/context.py (Simplified _update_state) &mdash;</h1>
<p>from browser_use.dom.service import DomService # Import the service from browser_use.browser.views import BrowserState</p>
<p>class BrowserContext: </p>
<h1><a class="anchor" id="autotoc_md902"></a>
... other methods ...</h1>
<p>async def _update_state(self) -&gt; BrowserState: page = await self.get_current_page() # Get the active Playwright page object </p>
<h1><a class="anchor" id="autotoc_md903"></a>
... error handling ...</h1>
<p>try: </p>
<h1><a class="anchor" id="autotoc_md904"></a>
1. Create DomService instance for the current page</h1>
<p>dom_service = DomService(page)</p>
<h1><a class="anchor" id="autotoc_md905"></a>
2. Call DomService to get the DOM map (DOMState)</h1>
<p>content_info = await dom_service.get_clickable_elements( highlight_elements=self.config.highlight_elements, viewport_expansion=self.config.viewport_expansion, </p>
<h1><a class="anchor" id="autotoc_md906"></a>
... other options ...</h1>
<p>)</p>
<h1><a class="anchor" id="autotoc_md907"></a>
3. Get other info (screenshot, URL, title etc.)</h1>
<p>screenshot_b64 = await self.take_screenshot() url = page.url title = await page.title() </p>
<h1><a class="anchor" id="autotoc_md908"></a>
... gather more state ...</h1>
<h1><a class="anchor" id="autotoc_md909"></a>
4. Package everything into BrowserState</h1>
<p>browser_state = BrowserState( element_tree=content_info.element_tree, # &lt;&mdash; From DomService selector_map=content_info.selector_map, # &lt;&mdash; From DomService url=url, title=title, screenshot=screenshot_b64, </p>
<h1><a class="anchor" id="autotoc_md910"></a>
... other state info ...</h1>
<p>) return browser_state except Exception as e: logger.error(f'Failed to update state: {str(e)}') raise # Or handle error ```</p>
<ol type="1">
<li><p class="startli"><b><code>DomService</code> runs JavaScript:</b> Inside <code>dom/service.py</code>, the <code>_build_dom_tree</code> method executes the JavaScript code stored in <code>buildDomTree.js</code> within the browser page's context.</p>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md911"></a>
&mdash; File: dom/service.py (Simplified _build_dom_tree) &mdash;</h1>
<p>import logging from importlib import resources </p>
<h1><a class="anchor" id="autotoc_md912"></a>
... other imports ...</h1>
<p>logger = logging.getLogger(<b>name</b>)</p>
<p>class DomService: def <b>init</b>(self, page: 'Page'): self.page = page </p>
<h1><a class="anchor" id="autotoc_md913"></a>
Load the JavaScript code from the file when DomService is created</h1>
<p>self.js_code = resources.read_text('browser_use.dom', 'buildDomTree.js') </p>
<h1><a class="anchor" id="autotoc_md914"></a>
...</h1>
<p>async def _build_dom_tree(
            self, highlight_elements: bool, focus_element: int, viewport_expansion: int
        ) -&gt; tuple[DOMElementNode, SelectorMap]: </p><pre class="fragment"># Prepare arguments for the JavaScript function
args = {
    'doHighlightElements': highlight_elements,
    'focusHighlightIndex': focus_element,
    'viewportExpansion': viewport_expansion,
    'debugMode': logger.getEffectiveLevel() == logging.DEBUG,
}

try:
    # Execute the JavaScript code in the browser page!
    # The JS code analyzes the live DOM and returns a structured result.
    eval_page = await self.page.evaluate(self.js_code, args)
except Exception as e:
    logger.error('Error evaluating JavaScript: %s', e)
    raise

# ... (optional debug logging) ...

# Parse the result from JavaScript into Python objects
return await self._construct_dom_tree(eval_page)
</pre><p>async def _construct_dom_tree(self, eval_page: dict) -&gt; tuple[DOMElementNode, SelectorMap]: </p>
<h1><a class="anchor" id="autotoc_md915"></a>
... (logic to parse js_node_map from eval_page) ...</h1>
<h1><a class="anchor" id="autotoc_md916"></a>
... (loops through nodes, creates DOMElementNode/DOMTextNode objects) ...</h1>
<h1><a class="anchor" id="autotoc_md917"></a>
... (builds the tree structure by linking parents/children) ...</h1>
<h1><a class="anchor" id="autotoc_md918"></a>
... (populates the selector_map dictionary) ...</h1>
<h1><a class="anchor" id="autotoc_md919"></a>
This uses the structures defined in dom/views.py</h1>
<h1><a class="anchor" id="autotoc_md920"></a>
...</h1>
<p>root_node = ... # Parsed root DOMElementNode selector_map = ... # Populated dictionary {index: DOMElementNode} return root_node, selector_map </p>
<h1><a class="anchor" id="autotoc_md921"></a>
... other methods like get_clickable_elements ...</h1>
<p>```</p>
<ol type="1">
<li><b><code>buildDomTree.js</code> (Conceptual):</b> This JavaScript file (located at <code>dom/buildDomTree.js</code> in the library) is the core map-making logic that runs <em>inside the browser</em>. It traverses the live DOM, checks element visibility and interactivity using browser APIs (like <code>element.getBoundingClientRect()</code>, <code>window.getComputedStyle()</code>, <code>document.elementFromPoint()</code>), assigns the <code>highlight_index</code>, and packages the results into a structured format that the Python <code>DomService</code> can understand. <em>We don't need to understand the JS code itself, just its purpose.</em></li>
<li><b>Python Data Structures (<code>DOMElementNode</code>, <code>DOMTextNode</code>):</b> The results from the JavaScript are parsed into Python objects defined in <code>dom/views.py</code>. These dataclasses (<code>DOMElementNode</code>, <code>DOMTextNode</code>) hold the information about each mapped element or text segment.</li>
</ol>
<h2><a class="anchor" id="autotoc_md922"></a>
Conclusion</h2>
<p>DOM Representation, primarily handled by the <code>DomService</code>, is crucial for bridging the gap between the complex reality of a webpage (the DOM) and the Agent/LLM's need for a simplified, actionable understanding. By creating a structured <code>element_tree</code> and an indexed <code>selector_map</code>, it provides a clear map of interactive landmarks on the page, identified by simple <code>highlight_index</code> numbers.</p>
<p>This map allows the LLM to make specific plans like "type into element [5]" or "click element [12]", which the Agent can then reliably translate into concrete actions.</p>
<p>Now that we understand how the Agent sees the page, how does it actually <em>perform</em> those actions like clicking or typing? In the next chapter, we'll explore the component responsible for executing the LLM's plan: the <a class="el" href="../../de/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_205__action__controller______registry.html">Action Controller &amp; Registry</a>.</p>
<p><a class="el" href="../../de/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Browser_01Use_205__action__controller______registry.html">Next Chapter: Action Controller &amp; Registry</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
