#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_core_schema___validation_serialization</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_core_schema___validation_serialization</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2880"></a>
autotoc_md2880</h2>
<p>layout: default title: "Core Schema &amp; Validation/Serialization" parent: "Pydantic Core" </p>
<h2><a class="anchor" id="autotoc_md2881"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md2882"></a>
Chapter 5: Core Schema &amp; Validation/Serialization</h1>
<p>In the previous chapters, we've seen how to define data structures using <a class="el" href="../../d7/d22/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_201__basemodel.html">BaseModel</a>, customize fields with <a class="el" href="../../d9/df6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_202__fields____fieldinfo______field__function__.html">Field()</a>, set model-wide behavior with <a class="el" href="../../d0/d6f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_203__configuration____configdict______configwrapper__.html">Configuration</a>, and even add <a class="el" href="../../d3/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_204__custom__logic____decorators______annotated__helpers__.html">Custom Logic</a> using decorators. You might be wondering: how does Pydantic take all these Python definitions and use them to perform such fast and reliable validation and serialization?</p>
<p>The secret lies in an internal representation called the <b>Core Schema</b> and a high-performance engine called <code>pydantic-core</code>. Let's peek under the hood!</p>
<h2><a class="anchor" id="autotoc_md2883"></a>
Why Look Under the Hood?</h2>
<p>Imagine you've designed a beautiful blueprint for a house (your Pydantic <code>BaseModel</code>). You've specified room sizes (type hints), special fixtures (<code>Field</code> constraints), and overall building codes (<code>ConfigDict</code>). You've even added custom inspection notes (decorators).</p>
<p>Now, how does the construction crew actually <em>build</em> the house and check everything rigorously? They don't just glance at the user-friendly blueprint. They work from a highly detailed <b>technical specification</b> derived from it. This spec leaves no room for ambiguity.</p>
<p>In Pydantic, the <b><code>CoreSchema</code></b> is that technical specification, and the <b><code>pydantic-core</code></b> engine (written in Rust) is the super-efficient construction crew that uses it. Understanding this helps explain:</p>
<ul>
<li><b>Speed:</b> Why Pydantic is so fast.</li>
<li><b>Consistency:</b> How validation and serialization rules are strictly enforced.</li>
<li><b>Power:</b> How complex requirements are translated into concrete instructions.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2884"></a>
What is the Core Schema? The Technical Specification</h2>
<p>When Pydantic processes your <code>BaseModel</code> definition (including type hints, <code>Field</code> calls, <code>ConfigDict</code>, decorators, etc.), it translates all that information into an internal data structure called the <b>Core Schema</b>.</p>
<p>Think of the Core Schema as:</p>
<ol type="1">
<li><b>The Bridge:</b> It connects your user-friendly Python code to the high-performance Rust engine (<code>pydantic-core</code>).</li>
<li><b>The Detailed Plan:</b> It's a precise, language-agnostic description of your data structure and all associated rules. It's like a very detailed dictionary or JSON object.</li>
<li><b>The Single Source of Truth:</b> It captures <em>everything</em> needed for validation and serialization:<ul>
<li>Field types (<code>str</code>, <code>int</code>, <code>datetime</code>, nested models, etc.)</li>
<li>Constraints (<code>min_length</code>, <code>gt</code>, <code>pattern</code>, etc. from <code>Field()</code>)</li>
<li>Aliases (&lsquo;alias='userName&rsquo;<code>from</code>Field()<code>)</code></li>
<li><code> Defaults (from</code>Field()<code>or</code>= default_value<code>)</code></li>
<li><code> Model-wide settings (</code>extra='forbid'<code>,</code>frozen=True<code>from</code>ConfigDict<code>)</code></li>
<li><code> Custom logic (references to your</code>@field_validator<code>,</code>@field_serializer` functions, etc.)</li>
</ul>
</li>
</ol>
<p><b>Analogy:</b> Your Python <code>BaseModel</code> is the architect's blueprint. The <code>CoreSchema</code> is the exhaustive technical specification document derived from that blueprint, detailing every material, dimension, and construction step.</p>
<h3><a class="anchor" id="autotoc_md2885"></a>
A Glimpse of the Schema (Conceptual)</h3>
<p>You don't normally interact with the Core Schema directly, but let's imagine what a simplified piece might look like for a field <code>name: str = Field(min_length=3)</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># Conceptual representation - the actual structure is more complex!</span></div>
<div class="line">name_field_schema = {</div>
<div class="line">  <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;str&#39;</span>,          <span class="comment"># The basic type expected</span></div>
<div class="line">  <span class="stringliteral">&#39;min_length&#39;</span>: 3,        <span class="comment"># Constraint from Field(min_length=3)</span></div>
<div class="line">  <span class="stringliteral">&#39;strict&#39;</span>: <span class="keyword">False</span>,        <span class="comment"># Default strictness mode from config</span></div>
<div class="line">  <span class="stringliteral">&#39;strip_whitespace&#39;</span>: <span class="keywordtype">None</span> <span class="comment"># Default string handling from config</span></div>
<div class="line">  <span class="comment"># ... other settings relevant to strings</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># A schema for a whole model wraps field schemas:</span></div>
<div class="line">model_schema = {</div>
<div class="line">    <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;model&#39;</span>,</div>
<div class="line">    <span class="stringliteral">&#39;cls&#39;</span>: YourModelClass, <span class="comment"># Reference to the Python class</span></div>
<div class="line">    <span class="stringliteral">&#39;schema&#39;</span>: {</div>
<div class="line">        <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;model-fields&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;fields&#39;</span>: {</div>
<div class="line">            <span class="stringliteral">&#39;name&#39;</span>: { <span class="stringliteral">&#39;type&#39;</span>: <span class="stringliteral">&#39;model-field&#39;</span>, <span class="stringliteral">&#39;schema&#39;</span>: name_field_schema },</div>
<div class="line">            <span class="comment"># ... schema for other fields ...</span></div>
<div class="line">        },</div>
<div class="line">        <span class="comment"># ... details about custom model validators ...</span></div>
<div class="line">    },</div>
<div class="line">    <span class="stringliteral">&#39;config&#39;</span>: { <span class="comment"># Merged config settings</span></div>
<div class="line">        <span class="stringliteral">&#39;title&#39;</span>: <span class="stringliteral">&#39;YourModelClass&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;extra_behavior&#39;</span>: <span class="stringliteral">&#39;ignore&#39;</span>,</div>
<div class="line">        <span class="stringliteral">&#39;frozen&#39;</span>: <span class="keyword">False</span>,</div>
<div class="line">        <span class="comment"># ...</span></div>
<div class="line">    },</div>
<div class="line">    <span class="comment"># ... details about custom serializers ...</span></div>
<div class="line">}</div>
</div><!-- fragment --><p>This internal schema precisely defines what <code>pydantic-core</code> needs to know to handle the <code>name</code> field and the overall model during validation and serialization.</p>
<p><b>Inspecting the Real Schema:</b></p>
<p>Pydantic actually stores this generated schema on your model class. You can (carefully) inspect it:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>User(BaseModel):</div>
<div class="line">    id: int</div>
<div class="line">    username: str = Field(min_length=5, alias=<span class="stringliteral">&#39;userName&#39;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Access the generated core schema</span></div>
<div class="line"><span class="comment"># Warning: Internal structure, subject to change!</span></div>
<div class="line">print(User.__pydantic_core_schema__)</div>
<div class="line"><span class="comment"># Output will be a complex dictionary representing the detailed schema</span></div>
<div class="line"><span class="comment"># (Output is large and complex, not shown here for brevity)</span></div>
</div><!-- fragment --><p>While you <em>can</em> look at <code>__pydantic_core_schema__</code>, treat it as an internal implementation detail. Its exact structure might change between Pydantic versions.</p>
<h2><a class="anchor" id="autotoc_md2886"></a>
What is <code>pydantic-core</code>? The Efficient Construction Crew</h2>
<p><code>pydantic-core</code> is the heart of Pydantic's performance. It's a separate library, written in Rust (a language known for speed and safety), that does the heavy lifting of validation and serialization.</p>
<p><b>How it Works:</b></p>
<ol type="1">
<li><b>Input:</b> When your <code>BaseModel</code> class is first defined, Pydantic generates the <code>CoreSchema</code> (as described above).</li>
<li><b>Compilation:</b> This <code>CoreSchema</code> is passed to the <code>pydantic-core</code> engine. The engine takes this schema and <em>compiles</em> it into highly optimized, specialized validator and serializer functions <em>specifically for your model</em>. Think of this as the crew studying the spec and preparing the exact tools needed for <em>this specific house</em>.</li>
<li><b>Storage:</b> These compiled Rust objects are attached to your Python model class, typically as <code>__pydantic_validator__</code> and <code>__pydantic_serializer__</code>.</li>
</ol>
<div class="fragment"><div class="line"><span class="comment"># You can access these too (again, internal details!)</span></div>
<div class="line">print(User.__pydantic_validator__)</div>
<div class="line"><span class="comment"># Output: &lt;SchemaValidator &#39;User&#39; ...&gt; (a pydantic-core object)</span></div>
<div class="line"> </div>
<div class="line">print(User.__pydantic_serializer__)</div>
<div class="line"><span class="comment"># Output: &lt;SchemaSerializer &#39;User&#39; ...&gt; (a pydantic-core object)</span></div>
</div><!-- fragment --><p>This "compilation" step happens only <em>once</em> when the class is created. This makes subsequent validation and serialization extremely fast.</p>
<h2><a class="anchor" id="autotoc_md2887"></a>
Validation Flow: Checking Incoming Materials</h2>
<p>When you create an instance of your model or validate data:</p>
<div class="fragment"><div class="line"><span class="comment"># Example: Validation</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    user_data = {<span class="stringliteral">&#39;id&#39;</span>: 1, <span class="stringliteral">&#39;userName&#39;</span>: <span class="stringliteral">&#39;validUser&#39;</span>}</div>
<div class="line">    user = User(**user_data) <span class="comment"># Calls __init__ -&gt; pydantic validation</span></div>
<div class="line">    <span class="comment"># or: user = User.model_validate(user_data)</span></div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(e)</div>
</div><!-- fragment --><p>Here's what happens behind the scenes:</p>
<ol type="1">
<li><b>Call:</b> Your Python code triggers validation (e.g., via <code>__init__</code> or <code>model_validate</code>).</li>
<li><b>Delegate:</b> Pydantic passes the input data (<code>user_data</code>) to the pre-compiled <code>User.__pydantic_validator__</code> (the Rust object).</li>
<li><b>Execute:</b> The <code>pydantic-core</code> validator executes its optimized Rust code, guided by the rules baked in from the <code>CoreSchema</code>. It checks:<ul>
<li>Types (is <code>id</code> an <code>int</code>? is <code>userName</code> a <code>str</code>?)</li>
<li>Coercion (can &lsquo;'1&rsquo;<code>be turned into</code>1<code>for</code>id<code>?)</code></li>
<li><code> Constraints (is</code>len('validUser') &gt;= 5<code>?)</code></li>
<li><code> Aliases (use</code>userName<code>from input for the</code>username<code>field)</code></li>
<li><code> Required fields (is</code>id<code>present?)</code></li>
<li><code> Extra fields (handle according to</code>model_config['extra']<code>)</code></li>
<li><code> Custom validators (</code>@field_validator<code>, etc. are called back into Python if needed, though core logic is Rust)</code></li>
</ul>
</li>
<li><code> **Result:**<ul>
<li>If all checks pass, the validator returns the validated data, which Pydantic uses to create/populate the</li>
</ul>
</code>User<code>instance.<ul>
<li>If any check fails, the Rust validator gathers detailed error information and raises a</li>
</ul>
</code>pydantic_core.ValidationError`, which Pydantic surfaces to your Python code.</li>
</ol>
<p><b>Analogy:</b> The construction crew takes the delivery of materials (<code>user_data</code>) and uses the technical spec (<code>CoreSchema</code> baked into the validator) to rigorously check if everything is correct (right type, right size, etc.). If not, they issue a detailed non-compliance report (<code>ValidationError</code>).</p>
<h2><a class="anchor" id="autotoc_md2888"></a>
Serialization Flow: Generating Reports</h2>
<p>When you dump your model instance:</p>
<div class="fragment"><div class="line"><span class="comment"># Example: Serialization</span></div>
<div class="line">user = User(id=1, username=<span class="stringliteral">&#39;validUser&#39;</span>)</div>
<div class="line">user_dict = user.model_dump()</div>
<div class="line"><span class="comment"># or: user_json = user.model_dump_json()</span></div>
</div><!-- fragment --><p>Here's the flow:</p>
<ol type="1">
<li><b>Call:</b> Your Python code calls <code>model_dump()</code> or <code>model_dump_json()</code>.</li>
<li><b>Delegate:</b> Pydantic passes the model instance (<code>user</code>) to the pre-compiled <code>User.__pydantic_serializer__</code> (the Rust object).</li>
<li><b>Execute:</b> The <code>pydantic-core</code> serializer executes its optimized Rust code, again guided by the <code>CoreSchema</code>. It:<ul>
<li>Iterates through the fields specified by the schema.</li>
<li>Applies serialization rules (e.g., use aliases if <code>by_alias=True</code>).</li>
<li>Handles <code>include</code>, <code>exclude</code>, <code>exclude_unset</code>, <code>exclude_defaults</code>, <code>exclude_none</code> logic efficiently.</li>
<li>Formats values for the target output (Python objects for <code>model_dump</code>, JSON types for <code>model_dump_json</code>).</li>
<li>Calls custom serializers (<code>@field_serializer</code>, etc.) back into Python if needed.</li>
</ul>
</li>
<li><b>Result:</b> The serializer returns the final dictionary or JSON string.</li>
</ol>
<p><b>Analogy:</b> The crew uses the technical spec (<code>CoreSchema</code> baked into the serializer) to generate a standardized report (<code>dict</code> or JSON) about the constructed house (<code>model instance</code>), formatting details (like using aliases) as requested.</p>
<h2><a class="anchor" id="autotoc_md2889"></a>
Under the Hood: The Assembly Line</h2>
<p>Let's visualize the entire process from defining a class to using it.</p>
<p><b>Step-by-Step:</b></p>
<ol type="1">
<li><b>Definition:</b> You define your <code>class User(BaseModel): ...</code> in Python.</li>
<li><b>Metaclass Magic:</b> When Python creates the <code>User</code> class, Pydantic's <code>ModelMetaclass</code> intercepts.</li>
<li><b>Inspection:</b> The metaclass inspects the class definition: fields, type hints, <code>Field()</code> calls, <code>model_config</code>, decorators.</li>
<li><b>Schema Generation (Python):</b> This information is fed into Pydantic's Python-based schema generation logic (<code>pydantic._internal._generate_schema</code>).</li>
<li><b>CoreSchema Creation:</b> The generator produces the detailed <code>CoreSchema</code> data structure.</li>
<li><b>Hand-off to Rust:</b> This <code>CoreSchema</code> is passed to the <code>pydantic-core</code> Rust library.</li>
<li><b>Compilation (Rust):</b> <code>pydantic-core</code> creates optimized <code>SchemaValidator</code> and <code>SchemaSerializer</code> instances based <em>specifically</em> on that schema.</li>
<li><b>Attachment:</b> These Rust-backed objects are attached to the <code>User</code> class as <code>__pydantic_validator__</code> and <code>__pydantic_serializer__</code>.</li>
<li><b>Ready:</b> The <code>User</code> class is now fully prepared.</li>
<li><b>Usage (Validation):</b> Calling <code>User(...)</code> uses <code>User.__pydantic_validator__</code> (Rust) to process input.</li>
<li><b>Usage (Serialization):</b> Calling <code>user.model_dump()</code> uses <code>User.__pydantic_serializer__</code> (Rust) to generate output.</li>
</ol>
<p><b>Sequence Diagram:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Dev as Developer</div>
<div class="line">    participant PyClassDef as Python Class Definition</div>
<div class="line">    participant PydanticPy as Pydantic (Python Layer)</div>
<div class="line">    participant CoreSchemaDS as CoreSchema (Data Structure)</div>
<div class="line">    participant PydanticCore as pydantic-core (Rust Engine)</div>
<div class="line">    participant UserCode as User Code</div>
<div class="line"> </div>
<div class="line">    Dev-&gt;&gt;PyClassDef: Define `class User(BaseModel): ...`</div>
<div class="line">    PyClassDef-&gt;&gt;PydanticPy: Python creates class, Pydantic metaclass intercepts</div>
<div class="line">    PydanticPy-&gt;&gt;PydanticPy: Inspects fields, config, decorators</div>
<div class="line">    PydanticPy-&gt;&gt;CoreSchemaDS: Generates detailed CoreSchema</div>
<div class="line">    PydanticPy-&gt;&gt;PydanticCore: Pass CoreSchema to Rust engine</div>
<div class="line">    PydanticCore-&gt;&gt;PydanticCore: Compile SchemaValidator from CoreSchema</div>
<div class="line">    PydanticCore-&gt;&gt;PydanticCore: Compile SchemaSerializer from CoreSchema</div>
<div class="line">    PydanticCore--&gt;&gt;PydanticPy: Return compiled Validator &amp; Serializer objects</div>
<div class="line">    PydanticPy-&gt;&gt;PyClassDef: Attach Validator/Serializer to class object (`User`)</div>
<div class="line"> </div>
<div class="line">    UserCode-&gt;&gt;PyClassDef: Instantiate: `User(...)` or `User.model_validate(...)`</div>
<div class="line">    PyClassDef-&gt;&gt;PydanticCore: Use attached SchemaValidator</div>
<div class="line">    PydanticCore-&gt;&gt;PydanticCore: Execute fast validation logic</div>
<div class="line">    alt Validation OK</div>
<div class="line">        PydanticCore--&gt;&gt;UserCode: Return validated instance/data</div>
<div class="line">    else Validation Error</div>
<div class="line">        PydanticCore--&gt;&gt;UserCode: Raise ValidationError</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    UserCode-&gt;&gt;PyClassDef: Serialize: `user.model_dump()`</div>
<div class="line">    PyClassDef-&gt;&gt;PydanticCore: Use attached SchemaSerializer</div>
<div class="line">    PydanticCore-&gt;&gt;PydanticCore: Execute fast serialization logic</div>
<div class="line">    PydanticCore--&gt;&gt;UserCode: Return dict/JSON string</div>
</div><!-- fragment --><p><b>Code Location:</b></p>
<ul>
<li><b>Metaclass &amp; Orchestration:</b> <code>pydantic._internal._model_construction.py</code> (handles class creation)</li>
<li><b>Schema Generation (Python side):</b> <code>pydantic._internal._generate_schema.py</code> (builds the schema structure)</li>
<li><b>Core Engine:</b> The <code>pydantic-core</code> library (Rust code, compiled). You interact with it via the <code>SchemaValidator</code> and <code>SchemaSerializer</code> objects attached to your models.</li>
<li><b>Schema Representation:</b> The <code>CoreSchema</code> itself is defined using types from <code>pydantic_core.core_schema</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2890"></a>
Conclusion</h2>
<p>You've now seen the engine behind Pydantic's power!</p>
<ul>
<li>Pydantic translates your Python model definitions (<code>BaseModel</code>, <code>Field</code>, <code>ConfigDict</code>, decorators) into a detailed, internal <b><code>CoreSchema</code></b>.</li>
<li>This <code>CoreSchema</code> acts as the <b>technical specification</b> for your data.</li>
<li>The high-performance <b><code>pydantic-core</code></b> engine (written in Rust) takes this schema and "compiles" it into optimized <code>SchemaValidator</code> and <code>SchemaSerializer</code> objects.</li>
<li>These specialized objects perform fast <b>validation</b> (checking input) and <b>serialization</b> (dumping output) according to the rules defined in the schema.</li>
</ul>
<p>This combination of a clear Python API and a powerful Rust core allows Pydantic to be both user-friendly and incredibly performant.</p>
<p>What if you want to leverage this powerful validation and serialization engine for types that <em>aren't</em> full <code>BaseModel</code> classes? Maybe just validate a standalone <code>list[int]</code> or serialize a <code>datetime</code> object according to specific rules? That's where <code>TypeAdapter</code> comes in handy.</p>
<p>Next: <a class="el" href="../../d8/d01/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_206__typeadapter.html">Chapter 6: TypeAdapter</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
