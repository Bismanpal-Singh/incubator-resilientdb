#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_configuration__configdict___configwrapper_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/d6f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_203__configuration____configdict______configwrapper__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_configuration__configdict___configwrapper_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2842"></a>
autotoc_md2842</h2>
<p>layout: default title: "Configuration (ConfigDict &amp; ConfigWrapper)" parent: "Pydantic Core" </p>
<h2><a class="anchor" id="autotoc_md2843"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md2844"></a>
Chapter 3: Configuring Your Blueprint - Model Settings</h1>
<p>In <a class="el" href="../../d7/d22/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_201__basemodel.html">Chapter 1</a>, we learned about <code>BaseModel</code> as our data blueprint, and in <a class="el" href="../../d9/df6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_202__fields____fieldinfo______field__function__.html">Chapter 2</a>, we saw how <code>Field()</code> lets us add specific notes (like defaults or aliases) to individual rooms (fields) on that blueprint.</p>
<p>But what about instructions that apply to the <em>entire</em> blueprint? Imagine needing rules like:</p>
<ul>
<li>"Absolutely no extra furniture allowed that's not in the plan!" (Forbid extra fields)</li>
<li>"Once built, nothing inside can be changed!" (Make the model immutable/frozen)</li>
<li>"All room names on the final report should be lowercase." (Apply a naming convention during output)</li>
</ul>
<p>These are model-wide settings, not specific to just one field. Pydantic provides a way to configure this overall behavior using model configuration.</p>
<h2><a class="anchor" id="autotoc_md2845"></a>
Why Configure the Whole Model?</h2>
<p>Let's consider a simple <code>Product</code> model:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Product(BaseModel):</div>
<div class="line">    item_id: int</div>
<div class="line">    name: str</div>
<div class="line">    price: float | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
</div><!-- fragment --><p>This works, but we might want to enforce stricter rules or change default behaviors:</p>
<ol type="1">
<li><b>Strictness:</b> What if we receive data like &lsquo;{'item_id&rsquo;: 123, 'name': 'Thingy', 'color': 'blue'}<code>? By default, Pydantic ignores the extra</code>color<code>field. We might want to *reject* data with unexpected fields.</code></li>
<li><code> **Immutability:** What if, once a</code>Product<code>object is created, we want to prevent accidental changes like</code>product.price = 99.99<code>?</code></li>
<li><code> **Naming Conventions:** What if our API expects JSON keys in</code>camelCase<code>(like</code>itemId<code>) instead of Python's standard</code>snake_case<code>(</code>item_id`)?</li>
</ol>
<p>These global behaviors are controlled via Pydantic's configuration system.</p>
<h2><a class="anchor" id="autotoc_md2846"></a>
Introducing <code>ConfigDict</code> and <code>model_config</code></h2>
<p>Pydantic allows you to customize model behavior by adding a special class attribute called <code>model_config</code>. This attribute should be assigned a dictionary-like object called <code>ConfigDict</code>.</p>
<p>Think of <code>model_config = ConfigDict(...)</code> as the <b>master instruction sheet</b> or the <b>global settings panel</b> attached to your <code>BaseModel</code> blueprint. It provides overarching rules for how Pydantic should handle the model.</p>
<p><b><code>ConfigDict</code>:</b> A special dictionary (specifically, a <code>TypedDict</code>) provided by Pydantic where you specify configuration options using key-value pairs. <b><code>model_config</code>:</b> The class attribute on your <code>BaseModel</code> where you assign your <code>ConfigDict</code>.</p>
<p>Let's add some configuration to our <code>Product</code> model:</p>
<div class="fragment"><div class="line"><span class="comment"># Import ConfigDict</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, ConfigDict</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>Product(BaseModel):</div>
<div class="line">    <span class="comment"># Define model-wide settings here</span></div>
<div class="line">    model_config = ConfigDict(</div>
<div class="line">        frozen=<span class="keyword">True</span>,             <span class="comment"># Setting 1: Make instances immutable</span></div>
<div class="line">        extra=<span class="stringliteral">&#39;forbid&#39;</span>,          <span class="comment"># Setting 2: Forbid extra fields during input validation</span></div>
<div class="line">        validate_assignment=<span class="keyword">True</span> <span class="comment"># Setting 3: Re-validate fields when they are assigned a new value</span></div>
<div class="line">    )</div>
<div class="line"> </div>
<div class="line">    item_id: int</div>
<div class="line">    name: str</div>
<div class="line">    price: float | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- How these settings affect behavior ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 1. Forbid Extra Fields (&#39;extra=forbid&#39;)</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    <span class="comment"># Input data has an extra &#39;color&#39; field</span></div>
<div class="line">    product_data_extra = {<span class="stringliteral">&#39;item_id&#39;</span>: 123, <span class="stringliteral">&#39;name&#39;</span>: <span class="stringliteral">&#39;Thingy&#39;</span>, <span class="stringliteral">&#39;color&#39;</span>: <span class="stringliteral">&#39;blue&#39;</span>}</div>
<div class="line">    Product(**product_data_extra)</div>
<div class="line"><span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Error on extra field:\n{e}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output (simplified):</span></div>
<div class="line">    <span class="comment"># Error on extra field:</span></div>
<div class="line">    <span class="comment"># 1 validation error for Product</span></div>
<div class="line">    <span class="comment"># color</span></div>
<div class="line">    <span class="comment">#   Extra inputs are not permitted [type=extra_forbidden, ...]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 2. Immutability (&#39;frozen=True&#39;)</span></div>
<div class="line">product = Product(item_id=456, name=<span class="stringliteral">&quot;Gadget&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Initial product: {product}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: Initial product: item_id=456 name=&#39;Gadget&#39; price=None</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    <span class="comment"># Attempt to change a field on the frozen instance</span></div>
<div class="line">    product.name = <span class="stringliteral">&quot;New Gadget&quot;</span></div>
<div class="line"><span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;\nError on assignment to frozen model:\n{e}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output (simplified):</span></div>
<div class="line">    <span class="comment"># Error on assignment to frozen model:</span></div>
<div class="line">    <span class="comment"># 1 validation error for Product</span></div>
<div class="line">    <span class="comment"># name</span></div>
<div class="line">    <span class="comment">#   Instance is frozen [type=frozen_instance, ...]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># 3. Validate Assignment (&#39;validate_assignment=True&#39;)</span></div>
<div class="line">product_mutable = Product.model_construct(item_id=789, name=<span class="stringliteral">&quot;Widget&quot;</span>) <span class="comment"># Use model_construct to bypass initial __init__ validation for demo</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    <span class="comment"># Attempt to assign an invalid type (int instead of str)</span></div>
<div class="line">    product_mutable.name = 999</div>
<div class="line"><span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;\nError on invalid assignment:\n{e}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output (simplified):</span></div>
<div class="line">    <span class="comment"># Error on invalid assignment:</span></div>
<div class="line">    <span class="comment"># 1 validation error for Product</span></div>
<div class="line">    <span class="comment"># name</span></div>
<div class="line">    <span class="comment">#  Input should be a valid string [type=string_type, input_value=999, input_type=int]</span></div>
</div><!-- fragment --><p>By adding the <code>model_config</code> dictionary, we changed the fundamental behavior of our <code>Product</code> model without altering the field definitions themselves.</p>
<h2><a class="anchor" id="autotoc_md2847"></a>
Common Configuration Options</h2>
<p>Here are a few more useful options you can set in <code>ConfigDict</code>:</p>
<ul>
<li><p class="startli"><b><code>alias_generator</code></b>: Automatically generate aliases for fields. Often used to convert between <code>snake_case</code> and <code>camelCase</code>. ```python from pydantic import BaseModel, ConfigDict from pydantic.alias_generators import to_camel # Import a helper</p>
<p class="startli">class User(BaseModel): user_id: int first_name: str</p>
<p class="startli">model_config = ConfigDict( alias_generator=to_camel, # Use the camelCase generator populate_by_name=True # Allow using EITHER alias or python name for input (see warning below) </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2848"></a>
Replaced by validate_by_name=True + validate_by_alias=True</h1>
<p>)</p>
<h1><a class="anchor" id="autotoc_md2849"></a>
Input using camelCase aliases</h1>
<p>user_data_camel = {'userId': 1, 'firstName': 'Arthur'} user = User(**user_data_camel) print(f"User created from camelCase: {user}") </p>
<h1><a class="anchor" id="autotoc_md2850"></a>
Expected Output: User created from camelCase: user_id=1 first_name='Arthur'</h1>
<h1><a class="anchor" id="autotoc_md2851"></a>
Output (dumping) using aliases requires <code>by_alias=True</code></h1>
<p>print(f"Dumped with aliases: {user.model_dump(by_alias=True)}") </p>
<h1><a class="anchor" id="autotoc_md2852"></a>
Expected Output: Dumped with aliases: {'userId': 1, 'firstName': 'Arthur'}</h1>
<p>print(f"Dumped without aliases: {user.model_dump()}") </p>
<h1><a class="anchor" id="autotoc_md2853"></a>
Expected Output: Dumped without aliases: {'user_id': 1, 'first_name': 'Arthur'}</h1>
<p><code></p><ul>
<li>**Modern Alias Control (Pydantic &gt;= v2.11):** Instead of `populate_by_name`, use `validate_by_alias`, `validate_by_name`, and `serialize_by_alias` for finer control: </li>
</ul>
<p></code>python from pydantic import BaseModel, ConfigDict from pydantic.alias_generators import to_camel</p>
<p>class UserV2(BaseModel): user_id: int first_name: str</p>
<p>model_config = ConfigDict( alias_generator=to_camel, validate_by_name=True, # Allow input using 'user_id', 'first_name' validate_by_alias=True, # Allow input using 'userId', 'firstName' (default is True) serialize_by_alias=True # Use aliases ('userId', 'firstName') when dumping by default )</p>
<p>user_data_camel = {'userId': 1, 'firstName': 'Zaphod'} user_camel = UserV2(**user_data_camel) print(f"User from camel: {user_camel}") </p>
<h1><a class="anchor" id="autotoc_md2854"></a>
&gt; User from camel: user_id=1 first_name='Zaphod'</h1>
<p>user_data_snake = {'user_id': 2, 'first_name': 'Ford'} user_snake = UserV2(**user_data_snake) print(f"User from snake: {user_snake}") </p>
<h1><a class="anchor" id="autotoc_md2855"></a>
&gt; User from snake: user_id=2 first_name='Ford'</h1>
<h1><a class="anchor" id="autotoc_md2856"></a>
serialize_by_alias=True means model_dump() uses aliases by default</h1>
<p>print(f"Dumped (default alias): {user_camel.model_dump()}") </p>
<h1><a class="anchor" id="autotoc_md2857"></a>
&gt; Dumped (default alias): {'userId': 1, 'firstName': 'Zaphod'}</h1>
<p>print(f"Dumped (force no alias): {user_camel.model_dump(by_alias=False)}") </p>
<h1><a class="anchor" id="autotoc_md2858"></a>
&gt; Dumped (force no alias): {'user_id': 1, 'first_name': 'Zaphod'}</h1>
<p>```</p>
<ul>
<li><p class="startli"><b><code>use_enum_values</code></b>: When serializing (e.g., with <code>model_dump</code>), use the <em>value</em> of an enum member instead of the member itself. ```python from enum import Enum from pydantic import BaseModel, ConfigDict</p>
<p class="startli">class Status(Enum): PENDING = "pending" PROCESSING = "processing" COMPLETE = "complete"</p>
<p class="startli">class Order(BaseModel): order_id: int status: Status</p>
<p class="startli">model_config = ConfigDict( use_enum_values=True # Use the string value of Status )</p>
<p class="startli">order = Order(order_id=101, status=Status.PROCESSING) print(f"Order object status type: {type(order.status)}") </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2859"></a>
Expected Output: Order object status type: &lt;enum 'Status'&gt;</h1>
<p>print(f"Order dumped: {order.model_dump()}") </p>
<h1><a class="anchor" id="autotoc_md2860"></a>
Expected Output: Order dumped: {'order_id': 101, 'status': 'processing'}</h1>
<h1><a class="anchor" id="autotoc_md2861"></a>
Note: 'status' is the string "processing", not Status.PROCESSING</h1>
<p>```</p>
<ul>
<li><p class="startli"><b><code>str_strip_whitespace</code> / <code>str_to_lower</code> / <code>str_to_upper</code></b>: Automatically clean string inputs. ```python from pydantic import BaseModel, ConfigDict</p>
<p class="startli">class Comment(BaseModel): text: str author: str</p>
<p class="startli">model_config = ConfigDict( str_strip_whitespace=True, # Remove leading/trailing whitespace str_to_lower=True # Convert to lowercase )</p>
<p class="startli">comment_data = {'text': ' Hello World! ', 'author': ' ALICE '} comment = Comment(**comment_data) print(comment) </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2862"></a>
Expected Output: text='hello world!' author='alice'</h1>
<p>```</p>
<p>You can find the full list of configuration options in the Pydantic documentation for <a href="https://docs.pydantic.dev/latest/api/config/#pydantic.config.ConfigDict"><code>ConfigDict</code></a>.</p>
<p><b>Important Note:</b> Configuration set in <code>model_config</code> generally applies <em>during validation and serialization</em>. For example, <code>alias_generator</code> helps Pydantic understand incoming data with aliases and optionally use aliases when producing output, but the internal attribute name in your Python code remains the Python name (e.g., <code>user_id</code>).</p>
<h2><a class="anchor" id="autotoc_md2863"></a>
What About <code>ConfigWrapper</code>? (Internal Detail)</h2>
<p>You might see <code>ConfigWrapper</code> mentioned in Pydantic's internal code or documentation.</p>
<p><b>Analogy:</b> If <code>ConfigDict</code> is the settings form you fill out (<code>frozen=True</code>, &lsquo;extra='forbid&rsquo;<code>), then</code>ConfigWrapper` is the internal manager object that Pydantic creates <em>from</em> your form. This manager holds onto your settings, knows the default values for settings you <em>didn't</em> specify, and provides a consistent way for the rest of Pydantic (like the schema builder) to ask "Is this model frozen?" or "What should happen with extra fields?".</p>
<p><b>Key Point:</b> As a user writing Pydantic models, you almost always interact with <b><code>ConfigDict</code></b> via the <code>model_config</code> attribute. You generally don't need to create or use <code>ConfigWrapper</code> directly. It's an internal helper that makes Pydantic's life easier.</p>
<h2><a class="anchor" id="autotoc_md2864"></a>
Under the Hood: How Configuration is Applied</h2>
<p>Let's refine our understanding of how a <code>BaseModel</code> class gets created, now including configuration.</p>
<p><b>High-Level Steps:</b></p>
<p>When Python creates your <code>Product</code> class:</p>
<ol type="1">
<li><b>Inspection:</b> Pydantic's <code>ModelMetaclass</code> inspects the class definition. It finds the fields (<code>item_id: int</code>, etc.) and also looks for the <code>model_config</code> attribute.</li>
<li><b>Config Processing:</b> If <code>model_config</code> (a <code>ConfigDict</code>) is found, Pydantic uses it (along with config from any parent classes) to create an internal <code>ConfigWrapper</code> instance. This wrapper standardizes access to all config settings, applying defaults for any missing options.</li>
<li><b>FieldInfo Creation:</b> It processes field definitions, potentially using <code>Field()</code> as discussed in <a class="el" href="../../d9/df6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_202__fields____fieldinfo______field__function__.html">Chapter 2</a>, creating <code>FieldInfo</code> objects.</li>
<li><b>Schema Generation:</b> Pydantic now uses <em>both</em> the <code>FieldInfo</code> objects <em>and</em> the settings from the <code>ConfigWrapper</code> to generate the detailed internal <a class="el" href="../../d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html">Core Schema</a>. For example, if the <code>ConfigWrapper</code> says <code>frozen=True</code>, this instruction is baked into the Core Schema.</li>
<li><b>Validator/Serializer Creation:</b> Optimized validator and serializer functions are created based on this final Core Schema.</li>
</ol>
<p><b>Sequence Diagram:</b></p>
<p>This diagram shows how <code>model_config</code> influences the process:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Dev as Developer</div>
<div class="line">    participant Py as Python</div>
<div class="line">    participant Meta as ModelMetaclass</div>
<div class="line">    participant CfgWrap as ConfigWrapper</div>
<div class="line">    participant Core as Pydantic Core Engine</div>
<div class="line"> </div>
<div class="line">    Dev-&gt;&gt;Py: Define `class Product(BaseModel): model_config = ConfigDict(frozen=True, extra=&#39;forbid&#39;) ...`</div>
<div class="line">    Py-&gt;&gt;Meta: Ask to create `Product` class</div>
<div class="line">    Meta-&gt;&gt;Meta: Find `model_config` dict in namespace</div>
<div class="line">    Meta-&gt;&gt;CfgWrap: Create `ConfigWrapper` using `model_config` (and defaults)</div>
<div class="line">    CfgWrap--&gt;&gt;Meta: Return `ConfigWrapper(config_dict={&#39;frozen&#39;: True, &#39;extra&#39;: &#39;forbid&#39;, ...other defaults...})`</div>
<div class="line">    Meta-&gt;&gt;Meta: Collect fields (`item_id`, `name`, `price`) and their FieldInfo</div>
<div class="line">    Meta-&gt;&gt;Core: Request Core Schema using FieldInfo AND ConfigWrapper settings (e.g., frozen, extra)</div>
<div class="line">    Core--&gt;&gt;Meta: Provide Core Schema incorporating model-wide rules</div>
<div class="line">    Meta-&gt;&gt;Core: Request validator/serializer from Core Schema</div>
<div class="line">    Core--&gt;&gt;Meta: Provide optimized validator/serializer reflecting config</div>
<div class="line">    Meta--&gt;&gt;Py: Return fully prepared `Product` class</div>
<div class="line">    Py--&gt;&gt;Dev: `Product` class is ready, respecting the config</div>
</div><!-- fragment --><p>The <code>ConfigWrapper</code> acts as a bridge, translating the user-friendly <code>ConfigDict</code> into instructions the Core Engine understands when building the schema and validators.</p>
<p><b>Code Location:</b></p>
<ul>
<li><code>ConfigDict</code>: Defined in <code>pydantic/config.py</code>. It's essentially a <code>TypedDict</code> listing all valid configuration keys.</li>
<li><code>ConfigWrapper</code>: Defined in <code>pydantic._internal._config.py</code>. Its <code>__init__</code> takes the config dictionary. The <code>ConfigWrapper.for_model</code> class method is used by the metaclass to gather configuration from base classes and the current class definition. Its <code>core_config</code> method translates the stored config into the format needed by <code>pydantic-core</code>.</li>
<li><code>ModelMetaclass</code>: In <code>pydantic._internal._model_construction.py</code>, the <code>__new__</code> method calls <code>ConfigWrapper.for_model</code> and passes the resulting wrapper to <code>build_schema_generator</code> and ultimately <code>complete_model_class</code>, which coordinates schema and validator/serializer creation.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># Simplified view from pydantic/config.py</span></div>
<div class="line"><span class="comment"># ConfigDict is a TypedDict listing allowed keys and their types</span></div>
<div class="line"><span class="keyword">class </span>ConfigDict(TypedDict, total=<span class="keyword">False</span>):</div>
<div class="line">    frozen: bool</div>
<div class="line">    extra: Literal[<span class="stringliteral">&#39;allow&#39;</span>, <span class="stringliteral">&#39;ignore&#39;</span>, <span class="stringliteral">&#39;forbid&#39;</span>] | <span class="keywordtype">None</span></div>
<div class="line">    alias_generator: Callable[[str], str] | <span class="keywordtype">None</span></div>
<div class="line">    <span class="comment"># ... many more options</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Simplified view from pydantic._internal._config.py</span></div>
<div class="line"><span class="keyword">class </span>ConfigWrapper:</div>
<div class="line">    config_dict: ConfigDict <span class="comment"># Stores the actual config values</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self, config: ConfigDict | dict[str, Any] | type[Any] | <span class="keywordtype">None</span>, *, check: bool = <span class="keyword">True</span>):</div>
<div class="line">        <span class="comment"># Simplification: Stores the input config, potentially validating keys</span></div>
<div class="line">        self.config_dict = prepare_config(config) <span class="comment"># prepare_config handles defaults/deprecation</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Provides attribute access like wrapper.frozen, falling back to defaults</span></div>
<div class="line">    <span class="keyword">def </span>__getattr__(self, name: str) -&gt; Any:</div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="keywordflow">return</span> self.config_dict[name]</div>
<div class="line">        <span class="keywordflow">except</span> KeyError:</div>
<div class="line">            <span class="comment"># Fallback to default values defined in config_defaults</span></div>
<div class="line">            <span class="comment"># return config_defaults[name] # Simplified</span></div>
<div class="line">            <span class="keywordflow">pass</span> <span class="comment"># Actual implementation is more complex</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Used during model creation to gather config from all sources</span></div>
<div class="line">    <span class="preprocessor">@classmethod</span></div>
<div class="line">    <span class="keyword">def </span>for_model(cls, bases: tuple[type[Any], ...], namespace: dict[str, Any], kwargs: dict[str, Any]) -&gt; Self:</div>
<div class="line">        config_new = ConfigDict()</div>
<div class="line">        <span class="comment"># 1. Inherit config from base classes</span></div>
<div class="line">        <span class="comment"># 2. Get config from &#39;model_config&#39; in the current class namespace</span></div>
<div class="line">        <span class="comment"># 3. Get config from kwargs passed during class definition (e.g., class Model(BaseModel, frozen=True): ...)</span></div>
<div class="line">        <span class="comment"># ... logic to merge these sources ...</span></div>
<div class="line">        <span class="keywordflow">return</span> cls(config_new) <span class="comment"># Return a wrapper with the final merged config</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Creates the config dictionary specifically for pydantic-core</span></div>
<div class="line">    <span class="keyword">def </span>core_config(self, title: str | <span class="keywordtype">None</span>) -&gt; core_schema.CoreConfig:</div>
<div class="line">         <span class="comment"># Extracts relevant keys from self.config_dict and maps them</span></div>
<div class="line">         <span class="comment"># to the names expected by pydantic_core.CoreConfig</span></div>
<div class="line">         <span class="comment"># e.g., {&#39;extra&#39;: &#39;forbid&#39;} becomes {&#39;extra_fields_behavior&#39;: &#39;forbid&#39;}</span></div>
<div class="line">         core_options = { ... }</div>
<div class="line">         <span class="keywordflow">return</span> core_schema.CoreConfig(**core_options)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Simplified view from pydantic._internal._model_construction.py (ModelMetaclass.__new__)</span></div>
<div class="line"><span class="keyword">def </span>__new__(mcs, name, bases, namespace, **kwargs):</div>
<div class="line">    <span class="comment"># ... lots of setup ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Step 1: Gather configuration</span></div>
<div class="line">    config_wrapper = ConfigWrapper.for_model(bases, namespace, kwargs) <span class="comment"># Merges config from bases, class def, kwargs</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Step 2: Prepare schema generator using the config</span></div>
<div class="line">    schema_generator = build_schema_generator(</div>
<div class="line">        cls, <span class="comment"># The class being built</span></div>
<div class="line">        config_wrapper,</div>
<div class="line">        <span class="comment"># ... other args ...</span></div>
<div class="line">    )</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Step 3: Build core schema, validator, serializer (using schema_generator which uses config_wrapper)</span></div>
<div class="line">    <span class="comment"># core_schema = schema_generator.generate_schema(cls) # Simplified</span></div>
<div class="line">    <span class="comment"># validator = SchemaValidator(core_schema, config_wrapper.core_config()) # Simplified</span></div>
<div class="line">    <span class="comment"># serializer = SchemaSerializer(core_schema, config_wrapper.core_config()) # Simplified</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... attach schema, validator, serializer to the class ...</span></div>
<div class="line">    cls = super().__new__(mcs, name, bases, namespace, **kwargs)</div>
<div class="line">    <span class="comment"># cls.__pydantic_validator__ = validator</span></div>
<div class="line">    <span class="comment"># ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">return</span> cls</div>
</div><!-- fragment --><p>This setup ensures that the model-wide rules defined in <code>model_config</code> are consistently applied during both validation (creating model instances) and serialization (dumping model instances).</p>
<h2><a class="anchor" id="autotoc_md2865"></a>
Conclusion</h2>
<p>You've learned how to configure the overall behavior of your <code>BaseModel</code> blueprints:</p>
<ul>
<li>Use the <code>model_config</code> class attribute, assigning it a <code>ConfigDict</code>.</li>
<li><code>ConfigDict</code> acts as the <b>master instruction sheet</b> or <b>settings panel</b> for the model.</li>
<li>Common settings include <code>frozen</code>, <code>extra</code>, <code>alias_generator</code>, <code>use_enum_values</code>, and string cleaning options.</li>
<li>Pydantic uses this configuration, often via the internal <code>ConfigWrapper</code>, to tailor the validation and serialization logic defined in the <a class="el" href="../../d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html">Core Schema</a>.</li>
</ul>
<p>With <code>BaseModel</code>, <code>Field</code>, and <code>ConfigDict</code>, you have powerful tools to define the structure, field-specific details, and overall behavior of your data models.</p>
<p>But what if you need logic that goes beyond simple configuration? What if you need custom validation rules that depend on multiple fields, or complex transformations before or after validation/serialization? That's where Pydantic's decorators come in.</p>
<p>Next: <a class="el" href="../../d3/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_204__custom__logic____decorators______annotated__helpers__.html">Chapter 4: Custom Logic (Decorators &amp; Annotated Helpers)</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
