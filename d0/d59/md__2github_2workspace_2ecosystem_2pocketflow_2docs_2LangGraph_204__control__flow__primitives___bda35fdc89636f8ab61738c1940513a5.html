#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_control_flow_primitives___branch____send____interrupt__</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_204__control__flow__primitives___bda35fdc89636f8ab61738c1940513a5.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_control_flow_primitives___branch____send____interrupt__</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2151"></a>
autotoc_md2151</h2>
<p>layout: default title: "Control Flow Primitives" parent: "LangGraph" </p>
<h2><a class="anchor" id="autotoc_md2152"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md2153"></a>
Chapter 4: Control Flow Primitives (<code>Branch</code>, <code>Send</code>, <code>Interrupt</code>)</h1>
<p>In <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Chapter 3: Channels</a>, we saw how information is stored and updated in our graph's shared state using Channels. We have the blueprint (<a class="el" href="../../df/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_201__graph______stategraph.html"><code>StateGraph</code></a>), the workers (<a class="el" href="../../dc/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_202__nodes______pregelnode____.html"><code>Nodes</code></a>), and the communication system (<a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a>).</p>
<p>But what if we don't want our graph to follow a single, fixed path? What if we need it to make decisions? For example, imagine a chatbot: sometimes it needs to use a tool (like a search engine), and other times it can answer directly. How do we tell the graph <em>which</em> path to take based on the current situation?</p>
<p>This is where <b>Control Flow Primitives</b> come in. They are special mechanisms that allow you to dynamically direct the execution path of your graph, making it much more flexible and powerful.</p>
<h2><a class="anchor" id="autotoc_md2154"></a>
What Problem Do Control Flow Primitives Solve?</h2>
<p>Think of our graph like a train system. So far, we've only built tracks that go in a straight line from one station (node) to the next. Control flow primitives are like the <b>switches</b> and <b>signals</b> that allow the train (our execution flow) to:</p>
<ol type="1">
<li><b>Choose a path:</b> Decide whether to go left or right at a junction based on some condition (like an "if" statement).</li>
<li><b>Dispatch specific trains:</b> Send a specific piece of cargo directly to a particular station, maybe even multiple pieces to the same station to be processed in parallel.</li>
<li><b>Wait for instructions:</b> Pause the train journey until an external signal (like human approval) is given.</li>
</ol>
<p>LangGraph provides three main primitives for this:</p>
<ul>
<li><b><code>Branch</code></b>: Acts like a conditional router or switch ("if/else"). It directs the flow to different nodes based on the current state.</li>
<li><b><code>Send</code></b>: Allows a node to directly trigger another node with specific input, useful for parallel processing patterns like map-reduce.</li>
<li><b><code>Interrupt</code></b>: Pauses the graph execution, usually to wait for external input (like a human clicking "Approve") before continuing.</li>
</ul>
<p>Let's explore each one.</p>
<h2><a class="anchor" id="autotoc_md2155"></a>
1. <code>Branch</code> - The Conditional Router</h2>
<p>Imagine our chatbot needs to decide: "Should I use the search tool, or can I answer from my knowledge?" This decision depends on the conversation history or the user's specific question stored in the graph's state.</p>
<p>The <code>Branch</code> primitive allows us to implement this kind of conditional logic. You add it using the <code>graph.add_conditional_edges()</code> method.</p>
<p><b>How it Works:</b></p>
<ol type="1">
<li>You define a regular node (let's call it <code>should_i_search</code>).</li>
<li>You define a separate <b>routing function</b>. This function takes the current state and decides <em>which node</em> should run next. It returns the name of the next node (or a list of names).</li>
<li>You connect the <code>should_i_search</code> node to the routing function using <code>add_conditional_edges</code>. You tell it: "After `should_i_search` finishes, call this routing function to decide where to go next."</li>
<li>You provide a mapping (a dictionary) that links the possible return values of your routing function to the actual node names in your graph.</li>
</ol>
<p><b>Example: Chatbot Deciding to Search</b></p>
<p>Let's build a tiny graph that decides whether to go to a <code>search_tool</code> node or a <code>respond_directly</code> node.</p>
<p><b>Step 1: Define State</b></p>
<div class="fragment"><div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict, Annotated, List</div>
<div class="line"><span class="keyword">import</span> operator</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ChatState(TypedDict):</div>
<div class="line">    user_query: str</div>
<div class="line">    <span class="comment"># We&#39;ll store the decision here</span></div>
<div class="line">    next_action: str</div>
<div class="line">    <span class="comment"># Keep track of intermediate results</span></div>
<div class="line">    search_result: Annotated[List[str], operator.add] <span class="comment"># Use Topic or add if accumulating</span></div>
<div class="line">    final_response: str</div>
</div><!-- fragment --><p>Our state holds the user's query and a field <code>next_action</code> to store the decision.</p>
<p><b>Step 2: Define Nodes</b></p>
<div class="fragment"><div class="line"><span class="comment"># Node that decides the next step</span></div>
<div class="line"><span class="keyword">def </span>determine_action(state: ChatState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Determining Action ---&quot;</span>)</div>
<div class="line">    query = state[<span class="stringliteral">&#39;user_query&#39;</span>]</div>
<div class="line">    <span class="keywordflow">if</span> <span class="stringliteral">&quot;weather&quot;</span> <span class="keywordflow">in</span> query.lower():</div>
<div class="line">        print(<span class="stringliteral">&quot;Decision: Need to use search tool for weather.&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> {<span class="stringliteral">&quot;next_action&quot;</span>: <span class="stringliteral">&quot;USE_TOOL&quot;</span>}</div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        print(<span class="stringliteral">&quot;Decision: Can respond directly.&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> {<span class="stringliteral">&quot;next_action&quot;</span>: <span class="stringliteral">&quot;RESPOND&quot;</span>}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node representing the search tool</span></div>
<div class="line"><span class="keyword">def </span>run_search_tool(state: ChatState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Using Search Tool ---&quot;</span>)</div>
<div class="line">    query = state[<span class="stringliteral">&#39;user_query&#39;</span>]</div>
<div class="line">    <span class="comment"># Simulate finding a result</span></div>
<div class="line">    result = f<span class="stringliteral">&quot;Search result for &#39;{query}&#39;: It&#39;s sunny!&quot;</span></div>
<div class="line">    <span class="comment"># We return the result to be ADDED to the state list</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;search_result&quot;</span>: [result]} <span class="comment"># Return as list for operator.add</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node that generates a final response</span></div>
<div class="line"><span class="keyword">def </span>generate_response(state: ChatState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Generating Response ---&quot;</span>)</div>
<div class="line">    <span class="keywordflow">if</span> state.get(<span class="stringliteral">&quot;search_result&quot;</span>):</div>
<div class="line">        response = f<span class="stringliteral">&quot;Based on my search: {state[&#39;search_result&#39;][-1]}&quot;</span></div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        response = f<span class="stringliteral">&quot;Responding directly to: {state[&#39;user_query&#39;]}&quot;</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;final_response&quot;</span>: response}</div>
</div><!-- fragment --><p><b>Step 3: Define the Routing Function</b></p>
<p>This function reads the <code>next_action</code> from the state and returns the <em>key</em> we'll use in our mapping.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>route_based_on_action(state: ChatState) -&gt; str:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Routing ---&quot;</span>)</div>
<div class="line">    action = state[<span class="stringliteral">&#39;next_action&#39;</span>]</div>
<div class="line">    print(f<span class="stringliteral">&quot;Routing based on action: {action}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">if</span> action == <span class="stringliteral">&quot;USE_TOOL&quot;</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;route_to_tool&quot;</span> <span class="comment"># This key must match our path_map</span></div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;route_to_respond&quot;</span> <span class="comment"># This key must match our path_map</span></div>
</div><!-- fragment --><p><b>Step 4: Build the Graph with Conditional Edges</b></p>
<div class="fragment"><div class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph, END, START</div>
<div class="line"> </div>
<div class="line">workflow = StateGraph(ChatState)</div>
<div class="line"> </div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;decider&quot;</span>, determine_action)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;search_tool&quot;</span>, run_search_tool)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;responder&quot;</span>, generate_response)</div>
<div class="line"> </div>
<div class="line">workflow.set_entry_point(<span class="stringliteral">&quot;decider&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># After &#39;decider&#39;, call &#39;route_based_on_action&#39; to choose the next step</span></div>
<div class="line">workflow.add_conditional_edges(</div>
<div class="line">    <span class="stringliteral">&quot;decider&quot;</span>, <span class="comment"># Start node</span></div>
<div class="line">    route_based_on_action, <span class="comment"># The routing function</span></div>
<div class="line">    {</div>
<div class="line">        <span class="comment"># Map the routing function&#39;s output to actual node names</span></div>
<div class="line">        <span class="stringliteral">&quot;route_to_tool&quot;</span>: <span class="stringliteral">&quot;search_tool&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;route_to_respond&quot;</span>: <span class="stringliteral">&quot;responder&quot;</span></div>
<div class="line">    }</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define what happens *after* the conditional paths</span></div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;search_tool&quot;</span>, <span class="stringliteral">&quot;responder&quot;</span>) <span class="comment"># After searching, generate response</span></div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;responder&quot;</span>, END) <span class="comment"># After responding, end</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Compile</span></div>
<div class="line">app = workflow.compile()</div>
</div><!-- fragment --><ul>
<li><code>add_conditional_edges("decider", route_based_on_action, ...)</code>: This is the key part. It tells LangGraph: after the "decider" node runs, execute the <code>route_based_on_action</code> function.</li>
<li><code>path_map = {"route_to_tool": "search_tool", ...}</code>: This dictionary maps the string returned by <code>route_based_on_action</code> to the actual next node to execute.</li>
</ul>
<p><b>Step 5: Run It!</b></p>
<div class="fragment"><div class="line"><span class="comment"># Scenario 1: Query needs the tool</span></div>
<div class="line">print(<span class="stringliteral">&quot;--- Scenario 1: Weather Query ---&quot;</span>)</div>
<div class="line">input1 = {<span class="stringliteral">&quot;user_query&quot;</span>: <span class="stringliteral">&quot;What&#39;s the weather like?&quot;</span>}</div>
<div class="line">final_state1 = app.invoke(input1)</div>
<div class="line">print(<span class="stringliteral">&quot;Final State 1:&quot;</span>, final_state1)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;\n--- Scenario 2: Direct Response ---&quot;</span>)</div>
<div class="line"><span class="comment"># Scenario 2: Query doesn&#39;t need the tool</span></div>
<div class="line">input2 = {<span class="stringliteral">&quot;user_query&quot;</span>: <span class="stringliteral">&quot;Tell me a joke.&quot;</span>}</div>
<div class="line">final_state2 = app.invoke(input2)</div>
<div class="line">print(<span class="stringliteral">&quot;Final State 2:&quot;</span>, final_state2)</div>
</div><!-- fragment --><p><b>Expected Output:</b></p>
<div class="fragment"><div class="line">--- Scenario 1: Weather Query ---</div>
<div class="line">--- Determining Action ---</div>
<div class="line">Decision: Need to use search tool for weather.</div>
<div class="line">--- Routing ---</div>
<div class="line">Routing based on action: USE_TOOL</div>
<div class="line">--- Using Search Tool ---</div>
<div class="line">--- Generating Response ---</div>
<div class="line">Final State 1: {&#39;user_query&#39;: &quot;What&#39;s the weather like?&quot;, &#39;next_action&#39;: &#39;USE_TOOL&#39;, &#39;search_result&#39;: [&quot;Search result for &#39;What&#39;s the weather like?&#39;: It&#39;s sunny!&quot;], &#39;final_response&#39;: &quot;Based on my search: Search result for &#39;What&#39;s the weather like?&#39;: It&#39;s sunny!&quot;}</div>
<div class="line"> </div>
<div class="line">--- Scenario 2: Direct Response ---</div>
<div class="line">--- Determining Action ---</div>
<div class="line">Decision: Can respond directly.</div>
<div class="line">--- Routing ---</div>
<div class="line">Routing based on action: RESPOND</div>
<div class="line">--- Generating Response ---</div>
<div class="line">Final State 2: {&#39;user_query&#39;: &#39;Tell me a joke.&#39;, &#39;next_action&#39;: &#39;RESPOND&#39;, &#39;search_result&#39;: [], &#39;final_response&#39;: &#39;Responding directly to: Tell me a joke.&#39;}</div>
</div><!-- fragment --><p>See how the graph took different paths based on the <code>next_action</code> set by the <code>decider</code> node and interpreted by the <code>route_based_on_action</code> function!</p>
<p><b>Visualizing the Branch:</b></p>
<div class="fragment"><div class="line">graph TD</div>
<div class="line">    Start[START] --&gt; Decider(decider);</div>
<div class="line">    Decider -- route_based_on_action --&gt; Route{Routing Logic};</div>
<div class="line">    Route -- &quot;route_to_tool&quot; --&gt; Search(search_tool);</div>
<div class="line">    Route -- &quot;route_to_respond&quot; --&gt; Respond(responder);</div>
<div class="line">    Search --&gt; Respond;</div>
<div class="line">    Respond --&gt; End(END);</div>
</div><!-- fragment --><p><b>Internals (<code>graph/branch.py</code>)</b></p>
<ul>
<li>When you call <code>add_conditional_edges</code>, LangGraph stores a <code>Branch</code> object (<code>graph/branch.py</code>). This object holds your routing function (<code>path</code>) and the mapping (<code>path_map</code> / <code>ends</code>).</li>
<li>During execution, after the source node ("decider") finishes, the <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> runs the <code>Branch</code> object.</li>
<li>The <code>Branch.run()</code> method eventually calls your routing function (<code>_route</code> or <code>_aroute</code> internally) with the current state.</li>
<li>It takes the return value (e.g., "route_to_tool"), looks it up in the <code>ends</code> dictionary to get the actual node name ("search_tool"), and tells the engine to schedule that node next.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># graph/branch.py (Simplified view)</span></div>
<div class="line"><span class="keyword">class </span>Branch(NamedTuple):</div>
<div class="line">    path: Runnable <span class="comment"># Your routing function wrapped as a Runnable</span></div>
<div class="line">    ends: Optional[dict[Hashable, str]] <span class="comment"># Your path_map</span></div>
<div class="line">    <span class="comment"># ... other fields ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>_route(self, input: Any, config: RunnableConfig, ...) -&gt; Runnable:</div>
<div class="line">        <span class="comment"># ... reads current state if needed ...</span></div>
<div class="line">        value = ... <span class="comment"># Get the state</span></div>
<div class="line">        result = self.path.invoke(value, config) <span class="comment"># Call your routing function</span></div>
<div class="line">        <span class="comment"># ... determines destination node(s) using self.ends mapping ...</span></div>
<div class="line">        destinations = [self.ends[r] <span class="keywordflow">for</span> r <span class="keywordflow">in</span> result]</div>
<div class="line">        <span class="comment"># ... tells the engine (via writer) which node(s) to run next ...</span></div>
<div class="line">        <span class="keywordflow">return</span> writer(destinations, config) <span class="keywordflow">or</span> input <span class="comment"># writer is a callback to the engine</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># graph/state.py (Simplified view)</span></div>
<div class="line"><span class="keyword">class </span>StateGraph(Graph):</div>
<div class="line">    <span class="comment"># ...</span></div>
<div class="line">    <span class="keyword">def </span>add_conditional_edges(self, source, path, path_map, ...):</div>
<div class="line">        <span class="comment"># ... wrap &#39;path&#39; into a Runnable ...</span></div>
<div class="line">        runnable_path = coerce_to_runnable(path, ...)</div>
<div class="line">        <span class="comment"># Create and store the Branch object</span></div>
<div class="line">        self.branches[source][name] = Branch.from_path(runnable_path, path_map, ...)</div>
<div class="line">        <span class="keywordflow">return</span> self</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2156"></a>
2. <code>Send</code> - Directing Specific Traffic</h2>
<p>Sometimes, you don't just want to choose <em>one</em> path, but you want to trigger a <em>specific</em> node with <em>specific</em> data, possibly multiple times. This is common in "map-reduce" patterns where you split a task into smaller pieces, process each piece independently, and then combine the results.</p>
<p>The <code>Send</code> primitive allows a node (or a conditional edge function) to directly "send" a piece of data to another node, telling the engine: "Run *this* node next, and give it *this* input."</p>
<p><b>How it Works:</b></p>
<ol type="1">
<li>You import <code>Send</code> from <code>langgraph.graph</code> (or <code>langgraph.types</code>).</li>
<li>In a node or a conditional edge function, instead of just returning a state update or a node name, you return <code>Send(target_node_name, data_for_that_node)</code>.</li>
<li>You can return a list of <code>Send</code> objects to trigger multiple node executions, potentially in parallel (depending on the executor).</li>
</ol>
<p><b>Example: Simple Map-Reduce</b></p>
<p>Let's imagine we want to process a list of items. One node splits the list, another node processes each item individually (the "map" step), and a final node aggregates the results (the "reduce" step).</p>
<p><b>Step 1: Define State</b></p>
<div class="fragment"><div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict, List, Annotated</div>
<div class="line"><span class="keyword">import</span> operator</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MapReduceState(TypedDict):</div>
<div class="line">    items_to_process: List[str]</div>
<div class="line">    <span class="comment"># Use Topic or operator.add to collect results from worker nodes</span></div>
<div class="line">    processed_items: Annotated[List[str], operator.add]</div>
<div class="line">    final_result: str</div>
</div><!-- fragment --><p><b>Step 2: Define Nodes</b></p>
<div class="fragment"><div class="line"><span class="comment"># Node to prepare items (not really needed here, but shows the flow)</span></div>
<div class="line"><span class="keyword">def </span>prepare_items(state: MapReduceState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Preparing Items (No change) ---&quot;</span>)</div>
<div class="line">    <span class="comment"># In a real scenario, this might fetch or generate the items</span></div>
<div class="line">    <span class="keywordflow">return</span> {}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node to process a single item (Our &quot;Worker&quot;)</span></div>
<div class="line"><span class="keyword">def </span>process_single_item(state: dict) -&gt; dict:</div>
<div class="line">    <span class="comment"># Note: This node receives the dict passed via Send, NOT the full MapReduceState</span></div>
<div class="line">    item = state[<span class="stringliteral">&#39;item&#39;</span>]</div>
<div class="line">    print(f<span class="stringliteral">&quot;--- Processing Item: {item} ---&quot;</span>)</div>
<div class="line">    processed = f<span class="stringliteral">&quot;Processed_{item.upper()}&quot;</span></div>
<div class="line">    <span class="comment"># Return the processed item to be ADDED to the list in the main state</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;processed_items&quot;</span>: [processed]} <span class="comment"># Return list for operator.add</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node to aggregate results</span></div>
<div class="line"><span class="keyword">def </span>aggregate_results(state: MapReduceState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Aggregating Results ---&quot;</span>)</div>
<div class="line">    all_processed = state[<span class="stringliteral">&#39;processed_items&#39;</span>]</div>
<div class="line">    final = <span class="stringliteral">&quot;, &quot;</span>.join(all_processed)</div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;final_result&quot;</span>: final}</div>
</div><!-- fragment --><p><b>Step 3: Define the Dispatching Function (using <code>Send</code>)</b></p>
<p>This function will run after <code>prepare_items</code> and will use <code>Send</code> to trigger <code>process_single_item</code> for each item.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> Send <span class="comment"># Import Send</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>dispatch_work(state: MapReduceState) -&gt; List[Send]:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Dispatching Work ---&quot;</span>)</div>
<div class="line">    items = state[<span class="stringliteral">&#39;items_to_process&#39;</span>]</div>
<div class="line">    send_packets = []</div>
<div class="line">    <span class="keywordflow">for</span> item <span class="keywordflow">in</span> items:</div>
<div class="line">        print(f<span class="stringliteral">&quot;Sending item &#39;{item}&#39; to worker node.&quot;</span>)</div>
<div class="line">        <span class="comment"># Create a Send object for each item</span></div>
<div class="line">        <span class="comment"># Target node: &quot;worker&quot;</span></div>
<div class="line">        <span class="comment"># Data payload: a dictionary {&#39;item&#39;: current_item}</span></div>
<div class="line">        packet = Send(<span class="stringliteral">&quot;worker&quot;</span>, {<span class="stringliteral">&quot;item&quot;</span>: item})</div>
<div class="line">        send_packets.append(packet)</div>
<div class="line">    <span class="keywordflow">return</span> send_packets <span class="comment"># Return a list of Send objects</span></div>
</div><!-- fragment --><p><b>Step 4: Build the Graph</b></p>
<div class="fragment"><div class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph, END, START</div>
<div class="line"> </div>
<div class="line">workflow = StateGraph(MapReduceState)</div>
<div class="line"> </div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;preparer&quot;</span>, prepare_items)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;worker&quot;</span>, process_single_item) <span class="comment"># The node targeted by Send</span></div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;aggregator&quot;</span>, aggregate_results)</div>
<div class="line"> </div>
<div class="line">workflow.set_entry_point(<span class="stringliteral">&quot;preparer&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># After &#39;preparer&#39;, call &#39;dispatch_work&#39; which returns Send packets</span></div>
<div class="line">workflow.add_conditional_edges(<span class="stringliteral">&quot;preparer&quot;</span>, dispatch_work)</div>
<div class="line"><span class="comment"># NOTE: We don&#39;t need a path_map here because dispatch_work directly</span></div>
<div class="line"><span class="comment">#       returns Send objects specifying the target node.</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># The &#39;worker&#39; node outputs are aggregated implicitly by the &#39;processed_items&#39; channel.</span></div>
<div class="line"><span class="comment"># We need an edge to tell the graph when to run the aggregator.</span></div>
<div class="line"><span class="comment"># Let&#39;s wait until ALL workers triggered by Send are done.</span></div>
<div class="line"><span class="comment"># We can achieve this implicitly if the aggregator reads state written by workers.</span></div>
<div class="line"><span class="comment"># A simple edge ensures aggregator runs *after* the step involving workers.</span></div>
<div class="line"><span class="comment"># (More complex aggregation might need explicit barrier channels)</span></div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;worker&quot;</span>, <span class="stringliteral">&quot;aggregator&quot;</span>)</div>
<div class="line"> </div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;aggregator&quot;</span>, END)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Compile</span></div>
<div class="line">app = workflow.compile()</div>
</div><!-- fragment --><p><b>Step 5: Run It!</b></p>
<div class="fragment"><div class="line">input_state = {<span class="stringliteral">&quot;items_to_process&quot;</span>: [<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;cherry&quot;</span>]}</div>
<div class="line">final_state = app.invoke(input_state)</div>
<div class="line">print(<span class="stringliteral">&quot;\nFinal State:&quot;</span>, final_state)</div>
</div><!-- fragment --><p><b>Expected Output (order of processing might vary):</b></p>
<div class="fragment"><div class="line">--- Preparing Items (No change) ---</div>
<div class="line">--- Dispatching Work ---</div>
<div class="line">Sending item &#39;apple&#39; to worker node.</div>
<div class="line">Sending item &#39;banana&#39; to worker node.</div>
<div class="line">Sending item &#39;cherry&#39; to worker node.</div>
<div class="line">--- Processing Item: apple ---</div>
<div class="line">--- Processing Item: banana ---</div>
<div class="line">--- Processing Item: cherry ---</div>
<div class="line">--- Aggregating Results ---</div>
<div class="line"> </div>
<div class="line">Final State: {&#39;items_to_process&#39;: [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;], &#39;processed_items&#39;: [&#39;Processed_APPLE&#39;, &#39;Processed_BANANA&#39;, &#39;Processed_CHERRY&#39;], &#39;final_result&#39;: &#39;Processed_APPLE, Processed_BANANA, Processed_CHERRY&#39;}</div>
</div><!-- fragment --><p>The <code>dispatch_work</code> function returned three <code>Send</code> objects. The LangGraph engine then scheduled the "worker" node to run three times, each time with a different input dictionary (&lsquo;{'item&rsquo;: 'apple'}<code>,</code>{'item': 'banana'}<code>,</code>{'item': 'cherry'}<code>). The results were automatically collected in</code>processed_items<code>thanks to the</code>operator.add<code>reducer on our</code>Annotated<code>state key. Finally, the</code>aggregator` ran.</p>
<p><b>Internals (<code>types.py</code>, <code>constants.py</code>)</b></p>
<ul>
<li><code>Send(node, arg)</code> is a simple data class defined in <code>langgraph/types.py</code>.</li>
<li>When a node or branch returns <code>Send</code> objects, the engine collects them. Internally, these are often associated with a special channel key like <code>TASKS</code> (defined in <code>langgraph/constants.py</code>).</li>
<li>The <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> processes these <code>TASKS</code>. For each <code>Send(node, arg)</code>, it schedules the target <code>node</code> to run in the <em>next</em> step, passing <code>arg</code> as its input.</li>
<li>This allows for dynamic, data-driven invocation of nodes outside the standard edge connections.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># types.py (Simplified view)</span></div>
<div class="line"><span class="keyword">class </span>Send:</div>
<div class="line">    __slots__ = (<span class="stringliteral">&quot;node&quot;</span>, <span class="stringliteral">&quot;arg&quot;</span>)</div>
<div class="line">    node: str <span class="comment"># Target node name</span></div>
<div class="line">    arg: Any  <span class="comment"># Data payload for the node</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self, /, node: str, arg: Any) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">        self.node = node</div>
<div class="line">        self.arg = arg</div>
<div class="line">    <span class="comment"># ... repr, eq, hash ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># constants.py (Simplified view)</span></div>
<div class="line">TASKS = sys.intern(<span class="stringliteral">&quot;__pregel_tasks&quot;</span>) <span class="comment"># Internal key for Send objects</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># pregel/algo.py (Conceptual idea during task processing)</span></div>
<div class="line"><span class="comment"># if write is for TASKS channel:</span></div>
<div class="line"><span class="comment">#   packet = write_value # This is the Send object</span></div>
<div class="line"><span class="comment">#   # Schedule packet.node to run in the next step with packet.arg</span></div>
<div class="line"><span class="comment">#   schedule_task(node=packet.node, input=packet.arg, ...)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2157"></a>
3. <code>Interrupt</code> - Pausing for Instructions</h2>
<p>Sometimes, your graph needs to stop and wait for external input before proceeding. A common case is Human-in-the-Loop (HITL), where an AI agent proposes a plan or an action, and a human needs to approve it.</p>
<p>The <code>Interrupt</code> primitive allows a node to pause the graph's execution and wait. This requires a <a class="el" href="../../d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html">Checkpointer</a> to be configured, as the graph needs to save its state to be resumable later.</p>
<p><b>How it Works:</b></p>
<ol type="1">
<li>You import <code>interrupt</code> from <code>langgraph.types</code>.</li>
<li>Inside a node, you call <code>interrupt(value_to_send_to_client)</code>.</li>
<li>This immediately raises a special <code>GraphInterrupt</code> exception.</li>
<li>The LangGraph engine catches this, saves the current state using the checkpointer, and returns control to your calling code, often signaling that an interrupt occurred. The <code>value_to_send_to_client</code> is included in the information returned.</li>
<li>Later, you can resume the graph execution by providing a value. This is typically done by invoking the compiled graph again with a special <code>Command(resume=value_for_interrupt)</code> object (from <code>langgraph.types</code>) and the same configuration (including the thread ID for the checkpointer).</li>
<li>When resumed, the graph loads the saved state. The execution engine restarts the <em>interrupted node from the beginning</em>. When the code reaches the <code>interrupt()</code> call again, instead of raising an exception, it <em>returns</em> the <code>value_for_interrupt</code> that you provided when resuming. The node then continues executing from that point.</li>
</ol>
<p><b>Example: Human Approval Step</b></p>
<p>Let's create a graph where a node plans an action, another node presents it for human approval (using <code>interrupt</code>), and a final node executes it if approved.</p>
<p><b>Step 1: Define State</b></p>
<div class="fragment"><div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict, Optional</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ApprovalState(TypedDict):</div>
<div class="line">    plan: str</div>
<div class="line">    <span class="comment"># We&#39;ll use the resume value to implicitly know if approved</span></div>
<div class="line">    feedback: Optional[str] <span class="comment"># Store feedback/approval status</span></div>
</div><!-- fragment --><p><b>Step 2: Define Nodes (including interrupt)</b></p>
<div class="fragment"><div class="line"><span class="keyword">from</span> langgraph.types <span class="keyword">import</span> interrupt, Command <span class="comment"># Import interrupt and Command</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node that creates a plan</span></div>
<div class="line"><span class="keyword">def </span>create_plan(state: ApprovalState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Creating Plan ---&quot;</span>)</div>
<div class="line">    plan = <span class="stringliteral">&quot;Plan: Execute risky action X.&quot;</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;plan&quot;</span>: plan}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node that requests human approval using interrupt</span></div>
<div class="line"><span class="keyword">def </span>request_approval(state: ApprovalState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Requesting Human Approval ---&quot;</span>)</div>
<div class="line">    plan = state[<span class="stringliteral">&#39;plan&#39;</span>]</div>
<div class="line">    print(f<span class="stringliteral">&quot;Proposed Plan: {plan}&quot;</span>)</div>
<div class="line">    <span class="comment"># Call interrupt, passing the plan to the client</span></div>
<div class="line">    <span class="comment"># Execution STOPS here on the first run.</span></div>
<div class="line">    feedback_or_approval = interrupt(plan)</div>
<div class="line">    <span class="comment"># --- Execution RESUMES here on the second run ---</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;--- Resumed with feedback: {feedback_or_approval} ---&quot;</span>)</div>
<div class="line">    <span class="comment"># Store the feedback received from the resume command</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;feedback&quot;</span>: str(feedback_or_approval)} <span class="comment"># Ensure it&#39;s a string</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node that executes the plan (only if approved implicitly by resuming)</span></div>
<div class="line"><span class="keyword">def </span>execute_plan(state: ApprovalState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Executing Plan ---&quot;</span>)</div>
<div class="line">    <span class="keywordflow">if</span> state.get(<span class="stringliteral">&quot;feedback&quot;</span>): <span class="comment"># Check if we got feedback (meaning we resumed)</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;Executing &#39;{state[&#39;plan&#39;]}&#39; based on feedback: {state[&#39;feedback&#39;]}&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span> {} <span class="comment"># No state change needed</span></div>
<div class="line">    <span class="keywordflow">else</span>:</div>
<div class="line">        <span class="comment"># This path shouldn&#39;t be hit if interrupt works correctly</span></div>
<div class="line">        print(<span class="stringliteral">&quot;Execution skipped (no feedback received).&quot;</span>)</div>
<div class="line">        <span class="keywordflow">return</span>{}</div>
</div><!-- fragment --><p><b>Step 3: Build the Graph (with Checkpointer!)</b></p>
<div class="fragment"><div class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph, END, START</div>
<div class="line"><span class="comment"># Need a checkpointer for interrupts!</span></div>
<div class="line"><span class="keyword">from</span> langgraph.checkpoint.memory <span class="keyword">import</span> MemorySaver</div>
<div class="line"> </div>
<div class="line">workflow = StateGraph(ApprovalState)</div>
<div class="line"> </div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;planner&quot;</span>, create_plan)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;approval_gate&quot;</span>, request_approval)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;executor&quot;</span>, execute_plan)</div>
<div class="line"> </div>
<div class="line">workflow.set_entry_point(<span class="stringliteral">&quot;planner&quot;</span>)</div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;planner&quot;</span>, <span class="stringliteral">&quot;approval_gate&quot;</span>)</div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;approval_gate&quot;</span>, <span class="stringliteral">&quot;executor&quot;</span>) <span class="comment"># Runs after interrupt is resolved</span></div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;executor&quot;</span>, END)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create checkpointer and compile</span></div>
<div class="line">memory_saver = MemorySaver()</div>
<div class="line">app = workflow.compile(checkpointer=memory_saver)</div>
</div><!-- fragment --><p><b>Step 4: Run and Resume</b></p>
<div class="fragment"><div class="line"><span class="keyword">import</span> uuid</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Unique ID for this conversation thread is needed for the checkpointer</span></div>
<div class="line">config = {<span class="stringliteral">&quot;configurable&quot;</span>: {<span class="stringliteral">&quot;thread_id&quot;</span>: str(uuid.uuid4())}}</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;--- Initial Invocation ---&quot;</span>)</div>
<div class="line"><span class="comment"># Start the graph. It should interrupt at the approval node.</span></div>
<div class="line">interrupt_info = <span class="keywordtype">None</span></div>
<div class="line"><span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> app.stream({<span class="stringliteral">&quot;plan&quot;</span>: <span class="stringliteral">&quot;&quot;</span>}, config=config):</div>
<div class="line">    print(chunk)</div>
<div class="line">    <span class="comment"># Check if the chunk contains interrupt information</span></div>
<div class="line">    <span class="keywordflow">if</span> <span class="stringliteral">&quot;__interrupt__&quot;</span> <span class="keywordflow">in</span> chunk:</div>
<div class="line">        interrupt_info = chunk[<span class="stringliteral">&quot;__interrupt__&quot;</span>]</div>
<div class="line">        print(<span class="stringliteral">&quot;\n!! Graph Interrupted !!&quot;</span>)</div>
<div class="line">        <span class="keywordflow">break</span> <span class="comment"># Stop processing stream after interrupt</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># The client code inspects the interrupt value (the plan)</span></div>
<div class="line"><span class="keywordflow">if</span> interrupt_info:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Interrupt Value (Plan): {interrupt_info[0].value}&quot;</span>) <span class="comment"># interrupt_info is a tuple</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># --- Simulate human interaction ---</span></div>
<div class="line">    human_decision = <span class="stringliteral">&quot;Approved, proceed with caution.&quot;</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;\n--- Resuming with Decision: &#39;{human_decision}&#39; ---&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Resume execution with the human&#39;s feedback/approval</span></div>
<div class="line">    <span class="comment"># We pass the decision using Command(resume=...)</span></div>
<div class="line">    <span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> app.stream(Command(resume=human_decision), config=config):</div>
<div class="line">         print(chunk)</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">else</span>:</div>
<div class="line">    print(<span class="stringliteral">&quot;Graph finished without interruption.&quot;</span>)</div>
</div><!-- fragment --><p><b>Expected Output:</b></p>
<div class="fragment"><div class="line">--- Initial Invocation ---</div>
<div class="line">{&#39;planner&#39;: {&#39;plan&#39;: &#39;Plan: Execute risky action X.&#39;}}</div>
<div class="line">{&#39;approval_gate&#39;: None} # Node starts execution</div>
<div class="line">--- Requesting Human Approval ---</div>
<div class="line">Proposed Plan: Plan: Execute risky action X.</div>
<div class="line">{&#39;__interrupt__&#39;: (Interrupt(value=&#39;Plan: Execute risky action X.&#39;, resumable=True, ns=..., when=&#39;during&#39;),)} # Interrupt occurs</div>
<div class="line"> </div>
<div class="line">!! Graph Interrupted !!</div>
<div class="line">Interrupt Value (Plan): Plan: Execute risky action X.</div>
<div class="line"> </div>
<div class="line">--- Resuming with Decision: &#39;Approved, proceed with caution.&#39; ---</div>
<div class="line">{&#39;approval_gate&#39;: {&#39;feedback&#39;: &#39;Approved, proceed with caution.&#39;}} # Node resumes and finishes</div>
<div class="line">--- Resumed with feedback: Approved, proceed with caution. ---</div>
<div class="line">{&#39;executor&#39;: {}} # Executor node runs</div>
<div class="line">--- Executing Plan ---</div>
<div class="line">Executing &#39;Plan: Execute risky action X.&#39; based on feedback: Approved, proceed with caution.</div>
<div class="line">{&#39;__end__&#39;: {&#39;plan&#39;: &#39;Plan: Execute risky action X.&#39;, &#39;feedback&#39;: &#39;Approved, proceed with caution.&#39;}} # Graph finishes</div>
</div><!-- fragment --><p>The graph paused at <code>request_approval</code> after printing the plan. We then resumed it by sending <code>Command(resume="Approved, proceed with caution.")</code>. The <code>request_approval</code> node restarted, the <code>interrupt()</code> call returned our resume value, which was stored in the state, and finally, the <code>executor</code> node ran using that feedback.</p>
<p><b>Internals (<code>types.py</code>, <code>errors.py</code>, Checkpointer)</b></p>
<ul>
<li>The <code>interrupt(value)</code> function (in <code>langgraph/types.py</code>) checks if a resume value is available for the current step within the node.</li>
<li>If no resume value exists (first run), it raises a <code>GraphInterrupt</code> exception (<code>langgraph/errors.py</code>) containing an <code>Interrupt</code> object (<code>langgraph/types.py</code>) which holds the <code>value</code>.</li>
<li>The <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> catches <code>GraphInterrupt</code>.</li>
<li>If a <a class="el" href="../../d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html">Checkpointer</a> is present, the engine saves the current state (including which node was interrupted) and passes the <code>Interrupt</code> object back to the caller.</li>
<li>When you resume with <code>Command(resume=resume_value)</code>, the engine loads the checkpoint.</li>
<li>It knows which node was interrupted and provides the <code>resume_value</code> to it (often via a special <code>RESUME</code> entry written to the state channels, managed internally via <code>PregelScratchpad</code> in <code>pregel/algo.py</code>).</li>
<li>The node restarts. When <code>interrupt()</code> is called again, it finds the <code>resume_value</code> (provided via the scratchpad or internal state) and returns it instead of raising an exception.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># types.py (Simplified view)</span></div>
<div class="line"><span class="keyword">def </span>interrupt(value: Any) -&gt; Any:</div>
<div class="line">    <span class="comment"># ... access internal config/scratchpad ...</span></div>
<div class="line">    scratchpad = conf[CONFIG_KEY_SCRATCHPAD]</div>
<div class="line">    idx = scratchpad.interrupt_counter()</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Check if resume value already exists for this interrupt index</span></div>
<div class="line">    <span class="keywordflow">if</span> scratchpad.resume <span class="keywordflow">and</span> idx &lt; len(scratchpad.resume):</div>
<div class="line">        <span class="keywordflow">return</span> scratchpad.resume[idx] <span class="comment"># Return existing resume value</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Check if a new global resume value was provided</span></div>
<div class="line">    v = scratchpad.get_null_resume(consume=<span class="keyword">True</span>)</div>
<div class="line">    <span class="keywordflow">if</span> v <span class="keywordflow">is</span> <span class="keywordflow">not</span> <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="comment"># Store and return the new resume value</span></div>
<div class="line">        scratchpad.resume.append(v)</div>
<div class="line">        conf[CONFIG_KEY_SEND]([(RESUME, scratchpad.resume)]) <span class="comment"># Update state internally</span></div>
<div class="line">        <span class="keywordflow">return</span> v</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># No resume value - raise the interrupt exception</span></div>
<div class="line">    <span class="keywordflow">raise</span> GraphInterrupt(</div>
<div class="line">        (Interrupt(value=value, resumable=<span class="keyword">True</span>, ns=...),)</div>
<div class="line">    )</div>
<div class="line"> </div>
<div class="line"><span class="comment"># types.py (Simplified view)</span></div>
<div class="line"><span class="preprocessor">@dataclasses.dataclass</span></div>
<div class="line"><span class="keyword">class </span>Interrupt:</div>
<div class="line">    value: Any <span class="comment"># The value passed to interrupt()</span></div>
<div class="line">    resumable: bool = <span class="keyword">True</span></div>
<div class="line">    <span class="comment"># ... other fields ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># types.py (Simplified view)</span></div>
<div class="line"><span class="preprocessor">@dataclasses.dataclass</span></div>
<div class="line"><span class="keyword">class </span>Command:</div>
<div class="line">    <span class="comment"># ... other fields like update, goto ...</span></div>
<div class="line">    resume: Optional[Any] = <span class="keywordtype">None</span> <span class="comment"># Value to provide to a pending interrupt</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># errors.py (Simplified view)</span></div>
<div class="line"><span class="keyword">class </span>GraphInterrupt(Exception): <span class="comment"># Base class for interrupts</span></div>
<div class="line">    <span class="keywordflow">pass</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2158"></a>
Conclusion</h2>
<p>You've learned about the essential tools for controlling the flow of execution in your LangGraph applications:</p>
<ul>
<li><b><code>Branch</code></b> (<code>add_conditional_edges</code>): Used to create conditional paths, like <code>if/else</code> statements, directing the flow based on the current state. Requires a routing function and often a path map.</li>
<li><b><code>Send</code></b>: Used to directly trigger a specific node with specific data, bypassing normal edges. Essential for patterns like map-reduce where you want to invoke the same worker node multiple times with different inputs.</li>
<li><b><code>Interrupt</code></b> (<code>langgraph.types.interrupt</code>): Used to pause graph execution, typically for human-in-the-loop scenarios. Requires a checkpointer and is resumed using <code>Command(resume=...)</code>.</li>
</ul>
<p>These primitives transform your graph from a simple linear sequence into a dynamic, decision-making process capable of handling complex, real-world workflows.</p>
<p>Now that we understand how nodes execute, how state is managed via channels, and how control flow directs traffic, let's look at the engine that orchestrates all of this behind the scenes.</p>
<p>Next up: <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Chapter 5: Pregel Execution Engine</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
