#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 07_umath_module</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/db5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_207__umath__module.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">07_umath_module</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2582"></a>
autotoc_md2582</h2>
<p>layout: default title: "Umath Module" parent: "NumPy Core" </p>
<h2><a class="anchor" id="autotoc_md2583"></a>
nav_order: 7</h2>
<h1><a class="anchor" id="autotoc_md2584"></a>
Chapter 7: umath Module</h1>
<p>Welcome to Chapter 7! In <a class="el" href="../../db/d8b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_206__multiarray__module.html">Chapter 6: multiarray Module</a>, we explored the core C engine that defines the <code>ndarray</code> object and handles fundamental operations like creating arrays and accessing elements. We saw that the actual power comes from C code.</p>
<p>But what about the mathematical operations themselves? When you perform <code>np.sin(my_array)</code> or <code>array1 + array2</code>, which part of the C engine handles the actual sine calculation or the addition for <em>every single element</em>? This is where the concept of the <code>umath</code> module comes in.</p>
<h2><a class="anchor" id="autotoc_md2585"></a>
What Problem Does <code>umath</code> Solve? Implementing Fast Array Math</h2>
<p>Remember the <a class="el" href="../../d6/def/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_203__ufunc____universal__function__.html">ufunc (Universal Function)</a> from Chapter 3? Ufuncs are NumPy's special functions designed to operate element-wise on arrays with incredible speed (like <code>np.add</code>, <code>np.sin</code>, <code>np.log</code>).</p>
<p>Let's take a simple example:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line">angles = np.array([0, np.pi/2, np.pi])</div>
<div class="line">sines = np.sin(angles) <span class="comment"># How is this sine calculated so fast?</span></div>
<div class="line"> </div>
<div class="line">print(angles)</div>
<div class="line">print(sines)</div>
</div><!-- fragment --><p><b>Output:</b></p>
<div class="fragment"><div class="line">[0.         1.57079633 3.14159265]</div>
<div class="line">[0.0000000e+00 1.0000000e+00 1.2246468e-16] # Note: pi value is approximate</div>
</div><!-- fragment --><p>The Python function <code>np.sin</code> acts as a dispatcher. It needs to hand off the actual, heavy-duty work of calculating the sine for each element in the <code>angles</code> array to highly optimized code. Where does this optimized code live?</p>
<p>Historically, the C code responsible for implementing the <em>loops and logic</em> of these mathematical ufuncs (like addition, subtraction, sine, cosine, logarithm, etc.) was contained within a dedicated C extension module called <code>umath</code>. It provided the fast, element-by-element computational kernels.</p>
<h2><a class="anchor" id="autotoc_md2586"></a>
What is the <code>umath</code> Module (Concept)?</h2>
<p>The <code>umath</code> module represents the part of NumPy's C core dedicated to implementing <b>universal functions (ufuncs)</b>. Think of it as NumPy's built-in, highly optimized math library specifically designed for element-wise operations on arrays.</p>
<p><b>Key Points:</b></p>
<ol type="1">
<li><b>Houses ufunc Implementations:</b> It contains the low-level C code that performs the actual calculations for functions like <code>np.add</code>, <code>np.sin</code>, <code>np.exp</code>, <code>np.sqrt</code>, etc.</li>
<li><b>Optimized Loops:</b> This C code includes specialized loops that iterate over the array elements very efficiently, often tailored for specific <a class="el" href="../../d6/d31/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_202__dtype____data__type__object__.html">dtype (Data Type Object)</a>s (like a fast loop for adding 32-bit integers, another for 64-bit floats, etc.).</li>
<li><b>Historical C Module:</b> Originally, <code>umath</code> was a separate compiled C extension module (<code>umath.so</code> or <code>umath.pyd</code>).</li>
<li><b>Merged with <code>multiarray</code>:</b> Since NumPy 1.16, the C code for <code>umath</code> has been merged with the C code for <code>multiarray</code> into a single, larger C extension module named <code>_multiarray_umath</code>. While they are now in the same compiled file, the <em>functions and purpose</em> associated with <code>umath</code> (implementing ufunc math) are distinct from those associated with <code>multiarray</code> (array object structure and basic manipulation).</li>
<li><b>Python Access (<code>numpy/core/umath.py</code>):</b> You don't usually interact with the C code directly. Instead, NumPy provides Python functions (like <code>np.add</code>, <code>np.sin</code>) in the Python file <code>numpy/core/umath.py</code>. These Python functions are wrappers that know how to find and trigger the correct C implementation within the <code>_multiarray_umath</code> extension module.</li>
</ol>
<p><b>Analogy:</b> Imagine <code>multiarray</code> builds the car chassis and engine block (<code>ndarray</code> structure). <code>umath</code> provides specialized, high-performance engine components like the fuel injectors for addition (<code>np.add</code>'s C code), the turbocharger for exponentiation (<code>np.exp</code>'s C code), and the precise valve timing for trigonometry (<code>np.sin</code>'s C code). The Python functions (<code>np.add</code>, <code>np.sin</code>) are the pedals and buttons you use to activate these components.</p>
<h2><a class="anchor" id="autotoc_md2587"></a>
How it Works (Usage Perspective)</h2>
<p>As a NumPy user, you typically trigger the <code>umath</code> C code indirectly by calling a ufunc:</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div>
<div class="line"> </div>
<div class="line">a = np.array([1, 2, 3])</div>
<div class="line">b = np.array([10, 20, 30])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Calling the ufunc np.add</span></div>
<div class="line">result1 = np.add(a, b) <span class="comment"># Triggers the C implementation for addition</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Using the operator &#39;+&#39; which also calls np.add for arrays</span></div>
<div class="line">result2 = a + b        <span class="comment"># Also triggers the C implementation</span></div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Using np.add: {result1}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Using + operator: {result2}&quot;</span>)</div>
</div><!-- fragment --><p><b>Output:</b></p>
<div class="fragment"><div class="line">Using np.add: [11 22 33]</div>
<div class="line">Using + operator: [11 22 33]</div>
</div><!-- fragment --><p>Both <code>np.add(a, b)</code> and <code>a + b</code> ultimately lead to NumPy executing the highly optimized C code associated with the addition ufunc, which conceptually belongs to the <code>umath</code> part of the core.</p>
<h2><a class="anchor" id="autotoc_md2588"></a>
A Glimpse Under the Hood</h2>
<p>When you call a ufunc like <code>np.add(a, b)</code>:</p>
<ol type="1">
<li><b>Python Call:</b> You invoke the Python function <code>np.add</code> (found in <code>numpy/core/umath.py</code> or exposed through <code>numpy/core/__init__.py</code>).</li>
<li><b>Identify Ufunc Object:</b> This Python function accesses the corresponding ufunc object (<code>np.add</code> itself is a ufunc object). This object holds metadata about the operation.</li>
<li><b>Dispatch to C:</b> The ufunc object mechanism (part of the <code>_multiarray_umath</code> C core) takes over.</li>
<li><b>Type Resolution &amp; Loop Selection:</b> The C code inspects the <code>dtype</code>s of the input arrays (<code>a</code> and <code>b</code>). Based on the input types, it looks up an internal table associated with the <code>add</code> ufunc to find the <em>best</em> matching, pre-compiled C loop. For example, if <code>a</code> and <code>b</code> are both <code>int64</code>, it selects the C function specifically designed for <code>int64 + int64 -&gt; int64</code>. This selection process might involve type casting rules (e.g., adding <code>int32</code> and <code>float64</code> might choose a loop that operates on <code>float64</code>).</li>
<li><b>Execute C Loop:</b> The selected C function (the core <code>umath</code> implementation for this specific type combination) is executed. This function iterates efficiently over the input array(s) memory, performs the addition element by element, and stores the results in the output array's memory.</li>
<li><b>Return Result:</b> The C machinery wraps the output memory into a new <code>ndarray</code> object and returns it back to your Python code.</li>
</ol>
<p>Here's a simplified sequence diagram:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User as Your Python Script</div>
<div class="line">    participant PyUfunc as np.add (Python Wrapper)</div>
<div class="line">    participant UfuncObj as Ufunc Object (Metadata)</div>
<div class="line">    participant C_Core as C Code (_multiarray_umath)</div>
<div class="line">    participant C_Loop as Specific Add Loop (e.g., int64_add)</div>
<div class="line">    participant Memory</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;PyUfunc: result = np.add(a, b)</div>
<div class="line">    PyUfunc-&gt;&gt;UfuncObj: Access the &#39;add&#39; ufunc object</div>
<div class="line">    UfuncObj-&gt;&gt;C_Core: Initiate ufunc execution (pass inputs a, b)</div>
<div class="line">    C_Core-&gt;&gt;C_Core: Inspect a.dtype, b.dtype</div>
<div class="line">    C_Core-&gt;&gt;UfuncObj: Find best C loop (e.g., int64_add loop)</div>
<div class="line">    C_Core-&gt;&gt;Memory: Allocate memory for result (if needed)</div>
<div class="line">    C_Core-&gt;&gt;C_Loop: Execute int64_add(a_data, b_data, result_data)</div>
<div class="line">    C_Loop-&gt;&gt;Memory: Read a, b, compute sum, write result</div>
<div class="line">    C_Loop--&gt;&gt;C_Core: Signal loop completion</div>
<div class="line">    C_Core-&gt;&gt;Memory: Wrap result memory in ndarray object</div>
<div class="line">    C_Core--&gt;&gt;PyUfunc: Return result ndarray</div>
<div class="line">    PyUfunc--&gt;&gt;User: Assign result ndarray to &#39;result&#39;</div>
</div><!-- fragment --><p><b>Where is the Code?</b></p>
<ul>
<li><b>C Extension Module:</b> The compiled code lives in <code>_multiarray_umath.so</code> / <code>.pyd</code>.</li>
<li><b>Ufunc Definition &amp; Generation:</b> The script <code>numpy/core/code_generators/generate_umath.py</code> is crucial. It contains definitions (like the <code>defdict</code> dictionary) that describe each ufunc: its name, number of inputs/outputs, identity element, the C functions to use for different type combinations (<code>TD</code> entries), and associated docstrings. This script generates C code (<code>__umath_generated.c</code>, which is then compiled) that sets up the ufunc objects and their internal loop tables. <code>python @section autotoc_md2589 Simplified snippet from generate_umath.py's defdict for 'add' 'add': Ufunc(2, 1, Zero, # nin=2, nout=1, identity=0 docstrings.get('numpy._core.umath.add'), # Docstring reference 'PyUFunc_AdditionTypeResolver', # Type resolution logic TD('?', ...), # Loop for booleans TD(no_bool_times_obj, dispatch=[...]), # Loops for numeric types @section autotoc_md2590 ... loops for datetime, object ... ), </code> This definition tells the generator how to build the <code>np.add</code> ufunc, including which C functions (often defined in other C files or generated from templates) handle addition for different data types.</li>
<li><b>C Loop Implementations:</b> The actual C code performing the math often comes from template files (like <code>numpy/core/src/umath/loops.c.src</code>) or CPU-dispatch-specific files (like <code>numpy/core/src/umath/loops_arithm_fp.dispatch.c.src</code>). These <code>.src</code> files contain templates written in a C-like syntax that get processed to generate specific C code for various data types (e.g., generating <code>int32_add</code>, <code>int64_add</code>, <code>float32_add</code>, <code>float64_add</code> from a single addition template). The dispatch files allow NumPy to choose optimized code paths (using e.g., AVX2, AVX512 instructions) based on your CPU's capabilities at runtime.</li>
<li><b>Python Wrappers:</b> <code>numpy/core/umath.py</code> provides the Python functions like <code>np.add</code>, <code>np.sin</code> that you call. It primarily imports these functions directly from the <code>_multiarray_umath</code> C extension module. ``&lsquo;python </li>
</ul>
<h1><a class="anchor" id="autotoc_md2591"></a>
From numpy/core/umath.py - Simplified</h1>
<p>from . import _multiarray_umath from ._multiarray_umath import * # Imports C-defined ufuncs like 'add&rsquo;</p>
<h1><a class="anchor" id="autotoc_md2592"></a>
Functions like 'add', 'sin', 'log' are now available in this module's</h1>
<h1><a class="anchor" id="autotoc_md2593"></a>
namespace, ready to be used via <code>np.add</code>, <code>np.sin</code>, etc.</h1>
<p>``<code></p><ul>
<li>**Namespace Setup:**</li>
</ul>
<p></code>numpy/core/__init__.py<code>imports from</code>numpy.core.umath&lt;tt&gt;(among others) to make functions likenp.add<code>easily accessible under the main</code>np` namespace.</p>
<h2><a class="anchor" id="autotoc_md2594"></a>
Conclusion</h2>
<p>You've now seen that the <code>umath</code> concept represents the implementation heart of NumPy's universal functions.</p>
<ul>
<li>It provides the optimized <b>C code</b> that performs element-wise mathematical operations.</li>
<li>It contains specialized <b>loops</b> for different data types, crucial for NumPy's speed.</li>
<li>While historically a separate C module, its functionality is now part of the merged <code>_multiarray_umath</code> C extension.</li>
<li>Python files like <code>numpy/core/umath.py</code> provide access, but the real work happens in C, often defined via generators like <code>generate_umath.py</code> and implemented in templated <code>.src</code> or dispatchable C files.</li>
</ul>
<p>Understanding <code>umath</code> clarifies where the computational power for element-wise operations originates within NumPy's core.</p>
<p>So far, we've focused on NumPy's built-in functions. But how does NumPy interact with other libraries or allow customization of how operations work on its arrays?</p>
<p>Next, we'll explore a powerful mechanism for extending NumPy's reach: <a class="el" href="../../d3/d50/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2NumPy_01Core_208______array__function______7b60f447b25b704c1d1f35f0473e9579.html">Chapter 8: <b>array_function</b> Protocol / Overrides (<code>overrides</code>)</a>.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
