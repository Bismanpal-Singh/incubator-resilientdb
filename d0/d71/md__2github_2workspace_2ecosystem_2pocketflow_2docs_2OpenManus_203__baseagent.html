#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_baseagent</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/d71/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_203__baseagent.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_baseagent</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2632"></a>
autotoc_md2632</h2>
<p>layout: default title: "BaseAgent" parent: "OpenManus" </p>
<h2><a class="anchor" id="autotoc_md2633"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md2634"></a>
Chapter 3: BaseAgent - The Agent Blueprint</h1>
<p>In the previous chapters, we learned about the "brain" (<a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">Chapter 1: The LLM</a>) that powers our agents and how they remember conversations using <a class="el" href="../../dc/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_202__message______memory.html">Chapter 2: Message / Memory</a>. Now, let's talk about the agent itself!</p>
<p>Imagine you want to build different kinds of digital helpers: one that can browse the web, one that can write code, and maybe one that just answers questions. While they have different jobs, they probably share some basic features, right? They all need a name, a way to remember things, a way to know if they are busy or waiting, and a process to follow when doing their work.</p>
<h2><a class="anchor" id="autotoc_md2635"></a>
What Problem Does <code>BaseAgent</code> Solve?</h2>
<p>Building every agent from scratch, defining these common features over and over again, would be tedious and error-prone. It's like designing a completely new car frame, engine, and wheels every time you want to build a new car model (a sports car, a truck, a sedan). It's inefficient!</p>
<p>This is where <code>BaseAgent</code> comes in. Think of it as the <b>master blueprint</b> or the standard <b>chassis and engine design</b> for <em>all</em> agents in OpenManus.</p>
<p><b>Use Case:</b> Let's say we want to create a simple "EchoAgent" that just repeats back whatever the user says. Even this simple agent needs:</p><ul>
<li>A name (e.g., "EchoBot").</li>
<li>Memory to store what the user said.</li>
<li>A state (is it idle, or is it working on echoing?).</li>
<li>A way to run and perform its simple "echo" task.</li>
</ul>
<p>Instead of defining all these basics for EchoAgent, and then again for a "WeatherAgent", and again for a "CodeWriterAgent", we define them <em>once</em> in <code>BaseAgent</code>.</p>
<h2><a class="anchor" id="autotoc_md2636"></a>
Key Concepts: The Building Blocks of an Agent</h2>
<p><code>BaseAgent</code> (<code>app/agent/base.py</code>) defines the fundamental properties and abilities that <em>all</em> agents built using OpenManus must have. It ensures consistency and saves us from repeating code. Here are the essential parts:</p>
<ol type="1">
<li><b><code>name</code> (str):</b> A unique name to identify the agent (e.g., "browser_agent", "code_writer").</li>
<li><b><code>description</code> (Optional[str]):</b> A short explanation of what the agent does.</li>
<li><b><code>state</code> (AgentState):</b> The agent's current status. Is it doing nothing (<code>IDLE</code>), actively working (<code>RUNNING</code>), finished its task (<code>FINISHED</code>), or encountered a problem (<code>ERROR</code>)?</li>
<li><b><code>memory</code> (Memory):</b> An instance of the <code>Memory</code> class we learned about in <a class="el" href="../../dc/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_202__message______memory.html">Chapter 2: Message / Memory</a>. This is where the agent stores the conversation history (<code>Message</code> objects).</li>
<li><b><code>llm</code> (LLM):</b> An instance of the <code>LLM</code> class from <a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">Chapter 1: The LLM - Your Agent's Brainpower</a>. This gives the agent access to the language model for "thinking".</li>
<li><b><code>run()</code> method:</b> The main function you call to start the agent's work. It manages the overall process, like changing the state to <code>RUNNING</code> and repeatedly calling the <code>step()</code> method.</li>
<li><b><code>step()</code> method:</b> This is the crucial part! <code>BaseAgent</code> defines <em>that</em> agents must have a <code>step</code> method, but it doesn't say <em>what</em> the step does. It's marked as <code>abstract</code>, meaning <b>each specific agent type (like our EchoAgent or a BrowserAgent) must provide its own implementation of <code>step()</code></b>. This method defines the actual work the agent performs in a single cycle.</li>
<li><b><code>max_steps</code> (int):</b> A safety limit on how many <code>step</code> cycles the agent can run before stopping automatically. This prevents agents from running forever if they get stuck.</li>
</ol>
<p>Think of it like this:</p><ul>
<li><code>BaseAgent</code> provides the car chassis (<code>name</code>, <code>state</code>), the engine (<code>llm</code>), the fuel tank (<code>memory</code>), and the ignition key (<code>run()</code>).</li>
<li>The <code>step()</code> method is like the specific driving instructions (turn left, accelerate, brake) that make a sports car drive differently from a truck, even though they share the same basic parts.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2637"></a>
How Do We Use <code>BaseAgent</code>?</h2>
<p>You typically don't use <code>BaseAgent</code> directly. It's an <b>abstract</b> class, meaning it's a template, not a finished product. You <b>build upon it</b> by creating new classes that <em>inherit</em> from <code>BaseAgent</code>.</p>
<p>Let's imagine creating our simple <code>EchoAgent</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># Conceptual Example - Not runnable code, just for illustration</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Import BaseAgent and necessary components</span></div>
<div class="line"><span class="keyword">from</span> app.agent.base <span class="keyword">import</span> BaseAgent</div>
<div class="line"><span class="keyword">from</span> app.schema <span class="keyword">import</span> Message</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EchoAgent(BaseAgent): <span class="comment"># Inherits from BaseAgent!</span></div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;A simple agent that echoes the last user message.&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    name: str = <span class="stringliteral">&quot;EchoBot&quot;</span></div>
<div class="line">    description: str = <span class="stringliteral">&quot;Repeats the last thing the user said.&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># THIS IS THE IMPORTANT PART - We implement the abstract &#39;step&#39; method</span></div>
<div class="line">    <span class="keyword">async def </span>step(self) -&gt; str:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Perform one step: find the last user message and echo it.&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">        last_user_message = <span class="keywordtype">None</span></div>
<div class="line">        <span class="comment"># Look backwards through memory to find the last user message</span></div>
<div class="line">        <span class="keywordflow">for</span> msg <span class="keywordflow">in</span> reversed(self.memory.messages):</div>
<div class="line">            <span class="keywordflow">if</span> msg.role == <span class="stringliteral">&quot;user&quot;</span>:</div>
<div class="line">                last_user_message = msg</div>
<div class="line">                <span class="keywordflow">break</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> last_user_message <span class="keywordflow">and</span> last_user_message.content:</div>
<div class="line">            echo_content = f<span class="stringliteral">&quot;You said: {last_user_message.content}&quot;</span></div>
<div class="line">            <span class="comment"># Add the echo response to memory as an &#39;assistant&#39; message</span></div>
<div class="line">            self.update_memory(<span class="stringliteral">&quot;assistant&quot;</span>, echo_content)</div>
<div class="line">            <span class="comment"># The state will be set to FINISHED after this step by run()</span></div>
<div class="line">            <span class="comment"># (Simplified: a real agent might need more complex logic)</span></div>
<div class="line">            self.state = AgentState.FINISHED <span class="comment"># Indicate task is done</span></div>
<div class="line">            <span class="keywordflow">return</span> echo_content <span class="comment"># Return the result of this step</span></div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">            self.state = AgentState.FINISHED <span class="comment"># Nothing to echo, finish</span></div>
<div class="line">            <span class="keywordflow">return</span> <span class="stringliteral">&quot;I didn&#39;t hear anything from the user to echo.&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># How you might conceptually use it:</span></div>
<div class="line"><span class="comment"># echo_bot = EchoAgent()</span></div>
<div class="line"><span class="comment"># # Add a user message to its memory</span></div>
<div class="line"><span class="comment"># echo_bot.update_memory(&quot;user&quot;, &quot;Hello there!&quot;)</span></div>
<div class="line"><span class="comment"># # Start the agent&#39;s run loop</span></div>
<div class="line"><span class="comment"># result = await echo_bot.run()</span></div>
<div class="line"><span class="comment"># print(result) # Output would contain: &quot;Step 1: You said: Hello there!&quot;</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><code>class EchoAgent(BaseAgent):</code> - We declare that <code>EchoAgent</code> is a <em>type of</em> <code>BaseAgent</code>. It automatically gets all the standard parts like <code>name</code>, <code>memory</code>, <code>llm</code>, <code>state</code>, and the <code>run()</code> method.</li>
<li>We provide a specific <code>name</code> and <code>description</code>.</li>
<li>Crucially, we define <code>async def step(self) -&gt; str:</code>. This is <em>our</em> specific logic for the <code>EchoAgent</code>. In this case, it looks through the <code>memory</code> (inherited from <code>BaseAgent</code>), finds the last user message, and prepares an echo response.</li>
<li>It uses <code>self.update_memory(...)</code> (a helper method provided by <code>BaseAgent</code>) to add its response to the memory.</li>
<li>It sets its <code>self.state</code> to <code>FINISHED</code> to signal that its job is done after this one step.</li>
<li>The <code>run()</code> method (which we didn't have to write, it's inherited from <code>BaseAgent</code>) would handle starting the process, calling our <code>step()</code> method, and returning the final result.</li>
</ol>
<p>This way, we only had to focus on the unique part – the echoing logic inside <code>step()</code> – while <code>BaseAgent</code> handled the common structure. More complex agents like <code>BrowserAgent</code> or <code>ToolCallAgent</code> (found in <code>app/agent/</code>) follow the same principle but have much more sophisticated <code>step()</code> methods, often involving thinking with the <a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">LLM</a> and using <a class="el" href="../../de/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_204__tool______toolcollection.html">Tools</a>.</p>
<h2><a class="anchor" id="autotoc_md2638"></a>
Under the Hood: The <code>run()</code> Loop</h2>
<p>What actually happens when you call <code>agent.run()</code>? The <code>BaseAgent</code> provides a standard execution loop:</p>
<ol type="1">
<li><b>Check State:</b> It makes sure the agent is <code>IDLE</code> before starting. You can't run an agent that's already running or has finished.</li>
<li><b>Set State:</b> It changes the agent's state to <code>RUNNING</code>. It uses a safety mechanism (<code>state_context</code>) to ensure the state is handled correctly, even if errors occur.</li>
<li><b>Initialize:</b> If you provided an initial request (e.g., <code>agent.run("What's the weather?")</code>), it adds that as the first <code>user</code> message to the <code>memory</code>.</li>
<li><b>Loop:</b> It enters a loop that continues as long as:<ul>
<li>The agent hasn't reached its <code>max_steps</code> limit.</li>
<li>The agent's state is still <code>RUNNING</code> (i.e., it hasn't set itself to <code>FINISHED</code> or <code>ERROR</code> inside its <code>step()</code> method).</li>
</ul>
</li>
<li><b>Increment Step Counter:</b> It increases <code>current_step</code>.</li>
<li><b>Execute <code>step()</code>:</b> This is where it calls the specific <code>step()</code> method implemented by the subclass (like our <code>EchoAgent.step()</code>). <b>This is the core of the agent's unique behavior.</b></li>
<li><b>Record Result:</b> It stores the string returned by <code>step()</code>.</li>
<li><b>Repeat:</b> It goes back to step 4 until the loop condition is false.</li>
<li><b>Finalize:</b> Once the loop finishes (either <code>max_steps</code> reached or state changed to <code>FINISHED</code>/<code>ERROR</code>), it sets the state back to <code>IDLE</code> (unless it ended in <code>ERROR</code>).</li>
<li><b>Return Results:</b> It returns a string summarizing the results from all the steps.</li>
</ol>
<p>Here's a simplified diagram showing the flow:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant MyAgent as MySpecificAgent (e.g., EchoAgent)</div>
<div class="line">    participant BaseRun as BaseAgent.run()</div>
<div class="line">    participant MyStep as MySpecificAgent.step()</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;+MyAgent: Calls run(&quot;Initial Request&quot;)</div>
<div class="line">    MyAgent-&gt;&gt;+BaseRun: run(&quot;Initial Request&quot;)</div>
<div class="line">    BaseRun-&gt;&gt;BaseRun: Check state (must be IDLE)</div>
<div class="line">    BaseRun-&gt;&gt;MyAgent: Set state = RUNNING</div>
<div class="line">    BaseRun-&gt;&gt;MyAgent: Add &quot;Initial Request&quot; to memory</div>
<div class="line">    Note over BaseRun, MyStep: Loop starts (while step &lt; max_steps AND state == RUNNING)</div>
<div class="line">    loop Execution Loop</div>
<div class="line">        BaseRun-&gt;&gt;BaseRun: Increment current_step</div>
<div class="line">        BaseRun-&gt;&gt;+MyStep: Calls step()</div>
<div class="line">        MyStep-&gt;&gt;MyStep: Executes specific logic (e.g., reads memory, calls LLM, adds response to memory)</div>
<div class="line">        MyStep-&gt;&gt;MyAgent: Maybe sets state = FINISHED</div>
<div class="line">        MyStep--&gt;&gt;-BaseRun: Returns step_result (string)</div>
<div class="line">        BaseRun-&gt;&gt;BaseRun: Record step_result</div>
<div class="line">        BaseRun-&gt;&gt;BaseRun: Check loop condition (step &lt; max_steps AND state == RUNNING?)</div>
<div class="line">    end</div>
<div class="line">    Note over BaseRun: Loop ends</div>
<div class="line">    BaseRun-&gt;&gt;MyAgent: Set state = IDLE (or keep ERROR)</div>
<div class="line">    BaseRun--&gt;&gt;-MyAgent: Returns combined results</div>
<div class="line">    MyAgent--&gt;&gt;-User: Returns final result string</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2639"></a>
Code Glimpse: Inside <code>app/agent/base.py</code></h2>
<p>Let's peek at the <code>BaseAgent</code> definition itself.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified snippet from app/agent/base.py</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod <span class="comment"># Needed for abstract classes/methods</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</div>
<div class="line"><span class="keyword">from</span> app.llm <span class="keyword">import</span> LLM</div>
<div class="line"><span class="keyword">from</span> app.schema <span class="keyword">import</span> AgentState, Memory, Message</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>BaseAgent(BaseModel, ABC): <span class="comment"># Inherits from Pydantic&#39;s BaseModel and ABC</span></div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Abstract base class for managing agent state and execution.&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Core attributes defined here</span></div>
<div class="line">    name: str = Field(..., description=<span class="stringliteral">&quot;Unique name&quot;</span>)</div>
<div class="line">    description: Optional[str] = Field(<span class="keywordtype">None</span>)</div>
<div class="line">    state: AgentState = Field(default=AgentState.IDLE)</div>
<div class="line">    memory: Memory = Field(default_factory=Memory) <span class="comment"># Gets a Memory instance</span></div>
<div class="line">    llm: LLM = Field(default_factory=LLM) <span class="comment"># Gets an LLM instance</span></div>
<div class="line">    max_steps: int = Field(default=10)</div>
<div class="line">    current_step: int = Field(default=0)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... other config and helper methods like update_memory ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>run(self, request: Optional[str] = <span class="keywordtype">None</span>) -&gt; str:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Execute the agent&#39;s main loop asynchronously.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">if</span> self.state != AgentState.IDLE:</div>
<div class="line">            <span class="keywordflow">raise</span> RuntimeError(<span class="stringliteral">&quot;Agent not IDLE&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> request:</div>
<div class="line">            self.update_memory(<span class="stringliteral">&quot;user&quot;</span>, request) <span class="comment"># Add initial request</span></div>
<div class="line"> </div>
<div class="line">        results = []</div>
<div class="line">        <span class="comment"># Simplified: using a context manager for state changes</span></div>
<div class="line">        <span class="comment"># async with self.state_context(AgentState.RUNNING):</span></div>
<div class="line">        self.state = AgentState.RUNNING</div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="keywordflow">while</span> (self.current_step &lt; self.max_steps <span class="keywordflow">and</span> self.state == AgentState.RUNNING):</div>
<div class="line">                self.current_step += 1</div>
<div class="line">                <span class="comment"># ====&gt; THE CORE CALL &lt;====</span></div>
<div class="line">                step_result = await self.step() <span class="comment"># Calls the subclass&#39;s step method</span></div>
<div class="line">                results.append(f<span class="stringliteral">&quot;Step {self.current_step}: {step_result}&quot;</span>)</div>
<div class="line">                <span class="comment"># (Simplified: actual code has more checks)</span></div>
<div class="line">        <span class="keywordflow">finally</span>:</div>
<div class="line">            <span class="comment"># Reset state after loop finishes or if error occurs</span></div>
<div class="line">            <span class="keywordflow">if</span> self.state != AgentState.ERROR:</div>
<div class="line">                self.state = AgentState.IDLE</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">return</span> <span class="stringliteral">&quot;\n&quot;</span>.join(results)</div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@abstractmethod</span> <span class="comment"># Marks this method as needing implementation by subclasses</span></div>
<div class="line">    <span class="keyword">async def </span>step(self) -&gt; str:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Execute a single step in the agent&#39;s workflow. Must be implemented by subclasses.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="keywordflow">pass</span> <span class="comment"># BaseAgent provides no implementation for step()</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>update_memory(self, role: str, content: str, ...) -&gt; <span class="keywordtype">None</span>:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Helper to add messages to self.memory easily.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># ... implementation uses Message.user_message etc. ...</span></div>
<div class="line">        self.memory.add_message(...)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>class BaseAgent(BaseModel, ABC):</code> declares it as both a Pydantic model (for data validation) and an Abstract Base Class.</li>
<li>Fields like <code>name</code>, <code>state</code>, <code>memory</code>, <code>llm</code>, <code>max_steps</code> are defined. <code>default_factory=Memory</code> means each agent gets its own fresh <code>Memory</code> instance when created.</li>
<li>The <code>run()</code> method contains the loop logic we discussed, crucially calling <code>await self.step()</code>.</li>
<li><code>@abstractmethod</code> above <code>async def step(self) -&gt; str:</code> signals that any class inheriting from <code>BaseAgent</code> <em>must</em> provide its own version of the <code>step</code> method. <code>BaseAgent</code> itself just puts <code>pass</code> (do nothing) there.</li>
<li>Helper methods like <code>update_memory</code> are provided for convenience.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2640"></a>
Wrapping Up Chapter 3</h2>
<p>We've learned about <code>BaseAgent</code>, the fundamental blueprint for all agents in OpenManus. It provides the common structure (<code>name</code>, <code>state</code>, <code>memory</code>, <code>llm</code>) and the core execution loop (<code>run()</code>), freeing us to focus on the unique logic of each agent by implementing the <code>step()</code> method. It acts as the chassis upon which specialized agents are built.</p>
<p>Now that we have the agent structure, how do agents gain specific skills beyond just talking to the LLM? How can they browse the web, run code, or interact with files? They use <b>Tools</b>!</p>
<p>Let's move on to <a class="el" href="../../de/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_204__tool______toolcollection.html">Chapter 4: Tool / ToolCollection</a> to explore how we give agents capabilities to interact with the world.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
