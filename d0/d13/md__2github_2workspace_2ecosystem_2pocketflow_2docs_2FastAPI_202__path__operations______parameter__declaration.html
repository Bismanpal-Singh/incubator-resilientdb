#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 02_path_operations___parameter_declaration</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d0/d13/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_202__path__operations______parameter__declaration.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">02_path_operations___parameter_declaration</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md1743"></a>
autotoc_md1743</h2>
<p>layout: default title: "Path Operations &amp; Parameter Declaration" parent: "FastAPI" </p>
<h2><a class="anchor" id="autotoc_md1744"></a>
nav_order: 2</h2>
<h1><a class="anchor" id="autotoc_md1745"></a>
Chapter 2: Path Operations &amp; Parameter Declaration</h1>
<p>Welcome back! In <a class="el" href="../../d0/d54/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_201__fastapi__application______routing.html">Chapter 1: FastAPI Application &amp; Routing</a>, we learned how to set up a basic FastAPI application and organize our code using <code>APIRouter</code>. We saw how to connect a URL like <code>/</code> to a Python function using <code>@app.get("/")</code>.</p>
<p>But what if we need more information from the user? Imagine you're building an API for an online store. You don't just want a single "hello" page; you want users to be able to:</p>
<ol type="1">
<li>Get information about a <em>specific</em> item, like <code>/items/5</code> (where 5 is the item ID).</li>
<li>Search or filter items, like <code>/items/?query=socks</code> (search for "socks").</li>
<li>Add a <em>new</em> item by sending its details (name, price, etc.).</li>
</ol>
<p>How do we tell FastAPI to expect this extra information (like the item ID <code>5</code>, the search query <code>"socks"</code>, or the new item's details) and make it available inside our Python function?</p>
<p>That's exactly what <b>Path Operations</b> and <b>Parameter Declaration</b> are for!</p>
<p><b>Our Goal Today:</b> Learn how FastAPI uses function parameters and type hints to automatically handle data coming from different parts of the web request (URL path, query string, request body) and even validate it!</p>
<h2><a class="anchor" id="autotoc_md1746"></a>
What Problem Does This Solve?</h2>
<p>Think of your API endpoint (like <code>/items/</code>) as a specific room in a building. To get into the room or ask for something specific within it, you often need to provide information:</p>
<ul>
<li>Maybe the room number is part of the address (<code>/items/10</code> - room number 10). This is like a <b>Path Parameter</b>.</li>
<li>Maybe you need to fill out a small form asking optional questions ("Any specific colour?", "Sort by price?"). This is like <b>Query Parameters</b>.</li>
<li>Maybe you need to hand over a detailed document with instructions or data (like the specs for a new item). This is like the <b>Request Body</b>.</li>
</ul>
<p>FastAPI needs a way to understand these different types of information, extract them from the incoming request, check if they are the correct type (e.g., is the item ID <em>really</em> a number?), and give them to your Python function in a clean, easy-to-use way. It does this magic using standard Python type hints and special functions we'll learn about.</p>
<h2><a class="anchor" id="autotoc_md1747"></a>
Path Operations: More Than Just GET</h2>
<p>In Chapter 1, we used <code>@app.get("/")</code>. The <code>get</code> part refers to the HTTP <b>method</b>. Browsers use <code>GET</code> when you simply visit a URL. But there are other common methods for different actions:</p>
<ul>
<li><code>GET</code>: Retrieve data.</li>
<li><code>POST</code>: Create new data.</li>
<li><code>PUT</code>: Update existing data completely.</li>
<li><code>PATCH</code>: Partially update existing data.</li>
<li><code>DELETE</code>: Remove data.</li>
</ul>
<p>FastAPI provides decorators for all these: <code>@app.post()</code>, <code>@app.put()</code>, <code>@app.patch()</code>, <code>@app.delete()</code>. You use them just like <code>@app.get()</code> to link a path and an HTTP method to your function.</p>
<div class="fragment"><div class="line"><span class="comment"># main.py (continuing from Chapter 1, maybe add this to routers/items.py)</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</div>
<div class="line"> </div>
<div class="line">app = FastAPI()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># A GET operation (read)</span></div>
<div class="line"><span class="preprocessor">@app.get(&quot;/items/&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>read_items():</div>
<div class="line">    <span class="keywordflow">return</span> [{<span class="stringliteral">&quot;item_id&quot;</span>: 1, <span class="stringliteral">&quot;name&quot;</span>: <span class="stringliteral">&quot;Thingamajig&quot;</span>}]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># A POST operation (create)</span></div>
<div class="line"><span class="preprocessor">@app.post(&quot;/items/&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>create_item():</div>
<div class="line">    <span class="comment"># We&#39;ll see how to get data *into* here later</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;message&quot;</span>: <span class="stringliteral">&quot;Item received!&quot;</span>} <span class="comment"># Placeholder</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># We&#39;ll focus on GET for now, but others work similarly!</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>We define different functions for different <em>actions</em> on the same path (<code>/items/</code>).</li>
<li><code>@app.get("/items/")</code> handles requests to <em>get</em> the list of items.</li>
<li><code>@app.post("/items/")</code> handles requests to <em>create</em> a new item. FastAPI knows which function to call based on the HTTP method used in the request.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1748"></a>
Path Parameters: Getting Data from the URL Path</h2>
<p>Let's say you want an endpoint to get a <em>single</em> item by its ID. The URL might look like <code><a href="http://127.0.0.1:8000/items/5">http://127.0.0.1:8000/items/5</a></code>. Here, <code>5</code> is the ID we want to capture.</p>
<p>You define this in FastAPI by putting the variable name in curly braces <code>{}</code> within the path string:</p>
<div class="fragment"><div class="line"><span class="comment"># main.py or routers/items.py</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</div>
<div class="line"> </div>
<div class="line">app = FastAPI() <span class="comment"># Or use your APIRouter</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.get(&quot;/items/{item_id}&quot;)</span>  <span class="comment"># Path parameter defined here</span></div>
<div class="line"><span class="keyword">async def </span>read_item(item_id: int): <span class="comment"># Parameter name MUST match! Type hint is key!</span></div>
<div class="line">    <span class="comment"># FastAPI automatically converts the &#39;item_id&#39; from the path (which is a string)</span></div>
<div class="line">    <span class="comment"># into an integer because of the &#39;int&#39; type hint.</span></div>
<div class="line">    <span class="comment"># It also validates if it *can* be converted to an int.</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;item_id&quot;</span>: item_id, <span class="stringliteral">&quot;name&quot;</span>: f<span class="stringliteral">&quot;Item {item_id} Name&quot;</span>}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>@app.get("/items/{item_id}")</code>: The <code>{item_id}</code> part tells FastAPI: "Expect some value here in the URL path, and call it `item_id`."</li>
<li><code>async def read_item(item_id: int)</code>:<ul>
<li>We declare a function parameter named <b>exactly</b> <code>item_id</code>. FastAPI connects the path variable to this function argument.</li>
<li>We use the Python type hint <code>: int</code>. This is crucial! FastAPI uses this to:<ol type="1">
<li><b>Convert:</b> The value from the URL (<code>"5"</code>) is automatically converted to an integer (<code>5</code>).</li>
<li><b>Validate:</b> If you visit <code>/items/foo</code>, FastAPI knows <code>"foo"</code> cannot be converted to an <code>int</code>, and it automatically returns a helpful error response <em>before</em> your function even runs!</li>
</ol>
</li>
</ul>
</li>
</ul>
<p><b>Try it:</b></p>
<ol type="1">
<li>Run <code>uvicorn main:app --reload</code>.</li>
<li>Visit <code><a href="http://127.0.0.1:8000/items/5">http://127.0.0.1:8000/items/5</a></code>. You should see: <code>json {"item_id":5,"name":"Item 5 Name"} </code></li>
<li>Visit <code><a href="http://127.0.0.1:8000/items/abc">http://127.0.0.1:8000/items/abc</a></code>. You should see an error like: <code>json { "detail": [ { "type": "int_parsing", "loc": [ "path", "item_id" ], "msg": "Input should be a valid integer, unable to parse string as an integer", "input": "abc", "url": "..." } ] } </code> See? Automatic validation!</li>
</ol>
<p>Path parameters are <em>required</em> parts of the path. The URL simply won't match the route if that part is missing.</p>
<h2><a class="anchor" id="autotoc_md1749"></a>
Query Parameters: Optional Info After "?"</h2>
<p>What if you want to provide optional filtering or configuration in the URL? Like getting items, but maybe skipping the first 10 and limiting the results to 5: <code><a href="http://127.0.0.1:8000/items/?skip=10">http://127.0.0.1:8000/items/?skip=10</a>&amp;limit=5</code>.</p>
<p>These <code>key=value</code> pairs after the <code>?</code> are called <b>Query Parameters</b>.</p>
<p>In FastAPI, you declare them as function parameters that are <em>not</em> part of the path string. You can provide default values to make them optional.</p>
<div class="fragment"><div class="line"><span class="comment"># main.py or routers/items.py</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</div>
<div class="line"> </div>
<div class="line">app = FastAPI() <span class="comment"># Or use your APIRouter</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># A simple fake database of items</span></div>
<div class="line">fake_items_db = [{<span class="stringliteral">&quot;item_name&quot;</span>: <span class="stringliteral">&quot;Foo&quot;</span>}, {<span class="stringliteral">&quot;item_name&quot;</span>: <span class="stringliteral">&quot;Bar&quot;</span>}, {<span class="stringliteral">&quot;item_name&quot;</span>: <span class="stringliteral">&quot;Baz&quot;</span>}]</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.get(&quot;/items/&quot;)</span></div>
<div class="line"><span class="comment"># &#39;skip&#39; and &#39;limit&#39; are NOT in the path &quot;/items/&quot;</span></div>
<div class="line"><span class="comment"># They have default values, making them optional query parameters</span></div>
<div class="line"><span class="keyword">async def </span>read_items(skip: int = 0, limit: int = 10):</div>
<div class="line">    <span class="comment"># FastAPI automatically gets &#39;skip&#39; and &#39;limit&#39; from the query string.</span></div>
<div class="line">    <span class="comment"># If they are not provided in the URL, it uses the defaults (0 and 10).</span></div>
<div class="line">    <span class="comment"># It also converts them to integers and validates them!</span></div>
<div class="line">    <span class="keywordflow">return</span> fake_items_db[skip : skip + limit]</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>async def read_items(skip: int = 0, limit: int = 10)</code>:<ul>
<li><code>skip</code> and <code>limit</code> are <em>not</em> mentioned in <code>@app.get("/items/")</code>. FastAPI knows they must be query parameters.</li>
<li>They have default values (<code>= 0</code>, <code>= 10</code>). This makes them optional. If the user doesn't provide them in the URL, these defaults are used.</li>
<li>The type hints <code>: int</code> ensure automatic conversion and validation, just like with path parameters.</li>
</ul>
</li>
</ul>
<p><b>Try it:</b></p>
<ol type="1">
<li>Make sure <code>uvicorn</code> is running.</li>
<li>Visit <code><a href="http://127.0.0.1:8000/items/">http://127.0.0.1:8000/items/</a></code>. Result (uses defaults <code>skip=0</code>, <code>limit=10</code>): <code>json [{"item_name":"Foo"},{"item_name":"Bar"},{"item_name":"Baz"}] </code></li>
<li>Visit <code><a href="http://127.0.0.1:8000/items/?skip=1">http://127.0.0.1:8000/items/?skip=1</a>&amp;limit=1</code>. Result: <code>json [{"item_name":"Bar"}] </code></li>
<li>Visit <code><a href="http://127.0.0.1:8000/items/?limit=abc">http://127.0.0.1:8000/items/?limit=abc</a></code>. Result: Automatic validation error because <code>abc</code> is not an integer.</li>
</ol>
<p>You can also declare query parameters without default values. In that case, they become <em>required</em> query parameters.</p>
<div class="fragment"><div class="line"><span class="comment"># Example: Required query parameter &#39;query_str&#39;</span></div>
<div class="line"><span class="preprocessor">@app.get(&quot;/search/&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>search_items(query_str: str): <span class="comment"># No default value means it&#39;s required</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;search_query&quot;</span>: query_str}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Visiting /search/ will cause an error</span></div>
<div class="line"><span class="comment"># Visiting /search/?query_str=hello will work</span></div>
</div><!-- fragment --><p>You can also use other types like <code>bool</code> or <code>float</code>, and even optional types like <code>str | None = None</code> (or <code>Optional[str] = None</code> in older Python).</p>
<div class="fragment"><div class="line"><span class="preprocessor">@app.get(&quot;/users/{user_id}/items&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>read_user_items(</div>
<div class="line">    user_id: int,                 <span class="comment"># Path parameter</span></div>
<div class="line">    show_details: bool = <span class="keyword">False</span>,   <span class="comment"># Optional query parameter (e.g., ?show_details=true)</span></div>
<div class="line">    category: str | <span class="keywordtype">None</span> = <span class="keywordtype">None</span> <span class="comment"># Optional query parameter (e.g., ?category=books)</span></div>
<div class="line">):</div>
<div class="line">    <span class="comment"># ... function logic ...</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;user_id&quot;</span>: user_id, <span class="stringliteral">&quot;show_details&quot;</span>: show_details, <span class="stringliteral">&quot;category&quot;</span>: category}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1750"></a>
Request Body: Sending Complex Data</h2>
<p>Sometimes, the data you need to send is too complex for the URL path or query string (like the name, description, price, tax, and tags for a new item). For <code>POST</code>, <code>PUT</code>, and <code>PATCH</code> requests, data is usually sent in the <b>Request Body</b>, often as JSON.</p>
<p>FastAPI uses <b>Pydantic models</b> to define the structure of the data you expect in the request body. We'll dive deep into Pydantic in <a class="el" href="../../d5/df9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_203__data__validation______serialization____pydantic__.html">Chapter 3: Data Validation &amp; Serialization (Pydantic)</a>, but here's a sneak peek:</p>
<div class="fragment"><div class="line"><span class="comment"># main.py or a new models.py file</span></div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the structure of an Item using Pydantic</span></div>
<div class="line"><span class="keyword">class </span>Item(BaseModel):</div>
<div class="line">    name: str</div>
<div class="line">    description: str | <span class="keywordtype">None</span> = <span class="keywordtype">None</span> <span class="comment"># Optional field</span></div>
<div class="line">    price: float</div>
<div class="line">    tax: float | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>       <span class="comment"># Optional field</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Now use it in a path operation</span></div>
<div class="line"><span class="comment"># main.py or routers/items.py</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI</div>
<div class="line"><span class="comment"># Assume Item is defined as above (maybe import it)</span></div>
<div class="line"> </div>
<div class="line">app = FastAPI() <span class="comment"># Or use your APIRouter</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.post(&quot;/items/&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>create_item(item: Item): <span class="comment"># Declare the body parameter using the Pydantic model</span></div>
<div class="line">    <span class="comment"># FastAPI automatically:</span></div>
<div class="line">    <span class="comment"># 1. Reads the request body.</span></div>
<div class="line">    <span class="comment"># 2. Parses the JSON data.</span></div>
<div class="line">    <span class="comment"># 3. Validates the data against the &#39;Item&#39; model (Are &#39;name&#39; and &#39;price&#39; present? Are types correct?).</span></div>
<div class="line">    <span class="comment"># 4. If valid, provides the data as the &#39;item&#39; argument (an instance of the Item class).</span></div>
<div class="line">    <span class="comment"># 5. If invalid, returns an automatic validation error.</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Received item: {item.name}, Price: {item.price}&quot;</span>)</div>
<div class="line">    item_dict = item.model_dump() <span class="comment"># Convert Pydantic model back to dict if needed</span></div>
<div class="line">    <span class="keywordflow">if</span> item.tax:</div>
<div class="line">        price_with_tax = item.price + item.tax</div>
<div class="line">        item_dict[<span class="stringliteral">&quot;price_with_tax&quot;</span>] = price_with_tax</div>
<div class="line">    <span class="keywordflow">return</span> item_dict</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>class Item(BaseModel): ...</code>: We define a class <code>Item</code> that inherits from Pydantic's <code>BaseModel</code>. We declare the expected fields (<code>name</code>, <code>description</code>, <code>price</code>, <code>tax</code>) and their types.</li>
<li><code>async def create_item(item: Item)</code>: We declare a <em>single</em> parameter <code>item</code> with the type hint <code>Item</code>. Because <code>Item</code> is a Pydantic model, FastAPI knows it should expect this data in the <b>request body</b> as JSON.</li>
<li>FastAPI handles all the parsing and validation. If the incoming JSON doesn't match the <code>Item</code> structure, the client gets an error. If it matches, your function receives a ready-to-use <code>item</code> object.</li>
</ul>
<p>You typically use request bodies for <code>POST</code>, <code>PUT</code>, and <code>PATCH</code> requests. You can only declare <em>one</em> body parameter per function (though that body can contain nested structures, as defined by your Pydantic model).</p>
<h2><a class="anchor" id="autotoc_md1751"></a>
Fine-tuning Parameters with <code>Path</code>, <code>Query</code>, <code>Body</code>, etc.</h2>
<p>Type hints are great for basic validation (like <code>int</code>, <code>str</code>, <code>bool</code>). But what if you need more specific rules?</p>
<ul>
<li>The <code>item_id</code> must be greater than 0.</li>
<li>A query parameter <code>q</code> should have a maximum length of 50 characters.</li>
<li>A <code>description</code> in the request body should have a minimum length.</li>
</ul>
<p>FastAPI provides functions like <code>Path</code>, <code>Query</code>, <code>Body</code>, <code>Header</code>, <code>Cookie</code>, and <code>File</code> (imported directly from <code>fastapi</code>) that you can use alongside type hints (using <code>typing.Annotated</code>) to add these extra validation rules and metadata.</p>
<p>Let's enhance our previous examples:</p>
<div class="fragment"><div class="line"><span class="comment"># main.py or routers/items.py</span></div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Annotated <span class="comment"># Use Annotated for extra metadata</span></div>
<div class="line"><span class="keyword">from</span> fastapi <span class="keyword">import</span> FastAPI, Path, Query</div>
<div class="line"><span class="comment"># Assume Item Pydantic model is defined/imported</span></div>
<div class="line"> </div>
<div class="line">app = FastAPI() <span class="comment"># Or use your APIRouter</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Fake DB</span></div>
<div class="line">fake_items_db = [{<span class="stringliteral">&quot;item_name&quot;</span>: <span class="stringliteral">&quot;Foo&quot;</span>}, {<span class="stringliteral">&quot;item_name&quot;</span>: <span class="stringliteral">&quot;Bar&quot;</span>}, {<span class="stringliteral">&quot;item_name&quot;</span>: <span class="stringliteral">&quot;Baz&quot;</span>}]</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.get(&quot;/items/{item_id}&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>read_item(</div>
<div class="line">    <span class="comment"># Use Annotated[type, Path(...)] for path parameters</span></div>
<div class="line">    item_id: Annotated[int, Path(</div>
<div class="line">        title=<span class="stringliteral">&quot;The ID of the item to get&quot;</span>,</div>
<div class="line">        description=<span class="stringliteral">&quot;The item ID must be a positive integer.&quot;</span>,</div>
<div class="line">        gt=0,  <span class="comment"># gt = Greater Than 0</span></div>
<div class="line">        le=1000 <span class="comment"># le = Less Than or Equal to 1000</span></div>
<div class="line">    )]</div>
<div class="line">):</div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;item_id&quot;</span>: item_id, <span class="stringliteral">&quot;name&quot;</span>: f<span class="stringliteral">&quot;Item {item_id} Name&quot;</span>}</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">@app.get(&quot;/items/&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>read_items(</div>
<div class="line">    <span class="comment"># Use Annotated[type | None, Query(...)] for optional query parameters</span></div>
<div class="line">    q: Annotated[str | <span class="keywordtype">None</span>, Query(</div>
<div class="line">        title=<span class="stringliteral">&quot;Query string&quot;</span>,</div>
<div class="line">        description=<span class="stringliteral">&quot;Optional query string to search items.&quot;</span>,</div>
<div class="line">        min_length=3,</div>
<div class="line">        max_length=50</div>
<div class="line">    )] = <span class="keywordtype">None</span>, <span class="comment"># Default value still makes it optional</span></div>
<div class="line">    skip: Annotated[int, Query(ge=0)] = 0, <span class="comment"># ge = Greater Than or Equal to 0</span></div>
<div class="line">    limit: Annotated[int, Query(gt=0, le=100)] = 10</div>
<div class="line">):</div>
<div class="line">    results = fake_items_db[skip : skip + limit]</div>
<div class="line">    <span class="keywordflow">if</span> q:</div>
<div class="line">        results = [item <span class="keywordflow">for</span> item <span class="keywordflow">in</span> results <span class="keywordflow">if</span> q.lower() <span class="keywordflow">in</span> item[<span class="stringliteral">&quot;item_name&quot;</span>].lower()]</div>
<div class="line">    <span class="keywordflow">return</span> results</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Using Body works similarly, often used inside Pydantic models (Chapter 3)</span></div>
<div class="line"><span class="comment"># or if you need to embed a single body parameter</span></div>
<div class="line"><span class="preprocessor">@app.post(&quot;/items/&quot;)</span></div>
<div class="line"><span class="keyword">async def </span>create_item(item: Item): <span class="comment"># Pydantic model handles body structure</span></div>
<div class="line">    <span class="comment"># Validation for item fields is defined within the Item model itself (See Chapter 3)</span></div>
<div class="line">    <span class="comment"># For simple body params without Pydantic, you might use:</span></div>
<div class="line">    <span class="comment"># importance: Annotated[int, Body(gt=0)]</span></div>
<div class="line">    <span class="keywordflow">return</span> item</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><b><code>Annotated</code></b>: This is the standard Python way (Python 3.9+) to add extra context to type hints. FastAPI uses this to associate <code>Path</code>, <code>Query</code>, etc., with your parameters.</li>
<li><b><code>Path(...)</code></b>: Used for path parameters.<ul>
<li><code>title</code>, <code>description</code>: Add metadata that will appear in the automatic documentation (see <a class="el" href="../../d9/d03/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_204__openapi______automatic__docs.html">Chapter 4</a>).</li>
<li><code>gt</code>, <code>ge</code>, <code>lt</code>, <code>le</code>: Numeric validation (greater than, greater than or equal, less than, less than or equal).</li>
</ul>
</li>
<li><b><code>Query(...)</code></b>: Used for query parameters.<ul>
<li>Takes similar arguments to <code>Path</code> for metadata and numeric validation.</li>
<li><code>min_length</code>, <code>max_length</code>: String length validation.</li>
<li>The default value (<code>= None</code>, <code>= 0</code>, <code>= 10</code>) still determines if the parameter is optional or required.</li>
</ul>
</li>
<li><b><code>Body(...)</code></b>: Used for request body parameters (often implicitly handled by Pydantic models). Can add metadata or validation similar to <code>Query</code>.</li>
<li><b>Others</b>: <code>Header()</code>, <code>Cookie()</code>, <code>File()</code> work similarly for data from request headers, cookies, or uploaded files.</li>
</ul>
<p>Using <code>Path</code>, <code>Query</code>, etc., gives you fine-grained control over data validation and adds useful information to your API documentation automatically.</p>
<h2><a class="anchor" id="autotoc_md1752"></a>
How it Works Under the Hood (Simplified)</h2>
<p>How does FastAPI magically connect URL parts and request data to your function arguments and validate them?</p>
<ol type="1">
<li><b>App Startup:</b> When you run your app, FastAPI (using Starlette's routing) inspects all the functions decorated with <code>@app.get</code>, <code>@app.post</code>, etc.</li>
<li><b>Function Signature Inspection:</b> For each function, FastAPI looks at its parameters (<code>item_id</code>, <code>skip</code>, <code>limit</code>, <code>item</code>, <code>q</code>).</li>
<li><b>Parameter Type Analysis:</b> It checks the type hints (<code>int</code>, <code>str</code>, <code>bool</code>, <code>Item</code>, <code>Annotated[...]</code>).</li>
<li><b>Location Determination:</b><ul>
<li>If a parameter name matches a variable in the path string (<code>{item_id}</code>), it's a <b>Path Parameter</b>.</li>
<li>If a parameter has a type hint that's a Pydantic model (<code>item: Item</code>), it's a <b>Body Parameter</b>.</li>
<li>Otherwise, it's a <b>Query Parameter</b> (<code>skip</code>, <code>limit</code>, <code>q</code>).</li>
<li>If <code>Annotated</code> is used with <code>Path</code>, <code>Query</code>, <code>Body</code>, <code>Header</code>, <code>Cookie</code>, or <code>File</code>, that explicitly defines the location and adds extra validation rules.</li>
</ul>
</li>
<li><b>Request Arrives:</b> A request comes in (e.g., <code>GET /items/5?q=search</code>).</li>
<li><b>Routing:</b> Uvicorn passes the request to FastAPI. FastAPI/Starlette matches the path (<code>/items/5</code>) and method (<code>GET</code>) to the <code>read_item</code> function (or <code>read_items</code> if the path was <code>/items/</code>). Let's assume it matches <code>read_item</code> for <code>/items/{item_id}</code>.</li>
<li><b>Data Extraction:</b> FastAPI extracts data from the request based on the parameter definitions found in step 4:<ul>
<li>Path: Extracts <code>"5"</code> for <code>item_id</code>.</li>
<li>Query: Extracts <code>"search"</code> for <code>q</code> (if the route was <code>/items/</code> and the function <code>read_items</code>).</li>
<li>Body: Reads and parses JSON (if it was a POST/PUT request with a body parameter).</li>
</ul>
</li>
<li><b>Validation &amp; Conversion:</b> FastAPI uses the type hints and any extra rules from <code>Path</code>, <code>Query</code>, <code>Body</code> (often leveraging Pydantic internally):<ul>
<li>Converts <code>"5"</code> to the integer <code>5</code> for <code>item_id</code>. Checks <code>gt=0</code>.</li>
<li>Converts <code>"search"</code> to a string for <code>q</code>. Checks <code>max_length</code>.</li>
<li>Validates the JSON body against the <code>Item</code> model.</li>
</ul>
</li>
<li><b>Error Handling:</b> If any validation or conversion fails, FastAPI <em>immediately</em> stops and sends back a 422 "Unprocessable Entity" error response with details about what went wrong. Your function is <em>not</em> called.</li>
<li><b>Function Call:</b> If everything is valid, FastAPI calls your function (<code>read_item</code> or <code>read_items</code>) with the extracted, converted, and validated data as arguments (<code>read_item(item_id=5)</code> or <code>read_items(q="search", skip=0, limit=10)</code>).</li>
<li><b>Response:</b> Your function runs and returns a result. FastAPI processes the result into an HTTP response.</li>
</ol>
<p>Here's a simplified diagram for a <code>GET /items/5?limit=10</code> request:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Client</div>
<div class="line">    participant ASGI Server (Uvicorn)</div>
<div class="line">    participant FastAPI App</div>
<div class="line">    participant Param Processor</div>
<div class="line">    participant Route Handler (read_item)</div>
<div class="line"> </div>
<div class="line">    Client-&gt;&gt;+ASGI Server (Uvicorn): GET /items/5?limit=10</div>
<div class="line">    ASGI Server (Uvicorn)-&gt;&gt;+FastAPI App: Pass Request (method=&#39;GET&#39;, path=&#39;/items/5&#39;, query=&#39;limit=10&#39;)</div>
<div class="line">    FastAPI App-&gt;&gt;FastAPI App: Match route for GET /items/{item_id}</div>
<div class="line">    FastAPI App-&gt;&gt;+Param Processor: Process params for read_item(item_id: Annotated[int, Path(gt=0)], limit: Annotated[int, Query(gt=0)]=10)</div>
<div class="line">    Param Processor-&gt;&gt;Param Processor: Extract &#39;5&#39; from path for item_id</div>
<div class="line">    Param Processor-&gt;&gt;Param Processor: Extract &#39;10&#39; from query for limit</div>
<div class="line">    Param Processor-&gt;&gt;Param Processor: Validate/Convert: item_id = 5 (int, &gt;0) -&gt; OK</div>
<div class="line">    Param Processor-&gt;&gt;Param Processor: Validate/Convert: limit = 10 (int, &gt;0) -&gt; OK</div>
<div class="line">    Param Processor--&gt;&gt;-FastAPI App: Validated Params: {item_id: 5, limit: 10}</div>
<div class="line">    FastAPI App-&gt;&gt;+Route Handler (read_item): Call read_item(item_id=5, limit=10)</div>
<div class="line">    Route Handler (read_item)--&gt;&gt;-FastAPI App: Return {&quot;item_id&quot;: 5, ...}</div>
<div class="line">    FastAPI App-&gt;&gt;FastAPI App: Convert result to JSON Response</div>
<div class="line">    FastAPI App--&gt;&gt;-ASGI Server (Uvicorn): Send HTTP Response</div>
<div class="line">    ASGI Server (Uvicorn)--&gt;&gt;-Client: HTTP 200 OK Response</div>
</div><!-- fragment --><p>FastAPI cleverly uses Python's type hinting system, Pydantic, and Starlette's request handling to automate the tedious tasks of parsing, validation, and documentation.</p>
<h2><a class="anchor" id="autotoc_md1753"></a>
Conclusion</h2>
<p>You've now learned the core mechanics of defining API endpoints (Path Operations) and extracting data from requests in FastAPI!</p>
<ul>
<li>You know how to use decorators like <code>@app.get</code>, <code>@app.post</code> for different HTTP methods.</li>
<li>You can define <b>Path Parameters</b> using <code>{}</code> in the path string and matching function arguments with type hints (<code>item_id: int</code>).</li>
<li>You can define <b>Query Parameters</b> using function arguments <em>not</em> in the path, making them optional with default values (<code>skip: int = 0</code>).</li>
<li>You understand the basics of receiving JSON <b>Request Bodies</b> using Pydantic models (<code>item: Item</code>).</li>
<li>You saw how to add extra validation and metadata using <code>Annotated</code> with <code>Path()</code>, <code>Query()</code>, and <code>Body()</code>.</li>
<li>You got a glimpse of how FastAPI uses type hints and these tools to automatically parse, validate, and document your API parameters.</li>
</ul>
<p>This powerful parameter declaration system is a cornerstone of FastAPI's ease of use and robustness. In the next chapter, we'll explore Pydantic models in much more detail, unlocking even more powerful data validation and serialization capabilities for your request bodies and responses.</p>
<p>Ready to master data shapes? Let's move on to <a class="el" href="../../d5/df9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2FastAPI_203__data__validation______serialization____pydantic__.html">Chapter 3: Data Validation &amp; Serialization (Pydantic)</a>!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
