#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 02_messaging_system__topic___subscription_</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/ddc/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_202__messaging__system____topic______subscription__.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">02_messaging_system__topic___subscription_</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md687"></a>
autotoc_md687</h2>
<p>layout: default title: "Messaging System" parent: "AutoGen Core" </p>
<h2><a class="anchor" id="autotoc_md688"></a>
nav_order: 2</h2>
<h1><a class="anchor" id="autotoc_md689"></a>
Chapter 2: Messaging System (Topic &amp; Subscription)</h1>
<p>In <a class="el" href="../../d6/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_201__agent.html">Chapter 1: Agent</a>, we learned about Agents as individual workers. But how do they coordinate when one agent doesn't know exactly <em>who</em> needs the information it produces? Imagine our Researcher finds some facts. Maybe the Writer needs them, but maybe a Fact-Checker agent or a Summary agent also needs them later. How can the Researcher just announce "Here are the facts!" without needing a specific mailing list?</p>
<p>This is where the <b>Messaging System</b>, specifically <b>Topics</b> and <b>Subscriptions</b>, comes in. It allows agents to broadcast messages to anyone interested, like posting on a company announcement board.</p>
<h2><a class="anchor" id="autotoc_md690"></a>
Motivation: Broadcasting Information</h2>
<p>Let's refine our blog post example:</p>
<ol type="1">
<li>The <code>Researcher</code> agent finds facts about "AutoGen Agents".</li>
<li>Instead of sending <em>directly</em> to the <code>Writer</code>, the <code>Researcher</code> <b>publishes</b> these facts to a general "research-results" <b>Topic</b>.</li>
<li>The <code>Writer</code> agent has previously told the system it's <b>subscribed</b> to the "research-results" Topic.</li>
<li>The system sees the new message on the Topic and delivers it to the <code>Writer</code> (and any other subscribers).</li>
</ol>
<p>This way, the <code>Researcher</code> doesn't need to know who the <code>Writer</code> is, or even if a <code>Writer</code> exists! It just broadcasts the results. If we later add a <code>FactChecker</code> agent that also needs the results, it simply subscribes to the same Topic.</p>
<h2><a class="anchor" id="autotoc_md691"></a>
Key Concepts: Topics and Subscriptions</h2>
<p>Let's break down the components of this broadcasting system:</p>
<ol type="1">
<li><p class="startli"><b>Topic (<code>TopicId</code>): The Announcement Board</b></p><ul>
<li>A <code>TopicId</code> represents a specific channel or category for messages. Think of it like the name of an announcement board (e.g., "Project Updates", "General Announcements").</li>
<li>It has two main parts:<ul>
<li><code>type</code>: What <em>kind</em> of event or information is this? (e.g., "research.completed", "user.request"). This helps categorize messages.</li>
<li><code>source</code>: <em>Where</em> or <em>why</em> did this event originate? Often, this relates to the specific task or context (e.g., the specific blog post being researched like "autogen-agents-blog-post", or the team generating the event like "research-team").</li>
</ul>
</li>
</ul>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md692"></a>
From: _topic.py (Simplified)</h1>
<p>from dataclasses import dataclass</p>
<p>@dataclass(frozen=True) # Immutable: can't change after creation class TopicId: type: str source: str</p>
<p>def <b>str</b>(self) -&gt; str: </p>
<h1><a class="anchor" id="autotoc_md693"></a>
Creates an id like "research.completed/autogen-agents-blog-post"</h1>
<p>return f"{self.type}/{self.source}" ``<code> This structure allows for flexible filtering. Agents might subscribe to all topics of a certain</code>type<code>, regardless of the</code>source<code>, or only to topics with a specific</code>source`.</p>
<ol type="1">
<li><b>Publishing: Posting the Announcement</b><ul>
<li>When an agent has information to share broadly, it <em>publishes</em> a message to a specific <code>TopicId</code>.</li>
<li>This is like pinning a note to the designated announcement board. The agent doesn't need to know who will read it.</li>
</ul>
</li>
<li><b>Subscription (<code>Subscription</code>): Signing Up for Updates</b><ul>
<li>A <code>Subscription</code> is how an agent declares its interest in certain <code>TopicId</code>s.</li>
<li>It acts like a rule: "If a message is published to a Topic that matches *this pattern*, please deliver it to *this kind of agent*".</li>
<li>The <code>Subscription</code> links a <code>TopicId</code> pattern (e.g., "all topics with type `research.completed`") to an <code>AgentId</code> (or a way to determine the <code>AgentId</code>).</li>
</ul>
</li>
<li><b>Routing: Delivering the Mail</b><ul>
<li>The <code>AgentRuntime</code> (the system manager we'll meet in <a class="el" href="../../db/ded/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_203__agentruntime.html">Chapter 3: AgentRuntime</a>) keeps track of all active <code>Subscription</code>s.</li>
<li>When a message is published to a <code>TopicId</code>, the <code>AgentRuntime</code> checks which <code>Subscription</code>s match that <code>TopicId</code>.</li>
<li>For each match, it uses the <code>Subscription</code>'s rule to figure out which specific <code>AgentId</code> should receive the message and delivers it.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md694"></a>
Use Case Example: Researcher Publishes, Writer Subscribes</h2>
<p>Let's see how our Researcher and Writer can use this system.</p>
<p><b>Goal:</b> Researcher publishes facts to a topic, Writer receives them via subscription.</p>
<p><b>1. Define the Topic:</b> We need a <code>TopicId</code> for research results. Let's say the <code>type</code> is "research.facts.available" and the <code>source</code> identifies the specific research task (e.g., "blog-post-autogen").</p>
<div class="fragment"><div class="line"><span class="comment"># From: _topic.py</span></div>
<div class="line"><span class="keyword">from</span> autogen_core <span class="keyword">import</span> TopicId</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the topic for this specific research task</span></div>
<div class="line">research_topic_id = TopicId(type=<span class="stringliteral">&quot;research.facts.available&quot;</span>, source=<span class="stringliteral">&quot;blog-post-autogen&quot;</span>)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Topic ID: {research_topic_id}&quot;</span>)</div>
<div class="line"><span class="comment"># Output: Topic ID: research.facts.available/blog-post-autogen</span></div>
</div><!-- fragment --><p> This defines the "announcement board" we'll use.</p>
<p><b>2. Researcher Publishes:</b> The <code>Researcher</code> agent, after finding facts, will use its <code>agent_context</code> (provided by the runtime) to publish the <code>ResearchFacts</code> message to this topic.</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified concept - Researcher agent logic</span></div>
<div class="line"><span class="comment"># Assume &#39;agent_context&#39; and &#39;message&#39; (ResearchTopic) are provided</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the facts message (from Chapter 1)</span></div>
<div class="line"><span class="preprocessor">@dataclass</span></div>
<div class="line"><span class="keyword">class </span>ResearchFacts:</div>
<div class="line">    topic: str</div>
<div class="line">    facts: list[str]</div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span>researcher_publish_logic(agent_context, message: ResearchTopic, msg_context):</div>
<div class="line">    print(f<span class="stringliteral">&quot;Researcher working on: {message.topic}&quot;</span>)</div>
<div class="line">    facts_data = ResearchFacts(</div>
<div class="line">        topic=message.topic,</div>
<div class="line">        facts=[f<span class="stringliteral">&quot;Fact A about {message.topic}&quot;</span>, f<span class="stringliteral">&quot;Fact B about {message.topic}&quot;</span>]</div>
<div class="line">    )</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Define the specific topic for this task&#39;s results</span></div>
<div class="line">    results_topic = TopicId(type=<span class="stringliteral">&quot;research.facts.available&quot;</span>, source=message.topic) <span class="comment"># Use message topic as source</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Publish the facts to the topic</span></div>
<div class="line">    await agent_context.publish_message(message=facts_data, topic_id=results_topic)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Researcher published facts to topic: {results_topic}&quot;</span>)</div>
<div class="line">    <span class="comment"># No direct reply needed</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
</div><!-- fragment --><p> Notice the <code>agent_context.publish_message</code> call. The Researcher doesn't specify a recipient, only the topic.</p>
<p><b>3. Writer Subscribes:</b> The <code>Writer</code> agent needs to tell the system it's interested in messages on topics like "research.facts.available". We can use a predefined <code>Subscription</code> type called <code>TypeSubscription</code>. This subscription typically means: "I am interested in all topics with this *exact type*. When a message arrives, create/use an agent of *my type* whose `key` matches the topic's `source`."</p>
<div class="fragment"><div class="line"><span class="comment"># From: _type_subscription.py (Simplified Concept)</span></div>
<div class="line"><span class="keyword">from</span> autogen_core <span class="keyword">import</span> TypeSubscription, BaseAgent</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>WriterAgent(BaseAgent):</div>
<div class="line">    <span class="comment"># ... agent implementation ...</span></div>
<div class="line">    <span class="keyword">async def </span>on_message_impl(self, message: ResearchFacts, ctx):</div>
<div class="line">        <span class="comment"># This method gets called when a subscribed message arrives</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;Writer ({self.id}) received facts via subscription: {message.facts}&quot;</span>)</div>
<div class="line">        <span class="comment"># ... process facts and write draft ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># How the Writer subscribes (usually done during runtime setup - Chapter 3)</span></div>
<div class="line"><span class="comment"># This tells the runtime: &quot;Messages on topics with type &#39;research.facts.available&#39;</span></div>
<div class="line"><span class="comment"># should go to a &#39;writer&#39; agent whose key matches the topic source.&quot;</span></div>
<div class="line">writer_subscription = TypeSubscription(</div>
<div class="line">    topic_type=<span class="stringliteral">&quot;research.facts.available&quot;</span>,</div>
<div class="line">    agent_type=<span class="stringliteral">&quot;writer&quot;</span> <span class="comment"># The type of agent that should handle this</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Writer subscription created for topic type: {writer_subscription.topic_type}&quot;</span>)</div>
<div class="line"><span class="comment"># Output: Writer subscription created for topic type: research.facts.available</span></div>
</div><!-- fragment --><p> When the <code>Researcher</code> publishes to <code>TopicId(type="research.facts.available", source="blog-post-autogen")</code>, the <code>AgentRuntime</code> will see that <code>writer_subscription</code> matches the <code>topic_type</code>. It will then use the rule: "Find (or create) an agent with `AgentId(type='writer', key='blog-post-autogen')` and deliver the message."</p>
<p><b>Benefit:</b> Decoupling! The Researcher just broadcasts. The Writer just listens for relevant broadcasts. We can add more listeners (like a <code>FactChecker</code> subscribing to the same <code>topic_type</code>) without changing the <code>Researcher</code> at all.</p>
<h2><a class="anchor" id="autotoc_md695"></a>
Under the Hood: How Publishing Works</h2>
<p>Let's trace the journey of a published message.</p>
<p><b>Conceptual Flow:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Publisher as Publisher Agent</div>
<div class="line">    participant Runtime as AgentRuntime</div>
<div class="line">    participant SubRegistry as Subscription Registry</div>
<div class="line">    participant Subscriber as Subscriber Agent</div>
<div class="line"> </div>
<div class="line">    Publisher-&gt;&gt;+Runtime: publish_message(message, topic_id)</div>
<div class="line">    Runtime-&gt;&gt;+SubRegistry: Find subscriptions matching topic_id</div>
<div class="line">    SubRegistry--&gt;&gt;-Runtime: Return list of matching Subscriptions</div>
<div class="line">    loop For each matching Subscription</div>
<div class="line">        Runtime-&gt;&gt;Subscription: map_to_agent(topic_id)</div>
<div class="line">        Subscription--&gt;&gt;Runtime: Return target AgentId</div>
<div class="line">        Runtime-&gt;&gt;+Subscriber: Locate/Create Agent instance by AgentId</div>
<div class="line">        Runtime-&gt;&gt;Subscriber: on_message(message, context)</div>
<div class="line">        Subscriber--&gt;&gt;-Runtime: Process message (optional return)</div>
<div class="line">    end</div>
<div class="line">    Runtime--&gt;&gt;-Publisher: Return (usually None for publish)</div>
</div><!-- fragment --><ol type="1">
<li><b>Publish:</b> An agent calls <code>agent_context.publish_message(message, topic_id)</code>. This internally calls the <code>AgentRuntime</code>'s publish method.</li>
<li><b>Lookup:</b> The <code>AgentRuntime</code> takes the <code>topic_id</code> and consults its internal <code>Subscription Registry</code>.</li>
<li><b>Match:</b> The Registry checks all registered <code>Subscription</code> objects. Each <code>Subscription</code> has an <code>is_match(topic_id)</code> method. The registry finds all subscriptions where <code>is_match</code> returns <code>True</code>.</li>
<li><b>Map:</b> For each matching <code>Subscription</code>, the Runtime calls its <code>map_to_agent(topic_id)</code> method. This method returns the specific <code>AgentId</code> that should handle this message based on the subscription rule and the topic details.</li>
<li><b>Deliver:</b> The <code>AgentRuntime</code> finds the agent instance corresponding to the returned <code>AgentId</code> (potentially creating it if it doesn't exist yet, especially with <code>TypeSubscription</code>). It then calls that agent's <code>on_message</code> method, delivering the original published <code>message</code>.</li>
</ol>
<p><b>Code Glimpse:</b></p>
<ul>
<li><p class="startli"><b><code>TopicId</code> (<code>_topic.py</code>):</b> As shown before, a simple dataclass holding <code>type</code> and <code>source</code>. It includes validation to ensure the <code>type</code> follows certain naming conventions.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md696"></a>
From: _topic.py</h1>
<p>@dataclass(eq=True, frozen=True) class TopicId: type: str source: str </p>
<h1><a class="anchor" id="autotoc_md697"></a>
... validation and <b>str</b> ...</h1>
<p>@classmethod def from_str(cls, topic_id: str) -&gt; Self: </p>
<h1><a class="anchor" id="autotoc_md698"></a>
Helper to parse "type/source" string</h1>
<h1><a class="anchor" id="autotoc_md699"></a>
... implementation ...</h1>
<p>```</p>
<ul>
<li><p class="startli"><b><code>Subscription</code> Protocol (<code>_subscription.py</code>):</b> This defines the <em>contract</em> for any subscription rule.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md700"></a>
From: _subscription.py (Simplified Protocol)</h1>
<p>from typing import Protocol </p>
<h1><a class="anchor" id="autotoc_md701"></a>
... other imports</h1>
<p>class Subscription(Protocol): </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
