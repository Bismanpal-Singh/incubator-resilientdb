#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_checkpointer___basecheckpointsaver__</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_checkpointer___basecheckpointsaver__</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2209"></a>
autotoc_md2209</h2>
<p>layout: default title: "Checkpointer (BaseCheckpointSaver)" parent: "LangGraph" </p>
<h2><a class="anchor" id="autotoc_md2210"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md2211"></a>
Chapter 6: Checkpointer (<code>BaseCheckpointSaver</code>) - Saving Your Progress</h1>
<p>In <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Chapter 5: Pregel Execution Engine</a>, we saw how the engine runs our graph step-by-step. But what happens if a graph takes hours to run, or if it needs to pause and wait for a human? If the program crashes or we need to stop it, do we lose all the progress?</p>
<p>That's where <b>Checkpointers</b> come to the rescue!</p>
<h2><a class="anchor" id="autotoc_md2212"></a>
What Problem Do Checkpointers Solve?</h2>
<p>Imagine you're playing a long video game. You wouldn't want to start from the very beginning every time you stop playing, right? Games have save points or checkpoints that record your progress.</p>
<p>LangGraph's <b>Checkpointer</b> does the same thing for your graph execution. It automatically saves the graph's state at certain points, usually after each step completed by the <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a>.</p>
<p>This is incredibly useful for:</p>
<ol type="1">
<li><b>Long-Running Processes:</b> If your graph involves many steps or calls to slow tools/LLMs, you can stop it and resume later without losing work.</li>
<li><b>Resilience:</b> If your program crashes unexpectedly, you can restart it from the last saved checkpoint.</li>
<li><b>Human-in-the-Loop (HITL):</b> As we saw with <code>Interrupt</code> in <a class="el" href="../../d0/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_204__control__flow__primitives___bda35fdc89636f8ab61738c1940513a5.html">Chapter 4: Control Flow Primitives</a>, pausing the graph requires saving its state so it can be perfectly restored when the human provides input. Checkpointers are essential for this.</li>
</ol>
<p><b>Analogy:</b> Think of a checkpointer as an automatic "Save" button for your graph's progress. It takes snapshots of the shared "whiteboard" (<a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a>) so you can always pick up where you left off.</p>
<h2><a class="anchor" id="autotoc_md2213"></a>
Key Concepts</h2>
<ol type="1">
<li><b>What is Saved?</b> The checkpointer saves the current value and version of every <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channel</a> in your graph's state. It also keeps track of which step the graph was on and any pending tasks (like those created by <code>Send</code>).</li>
<li><b>When is it Saved?</b> The <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> typically triggers the checkpointer to save after each "superstep" (a round of node executions and state updates).</li>
<li><b>Where is it Saved?</b> This depends on the specific checkpointer implementation you choose. LangGraph provides several:<ul>
<li><code>MemorySaver</code>: Stores checkpoints in your computer's RAM. Simple for testing, but <b>lost when your script ends</b>.</li>
<li><code>SqliteSaver</code>: Stores checkpoints in a local SQLite database file, making them persistent across script runs.</li>
<li>Other savers might store checkpoints in cloud databases or other persistent storage.</li>
</ul>
</li>
<li><b><code>thread_id</code> (The Save Slot Name):</b> To save and load progress correctly, you need a way to identify <em>which</em> specific run of the graph you want to work with. Think of this like naming your save file in a game. In LangGraph, this identifier is called the <code>thread_id</code>. You provide it in the <code>config</code> when you run the graph. Each unique <code>thread_id</code> represents an independent "conversation" or execution history.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2214"></a>
How to Use a Checkpointer</h2>
<p>Using a checkpointer is straightforward. You just need to tell LangGraph <em>which</em> checkpointer to use when you compile your graph.</p>
<p><b>Step 1: Import a Checkpointer</b></p>
<p>Let's start with the simplest one, <code>MemorySaver</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># Import the simplest checkpointer</span></div>
<div class="line"><span class="keyword">from</span> langgraph.checkpoint.memory <span class="keyword">import</span> MemorySaver</div>
</div><!-- fragment --><p><b>Step 2: Instantiate the Checkpointer</b></p>
<div class="fragment"><div class="line"><span class="comment"># Create an instance of the memory checkpointer</span></div>
<div class="line">memory_saver = MemorySaver()</div>
</div><!-- fragment --><p><b>Step 3: Compile Your Graph with the Checkpointer</b></p>
<p>Let's reuse our simple <code>adder -&gt; multiplier</code> graph. The graph definition itself doesn't change.</p>
<div class="fragment"><div class="line"><span class="comment"># --- Define State and Nodes (same as Chapter 1) ---</span></div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict</div>
<div class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph, END, START</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyState(TypedDict):</div>
<div class="line">    value: int</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>add_one(state: MyState) -&gt; dict:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Adder: Adding 1 to {state[&#39;value&#39;]}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;value&quot;</span>: state[<span class="stringliteral">&#39;value&#39;</span>] + 1}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>multiply_by_two(state: MyState) -&gt; dict:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Multiplier: Doubling {state[&#39;value&#39;]}&quot;</span>)</div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;value&quot;</span>: state[<span class="stringliteral">&#39;value&#39;</span>] * 2}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Build the Graph (same as Chapter 1) ---</span></div>
<div class="line">workflow = StateGraph(MyState)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;adder&quot;</span>, add_one)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;multiplier&quot;</span>, multiply_by_two)</div>
<div class="line">workflow.set_entry_point(<span class="stringliteral">&quot;adder&quot;</span>)</div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;adder&quot;</span>, <span class="stringliteral">&quot;multiplier&quot;</span>)</div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;multiplier&quot;</span>, END)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Compile WITH the checkpointer ---</span></div>
<div class="line"><span class="comment"># Pass the checkpointer instance to the compile method</span></div>
<div class="line">app = workflow.compile(checkpointer=memory_saver)</div>
</div><!-- fragment --><p>That's it! By passing <code>checkpointer=memory_saver</code> to <code>compile()</code>, you've enabled automatic checkpointing for this graph.</p>
<p><b>Step 4: Run with a <code>thread_id</code></b></p>
<p>To use the checkpointer, you need to provide a configuration dictionary (<code>config</code>) containing a unique identifier for this specific execution thread.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> uuid</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a unique ID for this run</span></div>
<div class="line">thread_id = str(uuid.uuid4())</div>
<div class="line">config = {<span class="stringliteral">&quot;configurable&quot;</span>: {<span class="stringliteral">&quot;thread_id&quot;</span>: thread_id}}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the initial state</span></div>
<div class="line">initial_state = {<span class="stringliteral">&quot;value&quot;</span>: 5}</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;--- Running Graph (First Time) ---&quot;</span>)</div>
<div class="line"><span class="comment"># Run the graph with the config</span></div>
<div class="line">final_state = app.invoke(initial_state, config=config)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;\n--- Final State (First Run) ---&quot;</span>)</div>
<div class="line">print(final_state)</div>
</div><!-- fragment --><p><b>Expected Output (First Run):</b></p>
<div class="fragment"><div class="line">--- Running Graph (First Time) ---</div>
<div class="line">Adder: Adding 1 to 5</div>
<div class="line">Multiplier: Doubling 6</div>
<div class="line"> </div>
<div class="line">--- Final State (First Run) ---</div>
<div class="line">{&#39;value&#39;: 12}</div>
</div><!-- fragment --><p>Behind the scenes, <code>MemorySaver</code> saved the state after the <code>adder</code> step and after the <code>multiplier</code> step, associating it with the <code>thread_id</code> you provided.</p>
<p><b>Step 5: Resume the Graph</b></p>
<p>Now, let's imagine we stopped the process. If we run the <em>same graph</em> with the <em>same <code>thread_id</code></em>, the checkpointer allows the <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> to load the last saved state and continue. Since the first run finished completely, running <code>invoke</code> again will just load the final state.</p>
<div class="fragment"><div class="line">print(<span class="stringliteral">&quot;\n--- Running Graph Again with SAME thread_id ---&quot;</span>)</div>
<div class="line"><span class="comment"># Use the SAME config (containing the same thread_id)</span></div>
<div class="line"><span class="comment"># Provide NO initial state, as it will be loaded from the checkpoint</span></div>
<div class="line">resumed_state = app.invoke(<span class="keywordtype">None</span>, config=config)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;\n--- Final State (Resumed Run) ---&quot;</span>)</div>
<div class="line">print(resumed_state)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Let&#39;s check the saved states using the checkpointer directly</span></div>
<div class="line">print(<span class="stringliteral">&quot;\n--- Checkpoints Saved ---&quot;</span>)</div>
<div class="line"><span class="keywordflow">for</span> checkpoint <span class="keywordflow">in</span> memory_saver.list(config):</div>
<div class="line">    print(checkpoint)</div>
</div><!-- fragment --><p><b>Expected Output (Second Run):</b></p>
<div class="fragment"><div class="line">--- Running Graph Again with SAME thread_id ---</div>
<div class="line"># Notice: No node printouts because the graph already finished!</div>
<div class="line"># It just loads the final saved state.</div>
<div class="line"> </div>
<div class="line">--- Final State (Resumed Run) ---</div>
<div class="line">{&#39;value&#39;: 12}</div>
<div class="line"> </div>
<div class="line">--- Checkpoints Saved ---</div>
<div class="line"># You&#39;ll see checkpoint objects representing saved states</div>
<div class="line">CheckpointTuple(config={&#39;configurable&#39;: {&#39;thread_id&#39;: &#39;...&#39;}}, checkpoint={&#39;v&#39;: 1, &#39;ts&#39;: &#39;...&#39;, &#39;id&#39;: &#39;...&#39;, &#39;channel_values&#39;: {&#39;value&#39;: 6}, &#39;channel_versions&#39;: {&#39;adder&#39;: 1}, &#39;versions_seen&#39;: {&#39;adder&#39;: {}}}, metadata={&#39;source&#39;: &#39;loop&#39;, &#39;step&#39;: 1, ...}, ...)</div>
<div class="line">CheckpointTuple(config={&#39;configurable&#39;: {&#39;thread_id&#39;: &#39;...&#39;}}, checkpoint={&#39;v&#39;: 1, &#39;ts&#39;: &#39;...&#39;, &#39;id&#39;: &#39;...&#39;, &#39;channel_values&#39;: {&#39;value&#39;: 12}, &#39;channel_versions&#39;: {&#39;adder&#39;: 1, &#39;multiplier&#39;: 2}, &#39;versions_seen&#39;: {&#39;adder&#39;: {}, &#39;multiplier&#39;: {&#39;adder&#39;: 1}}}, metadata={&#39;source&#39;: &#39;loop&#39;, &#39;step&#39;: 2, ...}, ...)</div>
<div class="line">CheckpointTuple(config={&#39;configurable&#39;: {&#39;thread_id&#39;: &#39;...&#39;}}, checkpoint={&#39;v&#39;: 1, &#39;ts&#39;: &#39;...&#39;, &#39;id&#39;: &#39;...&#39;, &#39;channel_values&#39;: {&#39;value&#39;: 12}, &#39;channel_versions&#39;: {&#39;adder&#39;: 1, &#39;multiplier&#39;: 2}, &#39;versions_seen&#39;: {&#39;adder&#39;: {}, &#39;multiplier&#39;: {&#39;adder&#39;: 1}}}, metadata={&#39;source&#39;: &#39;loop&#39;, &#39;step&#39;: 3, ...}, ...)</div>
</div><!-- fragment --><p>The checkpointer successfully loaded the final state (&lsquo;{'value&rsquo;: 12}<code>) associated with that</code>thread_id`.</p>
<p><b>Checkpointers and <code>Interrupt</code> (Human-in-the-Loop)</b></p>
<p>Remember the <code>Interrupt</code> example from <a class="el" href="../../d0/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_204__control__flow__primitives___bda35fdc89636f8ab61738c1940513a5.html">Chapter 4</a>?</p>
<div class="fragment"><div class="line"><span class="comment"># (Simplified HITL example from Chapter 4)</span></div>
<div class="line"><span class="keyword">from</span> langgraph.types <span class="keyword">import</span> interrupt, Command</div>
<div class="line"><span class="comment"># ... (State, Nodes: create_plan, request_approval, execute_plan) ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Compile WITH checkpointer (REQUIRED for interrupt)</span></div>
<div class="line">memory_saver_hitl = MemorySaver()</div>
<div class="line">app_hitl = workflow.compile(checkpointer=memory_saver_hitl)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Run, get interrupted</span></div>
<div class="line">config_hitl = {<span class="stringliteral">&quot;configurable&quot;</span>: {<span class="stringliteral">&quot;thread_id&quot;</span>: str(uuid.uuid4())}}</div>
<div class="line"><span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> app_hitl.stream({<span class="stringliteral">&quot;plan&quot;</span>: <span class="stringliteral">&quot;&quot;</span>}, config=config_hitl):</div>
<div class="line">    <span class="comment"># ... (detect interrupt) ...</span></div>
<div class="line">    print(<span class="stringliteral">&quot;Graph interrupted!&quot;</span>)</div>
<div class="line">    <span class="keywordflow">break</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Resume after human decision</span></div>
<div class="line">human_decision = <span class="stringliteral">&quot;Approved&quot;</span></div>
<div class="line"><span class="keywordflow">for</span> chunk <span class="keywordflow">in</span> app_hitl.stream(Command(resume=human_decision), config=config_hitl):</div>
<div class="line">     <span class="comment"># ... (process remaining steps) ...</span></div>
<div class="line">     print(<span class="stringliteral">&quot;Graph resumed and finished!&quot;</span>)</div>
</div><!-- fragment --><p>When <code>interrupt()</code> was called inside the <code>request_approval</code> node, the <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> automatically used the <code>memory_saver_hitl</code> checkpointer to save the <em>exact state</em> of the graph at that moment (including the plan). When we called <code>stream</code> again with <code>Command(resume=...)</code> and the <em>same</em> <code>config_hitl</code>, the engine loaded that saved state using the checkpointer, allowing the graph to continue exactly where it left off, now with the human's feedback.</p>
<p><b>Without a checkpointer, <code>Interrupt</code> cannot work.</b></p>
<h2><a class="anchor" id="autotoc_md2215"></a>
How Checkpointing Works Internally</h2>
<p>What happens behind the scenes when a checkpointer is configured?</p>
<p><b>Saving:</b></p>
<ol type="1">
<li><b>Step Complete:</b> The <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> finishes a step (e.g., after running the <code>adder</code> node and updating the state).</li>
<li><b>Signal Checkpointer:</b> The engine tells the configured checkpointer (<code>MemorySaver</code> in our example) that it's time to save.</li>
<li><b>Gather State:</b> The checkpointer (or the engine on its behalf) accesses all the active <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a>.</li>
<li><b>Serialize State:</b> For each channel, it calls the channel's internal <code>checkpoint()</code> method to get a serializable representation of its current value (e.g., the number <code>6</code> for the <code>"value"</code> channel).</li>
<li><b>Store Checkpoint:</b> The checkpointer bundles the serialized channel values, their versions, the current step number, and other metadata into a <code>Checkpoint</code> object. It then stores this <code>Checkpoint</code> associated with the current <code>thread_id</code> provided in the <code>config</code>. <code>MemorySaver</code> stores it in a dictionary in RAM; <code>SqliteSaver</code> writes it to a database table.</li>
</ol>
<p><b>Loading (Resuming):</b></p>
<ol type="1">
<li><b>Invoke with <code>thread_id</code>:</b> You call <code>app.invoke(None, config=config)</code> where <code>config</code> contains a <code>thread_id</code> that has been previously saved.</li>
<li><b>Request Checkpoint:</b> The <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> asks the checkpointer to load the latest checkpoint for the given <code>thread_id</code>.</li>
<li><b>Retrieve Checkpoint:</b> The checkpointer retrieves the saved <code>Checkpoint</code> object (e.g., from its memory dictionary or the database).</li>
<li><b>Restore State:</b> The engine takes the saved channel values from the checkpoint. For each channel, it calls the channel's <code>from_checkpoint()</code> method (or similar internal logic) to restore its state. The "whiteboard" (<a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a>) is now exactly as it was when the checkpoint was saved.</li>
<li><b>Continue Execution:</b> The engine looks at the saved step number and metadata to figure out where to resume execution, typically by preparing the tasks for the <em>next</em> step.</li>
</ol>
<p>Here's a simplified view of the interaction:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant App as CompiledGraph</div>
<div class="line">    participant Engine as Pregel Engine</div>
<div class="line">    participant Saver as Checkpointer (e.g., MemorySaver)</div>
<div class="line">    participant Storage as Underlying Storage (RAM, DB)</div>
<div class="line"> </div>
<div class="line">    %% Saving %%</div>
<div class="line">    Engine-&gt;&gt;Engine: Finishes Step N</div>
<div class="line">    Engine-&gt;&gt;Saver: Save checkpoint for config (thread_id)</div>
<div class="line">    Saver-&gt;&gt;Engine: Request current channel states &amp; versions</div>
<div class="line">    Engine--&gt;&gt;Saver: Provides states &amp; versions</div>
<div class="line">    Saver-&gt;&gt;Storage: Store Checkpoint(Step N, states, versions) linked to thread_id</div>
<div class="line">    Storage--&gt;&gt;Saver: Acknowledge Save</div>
<div class="line">    Saver--&gt;&gt;Engine: Save Complete</div>
<div class="line"> </div>
<div class="line">    %% Loading %%</div>
<div class="line">    User-&gt;&gt;App: invoke(None, config with thread_id)</div>
<div class="line">    App-&gt;&gt;Engine: Start/Resume Execution</div>
<div class="line">    Engine-&gt;&gt;Saver: Get latest checkpoint for config (thread_id)</div>
<div class="line">    Saver-&gt;&gt;Storage: Retrieve Checkpoint linked to thread_id</div>
<div class="line">    Storage--&gt;&gt;Saver: Returns Checkpoint(Step N, states, versions)</div>
<div class="line">    Saver--&gt;&gt;Engine: Provides Checkpoint</div>
<div class="line">    Engine-&gt;&gt;Engine: Restore channel states from checkpoint</div>
<div class="line">    Engine-&gt;&gt;Engine: Prepare tasks for Step N+1</div>
<div class="line">    Engine-&gt;&gt;App: Continue execution...</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2216"></a>
A Peek at the Code (<code>checkpoint/base.py</code>, <code>checkpoint/memory.py</code>, <code>pregel/loop.py</code>)</h2>
<p>Let's look at the core components:</p>
<ul>
<li><p class="startli"><b><code>BaseCheckpointSaver</code> (<code>checkpoint/base.py</code>)</b>: This is the abstract base class (like a template) that all checkpointers must implement. It defines the essential methods the engine needs.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2217"></a>
checkpoint/base.py (Highly Simplified)</h1>
<p>from abc import ABC, abstractmethod from typing import Any, Mapping, Optional, Sequence, Tuple, TypedDict</p>
<h1><a class="anchor" id="autotoc_md2218"></a>
Represents a saved checkpoint</h1>
<p>class Checkpoint(TypedDict): channel_values: Mapping[str, Any] # Saved state of channels channel_versions: Mapping[str, int] # Internal versions versions_seen: Mapping[str, Mapping[str, int]] # Tracking for node execution </p>
<h1><a class="anchor" id="autotoc_md2219"></a>
... other metadata like v, ts, id, pending_sends ...</h1>
<h1><a class="anchor" id="autotoc_md2220"></a>
Represents the checkpoint tuple retrieved from storage</h1>
<p>class CheckpointTuple(NamedTuple): config: dict # The config used (includes thread_id) checkpoint: Checkpoint metadata: dict </p>
<h1><a class="anchor" id="autotoc_md2221"></a>
... other fields like parent_config, pending_writes ...</h1>
<p>class BaseCheckpointSaver(ABC): </p>
<h1><a class="anchor" id="autotoc_md2222"></a>
&mdash; Sync Methods &mdash;</h1>
<p>@abstractmethod def get_tuple(self, config: dict) -&gt; Optional[CheckpointTuple]: """Load the checkpoint tuple for the given config.""" ...</p>
<p>@abstractmethod def put(self, config: dict, checkpoint: Checkpoint, metadata: dict) -&gt; dict: """Save a checkpoint.""" ...</p>
<h1><a class="anchor" id="autotoc_md2223"></a>
&mdash; Async Methods (similar structure) &mdash;</h1>
<p>@abstractmethod async def aget_tuple(self, config: dict) -&gt; Optional[CheckpointTuple]: """Async load the checkpoint tuple.""" ...</p>
<p>@abstractmethod async def aput(self, config: dict, checkpoint: Checkpoint, metadata: dict) -&gt; dict: """Async save a checkpoint.""" ...</p>
<h1><a class="anchor" id="autotoc_md2224"></a>
&mdash; Other methods (list, put_writes) omitted for brevity &mdash;</h1>
<p>``<code> The key methods are</code>get_tuple&lt;tt&gt;(to load) andput&lt;tt&gt;(to save), along with their async counterparts (aget_tuple<code>,</code>aput<code>). Any specific checkpointer (like</code>MemorySaver<code>,</code>SqliteSaver`) must provide concrete implementations for these methods.</p>
<ul>
<li><p class="startli"><b><code>MemorySaver</code> (<code>checkpoint/memory.py</code>)</b>: A simple implementation that uses an in-memory dictionary.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2225"></a>
checkpoint/memory.py (Highly Simplified)</h1>
<p>import threading from collections import defaultdict</p>
<p>class MemorySaver(BaseCheckpointSaver): def <b>init</b>(self): </p>
<h1><a class="anchor" id="autotoc_md2226"></a>
Use a dictionary to store checkpoints in RAM</h1>
<h1><a class="anchor" id="autotoc_md2227"></a>
Key: thread_id, Value: List of CheckpointTuples</h1>
<p>self._checkpoints: defaultdict[str, list[CheckpointTuple]] = defaultdict(list) self._lock = threading.RLock() # To handle multiple threads safely</p>
<p>def get_tuple(self, config: dict) -&gt; Optional[CheckpointTuple]: thread_id = config["configurable"]["thread_id"] with self._lock: if checkpoints := self._checkpoints.get(thread_id): </p>
<h1><a class="anchor" id="autotoc_md2228"></a>
Return the latest checkpoint for this thread_id</h1>
<p>return checkpoints[-1] return None</p>
<p>def put(self, config: dict, checkpoint: Checkpoint, metadata: dict) -&gt; dict: thread_id = config["configurable"]["thread_id"] with self._lock: </p>
<h1><a class="anchor" id="autotoc_md2229"></a>
Append the new checkpoint to the list for this thread_id</h1>
<p>self._checkpoints[thread_id].append(
                    CheckpointTuple(config, checkpoint, metadata)
                ) return {"configurable": {"thread_id": thread_id}}</p>
<h1><a class="anchor" id="autotoc_md2230"></a>
... async methods (aget_tuple, aput) are similar using the same dict ...</h1>
<h1><a class="anchor" id="autotoc_md2231"></a>
... list method iterates through the dictionary ...</h1>
<p>``<code> As you can see,</code>MemorySaver<code>just uses a standard Python dictionary (</code>self._checkpoints<code>) to store the</code>CheckpointTuple<code>for each</code>thread_id`. This is simple but not persistent.</p>
<ul>
<li><p class="startli"><b>Integration (<code>pregel/loop.py</code>)</b>: The <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> (<code>PregelLoop</code> classes) interacts with the checkpointer during its execution cycle.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md2232"></a>
pregel/loop.py (Conceptual Snippets)</h1>
<p>class PregelLoop: # Base class for Sync/Async loops def <b>init</b>(self, ..., checkpointer: Optional[BaseCheckpointSaver], ...): self.checkpointer = checkpointer </p>
<h1><a class="anchor" id="autotoc_md2233"></a>
... other init ...</h1>
<p>def _put_checkpoint(self, metadata: CheckpointMetadata) -&gt; None: </p>
<h1><a class="anchor" id="autotoc_md2234"></a>
Called by the loop after a step or input processing</h1>
<p>if self.checkpointer: </p>
<h1><a class="anchor" id="autotoc_md2235"></a>
1. Create the Checkpoint object from current channels/state</h1>
<p>checkpoint_data = create_checkpoint(self.checkpoint, self.channels, ...)</p>
<h1><a class="anchor" id="autotoc_md2236"></a>
2. Call the checkpointer's put method (sync or async)</h1>
<h1><a class="anchor" id="autotoc_md2237"></a>
(Uses self.submit to potentially run in background)</h1>
<p>self.submit(self.checkpointer.put, self.checkpoint_config, checkpoint_data, metadata)</p>
<h1><a class="anchor" id="autotoc_md2238"></a>
3. Update internal config with the new checkpoint ID</h1>
<p>self.checkpoint_config = {"configurable": {"thread_id": ..., "checkpoint_id": checkpoint_data["id"]}}</p>
<p>def <b>enter</b>(self): # Or <b>aenter</b> for async </p>
<h1><a class="anchor" id="autotoc_md2239"></a>
Called when the loop starts</h1>
<p>if self.checkpointer: </p>
<h1><a class="anchor" id="autotoc_md2240"></a>
1. Try to load an existing checkpoint tuple</h1>
<p>saved = self.checkpointer.get_tuple(self.checkpoint_config) else: saved = None</p>
<p>if saved: </p>
<h1><a class="anchor" id="autotoc_md2241"></a>
2. Restore state from the loaded checkpoint</h1>
<p>self.checkpoint = saved.checkpoint self.checkpoint_config = saved.config </p>
<h1><a class="anchor" id="autotoc_md2242"></a>
... restore channels from saved.checkpoint['channel_values'] ...</h1>
<p>else: </p>
<h1><a class="anchor" id="autotoc_md2243"></a>
Initialize with an empty checkpoint</h1>
<p>self.checkpoint = empty_checkpoint()</p>
<h1><a class="anchor" id="autotoc_md2244"></a>
... setup channels based on restored or empty checkpoint ...</h1>
<p>return self ``<code> The</code>PregelLoop<code>uses the checkpointer's</code>get_tuple<code>method when it starts (in</code>__enter__<code>or</code>__aenter__<code>) to load any existing state. It uses the</code>put<code>method (inside</code>_put_checkpoint`) during execution to save progress.</p>
<h2><a class="anchor" id="autotoc_md2245"></a>
Conclusion</h2>
<p>You've learned about <b>Checkpointers (<code>BaseCheckpointSaver</code>)</b>, the mechanism that gives your LangGraph applications memory and resilience.</p>
<ul>
<li>Checkpointers <b>save</b> the state of your graph's <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a> periodically.</li>
<li>They <b>load</b> saved states to resume execution.</li>
<li>This is crucial for <b>long-running graphs</b>, <b>human-in-the-loop</b> workflows (using <code>Interrupt</code>), and <b>recovering from failures</b>.</li>
<li>You enable checkpointing by passing a <code>checkpointer</code> instance (like <code>MemorySaver</code> or <code>SqliteSaver</code>) to <code>graph.compile()</code>.</li>
<li>You manage different execution histories using a unique <code>thread_id</code> in the <code>config</code>.</li>
<li><code>MemorySaver</code> is simple for testing but lost when the script ends; use database savers (like <code>SqliteSaver</code>) for true persistence.</li>
</ul>
<p>This chapter concludes our tour of the core concepts in LangGraph! You now understand the fundamental building blocks: the blueprint (<a class="el" href="../../df/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_201__graph______stategraph.html"><code>StateGraph</code></a>), the workers (<a class="el" href="../../dc/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_202__nodes______pregelnode____.html"><code>Nodes</code></a>), the communication system (<a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html"><code>Channels</code></a>), the traffic signals (<a class="el" href="../../d0/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_204__control__flow__primitives___bda35fdc89636f8ab61738c1940513a5.html">Control Flow Primitives</a>), the engine room (<a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a>), and the save system (<a class="el" href="../../d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html">Checkpointer</a>).</p>
<p>With these concepts, you're well-equipped to start building your own sophisticated, stateful applications with LangGraph! Explore the documentation for more examples, advanced patterns, and different checkpointer implementations. Happy building!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
