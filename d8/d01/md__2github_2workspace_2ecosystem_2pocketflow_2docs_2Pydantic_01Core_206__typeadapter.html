#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_typeadapter</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d01/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_206__typeadapter.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_typeadapter</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2891"></a>
autotoc_md2891</h2>
<p>layout: default title: "TypeAdapter" parent: "Pydantic Core" </p>
<h2><a class="anchor" id="autotoc_md2892"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md2893"></a>
Chapter 6: TypeAdapter - Your Universal Data Handler</h1>
<p>Welcome to the final chapter of our Pydantic Core tutorial! In <a class="el" href="../../d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html">Chapter 5: Core Schema &amp; Validation/Serialization</a>, we dove deep into how Pydantic uses the <code>CoreSchema</code> and the <code>pydantic-core</code> engine to efficiently validate and serialize data for your <code>BaseModel</code> classes.</p>
<p>But what if you have data that <em>isn't</em> structured as a <code>BaseModel</code>? Imagine you receive a simple list of product IDs from an API, or you need to validate a function argument that's just a dictionary or a date. You still want Pydantic's powerful validation and maybe its smart serialization, but creating a whole <code>BaseModel</code> just for <code>list[int]</code> seems like overkill.</p>
<p>This is exactly where <code>TypeAdapter</code> comes in!</p>
<h2><a class="anchor" id="autotoc_md2894"></a>
The Problem: Handling Simple Types</h2>
<p>Let's say you're working with a function that expects a list of user IDs, which should all be positive integers:</p>
<div class="fragment"><div class="line"><span class="comment"># Our expected data structure: a list of positive integers</span></div>
<div class="line"><span class="comment"># Example: [101, 205, 300]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Incoming data might be messy:</span></div>
<div class="line">raw_data_ok = <span class="stringliteral">&#39;[101, &quot;205&quot;, 300]&#39;</span> <span class="comment"># Comes as JSON string, contains string number</span></div>
<div class="line">raw_data_bad = <span class="stringliteral">&#39;[101, -5, &quot;abc&quot;]&#39;</span> <span class="comment"># Contains negative number and non-number string</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>process_user_ids(user_ids: list[int]):</div>
<div class="line">    <span class="comment"># How do we easily validate &#39;raw_data&#39; conforms to list[int]</span></div>
<div class="line">    <span class="comment"># AND ensure all IDs are positive *before* this function runs?</span></div>
<div class="line">    <span class="comment"># And how do we handle the string &quot;205&quot;?</span></div>
<div class="line">    <span class="keywordflow">for</span> user_id <span class="keywordflow">in</span> user_ids:</div>
<div class="line">        print(f<span class="stringliteral">&quot;Processing user ID: {user_id}&quot;</span>)</div>
<div class="line">        <span class="comment"># We assume user_ids is already clean list[int] here</span></div>
</div><!-- fragment --><p>Manually parsing the JSON, checking the type of the list and its elements, converting strings like <code>"205"</code> to integers, and validating positivity can be tedious and error-prone. We want Pydantic's magic for this simple list!</p>
<h2><a class="anchor" id="autotoc_md2895"></a>
Introducing <code>TypeAdapter</code>: The Universal Handler</h2>
<p><code>TypeAdapter</code> provides Pydantic's validation and serialization capabilities for <b>arbitrary Python types</b>, not just <code>BaseModel</code> subclasses.</p>
<p><b>Analogy:</b> Think of <code>TypeAdapter</code> as a <b>universal quality checker and packager</b>. Unlike <code>BaseModel</code> (which is like a specific blueprint for a complex object), <code>TypeAdapter</code> can handle <em>any</em> kind of item – a list, a dictionary, an integer, a date, a union type, etc. – as long as you tell it the <b>type specification</b> the item should conform to.</p>
<p>It acts as a lightweight wrapper around Pydantic's core validation and serialization engine for any type hint you give it.</p>
<h2><a class="anchor" id="autotoc_md2896"></a>
Creating a <code>TypeAdapter</code></h2>
<p>You create a <code>TypeAdapter</code> by simply passing the Python type you want to handle to its initializer.</p>
<p>Let's create one for our <code>list[int]</code> requirement, but let's add the positivity constraint using <code>PositiveInt</code> from Pydantic's types.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> TypeAdapter, PositiveInt</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the specific type we want to validate against</span></div>
<div class="line"><span class="comment"># This can be any Python type hint Pydantic understands</span></div>
<div class="line">UserIdListType = List[PositiveInt]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the adapter for this type</span></div>
<div class="line">user_id_list_adapter = TypeAdapter(UserIdListType)</div>
<div class="line"> </div>
<div class="line">print(user_id_list_adapter)</div>
<div class="line"><span class="comment"># Expected Output: TypeAdapter(&lt;class &#39;list[pydantic.types.PositiveInt]&#39;&gt;)</span></div>
</div><!-- fragment --><p>We now have <code>user_id_list_adapter</code>, an object specifically configured to validate data against the <code>List[PositiveInt]</code> type and serialize Python lists matching this type.</p>
<h2><a class="anchor" id="autotoc_md2897"></a>
Validation with <code>TypeAdapter</code></h2>
<p>The primary use case is validation. <code>TypeAdapter</code> offers methods similar to <code>BaseModel</code>'s <code>model_validate</code> and <code>model_validate_json</code>.</p>
<h3><a class="anchor" id="autotoc_md2898"></a>
<code>validate_python()</code></h3>
<p>This method takes a Python object (like a list or dict) and validates it against the adapter's type. It performs type checks, coercion (like converting <code>"205"</code> to <code>205</code>), and runs any defined constraints (like <code>PositiveInt</code>).</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> ValidationError, PositiveInt, TypeAdapter</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</div>
<div class="line"> </div>
<div class="line">UserIdListType = List[PositiveInt]</div>
<div class="line">user_id_list_adapter = TypeAdapter(UserIdListType)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Example 1: Valid data (with coercion needed) ---</span></div>
<div class="line">python_data_ok = [101, <span class="stringliteral">&quot;205&quot;</span>, 300] <span class="comment"># &quot;205&quot; needs converting to int</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    validated_list = user_id_list_adapter.validate_python(python_data_ok)</div>
<div class="line">    print(f<span class="stringliteral">&quot;Validation successful: {validated_list}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output: Validation successful: [101, 205, 300]</span></div>
<div class="line">    print(f<span class="stringliteral">&quot;Types: {[type(x) for x in validated_list]}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output: Types: [&lt;class &#39;int&#39;&gt;, &lt;class &#39;int&#39;&gt;, &lt;class &#39;int&#39;&gt;]</span></div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;Validation failed: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Example 2: Invalid data (negative number) ---</span></div>
<div class="line">python_data_bad_value = [101, -5, 300] <span class="comment"># -5 is not PositiveInt</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    user_id_list_adapter.validate_python(python_data_bad_value)</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;\nValidation failed as expected:\n{e}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output (simplified):</span></div>
<div class="line">    <span class="comment"># Validation failed as expected:</span></div>
<div class="line">    <span class="comment"># 1 validation error for list[PositiveInt]</span></div>
<div class="line">    <span class="comment"># 1</span></div>
<div class="line">    <span class="comment">#   Input should be greater than 0 [type=greater_than, context={&#39;gt&#39;: 0}, input_value=-5, input_type=int]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Example 3: Invalid data (wrong type) ---</span></div>
<div class="line">python_data_bad_type = [101, <span class="stringliteral">&quot;abc&quot;</span>, 300] <span class="comment"># &quot;abc&quot; cannot be int</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    user_id_list_adapter.validate_python(python_data_bad_type)</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;\nValidation failed as expected:\n{e}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output (simplified):</span></div>
<div class="line">    <span class="comment"># Validation failed as expected:</span></div>
<div class="line">    <span class="comment"># 1 validation error for list[PositiveInt]</span></div>
<div class="line">    <span class="comment"># 1</span></div>
<div class="line">    <span class="comment">#   Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value=&#39;abc&#39;, input_type=str]</span></div>
</div><!-- fragment --><p>Just like with <code>BaseModel</code>, <code>TypeAdapter</code> gives you clear validation errors pinpointing the exact location and reason for the failure. It also handles useful type coercion automatically.</p>
<h3><a class="anchor" id="autotoc_md2899"></a>
<code>validate_json()</code></h3>
<p>If your input data is a JSON string (or bytes/bytearray), you can use <code>validate_json()</code> to parse and validate in one step.</p>
<div class="fragment"><div class="line"><span class="comment"># Continuing from above...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Input as a JSON string</span></div>
<div class="line">raw_data_ok_json = <span class="stringliteral">&#39;[101, &quot;205&quot;, 300]&#39;</span></div>
<div class="line">raw_data_bad_json = <span class="stringliteral">&#39;[101, -5, &quot;abc&quot;]&#39;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Validate the good JSON</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    validated_list_from_json = user_id_list_adapter.validate_json(raw_data_ok_json)</div>
<div class="line">    print(f<span class="stringliteral">&quot;\nValidated from JSON: {validated_list_from_json}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output: Validated from JSON: [101, 205, 300]</span></div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;\nJSON validation failed: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Validate the bad JSON</span></div>
<div class="line"><span class="keywordflow">try</span>:</div>
<div class="line">    user_id_list_adapter.validate_json(raw_data_bad_json)</div>
<div class="line"><span class="keywordflow">except</span> ValidationError <span class="keyword">as</span> e:</div>
<div class="line">    print(f<span class="stringliteral">&quot;\nJSON validation failed as expected:\n{e}&quot;</span>)</div>
<div class="line">    <span class="comment"># Expected Output (simplified):</span></div>
<div class="line">    <span class="comment"># JSON validation failed as expected:</span></div>
<div class="line">    <span class="comment"># 1 validation error for list[PositiveInt]</span></div>
<div class="line">    <span class="comment"># 1</span></div>
<div class="line">    <span class="comment">#   Input should be greater than 0 [type=greater_than, context={&#39;gt&#39;: 0}, input_value=-5, input_type=int]</span></div>
</div><!-- fragment --><p>This is extremely handy for validating raw API request bodies or data loaded from JSON files without needing to parse the JSON yourself first.</p>
<h2><a class="anchor" id="autotoc_md2900"></a>
Serialization with <code>TypeAdapter</code></h2>
<p><code>TypeAdapter</code> can also serialize Python objects according to the rules of its associated type, similar to <code>BaseModel.model_dump()</code> and <code>model_dump_json()</code>.</p>
<h3><a class="anchor" id="autotoc_md2901"></a>
<code>dump_python()</code></h3>
<p>Converts a Python object into a "dumped" representation (often simpler Python types). This is most useful when the type involves Pydantic models or types with custom serialization logic (like datetimes, enums, etc.). For simple types like <code>list[int]</code>, it might not change much.</p>
<p>Let's use a slightly more complex example: <code>List[datetime]</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> TypeAdapter</div>
<div class="line"> </div>
<div class="line">datetime_list_adapter = TypeAdapter(List[datetime])</div>
<div class="line"> </div>
<div class="line"><span class="comment"># A list of datetime objects</span></div>
<div class="line">dt_list = [datetime(2023, 1, 1, 12, 0, 0), datetime(2024, 7, 15, 9, 30, 0)]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Dump to Python objects (datetimes remain datetimes by default)</span></div>
<div class="line">dumped_python = datetime_list_adapter.dump_python(dt_list)</div>
<div class="line">print(f<span class="stringliteral">&quot;Dumped Python: {dumped_python}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: Dumped Python: [datetime.datetime(2023, 1, 1, 12, 0), datetime.datetime(2024, 7, 15, 9, 30)]</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># To get JSON-compatible types (strings), use mode=&#39;json&#39;</span></div>
<div class="line">dumped_for_json = datetime_list_adapter.dump_python(dt_list, mode=<span class="stringliteral">&#39;json&#39;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Dumped for JSON: {dumped_for_json}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output: Dumped for JSON: [&#39;2023-01-01T12:00:00&#39;, &#39;2024-07-15T09:30:00&#39;]</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md2902"></a>
<code>dump_json()</code></h3>
<p>Directly serializes the Python object into a JSON string, using Pydantic's encoders (e.g., converting <code>datetime</code> to ISO 8601 strings).</p>
<div class="fragment"><div class="line"><span class="comment"># Continuing with datetime_list_adapter and dt_list...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Dump directly to a JSON string</span></div>
<div class="line">dumped_json_str = datetime_list_adapter.dump_json(dt_list, indent=2)</div>
<div class="line">print(f<span class="stringliteral">&quot;\nDumped JSON:\n{dumped_json_str.decode()}&quot;</span>) <span class="comment"># .decode() to convert bytes to string for printing</span></div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># Dumped JSON:</span></div>
<div class="line"><span class="comment"># [</span></div>
<div class="line"><span class="comment">#   &quot;2023-01-01T12:00:00&quot;,</span></div>
<div class="line"><span class="comment">#   &quot;2024-07-15T09:30:00&quot;</span></div>
<div class="line"><span class="comment"># ]</span></div>
</div><!-- fragment --><p>This uses the same powerful serialization engine as <code>BaseModel</code>, ensuring consistent output formats.</p>
<h2><a class="anchor" id="autotoc_md2903"></a>
Getting JSON Schema</h2>
<p>You can also generate a <a href="https://json-schema.org/">JSON Schema</a> for the type handled by the adapter using the <code>json_schema()</code> method.</p>
<div class="fragment"><div class="line"><span class="comment"># Using our user_id_list_adapter from before...</span></div>
<div class="line"><span class="comment"># UserIdListType = List[PositiveInt]</span></div>
<div class="line"><span class="comment"># user_id_list_adapter = TypeAdapter(UserIdListType)</span></div>
<div class="line"> </div>
<div class="line">schema = user_id_list_adapter.json_schema()</div>
<div class="line"> </div>
<div class="line"><span class="keyword">import</span> json</div>
<div class="line">print(f<span class="stringliteral">&quot;\nJSON Schema:\n{json.dumps(schema, indent=2)}&quot;</span>)</div>
<div class="line"><span class="comment"># Expected Output:</span></div>
<div class="line"><span class="comment"># JSON Schema:</span></div>
<div class="line"><span class="comment"># {</span></div>
<div class="line"><span class="comment">#   &quot;items&quot;: {</span></div>
<div class="line"><span class="comment">#     &quot;exclusiveMinimum&quot;: 0,</span></div>
<div class="line"><span class="comment">#     &quot;type&quot;: &quot;integer&quot;</span></div>
<div class="line"><span class="comment">#   },</span></div>
<div class="line"><span class="comment">#   &quot;title&quot;: &quot;List[PositiveInt]&quot;,</span></div>
<div class="line"><span class="comment">#   &quot;type&quot;: &quot;array&quot;</span></div>
<div class="line"><span class="comment"># }</span></div>
</div><!-- fragment --><p>This schema accurately describes the expected data: an array (<code>"type": "array"</code>) where each item (<code>"items"</code>) must be an integer (<code>"type": "integer"</code>) that is greater than 0 (<code>"exclusiveMinimum": 0</code>).</p>
<h2><a class="anchor" id="autotoc_md2904"></a>
Under the Hood: Direct Line to the Core</h2>
<p>How does <code>TypeAdapter</code> work? It acts as a direct interface to the validation and serialization machinery we discussed in <a class="el" href="../../d0/d56/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2Pydantic_01Core_205__core__schema______validation__serialization.html">Chapter 5</a>.</p>
<p><b>Step-by-Step:</b></p>
<ol type="1">
<li><b>Instantiation:</b> When you create <code>adapter = TypeAdapter(MyType)</code>, Pydantic immediately analyzes <code>MyType</code>.</li>
<li><b>Schema Generation:</b> It generates the internal <code>CoreSchema</code> specifically for <code>MyType</code>, just like it would for a field within a <code>BaseModel</code>.</li>
<li><b>Core Engine:</b> This <code>CoreSchema</code> is passed to the <code>pydantic-core</code> Rust engine.</li>
<li><b>Compilation:</b> <code>pydantic-core</code> compiles and creates optimized <code>SchemaValidator</code> and <code>SchemaSerializer</code> objects based <em>only</em> on the <code>CoreSchema</code> for <code>MyType</code>.</li>
<li><b>Storage:</b> These compiled validator and serializer objects are stored directly on the <code>TypeAdapter</code> instance (e.g., as <code>adapter.validator</code> and <code>adapter.serializer</code>).</li>
<li><b>Usage:</b> When you call <code>adapter.validate_python(data)</code> or <code>adapter.dump_json(obj)</code>, the <code>TypeAdapter</code> simply delegates the call directly to its stored <code>SchemaValidator</code> or <code>SchemaSerializer</code>.</li>
</ol>
<p><b>Sequence Diagram:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Dev as Developer</div>
<div class="line">    participant TA as TypeAdapter</div>
<div class="line">    participant PydanticPy as Pydantic (Python Layer)</div>
<div class="line">    participant CoreSchemaDS as CoreSchema</div>
<div class="line">    participant PydanticCore as pydantic-core (Rust Engine)</div>
<div class="line"> </div>
<div class="line">    Dev-&gt;&gt;TA: adapter = TypeAdapter(List[PositiveInt])</div>
<div class="line">    TA-&gt;&gt;PydanticPy: Request schema generation for List[PositiveInt]</div>
<div class="line">    PydanticPy-&gt;&gt;CoreSchemaDS: Generate CoreSchema for List[PositiveInt]</div>
<div class="line">    PydanticPy-&gt;&gt;PydanticCore: Pass CoreSchema to Rust engine</div>
<div class="line">    PydanticCore-&gt;&gt;PydanticCore: Compile SchemaValidator for List[PositiveInt]</div>
<div class="line">    PydanticCore-&gt;&gt;PydanticCore: Compile SchemaSerializer for List[PositiveInt]</div>
<div class="line">    PydanticCore--&gt;&gt;TA: Return compiled Validator &amp; Serializer</div>
<div class="line">    TA-&gt;&gt;TA: Store validator on self.validator</div>
<div class="line">    TA-&gt;&gt;TA: Store serializer on self.serializer</div>
<div class="line">    TA--&gt;&gt;Dev: Adapter instance is ready</div>
<div class="line"> </div>
<div class="line">    Dev-&gt;&gt;TA: adapter.validate_python(data)</div>
<div class="line">    TA-&gt;&gt;PydanticCore: Call self.validator.validate_python(data)</div>
<div class="line">    PydanticCore--&gt;&gt;TA: Return validated data or raise ValidationError</div>
<div class="line">    TA--&gt;&gt;Dev: Return result</div>
<div class="line"> </div>
<div class="line">    Dev-&gt;&gt;TA: adapter.dump_json(obj)</div>
<div class="line">    TA-&gt;&gt;PydanticCore: Call self.serializer.to_json(obj)</div>
<div class="line">    PydanticCore--&gt;&gt;TA: Return JSON bytes</div>
<div class="line">    TA--&gt;&gt;Dev: Return result</div>
</div><!-- fragment --><p>Unlike <code>BaseModel</code>, where the validator/serializer are attached to the <em>class</em>, with <code>TypeAdapter</code>, they are attached to the <em>instance</em> of the adapter. This makes <code>TypeAdapter</code> a neat, self-contained tool for handling specific types.</p>
<p><b>Code Location:</b></p>
<ul>
<li>The main logic is in <code>pydantic/type_adapter.py</code>.</li>
<li>The <code>TypeAdapter.__init__</code> method orchestrates the process:<ul>
<li>It determines the correct Python namespaces for resolving type hints.</li>
<li>It calls internal schema generation logic (<code>pydantic._internal._generate_schema.GenerateSchema</code>) to build the <code>CoreSchema</code> for the given type.</li>
<li>It uses <code>pydantic_core.SchemaValidator(core_schema, config)</code> and <code>pydantic_core.SchemaSerializer(core_schema, config)</code> to create the core engine objects.</li>
<li>These are stored on the instance as <code>self.validator</code> and <code>self.serializer</code>.</li>
</ul>
</li>
<li>Methods like <code>validate_python</code>, <code>dump_json</code>, etc., are thin wrappers that call the corresponding methods on <code>self.validator</code> or <code>self.serializer</code>.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment"># Simplified conceptual view from pydantic/type_adapter.py</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> pydantic_core <span class="keyword">import</span> SchemaValidator, SchemaSerializer, CoreSchema</div>
<div class="line"><span class="comment"># ... other imports</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>TypeAdapter(Generic[T]):</div>
<div class="line">    core_schema: CoreSchema</div>
<div class="line">    validator: SchemaValidator | PluggableSchemaValidator <span class="comment"># Actually uses PluggableSchemaValidator internally</span></div>
<div class="line">    serializer: SchemaSerializer</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self, type: Any, *, config: ConfigDict | <span class="keywordtype">None</span> = <span class="keywordtype">None</span>, ...):</div>
<div class="line">        self._type = type</div>
<div class="line">        self._config = config</div>
<div class="line">        <span class="comment"># ... (fetch parent frame namespaces) ...</span></div>
<div class="line">        ns_resolver = _namespace_utils.NsResolver(...)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># ... Call internal _init_core_attrs ...</span></div>
<div class="line">        self._init_core_attrs(ns_resolver=ns_resolver, force=<span class="keyword">True</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>_init_core_attrs(self, ns_resolver, force, raise_errors=False):</div>
<div class="line">        <span class="comment"># ... Simplified schema generation ...</span></div>
<div class="line">        config_wrapper = _config.ConfigWrapper(self._config)</div>
<div class="line">        schema_generator = _generate_schema.GenerateSchema(config_wrapper, ns_resolver)</div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            core_schema = schema_generator.generate_schema(self._type)</div>
<div class="line">            self.core_schema = schema_generator.clean_schema(core_schema)</div>
<div class="line">            core_config = config_wrapper.core_config(<span class="keywordtype">None</span>)</div>
<div class="line"> </div>
<div class="line">            <span class="comment"># Create and store validator and serializer</span></div>
<div class="line">            <span class="comment"># Note: Actual code uses create_schema_validator for plugin support</span></div>
<div class="line">            self.validator = SchemaValidator(self.core_schema, core_config)</div>
<div class="line">            self.serializer = SchemaSerializer(self.core_schema, core_config)</div>
<div class="line">            self.pydantic_complete = <span class="keyword">True</span></div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">except</span> Exception:</div>
<div class="line">            <span class="comment"># Handle errors, potentially set mocks if build fails</span></div>
<div class="line">            <span class="comment"># ...</span></div>
<div class="line">            <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>validate_python(self, object: Any, /, **kwargs) -&gt; T:</div>
<div class="line">        <span class="comment"># Directly delegates to the stored validator</span></div>
<div class="line">        <span class="keywordflow">return</span> self.validator.validate_python(object, **kwargs)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>validate_json(self, data: str | bytes | bytearray, /, **kwargs) -&gt; T:</div>
<div class="line">        <span class="comment"># Directly delegates to the stored validator</span></div>
<div class="line">        <span class="keywordflow">return</span> self.validator.validate_json(data, **kwargs)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>dump_python(self, instance: T, /, **kwargs) -&gt; Any:</div>
<div class="line">        <span class="comment"># Directly delegates to the stored serializer</span></div>
<div class="line">        <span class="keywordflow">return</span> self.serializer.to_python(instance, **kwargs)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>dump_json(self, instance: T, /, **kwargs) -&gt; bytes:</div>
<div class="line">        <span class="comment"># Directly delegates to the stored serializer</span></div>
<div class="line">        <span class="keywordflow">return</span> self.serializer.to_json(instance, **kwargs)</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>json_schema(self, **kwargs) -&gt; dict[str, Any]:</div>
<div class="line">        <span class="comment"># Generates schema based on self.core_schema</span></div>
<div class="line">        schema_generator_instance = GenerateJsonSchema(**kwargs)</div>
<div class="line">        <span class="keywordflow">return</span> schema_generator_instance.generate(self.core_schema, mode=kwargs.get(<span class="stringliteral">&#39;mode&#39;</span>, <span class="stringliteral">&#39;validation&#39;</span>))</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2905"></a>
Conclusion</h2>
<p>Congratulations! You've learned about <code>TypeAdapter</code>, a flexible tool for applying Pydantic's validation and serialization to any Python type, not just <code>BaseModel</code>s.</p>
<ul>
<li>It's ideal for validating simple types, function arguments, or data structures where a full <code>BaseModel</code> isn't necessary.</li>
<li>You create it by passing the target type: <code>TypeAdapter(YourType)</code>.</li>
<li>It provides <code>.validate_python()</code>, <code>.validate_json()</code>, <code>.dump_python()</code>, <code>.dump_json()</code>, and <code>.json_schema()</code> methods.</li>
<li>It works by generating a <code>CoreSchema</code> for the target type and using dedicated <code>SchemaValidator</code> and <code>SchemaSerializer</code> instances from <code>pydantic-core</code>.</li>
</ul>
<p><code>TypeAdapter</code> completes our tour of the essential concepts in Pydantic V2. You've journeyed from the basic <code>BaseModel</code> blueprint, through customizing fields and configuration, adding custom logic, understanding the core schema engine, and finally, applying these powers universally with <code>TypeAdapter</code>.</p>
<p>We hope this tutorial has given you a solid foundation for using Pydantic effectively to build robust, reliable, and well-defined data interfaces in your Python applications. Happy coding!</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
