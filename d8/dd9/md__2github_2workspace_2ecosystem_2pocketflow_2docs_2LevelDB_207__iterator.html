#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 07_iterator</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/dd9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_207__iterator.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">07_iterator</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2314"></a>
autotoc_md2314</h2>
<p>layout: default title: "Iterator" parent: "LevelDB" </p>
<h2><a class="anchor" id="autotoc_md2315"></a>
nav_order: 7</h2>
<h1><a class="anchor" id="autotoc_md2316"></a>
Chapter 7: Iterator - Your Guide Through the Database</h1>
<p>Welcome back! In <a class="el" href="../../d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html">Chapter 6: Version &amp; VersionSet</a>, we learned how LevelDB keeps track of all the live SSTable files using <code>Version</code> objects and the <code>VersionSet</code>. This catalog helps LevelDB efficiently find a single key by looking first in the <a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">MemTable</a> and then pinpointing the right <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">SSTables</a> to check.</p>
<p>But what if you don't want just <em>one</em> key? What if you want to see <em>all</em> the key-value pairs in the database, or all the keys within a specific range?</p>
<h2><a class="anchor" id="autotoc_md2317"></a>
What's the Problem? Scanning Multiple Keys</h2>
<p>Imagine you have a database storing user scores, with keys like <code>score:userA</code>, <code>score:userB</code>, <code>score:userC</code>, etc. How would you find all the users whose usernames start with 'user'? Or how would you list all scores from highest to lowest?</p>
<p>Calling <code>db-&gt;Get()</code> repeatedly for every possible key isn't practical or efficient. We need a way to easily <b>scan</b> or <b>traverse</b> through the key-value pairs stored in the database, in sorted order.</p>
<p>Furthermore, this scan needs to be smart. It has to combine the data from the current MemTable (the fast notepad), potentially an older immutable MemTable, and all the different SSTable files on disk. It also needs to correctly handle situations where a key was updated or deleted â€“ showing you only the <em>latest</em> live version of the data, just like <code>Get</code> does.</p>
<h2><a class="anchor" id="autotoc_md2318"></a>
Iterator: Your Database Research Assistant</h2>
<p>LevelDB provides the <code>Iterator</code> concept to solve this. Think of an <code>Iterator</code> as a <b>super-smart research assistant</b>.</p>
<p>You tell the assistant what you're looking for (e.g., "start from the beginning" or "find keys starting with 'user'"). The assistant then efficiently looks through the current notepad (<code>MemTable</code>), the previous notepad (<code>imm_</code>), and all the relevant books on the shelves (<code>SSTables</code>), using the latest catalog (<code>Version</code>).</p>
<p>As the assistant finds relevant entries, it presents them to you one by one, in perfect sorted order by key. Crucially, the assistant knows how to:</p>
<ol type="1">
<li><b>Merge Sources:</b> Combine results from memory (MemTable) and disk (SSTables) seamlessly.</li>
<li><b>Handle Versions:</b> If the same key exists in multiple places (e.g., an old value in an SSTable and a newer value in the MemTable), the assistant only shows you the <em>most recent</em> one based on the database's internal sequence numbers.</li>
<li><b>Handle Deletions:</b> If a key has been deleted, the assistant knows to <em>skip</em> it entirely, even if older versions of the key exist in SSTables.</li>
<li><b>Provide a Snapshot:</b> An iterator typically operates on a consistent snapshot of the database. Data added <em>after</em> the iterator was created won't suddenly appear during your scan.</li>
</ol>
<p>The main iterator you interact with, obtained via <code>db-&gt;NewIterator()</code>, is often implemented internally by a class called <code>DBIter</code>. <code>DBIter</code> coordinates the work of lower-level iterators.</p>
<h2><a class="anchor" id="autotoc_md2319"></a>
How to Use an Iterator</h2>
<p>Using an iterator is quite straightforward. Here's a typical pattern:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;leveldb/db.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;leveldb/iterator.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... assume db is an open LevelDB database ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// 1. Create an iterator</span></div>
<div class="line">leveldb::ReadOptions options;</div>
<div class="line"><span class="comment">// options.snapshot = db-&gt;GetSnapshot(); // Optional: Use a specific snapshot</span></div>
<div class="line">leveldb::Iterator* it = db-&gt;NewIterator(options);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 2. Position the iterator (e.g., seek to the first key &gt;= &quot;start_key&quot;)</span></div>
<div class="line">std::string start_key = <span class="stringliteral">&quot;user:&quot;</span>;</div>
<div class="line">it-&gt;Seek(start_key);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 3. Loop through the keys</span></div>
<div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Keys starting with &#39;&quot;</span> &lt;&lt; start_key &lt;&lt; <span class="stringliteral">&quot;&#39;:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="keywordflow">for</span> (; it-&gt;Valid(); it-&gt;Next()) {</div>
<div class="line">  leveldb::Slice key = it-&gt;key();</div>
<div class="line">  leveldb::Slice value = it-&gt;value();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Optional: Stop if we go past the desired range</span></div>
<div class="line">  <span class="keywordflow">if</span> (!key.starts_with(start_key)) {</div>
<div class="line">     <span class="keywordflow">break</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  std::cout &lt;&lt; key.ToString() &lt;&lt; <span class="stringliteral">&quot; =&gt; &quot;</span> &lt;&lt; value.ToString() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 4. Check for errors (optional but recommended)</span></div>
<div class="line"><span class="keywordflow">if</span> (!it-&gt;status().ok()) {</div>
<div class="line">  std::cerr &lt;&lt; <span class="stringliteral">&quot;Iterator error: &quot;</span> &lt;&lt; it-&gt;status().ToString() &lt;&lt; std::endl;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// 5. Clean up the iterator and snapshot (if used)</span></div>
<div class="line"><span class="keyword">delete</span> it;</div>
<div class="line"><span class="comment">// if (options.snapshot != nullptr) {</span></div>
<div class="line"><span class="comment">//   db-&gt;ReleaseSnapshot(options.snapshot);</span></div>
<div class="line"><span class="comment">// }</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><b><code>db-&gt;NewIterator(options)</code>:</b> You ask the database for a new iterator. You can pass <code>ReadOptions</code>, optionally including a specific snapshot you obtained earlier using <code>db-&gt;GetSnapshot()</code>. If you don't provide a snapshot, the iterator uses an implicit snapshot of the database state at the time of creation.</li>
<li><b>Positioning:</b><ul>
<li><code>it-&gt;Seek(slice)</code>: Moves the iterator to the first key-value pair whose key is greater than or equal to the <code>slice</code>.</li>
<li><code>it-&gt;SeekToFirst()</code>: Moves to the very first key-value pair in the database.</li>
<li><code>it-&gt;SeekToLast()</code>: Moves to the very last key-value pair.</li>
</ul>
</li>
<li><b>Looping:</b><ul>
<li><code>it-&gt;Valid()</code>: Returns <code>true</code> if the iterator is currently pointing to a valid key-value pair, <code>false</code> otherwise (e.g., if you've reached the end).</li>
<li><code>it-&gt;Next()</code>: Moves the iterator to the next key-value pair in sorted order.</li>
<li><code>it-&gt;Prev()</code>: Moves to the previous key-value pair (less common, but supported).</li>
<li><code>it-&gt;key()</code>: Returns a <code>Slice</code> representing the current key.</li>
<li><code>it-&gt;value()</code>: Returns a <code>Slice</code> representing the current value. <b>Important:</b> The <code>Slice</code>s returned by <code>key()</code> and <code>value()</code> are only valid until the next call that modifies the iterator (<code>Next</code>, <code>Prev</code>, <code>Seek</code>, etc.). If you need to keep the data longer, make a copy (e.g., <code>key.ToString()</code>).</li>
</ul>
</li>
<li><b><code>it-&gt;status()</code>:</b> After the loop, check this to see if any errors occurred during iteration (e.g., disk corruption).</li>
<li><b><code>delete it;</code>:</b> Crucially, you <b>must</b> delete the iterator when you're done with it to free up resources. If you used an explicit snapshot, release it too.</li>
</ol>
<p>This simple interface lets you scan through potentially vast amounts of data spread across memory and disk files without needing to know the complex details of where each piece resides.</p>
<h2><a class="anchor" id="autotoc_md2320"></a>
Under the Hood: Merging and Filtering</h2>
<p>How does the iterator provide this unified, sorted view? It doesn't load everything into memory! Instead, it uses a clever strategy involving <b>merging</b> and <b>filtering</b>.</p>
<ol type="1">
<li><b>Gather Internal Iterators:</b> When you call <code>db-&gt;NewIterator()</code>, the <code>DBImpl</code> asks for iterators from all the relevant sources, based on the current <a class="el" href="../../d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html">Version</a>:<ul>
<li>An iterator for the active <code>MemTable</code>.</li>
<li>An iterator for the immutable <code>imm_</code> (if it exists).</li>
<li>Iterators for all the files in Level-0.</li>
<li>A special "concatenating" iterator for Level-1 (which opens SSTable files lazily as needed).</li>
<li>Similar concatenating iterators for Level-2, Level-3, etc.</li>
</ul>
</li>
<li><b>Create MergingIterator:</b> These individual iterators are then passed to a <code>MergingIterator</code>. The <code>MergingIterator</code> acts like a zipper, taking multiple sorted streams and producing a single output stream that is also sorted. It keeps track of the current position in each input iterator and always yields the smallest key currently available across all inputs.</li>
<li><b>Wrap with DBIter:</b> The <code>MergingIterator</code> produces <em>internal</em> keys (with sequence numbers and types). This merged stream is then wrapped by the <code>DBIter</code>. <code>DBIter</code> is the "research assistant" we talked about. It reads the stream from the <code>MergingIterator</code> and performs the final filtering:<ul>
<li>It compares the sequence number of each internal key with the iterator's snapshot sequence number. Keys newer than the snapshot are ignored.</li>
<li>It keeps track of the current user key. If it sees multiple versions of the same user key, it only considers the one with the highest sequence number (that's still &lt;= the snapshot sequence).</li>
<li>If the most recent entry for a user key is a deletion marker (<code>kTypeDeletion</code>), it skips that key entirely.</li>
<li>Only when it finds a valid, non-deleted key (<code>kTypeValue</code>) with the highest sequence number for that user key (within the snapshot) does it make that key/value available via <code>it-&gt;key()</code> and <code>it-&gt;value()</code>.</li>
</ul>
</li>
</ol>
<p><b>Sequence Diagram:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant App as Application</div>
<div class="line">    participant DBImpl</div>
<div class="line">    participant MemTable as Active MemTable</div>
<div class="line">    participant ImmMemTable as Immutable MemTable</div>
<div class="line">    participant Version as Current Version</div>
<div class="line">    participant MergingIter as MergingIterator</div>
<div class="line">    participant DBIter</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;DBImpl: NewIterator(options)</div>
<div class="line">    DBImpl-&gt;&gt;MemTable: NewIterator()</div>
<div class="line">    MemTable--&gt;&gt;DBImpl: Return mem_iter</div>
<div class="line">    DBImpl-&gt;&gt;ImmMemTable: NewIterator()</div>
<div class="line">    ImmMemTable--&gt;&gt;DBImpl: Return imm_iter</div>
<div class="line">    DBImpl-&gt;&gt;Version: AddIterators(options)  # Gets SSTable iterators</div>
<div class="line">    Version--&gt;&gt;DBImpl: Return sstable_iters_list</div>
<div class="line">    DBImpl-&gt;&gt;MergingIter: Create(mem_iter, imm_iter, sstable_iters...)</div>
<div class="line">    MergingIter--&gt;&gt;DBImpl: Return merged_iter</div>
<div class="line">    DBImpl-&gt;&gt;DBIter: Create(merged_iter, snapshot_seq)</div>
<div class="line">    DBIter--&gt;&gt;DBImpl: Return db_iter</div>
<div class="line">    DBImpl--&gt;&gt;App: Return db_iter (as Iterator*)</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;DBIter: Seek(&quot;some_key&quot;)</div>
<div class="line">    DBIter-&gt;&gt;MergingIter: Seek to internal key for &quot;some_key&quot;</div>
<div class="line">    Note right of DBIter: DBIter finds the first valid user entry &gt;= &quot;some_key&quot;</div>
<div class="line">    DBIter--&gt;&gt;App: Iterator positioned</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;DBIter: Valid()?</div>
<div class="line">    DBIter--&gt;&gt;App: true</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;DBIter: key()</div>
<div class="line">    DBIter--&gt;&gt;App: Return &quot;user_key_A&quot;</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;DBIter: Next()</div>
<div class="line">    DBIter-&gt;&gt;MergingIter: Next() until user key changes</div>
<div class="line">    Note right of DBIter: DBIter skips older versions or deleted keys</div>
<div class="line">    DBIter-&gt;&gt;MergingIter: Next() to find next user key&#39;s latest version</div>
<div class="line">    DBIter--&gt;&gt;App: Iterator positioned at next valid entry</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2321"></a>
Code Dive: <code>DBImpl::NewIterator</code> and <code>DBIter</code></h2>
<p>Let's look at how this is initiated in the code.</p>
<p><b>1. Creating the Iterator (<code>db_impl.cc</code>)</b></p>
<p>When you call <code>db-&gt;NewIterator(options)</code>, it eventually calls <code>DBImpl::NewIterator</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/db_impl.cc ---</span></div>
<div class="line"> </div>
<div class="line">Iterator* DBImpl::NewIterator(<span class="keyword">const</span> ReadOptions&amp; options) {</div>
<div class="line">  SequenceNumber latest_snapshot;</div>
<div class="line">  uint32_t seed; <span class="comment">// Used for read sampling randomization</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// (1) Create the internal merging iterator</span></div>
<div class="line">  Iterator* internal_iter = NewInternalIterator(options, &amp;latest_snapshot, &amp;seed);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// (2) Determine the sequence number for the snapshot</span></div>
<div class="line">  SequenceNumber snapshot_seq =</div>
<div class="line">      (options.snapshot != <span class="keyword">nullptr</span></div>
<div class="line">           ? <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>SnapshotImpl*<span class="keyword">&gt;</span>(options.snapshot)</div>
<div class="line">                 -&gt;sequence_number()</div>
<div class="line">           : latest_snapshot);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// (3) Wrap the internal iterator with DBIter</span></div>
<div class="line">  <span class="keywordflow">return</span> NewDBIterator(<span class="keyword">this</span>, <span class="comment">// Pass DBImpl pointer for read sampling</span></div>
<div class="line">                       user_comparator(),</div>
<div class="line">                       internal_iter,</div>
<div class="line">                       snapshot_seq,</div>
<div class="line">                       seed);</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><code>NewInternalIterator</code>: This helper function (we'll glance at it next) creates the <code>MergingIterator</code> that combines MemTables and SSTables.</li>
<li><code>snapshot_seq</code>: It figures out which sequence number to use. If the user provided an explicit <code>options.snapshot</code>, it uses that snapshot's sequence number. Otherwise, it uses the latest sequence number in the database when the iterator was created (<code>latest_snapshot</code>).</li>
<li><code>NewDBIterator</code>: This function (defined in <code>db_iter.cc</code>) creates the <code>DBIter</code> object, passing it the underlying <code>internal_iter</code> and the <code>snapshot_seq</code> to use for filtering.</li>
</ol>
<p><b>2. Creating the Internal Iterator (<code>db_impl.cc</code>)</b></p>
<p>The <code>NewInternalIterator</code> gathers all the source iterators:</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/db_impl.cc ---</span></div>
<div class="line"> </div>
<div class="line">Iterator* DBImpl::NewInternalIterator(<span class="keyword">const</span> ReadOptions&amp; options,</div>
<div class="line">                                      SequenceNumber* latest_snapshot,</div>
<div class="line">                                      uint32_t* seed) {</div>
<div class="line">  mutex_.Lock(); <span class="comment">// Need lock to access shared state (mem_, imm_, versions_)</span></div>
<div class="line">  *latest_snapshot = versions_-&gt;LastSequence();</div>
<div class="line">  *seed = ++seed_; <span class="comment">// For random sampling</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Collect together all needed child iterators</span></div>
<div class="line">  std::vector&lt;Iterator*&gt; list;</div>
<div class="line">  <span class="comment">// Add iterator for active MemTable</span></div>
<div class="line">  list.push_back(mem_-&gt;NewIterator());</div>
<div class="line">  mem_-&gt;Ref(); <span class="comment">// Manage lifetime with ref counting</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add iterator for immutable MemTable (if it exists)</span></div>
<div class="line">  <span class="keywordflow">if</span> (imm_ != <span class="keyword">nullptr</span>) {</div>
<div class="line">    list.push_back(imm_-&gt;NewIterator());</div>
<div class="line">    imm_-&gt;Ref();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Add iterators for all SSTable files in the current Version</span></div>
<div class="line">  versions_-&gt;current()-&gt;AddIterators(options, &amp;list);</div>
<div class="line">  versions_-&gt;current()-&gt;Ref();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create the MergingIterator</span></div>
<div class="line">  Iterator* internal_iter =</div>
<div class="line">      NewMergingIterator(&amp;internal_comparator_, &amp;list[0], list.size());</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Register cleanup function to Unref MemTables/Version when iterator is deleted</span></div>
<div class="line">  IterState* cleanup = <span class="keyword">new</span> IterState(&amp;mutex_, mem_, imm_, versions_-&gt;current());</div>
<div class="line">  internal_iter-&gt;RegisterCleanup(CleanupIteratorState, cleanup, <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">  mutex_.Unlock();</div>
<div class="line">  <span class="keywordflow">return</span> internal_iter;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>It locks the database mutex to safely access the current MemTables (<code>mem_</code>, <code>imm_</code>) and the current <code>Version</code>.</li>
<li>It creates iterators for <code>mem_</code> and <code>imm_</code> using their <code>NewIterator()</code> methods (<a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">MemTable</a> uses a SkipList iterator).</li>
<li>It calls <code>versions_-&gt;current()-&gt;AddIterators(...)</code>. This method (in <code>version_set.cc</code>) adds iterators for Level-0 files and the special concatenating iterators for Levels 1+ to the <code>list</code>. See <a class="el" href="../../d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html">Version &amp; VersionSet</a>.</li>
<li><code>NewMergingIterator</code> creates the iterator that merges all sources in <code>list</code>.</li>
<li><code>RegisterCleanup</code> ensures that the MemTables and Version are properly <code>Unref</code>'d when the iterator is eventually deleted.</li>
<li>It returns the <code>MergingIterator</code>.</li>
</ol>
<p><b>3. <code>DBIter</code> Filtering Logic (<code>db_iter.cc</code>)</b></p>
<p>The <code>DBIter</code> class takes the <code>MergingIterator</code> and applies the filtering logic. Let's look at a simplified <code>Next()</code> method:</p>
<div class="fragment"><div class="line"><span class="comment">// --- File: db/db_iter.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> DBIter::Next() {</div>
<div class="line">  assert(valid_);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (direction_ == kReverse) {</div>
<div class="line">    <span class="comment">// ... code to switch from moving backward to forward ...</span></div>
<div class="line">    <span class="comment">// Position iter_ at the first entry &gt;= saved_key_</span></div>
<div class="line">    <span class="comment">// Fall through to FindNextUserEntry...</span></div>
<div class="line">    direction_ = kForward;</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// We are moving forward. Save the current user key so we can skip</span></div>
<div class="line">    <span class="comment">// all other entries for it.</span></div>
<div class="line">    SaveKey(ExtractUserKey(iter_-&gt;key()), &amp;saved_key_);</div>
<div class="line">    <span class="comment">// Advance the internal iterator.</span></div>
<div class="line">    iter_-&gt;Next();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Find the next user key entry that is visible at our sequence number.</span></div>
<div class="line">  FindNextUserEntry(<span class="keyword">true</span>, &amp;saved_key_);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Find the next entry for a different user key, skipping deleted</span></div>
<div class="line"><span class="comment">// or older versions of the key in &#39;skip&#39;.</span></div>
<div class="line"><span class="keywordtype">void</span> DBIter::FindNextUserEntry(<span class="keywordtype">bool</span> skipping, std::string* skip) {</div>
<div class="line">  <span class="comment">// Loop until we hit an acceptable entry</span></div>
<div class="line">  assert(iter_-&gt;Valid() || !valid_); <span class="comment">// iter_ might be invalid if Next() moved past end</span></div>
<div class="line">  assert(direction_ == kForward);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    <span class="keywordflow">if</span> (!iter_-&gt;Valid()) { <span class="comment">// Reached end of internal iterator</span></div>
<div class="line">        valid_ = <span class="keyword">false</span>;</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    ParsedInternalKey ikey;</div>
<div class="line">    <span class="comment">// Parse the internal key (key, sequence, type)</span></div>
<div class="line">    <span class="keywordflow">if</span> (ParseKey(&amp;ikey)) {</div>
<div class="line">      <span class="comment">// Check if the sequence number is visible in our snapshot</span></div>
<div class="line">      <span class="keywordflow">if</span> (ikey.sequence &lt;= sequence_) {</div>
<div class="line">        <span class="comment">// Check the type (Put or Deletion)</span></div>
<div class="line">        <span class="keywordflow">switch</span> (ikey.type) {</div>
<div class="line">          <span class="keywordflow">case</span> kTypeDeletion:</div>
<div class="line">            <span class="comment">// This key is deleted. Save the user key so we skip</span></div>
<div class="line">            <span class="comment">// any older versions of it we might encounter later.</span></div>
<div class="line">            SaveKey(ikey.user_key, skip);</div>
<div class="line">            skipping = <span class="keyword">true</span>; <span class="comment">// Ensure we skip older versions</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          <span class="keywordflow">case</span> kTypeValue:</div>
<div class="line">            <span class="comment">// This is a potential result (a Put operation).</span></div>
<div class="line">            <span class="comment">// Is it for the user key we are trying to skip?</span></div>
<div class="line">            <span class="keywordflow">if</span> (skipping &amp;&amp;</div>
<div class="line">                user_comparator_-&gt;Compare(ikey.user_key, *skip) &lt;= 0) {</div>
<div class="line">              <span class="comment">// Yes, it&#39;s hidden by a newer deletion or is an older version</span></div>
<div class="line">              <span class="comment">// of the key we just yielded. Skip it.</span></div>
<div class="line">            } <span class="keywordflow">else</span> {</div>
<div class="line">              <span class="comment">// Found a valid entry!</span></div>
<div class="line">              valid_ = <span class="keyword">true</span>;</div>
<div class="line">              <span class="comment">// Clear skip key since we found a new valid key</span></div>
<div class="line">              <span class="comment">// saved_key_.clear(); // Done in Next() or Seek()</span></div>
<div class="line">              <span class="keywordflow">return</span>; <span class="comment">// Exit the loop, iterator is now positioned correctly.</span></div>
<div class="line">            }</div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Corrupted key, mark iterator as invalid</span></div>
<div class="line">      valid_ = <span class="keyword">false</span>;</div>
<div class="line">      status_ = Status::Corruption(<span class="stringliteral">&quot;corrupted internal key in DBIter&quot;</span>);</div>
<div class="line">      <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Current internal key was skipped (too new, deleted, hidden), move to next.</span></div>
<div class="line">    iter_-&gt;Next();</div>
<div class="line">  } <span class="keywordflow">while</span> (<span class="keyword">true</span>); <span class="comment">// Loop until we return or reach the end</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>The <code>Next()</code> method first handles switching direction if needed. If moving forward, it saves the current user key (<code>saved_key_</code>) so it can skip other entries for the same key. It then advances the underlying <code>iter_</code> (the <code>MergingIterator</code>).</li>
<li><code>FindNextUserEntry</code> is the core loop. It repeatedly gets the next entry from <code>iter_</code>.</li>
<li><code>ParseKey(&amp;ikey)</code> decodes the internal key, sequence number, and type.</li>
<li>It checks if <code>ikey.sequence &lt;= sequence_</code> (the iterator's snapshot sequence number). If the entry is too new, it's skipped.</li>
<li>If it's a <code>kTypeDeletion</code>, the user key is saved in <code>skip</code>, and the <code>skipping</code> flag is set to true. Any older entries for this <code>user_key</code> will be ignored.</li>
<li>If it's a <code>kTypeValue</code>:<ul>
<li>It checks if <code>skipping</code> is true and if the current <code>ikey.user_key</code> is less than or equal to the key in <code>skip</code>. If so, it means this entry is hidden by a newer deletion or is an older version of a key we just processed, so it's skipped.</li>
<li>Otherwise, this is the newest, visible version of this user key! The loop terminates, <code>valid_</code> is set to true, and the <code>DBIter</code> is now positioned at this entry.</li>
</ul>
</li>
<li>If the current entry from <code>iter_</code> was skipped for any reason, the loop continues by calling <code>iter_-&gt;Next()</code>.</li>
</ul>
<p>This careful dance ensures that <code>DBIter</code> only exposes the correct, latest, non-deleted user key/value pairs according to the snapshot sequence number, while efficiently merging data from all underlying sources.</p>
<h2><a class="anchor" id="autotoc_md2322"></a>
Conclusion</h2>
<p>LevelDB's <code>Iterator</code> provides a powerful and convenient way to scan through key-value pairs. It acts like a smart assistant, giving you a unified, sorted view across data stored in the <code>MemTable</code> and numerous <code>SSTable</code> files.</p>
<p>Under the hood, it uses a <code>MergingIterator</code> to combine multiple sorted sources and the <code>DBIter</code> wrapper to filter out deleted entries and older versions based on sequence numbers and the requested snapshot.</p>
<p>This ability to efficiently scan sorted data is not just useful for application queries, but it's also fundamental to how LevelDB maintains itself. How does LevelDB merge old SSTables and incorporate data flushed from the MemTable to keep the database structure efficient? It uses these very same iterator concepts!</p>
<p>Next up: <a class="el" href="../../df/d5d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_208__compaction.html">Chapter 8: Compaction</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
