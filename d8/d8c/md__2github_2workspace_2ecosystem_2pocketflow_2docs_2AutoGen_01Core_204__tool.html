#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_tool</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d8c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_204__tool.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_tool</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md730"></a>
autotoc_md730</h2>
<p>layout: default title: "Tool" parent: "AutoGen Core" </p>
<h2><a class="anchor" id="autotoc_md731"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md732"></a>
Chapter 4: Tool - Giving Agents Specific Capabilities</h1>
<p>In the previous chapters, we learned about Agents as workers (<a class="el" href="../../d6/d55/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_201__agent.html">Chapter 1</a>), how they can communicate directly or using announcements (<a class="el" href="../../d8/ddc/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_202__messaging__system____topic______subscription__.html">Chapter 2</a>), and the <code>AgentRuntime</code> that manages them (<a class="el" href="../../db/ded/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_203__agentruntime.html">Chapter 3</a>).</p>
<p>Agents can process messages and coordinate, but what if an agent needs to perform a very specific action, like looking up information online, running a piece of code, accessing a database, or even just finding out the current date? They need specialized <em>capabilities</em>.</p>
<p>This is where the concept of a <b>Tool</b> comes in.</p>
<h2><a class="anchor" id="autotoc_md733"></a>
Motivation: Agents Need Skills!</h2>
<p>Imagine our <code>Writer</code> agent from before. It receives facts and writes a draft. Now, let's say we want the <code>Writer</code> (or perhaps a smarter <code>Assistant</code> agent helping it) to always include the current date in the blog post title.</p>
<p>How does the agent get the current date? It doesn't inherently know it. It needs a specific <em>skill</em> or <em>tool</em> for that.</p>
<p>A <code>Tool</code> in AutoGen Core represents exactly this: a specific, well-defined capability that an Agent can use. Think of it like giving an employee (Agent) a specialized piece of equipment (Tool), like a calculator, a web browser, or a calendar lookup program.</p>
<h2><a class="anchor" id="autotoc_md734"></a>
Key Concepts: Understanding Tools</h2>
<p>Let's break down what defines a Tool:</p>
<ol type="1">
<li><b>It's a Specific Capability:</b> A Tool performs one well-defined task. Examples:<ul>
<li><code>search_web(query: str)</code></li>
<li><code>run_python_code(code: str)</code></li>
<li><code>get_stock_price(ticker: str)</code></li>
<li><code>get_current_date()</code></li>
</ul>
</li>
<li><p class="startli"><b>It Has a Schema (The Manual):</b> This is crucial! For an Agent (especially one powered by a Large Language Model - LLM) to know <em>when</em> and <em>how</em> to use a tool, the tool needs a clear description or "manual". This is called the <code>ToolSchema</code>. It typically includes:</p><ul>
<li><b><code>name</code></b>: A unique identifier for the tool (e.g., <code>get_current_date</code>).</li>
<li><b><code>description</code></b>: A clear explanation of what the tool does, which helps the LLM decide if this tool is appropriate for the current task (e.g., "Fetches the current date in YYYY-MM-DD format").</li>
<li><b><code>parameters</code></b>: Defines what inputs the tool needs. This is itself a schema (<code>ParametersSchema</code>) describing the input fields, their types, and which ones are required. For our <code>get_current_date</code> example, it might need no parameters. For <code>get_stock_price</code>, it would need a <code>ticker</code> parameter of type string.</li>
</ul>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md735"></a>
From: tools/_base.py (Simplified Concept)</h1>
<p>from typing import TypedDict, Dict, Any, Sequence, NotRequired</p>
<p>class ParametersSchema(TypedDict): type: str # Usually "object" properties: Dict[str, Any] # Defines input fields and their types required: NotRequired[Sequence[str]] # List of required field names</p>
<p>class ToolSchema(TypedDict): name: str description: NotRequired[str] parameters: NotRequired[ParametersSchema] </p>
<h1><a class="anchor" id="autotoc_md736"></a>
'strict' flag also possible (Chapter 5 related)</h1>
<p>``<code> This schema allows an LLM to understand: "Ah, there's a tool called&lt;/tt&gt;get_current_date` that takes no inputs and gives me the current date. I should use that now!"</code></p>
<p><code></p><ol type="1">
<li><b>It Can Be Executed:</b> Once an agent decides to use a tool (often based on the schema), there needs to be a mechanism to actually <em>run</em> the tool's underlying function and get the result.</li>
</ol>
<p></code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md737"></a>
<code>Use Case Example: Adding a <code>get_current_date</code> Tool</code></h2>
<p><code></code></p>
<p><code>Let's equip an agent with the ability to find the current date.</code></p>
<p><code><b>Goal:</b> Define a tool that gets the current date and show how it could be executed by a specialized agent.</code></p>
<p><code><b>Step 1: Define the Python Function</b></code></p>
<p><code>First, we need the actual Python code that performs the action.</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="comment"># File: get_date_function.py</span></div>
<div class="line"><span class="keyword">import</span> datetime</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>get_current_date() -&gt; str:</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Fetches the current date as a string.&quot;&quot;&quot;</span></div>
<div class="line">    today = datetime.date.today()</div>
<div class="line">    <span class="keywordflow">return</span> today.isoformat() <span class="comment"># Returns date like &quot;2023-10-27&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Test the function</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Function output: {get_current_date()}&quot;</span>)</div>
</div><!-- fragment --><p> This is a standard Python function. It takes no arguments and returns the date as a string.</code></p>
<p><code><b>Step 2: Wrap it as a <code>FunctionTool</code></b></code></p>
<p><code>AutoGen Core provides a convenient way to turn a Python function like this into a <code>Tool</code> object using <code>FunctionTool</code>. It automatically inspects the function's signature (arguments and return type) and docstring to help build the <code>ToolSchema</code>.</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="comment"># File: create_date_tool.py</span></div>
<div class="line"><span class="keyword">from</span> autogen_core.tools <span class="keyword">import</span> FunctionTool</div>
<div class="line"><span class="keyword">from</span> get_date_function <span class="keyword">import</span> get_current_date <span class="comment"># Import our function</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the Tool instance</span></div>
<div class="line"><span class="comment"># We provide the function and a clear description for the LLM</span></div>
<div class="line">date_tool = FunctionTool(</div>
<div class="line">    func=get_current_date,</div>
<div class="line">    description=<span class="stringliteral">&quot;Use this tool to get the current date in YYYY-MM-DD format.&quot;</span></div>
<div class="line">    <span class="comment"># Name defaults to function name &#39;get_current_date&#39;</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Let&#39;s see what FunctionTool generated</span></div>
<div class="line">print(f<span class="stringliteral">&quot;Tool Name: {date_tool.name}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Tool Description: {date_tool.description}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># The schema defines inputs (none in this case)</span></div>
<div class="line"><span class="comment"># print(f&quot;Tool Schema Parameters: {date_tool.schema[&#39;parameters&#39;]}&quot;)</span></div>
<div class="line"><span class="comment"># Output (simplified): {&#39;type&#39;: &#39;object&#39;, &#39;properties&#39;: {}, &#39;required&#39;: []}</span></div>
</div><!-- fragment --><p> <code>FunctionTool</code> wraps our <code>get_current_date</code> function. It uses the function name as the tool name and the description we provided. It also correctly determines from the function signature that there are no input parameters (<code>properties: {}</code>).</code></p>
<p><code><b>Step 3: How an Agent Might Request Tool Use</b></code></p>
<p><code>Now we have a <code>date_tool</code>. How is it used? Typically, an LLM-powered agent (which we'll see more of in <a class="el" href="../../d8/df2/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_205__chatcompletionclient.html">Chapter 5: ChatCompletionClient</a>) analyzes a request and decides a tool is needed. It then generates a request to <em>call</em> that tool, often using a specific message type like <code>FunctionCall</code>.</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="comment"># File: tool_call_request.py</span></div>
<div class="line"><span class="keyword">from</span> autogen_core <span class="keyword">import</span> FunctionCall <span class="comment"># Represents a request to call a tool</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Imagine an LLM agent decided to use the date tool.</span></div>
<div class="line"><span class="comment"># It constructs this message, providing the tool name and arguments (as JSON string).</span></div>
<div class="line">date_call_request = FunctionCall(</div>
<div class="line">    id=<span class="stringliteral">&quot;call_date_001&quot;</span>, <span class="comment"># A unique ID for this specific call attempt</span></div>
<div class="line">    name=<span class="stringliteral">&quot;get_current_date&quot;</span>, <span class="comment"># Matches the Tool&#39;s name</span></div>
<div class="line">    arguments=<span class="stringliteral">&quot;{}&quot;</span> <span class="comment"># An empty JSON object because no arguments are needed</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;FunctionCall message:&quot;</span>, date_call_request)</div>
<div class="line"><span class="comment"># Output: FunctionCall(id=&#39;call_date_001&#39;, name=&#39;get_current_date&#39;, arguments=&#39;{}&#39;)</span></div>
</div><!-- fragment --><p> This <code>FunctionCall</code> message is like a work order: "Please execute the tool named `get_current_date` with these arguments."</code></p>
<p><code><b>Step 4: The <code>ToolAgent</code> Executes the Tool</b></code></p>
<p><code>Who receives this <code>FunctionCall</code> message? Usually, a specialized agent called <code>ToolAgent</code>. You create a <code>ToolAgent</code> and give it the list of tools it knows how to execute. When it receives a <code>FunctionCall</code>, it finds the matching tool and runs it.</code></p>
<p><code></p><div class="fragment"><div class="line"><span class="comment"># File: tool_agent_example.py</span></div>
<div class="line"><span class="keyword">import</span> asyncio</div>
<div class="line"><span class="keyword">from</span> autogen_core.tool_agent <span class="keyword">import</span> ToolAgent</div>
<div class="line"><span class="keyword">from</span> autogen_core.models <span class="keyword">import</span> FunctionExecutionResult</div>
<div class="line"><span class="keyword">from</span> create_date_tool <span class="keyword">import</span> date_tool <span class="comment"># Import the tool we created</span></div>
<div class="line"><span class="keyword">from</span> tool_call_request <span class="keyword">import</span> date_call_request <span class="comment"># Import the request message</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create an agent specifically designed to execute tools</span></div>
<div class="line">tool_executor = ToolAgent(</div>
<div class="line">    description=<span class="stringliteral">&quot;I can execute tools like getting the date.&quot;</span>,</div>
<div class="line">    tools=[date_tool] <span class="comment"># Give it the list of tools it manages</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Simulation of Runtime delivering the message ---</span></div>
<div class="line"><span class="comment"># In a real app, the AgentRuntime (Chapter 3) would route the</span></div>
<div class="line"><span class="comment"># date_call_request message to this tool_executor agent.</span></div>
<div class="line"><span class="comment"># We simulate the call to its message handler here:</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">async def </span>simulate_execution():</div>
<div class="line">    <span class="comment"># Fake context (normally provided by runtime)</span></div>
<div class="line">    <span class="keyword">class </span>MockContext: cancellation_token = <span class="keywordtype">None</span></div>
<div class="line">    ctx = MockContext()</div>
<div class="line"> </div>
<div class="line">    print(f<span class="stringliteral">&quot;ToolAgent received request: {date_call_request.name}&quot;</span>)</div>
<div class="line">    result: FunctionExecutionResult = await tool_executor.handle_function_call(</div>
<div class="line">        message=date_call_request,</div>
<div class="line">        ctx=ctx</div>
<div class="line">    )</div>
<div class="line">    print(f<span class="stringliteral">&quot;ToolAgent produced result: {result}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">asyncio.run(simulate_execution())</div>
</div><!-- fragment --><p></code></p>
<p><code><b>Expected Output:</b></code></p>
<p><code></p><div class="fragment"><div class="line">ToolAgent received request: get_current_date</div>
<div class="line">ToolAgent produced result: FunctionExecutionResult(content=&#39;2023-10-27&#39;, call_id=&#39;call_date_001&#39;, is_error=False, name=&#39;get_current_date&#39;) # Date will be current date</div>
</div><!-- fragment --><p> The <code>ToolAgent</code> received the <code>FunctionCall</code>, found the <code>date_tool</code> in its list, executed the underlying <code>get_current_date</code> function, and packaged the result (the date string) into a <code>FunctionExecutionResult</code> message. This result message can then be sent back to the agent that originally requested the tool use.</code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md738"></a>
<code>Under the Hood: How Tool Execution Works</code></h2>
<p><code></code></p>
<p><code>Let's visualize the typical flow when an LLM agent decides to use a tool managed by a <code>ToolAgent</code>.</code></p>
<p><code><b>Conceptual Flow:</b></code></p>
<p><code></p><div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant LLMA as LLM Agent (Decides)</div>
<div class="line">    participant Caller as Caller Agent (Orchestrates)</div>
<div class="line">    participant ToolA as ToolAgent (Executes)</div>
<div class="line">    participant ToolFunc as Tool Function (e.g., get_current_date)</div>
<div class="line"> </div>
<div class="line">    Note over LLMA: Analyzes conversation, decides tool needed.</div>
<div class="line">    LLMA-&gt;&gt;Caller: Sends AssistantMessage containing FunctionCall(name=&#39;get_current_date&#39;, args=&#39;{}&#39;)</div>
<div class="line">    Note over Caller: Receives LLM response, sees FunctionCall.</div>
<div class="line">    Caller-&gt;&gt;+ToolA: Uses runtime.send_message(message=FunctionCall, recipient=ToolAgent_ID)</div>
<div class="line">    Note over ToolA: Receives FunctionCall via on_message.</div>
<div class="line">    ToolA-&gt;&gt;ToolA: Looks up &#39;get_current_date&#39; in its internal list of Tools.</div>
<div class="line">    ToolA-&gt;&gt;+ToolFunc: Calls tool.run_json(args={}) -&gt; triggers get_current_date()</div>
<div class="line">    ToolFunc--&gt;&gt;-ToolA: Returns the result (e.g., &quot;2023-10-27&quot;)</div>
<div class="line">    ToolA-&gt;&gt;ToolA: Creates FunctionExecutionResult message with the content.</div>
<div class="line">    ToolA--&gt;&gt;-Caller: Returns FunctionExecutionResult via runtime messaging.</div>
<div class="line">    Note over Caller: Receives the tool result.</div>
<div class="line">    Caller-&gt;&gt;LLMA: Sends FunctionExecutionResultMessage to LLM for next step.</div>
<div class="line">    Note over LLMA: Now knows the current date.</div>
</div><!-- fragment --><p></code></p>
<p><code></p><ol type="1">
<li><b>Decision:</b> An LLM-powered agent decides a tool is needed based on the conversation and the available tools' descriptions. It generates a <code>FunctionCall</code>.</li>
<li><b>Request:</b> A "Caller" agent (often the same LLM agent or a managing agent) sends this <code>FunctionCall</code> message to the dedicated <code>ToolAgent</code> using the <code>AgentRuntime</code>.</li>
<li><b>Lookup:</b> The <code>ToolAgent</code> receives the message, extracts the tool <code>name</code> (<code>get_current_date</code>), and finds the corresponding <code>Tool</code> object (our <code>date_tool</code>) in the list it was configured with.</li>
<li><b>Execution:</b> The <code>ToolAgent</code> calls the <code>run_json</code> method on the <code>Tool</code> object, passing the arguments from the <code>FunctionCall</code>. For a <code>FunctionTool</code>, <code>run_json</code> validates the arguments against the generated schema and then executes the original Python function (<code>get_current_date</code>).</li>
<li><b>Result:</b> The Python function returns its result (the date string).</li>
<li><b>Response:</b> The <code>ToolAgent</code> wraps this result string in a <code>FunctionExecutionResult</code> message, including the original <code>call_id</code>, and sends it back to the Caller agent.</li>
<li><b>Continuation:</b> The Caller agent typically sends this result back to the LLM agent, allowing the conversation or task to continue with the new information.</li>
</ol>
<p></code></p>
<p><code><b>Code Glimpse:</b></code></p>
<p><code></p><ul>
<li><b><code>Tool</code> Protocol (<code>tools/_base.py</code>):</b> Defines the basic contract any tool must fulfill. Key methods are <code>schema</code> (property returning the <code>ToolSchema</code>) and <code>run_json</code> (method to execute the tool with JSON-like arguments).</li>
<li><b><code>BaseTool</code> (<code>tools/_base.py</code>):</b> An abstract class that helps implement the <code>Tool</code> protocol, especially using Pydantic models for defining arguments (<code>args_type</code>) and return values (<code>return_type</code>). It automatically generates the <code>parameters</code> part of the schema from the <code>args_type</code> model.</li>
<li><b><code>FunctionTool</code> (<code>tools/_function_tool.py</code>):</b> Inherits from <code>BaseTool</code>. Its magic lies in automatically creating the <code>args_type</code> Pydantic model by inspecting the wrapped Python function's signature (<code>args_base_model_from_signature</code>). Its <code>run</code> method handles calling the original sync or async Python function. ```python </li>
</ul>
<p></code></p>
<h1><a class="anchor" id="autotoc_md739"></a>
<code>Inside FunctionTool (Simplified Concept)</code></h1>
<p><code> class FunctionTool(BaseTool[BaseModel, BaseModel]): def <b>init</b>(self, func, description, ...): self._func = func self._signature = get_typed_signature(func) </code></p>
<h1><a class="anchor" id="autotoc_md740"></a>
<code>Automatically create Pydantic model for arguments</code></h1>
<p><code> args_model = args_base_model_from_signature(...) </code></p>
<h1><a class="anchor" id="autotoc_md741"></a>
<code>Get return type from signature</code></h1>
<p><code> return_type = self._signature.return_annotation super().__init__(args_model, return_type, ...)</code></p>
<p><code> async def run(self, args: BaseModel, ...): </code></p>
<h1><a class="anchor" id="autotoc_md742"></a>
<code>Extract arguments from the 'args' model</code></h1>
<p><code> kwargs = args.model_dump() </code></p>
<h1><a class="anchor" id="autotoc_md743"></a>
<code>Call the original Python function (sync or async)</code></h1>
<p><code> result = await self._call_underlying_func(&lt;strong&gt;kwargs) return result # Must match the expected return_type ``<code></p><ul>
<li>**</li>
</ul>
<p></code>ToolAgent<code>(</code>tool_agent/_tool_agent.py`): A specialized <code>RoutedAgent</code>. It registers a handler specifically for <code>FunctionCall</code> messages. ```python </code></p>
<h1><a class="anchor" id="autotoc_md744"></a>
<code>Inside ToolAgent (Simplified Concept)</code></h1>
<p><code> class ToolAgent(RoutedAgent): def <b>init</b>(self, ..., tools: List[Tool]): super().__init__(...) self._tools = {tool.name: tool for tool in tools} # Store tools by name</code></p>
<p><code> @message_handler # Registers this for FunctionCall messages async def handle_function_call(self, message: FunctionCall, ctx: MessageContext): </code></p>
<h1><a class="anchor" id="autotoc_md745"></a>
<code>Find the tool by name</code></h1>
<p><code> tool = self._tools.get(message.name) if tool is None: </code></p>
<h1><a class="anchor" id="autotoc_md746"></a>
<code>Handle error: Tool not found</code></h1>
<p><code> raise ToolNotFoundException(...) try: </code></p>
<h1><a class="anchor" id="autotoc_md747"></a>
<code>Parse arguments string into a dictionary</code></h1>
<p><code> arguments = json.loads(message.arguments) </code></p>
<h1><a class="anchor" id="autotoc_md748"></a>
<code>Execute the tool's run_json method</code></h1>
<p><code> result_obj = await tool.run_json(args=arguments, ...) </code></p>
<h1><a class="anchor" id="autotoc_md749"></a>
<code>Convert result object back to string if needed</code></h1>
<p><code> result_str = tool.return_value_as_string(result_obj) </code></p>
<h1><a class="anchor" id="autotoc_md750"></a>
<code>Create the success result message</code></h1>
<p><code> return FunctionExecutionResult(content=result_str, ...) except Exception as e: </code></p>
<h1><a class="anchor" id="autotoc_md751"></a>
<code>Handle execution errors</code></h1>
<p><code> return FunctionExecutionResult(content=f"Error: {e}", is_error=True, ...) ``` Its core logic is: find tool -&gt; parse args -&gt; run tool -&gt; return result/error.</code></p>
<p><code></code></p>
<h2><a class="anchor" id="autotoc_md752"></a>
<code>Next Steps</code></h2>
<p><code></code></p>
<p><code>You've learned how <b>Tools</b> provide specific capabilities to Agents, defined by a <b>Schema</b> that LLMs can understand. We saw how <code>FunctionTool</code> makes it easy to wrap existing Python functions and how <code>ToolAgent</code> acts as the executor for these tools.</code></p>
<p><code>This ability for agents to use tools is fundamental to building powerful and versatile AI systems that can interact with the real world or perform complex calculations.</code></p>
<p><code>Now that agents can use tools, we need to understand more about the agents that <em>decide</em> which tools to use, which often involves interacting with Large Language Models:</code></p>
<p><code></p><ul>
<li><a class="el" href="../../d8/df2/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_205__chatcompletionclient.html">Chapter 5: ChatCompletionClient</a>: How agents interact with LLMs like GPT to generate responses or decide on actions (like calling a tool).</li>
<li><a class="el" href="../../dd/dc3/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2AutoGen_01Core_206__chatcompletioncontext.html">Chapter 6: ChatCompletionContext</a>: How the history of the conversation, including tool calls and results, is managed when talking to an LLM.</li>
</ul>
<p></code></p>
<p><code></p><hr  />
<p></code></p>
<p><code>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </code></p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
