#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_channels</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_channels</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2142"></a>
autotoc_md2142</h2>
<p>layout: default title: "Channels" parent: "LangGraph" </p>
<h2><a class="anchor" id="autotoc_md2143"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md2144"></a>
Chapter 3: Channels - The Communication System</h1>
<p>In <a class="el" href="../../df/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_201__graph______stategraph.html">Chapter 1: Graph / StateGraph</a>, we learned about the <code>StateGraph</code> as the blueprint for our application, holding the shared "whiteboard" or state. In <a class="el" href="../../dc/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_202__nodes______pregelnode____.html">Chapter 2: Nodes (<code>PregelNode</code>)</a>, we met the "workers" or Nodes that perform tasks and read/write to this whiteboard.</p>
<p>But how does this "whiteboard" <em>actually</em> work? How does the information written by one node reliably get seen by the next? What happens if multiple nodes try to write to the <em>same part</em> of the whiteboard at roughly the same time?</p>
<p>This is where <b>Channels</b> come in. They are the fundamental mechanism for communication and state management within a <code>StateGraph</code>.</p>
<h2><a class="anchor" id="autotoc_md2145"></a>
What Problem Do Channels Solve?</h2>
<p>Imagine our simple graph from Chapter 1:</p>
<div class="fragment"><div class="line"><span class="comment"># State: {&#39;value&#39;: int}</span></div>
<div class="line"><span class="comment"># Node 1: adder (reads &#39;value&#39;, returns {&#39;value&#39;: value + 1})</span></div>
<div class="line"><span class="comment"># Node 2: multiplier (reads &#39;value&#39;, returns {&#39;value&#39;: value * 2})</span></div>
<div class="line"><span class="comment"># Flow: START -&gt; adder -&gt; multiplier -&gt; END</span></div>
</div><!-- fragment --><p>When <code>adder</code> runs with &lsquo;{'value&rsquo;: 5}<code>, it returns</code>{'value': 6}<code>. How does this update the central state so that</code>multiplier<code>receives</code>{'value': 6}<code>and not the original</code>{'value': 5}`?</p>
<p>Furthermore, what if we had a more complex graph where two different nodes, say <code>node_A</code> and <code>node_B</code>, both finished their work and <em>both</em> wanted to update the <code>value</code> key in the same step? Should the final <code>value</code> be the one from <code>node_A</code>, the one from <code>node_B</code>, their sum, or something else?</p>
<p><b>Channels</b> solve these problems by defining:</p>
<ol type="1">
<li><b>Storage:</b> How the value for a specific key in the state is stored.</li>
<li><b>Update Logic:</b> How incoming updates for that key are combined or processed.</li>
</ol>
<h2><a class="anchor" id="autotoc_md2146"></a>
Channels: Mailboxes for Your State</h2>
<p>Think of the shared state (our "whiteboard") not as one big surface, but as a collection of <b>mailboxes</b>.</p>
<ul>
<li><b>Each key in your state dictionary (<code>MyState</code>) gets its own dedicated mailbox.</b> In our example, there's a mailbox labeled <code>"value"</code>.</li>
<li>When a Node finishes and returns a dictionary (like &lsquo;{'value&rsquo;: 6}<code>), the [Pregel Execution Engine](<a class="el" href="../../d9/d08/05__pregel__execution__engine_8md.html">05_pregel_execution_engine.md</a>) acts like a mail carrier. It takes the value</code>6<code>and puts it into the mailbox labeled</code>"value"<code>.</code></li>
<li><code> When another Node needs to read the state, the engine goes to the relevant mailboxes (like</code>"value"`) and gets the current contents.</li>
</ul>
<p>This mailbox concept ensures that updates intended for <code>"value"</code> only affect <code>"value"</code>, and updates for another key (say, <code>"messages"</code>) would go into <em>its</em> own separate mailbox.</p>
<p><b>Crucially, each mailbox (Channel) has specific rules about how incoming mail (updates) is handled.</b> Does the new mail replace the old one? Is it added to a list? Is it mathematically combined with the previous value? These rules are defined by the <b>Channel Type</b>.</p>
<h2><a class="anchor" id="autotoc_md2147"></a>
How Channels Work: The Update Cycle</h2>
<p>Here's a step-by-step view of how channels manage state during graph execution:</p>
<ol type="1">
<li><b>Node Returns Update:</b> A node (e.g., <code>adder</code>) finishes and returns a dictionary (e.g., &lsquo;{'value&rsquo;: 6}<code>).</code></li>
<li><code> **Engine Routes Update:** The [Pregel Execution Engine](<a class="el" href="../../d9/d08/05__pregel__execution__engine_8md.html">05_pregel_execution_engine.md</a>) sees the key</code>"value"<code>and routes the update</code>6<code>to the Channel associated with</code>"value"<code>.</code></li>
<li><code> **Channel Receives Update(s):** The</code>"value"<code>Channel receives</code>6<code>. If other nodes also returned updates for</code>"value"<code>in the same step, the Channel would receive all of them in a sequence (e.g.,</code>[6, maybe_another_update]<code>).</code></li>
<li><code> **Channel Applies Update Logic:** The Channel uses its specific rule (its type) to process the incoming update(s). For example, a</code>LastValue<code>channel would just keep the *last* update it received in the sequence. A</code>BinaryOperatorAggregate<code>channel might *sum* all the updates with its current value.</code></li>
<li><code> **State is Updated:** The Channel now holds the new, processed value.</code></li>
<li><code> **Node Reads State:** When the next node (e.g.,</code>multiplier<code>) needs the state, the Engine queries the relevant Channels (e.g., the</code>"value"<code>Channel).</code></li>
<li><code> **Channel Provides Value:** The Channel provides its current stored value (e.g.,</code>6`) to the Engine, which passes it to the node.</li>
</ol>
<p>This ensures that state updates are handled consistently according to predefined rules for each piece of state.</p>
<h2><a class="anchor" id="autotoc_md2148"></a>
Common Channel Types: Defining the Rules</h2>
<p>LangGraph provides several types of Channels, each with different update logic. You usually define which channel type to use for a state key when you define your state <code>TypedDict</code>, often using <code>typing.Annotated</code>.</p>
<p>Here are the most common ones:</p>
<ol type="1">
<li><p class="startli"><b><code>LastValue[T]</code></b> (The Default Overwriter)</p><ul>
<li><b>Rule:</b> Keeps only the <b>last</b> value it received. If multiple updates arrive in the same step, the final value is simply the last one in the sequence processed by the engine.</li>
<li><b>Analogy:</b> Like a standard variable assignment (<code>my_variable = new_value</code>). The old value is discarded.</li>
<li><b>When to Use:</b> This is the <b>default</b> for keys in your <code>TypedDict</code> state unless you specify otherwise with <code>Annotated</code>. It's perfect for state values that should be replaced entirely, like the current step's result or a user's latest query.</li>
<li><b>Code:</b> <code>langgraph.channels.LastValue</code> (from <code>channels/last_value.py</code>)</li>
</ul>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md2149"></a>
channels/last_value.py (Simplified)</h1>
<p>class LastValue(Generic[Value], BaseChannel[Value, Value, Value]): </p>
<h1><a class="anchor" id="autotoc_md2150"></a>
... (initializer, etc.)</h1>
<p>value: Any = MISSING # Stores the single, last value</p>
<p>def update(self, values: Sequence[Value]) -&gt; bool: if len(values) == 0: # No updates this step return False </p>
<h1><a class="anchor" id="autotoc_md2151"></a>
If multiple updates in one step, only the last one matters!</h1>
<h1><a class="anchor" id="autotoc_md2152"></a>
Example: if values = [update1, update2], self.value becomes update2</h1>
<p>self.value = values[-1] return True</p>
<p>def get(self) -&gt; Value: if self.value is MISSING: raise EmptyChannelError() return self.value # Return the currently stored last value <code></p><ul>
<li>**How to Use (Implicitly):** </li>
</ul>
<p></code>python from typing import TypedDict</p>
<p>class MyState(TypedDict): </p>
<h1><a class="anchor" id="autotoc_md2153"></a>
Because we didn't use Annotated, LangGraph defaults to LastValue[int]</h1>
<p>value: int user_query: str # Also defaults to LastValue[str] ```</p>
<ol type="1">
<li><p class="startli"><b><code>BinaryOperatorAggregate[T]</code></b> (The Combiner)</p><ul>
<li><b>Rule:</b> Takes an initial "identity" value (like <code>0</code> for addition, <code>1</code> for multiplication) and a <b>binary operator</b> function (e.g., <code>+</code>, <code>*</code>, <code>operator.add</code>). When it receives updates, it applies the operator between its current value and each new update, accumulating the result.</li>
<li><b>Analogy:</b> Like a running total (<code>total += new_number</code>).</li>
<li><b>When to Use:</b> Useful for accumulating scores, counts, or combining numerical results.</li>
<li><b>Code:</b> <code>langgraph.channels.BinaryOperatorAggregate</code> (from <code>channels/binop.py</code>)</li>
</ul>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md2154"></a>
channels/binop.py (Simplified)</h1>
<p>import operator from typing import Callable</p>
<p>class BinaryOperatorAggregate(Generic[Value], BaseChannel[Value, Value, Value]): </p>
<h1><a class="anchor" id="autotoc_md2155"></a>
... (initializer stores the operator and identity value)</h1>
<p>value: Any = MISSING operator: Callable[[Value, Value], Value]</p>
<p>def update(self, values: Sequence[Value]) -&gt; bool: if not values: return False </p>
<h1><a class="anchor" id="autotoc_md2156"></a>
Start with the first value if the channel was empty</h1>
<p>if self.value is MISSING: self.value = values[0] values = values[1:] </p>
<h1><a class="anchor" id="autotoc_md2157"></a>
Apply the operator for all subsequent values</h1>
<p>for val in values: self.value = self.operator(self.value, val) return True</p>
<p>def get(self) -&gt; Value: </p>
<h1><a class="anchor" id="autotoc_md2158"></a>
... (return self.value, handling MISSING)</h1>
<p><code></p><ul>
<li>**How to Use (Explicitly with `Annotated`):** </li>
</ul>
<p></code>python import operator from typing import TypedDict, Annotated from langgraph.channels import BinaryOperatorAggregate</p>
<p>class AgentState(TypedDict): </p>
<h1><a class="anchor" id="autotoc_md2159"></a>
Use Annotated to specify the channel type and operator</h1>
<p>total_score: Annotated[int, BinaryOperatorAggregate(int, operator.add)] </p>
<h1><a class="anchor" id="autotoc_md2160"></a>
^^^ state key 'total_score' will use BinaryOperatorAggregate with addition</h1>
<p>```</p>
<ol type="1">
<li><p class="startli"><b><code>Topic[T]</code></b> (The Collector)</p><ul>
<li><b>Rule:</b> Collects all updates it receives into a <b>list</b>. By default (<code>accumulate=False</code>), it clears the list after each step, so <code><a class="el" href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get()</a></code> returns only the updates from the <em>immediately preceding</em> step. If <code>accumulate=True</code>, it keeps adding to the list across multiple steps.</li>
<li><b>Analogy:</b> Like appending to a log file or a list (<code>my_list.append(new_item)</code>).</li>
<li><b>When to Use:</b> Great for gathering messages in a conversation (<code>MessageGraph</code> uses this internally!), collecting events, or tracking a sequence of results.</li>
<li><b>Code:</b> <code>langgraph.channels.Topic</code> (from <code>channels/topic.py</code>)</li>
</ul>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md2161"></a>
channels/topic.py (Simplified)</h1>
<p>from typing import Sequence, List, Union</p>
<p>class Topic(Generic[Value], BaseChannel[Sequence[Value], Union[Value, list[Value]], list[Value]]): </p>
<h1><a class="anchor" id="autotoc_md2162"></a>
... (initializer sets accumulate flag)</h1>
<p>values: list[Value] accumulate: bool</p>
<p>def update(self, updates: Sequence[Union[Value, list[Value]]]) -&gt; bool: old_len = len(self.values) </p>
<h1><a class="anchor" id="autotoc_md2163"></a>
Clear list if not accumulating</h1>
<p>if not self.accumulate: self.values = [] </p>
<h1><a class="anchor" id="autotoc_md2164"></a>
Flatten and extend the list with new updates</h1>
<p>new_values = list(flatten(updates)) # flatten handles list-of-lists self.values.extend(new_values) return len(self.values) != old_len # Return True if list changed</p>
<p>def get(self) -&gt; Sequence[Value]: </p>
<h1><a class="anchor" id="autotoc_md2165"></a>
... (return list(self.values), handling empty)</h1>
<p><code></p><ul>
<li>**How to Use (Explicitly with `Annotated`):** </li>
</ul>
<p></code>python from typing import TypedDict, Annotated, List from langgraph.channels import Topic</p>
<p>class ChatState(TypedDict): </p>
<h1><a class="anchor" id="autotoc_md2166"></a>
Use Annotated to specify the Topic channel</h1>
<h1><a class="anchor" id="autotoc_md2167"></a>
The final type hint for the state is List[str]</h1>
<p>chat_history: Annotated[List[str], Topic(str, accumulate=True)] </p>
<h1><a class="anchor" id="autotoc_md2168"></a>
^^^ state key 'chat_history' will use Topic to accumulate strings</h1>
<p>```</p>
<p>There are other specialized channels like <code>EphemeralValue</code> (clears after reading) and <code>Context</code> (allows passing values down without modifying state), but <code>LastValue</code>, <code>BinaryOperatorAggregate</code>, and <code>Topic</code> are the most fundamental.</p>
<h2><a class="anchor" id="autotoc_md2169"></a>
Channels in Action: Our Simple Graph Revisited</h2>
<p>Let's trace our <code>adder</code> -&gt; <code>multiplier</code> graph again, focusing on the implicit <code>LastValue</code> channel for the <code>"value"</code> key:</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict</div>
<div class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph, END, START</div>
<div class="line"> </div>
<div class="line"><span class="comment"># State uses implicit LastValue[int] for &#39;value&#39;</span></div>
<div class="line"><span class="keyword">class </span>MyState(TypedDict):</div>
<div class="line">    value: int</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Nodes (same as before)</span></div>
<div class="line"><span class="keyword">def </span>add_one(state: MyState) -&gt; dict:</div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;value&quot;</span>: state[<span class="stringliteral">&#39;value&#39;</span>] + 1}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>multiply_by_two(state: MyState) -&gt; dict:</div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;value&quot;</span>: state[<span class="stringliteral">&#39;value&#39;</span>] * 2}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Graph setup (same as before)</span></div>
<div class="line">workflow = StateGraph(MyState)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;adder&quot;</span>, add_one)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;multiplier&quot;</span>, multiply_by_two)</div>
<div class="line">workflow.set_entry_point(<span class="stringliteral">&quot;adder&quot;</span>)</div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;adder&quot;</span>, <span class="stringliteral">&quot;multiplier&quot;</span>)</div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;multiplier&quot;</span>, END)</div>
<div class="line">app = workflow.compile()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Execution with initial state {&quot;value&quot;: 5}</span></div>
<div class="line">initial_state = {<span class="stringliteral">&quot;value&quot;</span>: 5}</div>
<div class="line">final_state = app.invoke(initial_state)</div>
</div><!-- fragment --><p>Here's the flow with the Channel involved:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant App as CompiledGraph</div>
<div class="line">    participant Engine as Pregel Engine</div>
<div class="line">    participant ValueChannel as &quot;value&quot; (LastValue)</div>
<div class="line">    participant AdderNode as adder</div>
<div class="line">    participant MultiplierNode as multiplier</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;App: invoke({&quot;value&quot;: 5})</div>
<div class="line">    App-&gt;&gt;Engine: Start execution</div>
<div class="line">    Engine-&gt;&gt;ValueChannel: Initialize/Set state from input (value = 5)</div>
<div class="line">    App-&gt;&gt;Engine: Entry point is &quot;adder&quot;</div>
<div class="line">    Engine-&gt;&gt;ValueChannel: Read current value (5)</div>
<div class="line">    ValueChannel--&gt;&gt;Engine: Returns 5</div>
<div class="line">    Engine-&gt;&gt;AdderNode: Execute(state={&#39;value&#39;: 5})</div>
<div class="line">    AdderNode--&gt;&gt;Engine: Return {&quot;value&quot;: 6}</div>
<div class="line">    Engine-&gt;&gt;ValueChannel: Update with [6]</div>
<div class="line">    Note over ValueChannel: LastValue rule: value becomes 6</div>
<div class="line">    ValueChannel--&gt;&gt;Engine: Acknowledge update</div>
<div class="line">    Engine-&gt;&gt;Engine: Follow edge &quot;adder&quot; -&gt; &quot;multiplier&quot;</div>
<div class="line">    Engine-&gt;&gt;ValueChannel: Read current value (6)</div>
<div class="line">    ValueChannel--&gt;&gt;Engine: Returns 6</div>
<div class="line">    Engine-&gt;&gt;MultiplierNode: Execute(state={&#39;value&#39;: 6})</div>
<div class="line">    MultiplierNode--&gt;&gt;Engine: Return {&quot;value&quot;: 12}</div>
<div class="line">    Engine-&gt;&gt;ValueChannel: Update with [12]</div>
<div class="line">    Note over ValueChannel: LastValue rule: value becomes 12</div>
<div class="line">    ValueChannel--&gt;&gt;Engine: Acknowledge update</div>
<div class="line">    Engine-&gt;&gt;Engine: Follow edge &quot;multiplier&quot; -&gt; END</div>
<div class="line">    Engine-&gt;&gt;ValueChannel: Read final value (12)</div>
<div class="line">    ValueChannel--&gt;&gt;Engine: Returns 12</div>
<div class="line">    Engine-&gt;&gt;App: Execution finished, final state {&#39;value&#39;: 12}</div>
<div class="line">    App-&gt;&gt;User: Return final state {&#39;value&#39;: 12}</div>
</div><!-- fragment --><p>The <code>LastValue</code> channel ensures that the output of <code>adder</code> correctly overwrites the initial state before <code>multiplier</code> reads it.</p>
<h2><a class="anchor" id="autotoc_md2170"></a>
Example: Using <code>BinaryOperatorAggregate</code> Explicitly</h2>
<p>Let's modify the state to <em>sum</em> values instead of overwriting them.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> operator</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict, Annotated</div>
<div class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph, END, START</div>
<div class="line"><span class="comment"># Import the channel type</span></div>
<div class="line"><span class="keyword">from</span> langgraph.channels <span class="keyword">import</span> BinaryOperatorAggregate</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define state with an explicitly configured channel</span></div>
<div class="line"><span class="keyword">class </span>SummingState(TypedDict):</div>
<div class="line">    <span class="comment"># Use Annotated to specify the channel and its operator (addition)</span></div>
<div class="line">    value: Annotated[int, BinaryOperatorAggregate(int, operator.add)]</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node 1: Returns 5 to be ADDED to the current value</span></div>
<div class="line"><span class="keyword">def </span>add_five(state: SummingState) -&gt; dict:</div>
<div class="line">    print(f<span class="stringliteral">&quot;--- Running Adder Node 1 (current value: {state.get(&#39;value&#39;, 0)}) ---&quot;</span>)</div>
<div class="line">    <span class="comment"># Note: We return the *increment*, not the new total</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;value&quot;</span>: 5}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node 2: Returns 10 to be ADDED to the current value</span></div>
<div class="line"><span class="keyword">def </span>add_ten(state: SummingState) -&gt; dict:</div>
<div class="line">    print(f<span class="stringliteral">&quot;--- Running Adder Node 2 (current value: {state[&#39;value&#39;]}) ---&quot;</span>)</div>
<div class="line">     <span class="comment"># Note: We return the *increment*, not the new total</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;value&quot;</span>: 10}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create graph</span></div>
<div class="line">workflow = StateGraph(SummingState)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;adder1&quot;</span>, add_five)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;adder2&quot;</span>, add_ten)</div>
<div class="line">workflow.set_entry_point(<span class="stringliteral">&quot;adder1&quot;</span>)</div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;adder1&quot;</span>, <span class="stringliteral">&quot;adder2&quot;</span>)</div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;adder2&quot;</span>, END)</div>
<div class="line"> </div>
<div class="line">app = workflow.compile()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Run with initial state value = 0 (BinaryOperatorAggregate defaults int to 0)</span></div>
<div class="line">print(<span class="stringliteral">&quot;Invoking graph...&quot;</span>)</div>
<div class="line"><span class="comment"># You could also provide an initial value: app.invoke({&quot;value&quot;: 100})</span></div>
<div class="line">final_state = app.invoke({})</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;\n--- Final State ---&quot;</span>)</div>
<div class="line">print(final_state)</div>
</div><!-- fragment --><p><b>Expected Output:</b></p>
<div class="fragment"><div class="line">Invoking graph...</div>
<div class="line">--- Running Adder Node 1 (current value: 0) ---</div>
<div class="line">--- Running Adder Node 2 (current value: 5) ---</div>
<div class="line"> </div>
<div class="line">--- Final State ---</div>
<div class="line">{&#39;value&#39;: 15}</div>
</div><!-- fragment --><p>Because we used <code>Annotated[int, BinaryOperatorAggregate(int, operator.add)]</code>, the <code>"value"</code> channel now <em>adds</em> incoming updates (<code>5</code> then <code>10</code>) to its current state, resulting in a final sum of <code>15</code>.</p>
<h2><a class="anchor" id="autotoc_md2171"></a>
How <code>StateGraph</code> Finds the Right Channel</h2>
<p>You might wonder how <code>StateGraph</code> knows whether to use <code>LastValue</code> or something else. When you initialize <code>StateGraph(MyState)</code>, it inspects your state schema (<code>MyState</code>).</p>
<ul>
<li>It uses Python's <code>get_type_hints(MyState, include_extras=True)</code> to look at each field (like <code>value</code>).</li>
<li>If a field has <code>Annotated[SomeType, SomeChannelConfig]</code>, it uses <code>SomeChannelConfig</code> (e.g., <code>BinaryOperatorAggregate(...)</code>, <code>Topic(...)</code>) to create the channel for that key.</li>
<li>If a field is just <code>SomeType</code> (like <code>value: int</code>), it defaults to creating a <code>LastValue[SomeType]</code> channel for that key.</li>
</ul>
<p>This logic is primarily handled within the <code>StateGraph._add_schema</code> method, which calls internal helpers like <code>_get_channels</code>.</p>
<div class="fragment"><div class="line"><span class="comment"># graph/state.py (Simplified view of channel detection)</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>_get_channels(schema: Type[dict]) -&gt; tuple[...]:</div>
<div class="line">    <span class="comment"># ... gets type hints including Annotated metadata ...</span></div>
<div class="line">    type_hints = get_type_hints(schema, include_extras=<span class="keyword">True</span>)</div>
<div class="line">    all_keys = {}</div>
<div class="line">    <span class="keywordflow">for</span> name, typ <span class="keywordflow">in</span> type_hints.items():</div>
<div class="line">         <span class="comment"># Checks if the annotation specifies a channel or binop</span></div>
<div class="line">        <span class="keywordflow">if</span> channel := _is_field_channel(typ) <span class="keywordflow">or</span> _is_field_binop(typ):</div>
<div class="line">             channel.key = name</div>
<div class="line">             all_keys[name] = channel</div>
<div class="line">        <span class="keywordflow">else</span>:</div>
<div class="line">             <span class="comment"># Default case: Use LastValue</span></div>
<div class="line">             fallback = LastValue(typ)</div>
<div class="line">             fallback.key = name</div>
<div class="line">             all_keys[name] = fallback</div>
<div class="line">    <span class="comment"># ... separate BaseChannel instances from ManagedValueSpec ...</span></div>
<div class="line">    <span class="keywordflow">return</span> channels, managed_values, type_hints</div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>_is_field_channel(typ: Type[Any]) -&gt; Optional[BaseChannel]:</div>
<div class="line">    <span class="comment"># Checks if Annotated metadata contains a BaseChannel instance or class</span></div>
<div class="line">    <span class="keywordflow">if</span> hasattr(typ, <span class="stringliteral">&quot;__metadata__&quot;</span>):</div>
<div class="line">        meta = typ.__metadata__</div>
<div class="line">        <span class="keywordflow">if</span> len(meta) &gt;= 1 <span class="keywordflow">and</span> isinstance(meta[-1], BaseChannel):</div>
<div class="line">            <span class="keywordflow">return</span> meta[-1] <span class="comment"># Return the channel instance directly</span></div>
<div class="line">        <span class="comment"># ... (handle channel classes too) ...</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">def </span>_is_field_binop(typ: Type[Any]) -&gt; Optional[BinaryOperatorAggregate]:</div>
<div class="line">    <span class="comment"># Checks if Annotated metadata contains a callable (the reducer function)</span></div>
<div class="line">    <span class="keywordflow">if</span> hasattr(typ, <span class="stringliteral">&quot;__metadata__&quot;</span>):</div>
<div class="line">        meta = typ.__metadata__</div>
<div class="line">        <span class="keywordflow">if</span> len(meta) &gt;= 1 <span class="keywordflow">and</span> callable(meta[-1]):</div>
<div class="line">            <span class="comment"># ... (validate function signature) ...</span></div>
<div class="line">            <span class="keywordflow">return</span> BinaryOperatorAggregate(typ, meta[-1]) <span class="comment"># Create binop channel</span></div>
<div class="line">    <span class="keywordflow">return</span> <span class="keywordtype">None</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- In StateGraph.__init__ ---</span></div>
<div class="line"><span class="comment"># self._add_schema(state_schema) # This calls _get_channels</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2172"></a>
Under the Hood: <code>BaseChannel</code></h2>
<p>All channel types inherit from a base class called <code>BaseChannel</code>. This class defines the common interface that the <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> uses to interact with any channel.</p>
<div class="fragment"><div class="line"><span class="comment"># channels/base.py (Simplified Abstract Base Class)</span></div>
<div class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Generic, Sequence, TypeVar</div>
<div class="line"> </div>
<div class="line">Value = TypeVar(<span class="stringliteral">&quot;Value&quot;</span>) <span class="comment"># The type of the stored state</span></div>
<div class="line">Update = TypeVar(<span class="stringliteral">&quot;Update&quot;</span>) <span class="comment"># The type of incoming updates</span></div>
<div class="line">Checkpoint = TypeVar(<span class="stringliteral">&quot;Checkpoint&quot;</span>) <span class="comment"># The type of saved state</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>BaseChannel(Generic[Value, Update, Checkpoint], ABC):</div>
<div class="line">    <span class="comment"># ... (init, type properties) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@abstractmethod</span></div>
<div class="line">    <span class="keyword">def </span>update(self, values: Sequence[Update]) -&gt; bool:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Combines the sequence of updates with the current channel value.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Must be implemented by subclasses (like LastValue, Topic)</span></div>
<div class="line">        <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@abstractmethod</span></div>
<div class="line">    <span class="keyword">def </span><a class="code hl_function" href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get</a>(self) -&gt; Value:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Returns the current value of the channel.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Must be implemented by subclasses</span></div>
<div class="line">        <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@abstractmethod</span></div>
<div class="line">    <span class="keyword">def </span>checkpoint(self) -&gt; Checkpoint:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Returns a serializable representation of the channel&#39;s state.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Used by the Checkpointer</span></div>
<div class="line">        <span class="keywordflow">pass</span></div>
<div class="line"> </div>
<div class="line">    <span class="preprocessor">@abstractmethod</span></div>
<div class="line">    <span class="keyword">def </span>from_checkpoint(self, checkpoint: Checkpoint) -&gt; Self:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Creates a new channel instance from a saved checkpoint.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Used by the Checkpointer</span></div>
<div class="line">        <span class="keywordflow">pass</span></div>
<div class="ttc" id="apybind__kv__service_8cpp_html_abe6524afb3a69dc9a4c314e11f96f29f"><div class="ttname"><a href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get</a></div><div class="ttdeci">std::string get(std::string key, std::string config_path)</div><div class="ttdef"><b>Definition</b> <a href="../../d7/da6/pybind__kv__service_8cpp_source.html#l00039">pybind_kv_service.cpp:39</a></div></div>
</div><!-- fragment --><p>The specific logic for <code>LastValue</code>, <code>Topic</code>, <code>BinaryOperatorAggregate</code>, etc., is implemented within their respective <code>update</code> and <code>get</code> methods, adhering to this common interface. The <code>checkpoint</code> and <code>from_checkpoint</code> methods are crucial for saving and loading the graph's state, which we'll explore more in <a class="el" href="../../d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html">Chapter 6: Checkpointer (<code>BaseCheckpointSaver</code>)</a>.</p>
<h2><a class="anchor" id="autotoc_md2173"></a>
Conclusion</h2>
<p>You've learned about <b>Channels</b>, the crucial communication and state management system within LangGraph's <code>StateGraph</code>.</p>
<ul>
<li>Channels act like <b>mailboxes</b> for each key in your graph's state.</li>
<li>They define <b>how updates are combined</b> when nodes write to the state.</li>
<li>The default channel is <b><code>LastValue</code></b>, which overwrites the previous value.</li>
<li>You can use <code>typing.Annotated</code> in your state definition to specify other channel types like <b><code>BinaryOperatorAggregate</code></b> (for combining values, e.g., summing) or <b><code>Topic</code></b> (for collecting updates into a list).</li>
<li><code>StateGraph</code> automatically creates the correct channel for each state key based on your type hints.</li>
</ul>
<p>Understanding channels helps you control precisely how information flows and accumulates in your stateful applications.</p>
<p>Now that we know how the state is managed (Channels) and how work gets done (Nodes), how do we control the <em>flow</em> of execution? What if we want to go to different nodes based on the current state? That's where conditional logic comes in.</p>
<p>Let's move on to <a class="el" href="../../d0/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_204__control__flow__primitives___bda35fdc89636f8ab61738c1940513a5.html">Chapter 4: Control Flow Primitives (<code>Branch</code>, <code>Send</code>, <code>Interrupt</code>)</a> to learn how to direct the traffic within our graph.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
