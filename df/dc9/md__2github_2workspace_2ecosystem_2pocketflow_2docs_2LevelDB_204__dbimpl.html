#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_dbimpl</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('df/dc9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_204__dbimpl.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_dbimpl</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2281"></a>
autotoc_md2281</h2>
<p>layout: default title: "DBImpl" parent: "LevelDB" </p>
<h2><a class="anchor" id="autotoc_md2282"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md2283"></a>
Chapter 4: DBImpl - The Database General Manager</h1>
<p>In the previous chapters, we've explored some key ingredients of LevelDB:</p><ul>
<li><a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">SSTables</a> for storing data permanently on disk.</li>
<li>The <a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">MemTable</a> for quickly handling recent writes in memory.</li>
<li>The <a class="el" href="../../df/d85/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_203__write__ahead__log____wal________logwriter__logreader.html">Write-Ahead Log (WAL)</a> for ensuring durability even if the system crashes.</li>
</ul>
<p>But how do all these pieces work together? Who tells LevelDB to write to the WAL first, <em>then</em> the MemTable? Who decides when the MemTable is full and needs to be flushed to an SSTable? Who coordinates reading data from both memory <em>and</em> disk files?</p>
<h2><a class="anchor" id="autotoc_md2284"></a>
What's the Problem? Orchestrating Everything</h2>
<p>Imagine a large library. You have librarians putting books on shelves (SSTables), a front desk clerk taking newly returned books (MemTable), and a security guard logging everyone who enters (WAL). But someone needs to be in charge of the whole operation – the <b>General Manager</b>.</p>
<p>This manager doesn't shelve every book themselves, but they direct the staff, manage the budget, decide when to rearrange sections (compaction), and handle emergencies (recovery). Without a manager, it would be chaos!</p>
<p>LevelDB needs a similar central coordinator to manage all its different parts and ensure they work together smoothly and correctly.</p>
<h2><a class="anchor" id="autotoc_md2285"></a>
DBImpl: The General Manager of LevelDB</h2>
<p>The <code>DBImpl</code> class is the heart of LevelDB's implementation. It's the <b>General Manager</b> of our database library. It doesn't <em>contain</em> the data itself (that's in MemTables and SSTables), but it <b>orchestrates</b> almost every operation.</p>
<ul>
<li>It takes requests from your application (like <code>Put</code>, <code>Get</code>, <code>Delete</code>).</li>
<li>It directs these requests to the right components (WAL, MemTable, TableCache).</li>
<li>It manages the state of the database (like which MemTable is active, which files exist).</li>
<li>It initiates and manages background tasks like flushing the MemTable and running compactions.</li>
<li>It handles the recovery process when the database starts up.</li>
</ul>
<p>Almost every interaction you have with a LevelDB database object ultimately goes through <code>DBImpl</code>.</p>
<h2><a class="anchor" id="autotoc_md2286"></a>
Key Responsibilities of DBImpl</h2>
<p>Think of the <code>DBImpl</code> general manager juggling several key tasks:</p>
<ol type="1">
<li><b>Handling Writes (<code>Put</code>, <code>Delete</code>, <code>Write</code>):</b> Ensuring data is safely written to the WAL and then the MemTable. Managing the process when the MemTable fills up.</li>
<li><b>Handling Reads (<code>Get</code>, <code>NewIterator</code>):</b> Figuring out where to find the requested data – checking the active MemTable, the soon-to-be-flushed immutable MemTable, and finally the various SSTable files on disk (using helpers like <a class="el" href="../../d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html">Version &amp; VersionSet</a> and <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">Table / SSTable &amp; TableCache</a>).</li>
<li><b>Background Maintenance (<a class="el" href="../../df/d5d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_208__compaction.html">Compaction</a>):</b> Deciding when and how to run compactions to clean up old data, merge SSTables, and keep reads efficient. It schedules and oversees this background work.</li>
<li><b>Startup and Recovery:</b> When the database opens, <code>DBImpl</code> manages locking the database directory, reading the manifest file (<a class="el" href="../../d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html">Version &amp; VersionSet</a>), and replaying the <a class="el" href="../../df/d85/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_203__write__ahead__log____wal________logwriter__logreader.html">WAL</a> to recover any data that wasn't flushed before the last shutdown or crash.</li>
<li><b>Snapshot Management:</b> Handling requests to create and release snapshots, which provide a consistent view of the database at a specific point in time.</li>
</ol>
<p><code>DBImpl</code> uses other components extensively to perform these tasks. It holds references to the active MemTable (<code>mem_</code>), the immutable MemTable (<code>imm_</code>), the WAL (<code>log_</code>), the <code>TableCache</code>, and the <code>VersionSet</code> (which tracks all the SSTable files).</p>
<h2><a class="anchor" id="autotoc_md2287"></a>
How DBImpl Handles Writes</h2>
<p>Let's trace a simple <code>Put</code> operation:</p>
<ol type="1">
<li><b>Request:</b> Your application calls <code>db-&gt;Put("mykey", "myvalue")</code>.</li>
<li><b>DBImpl Entry:</b> This call enters the <code>DBImpl::Put</code> method (which typically wraps the operation in a <a class="el" href="../../d1/dce/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_205__writebatch.html">WriteBatch</a> and calls <code>DBImpl::Write</code>).</li>
<li><b>Queueing (Optional):</b> <code>DBImpl</code> manages a queue of writers to ensure writes happen in order. It might group multiple concurrent writes together for efficiency (<code>BuildBatchGroup</code>).</li>
<li><b>Making Room:</b> Before writing, <code>DBImpl</code> checks if there's space in the current <code>MemTable</code> (<code>mem_</code>). If not (<code>MakeRoomForWrite</code>), it might:<ul>
<li>Pause briefly if Level-0 SSTable count is high (slowdown trigger).</li>
<li>Wait if the <em>immutable</em> MemTable (<code>imm_</code>) is still being flushed.</li>
<li>Wait if Level-0 SSTable count is too high (stop trigger).</li>
<li><b>Trigger a MemTable switch:</b><ul>
<li>Mark the current <code>mem_</code> as read-only (<code>imm_</code>).</li>
<li>Create a new empty <code>mem_</code>.</li>
<li>Create a new WAL file (<code>logfile_</code>).</li>
<li>Schedule a background task (<code>MaybeScheduleCompaction</code>) to flush the old <code>imm_</code> to an SSTable.</li>
</ul>
</li>
</ul>
</li>
<li><b>Write to WAL:</b> <code>DBImpl</code> writes the operation(s) to the current WAL file (<code>log_-&gt;AddRecord(...)</code>). If requested (<code>options.sync</code>), it ensures the WAL data is physically on disk (<code>logfile_-&gt;Sync()</code>).</li>
<li><b>Write to MemTable:</b> Only after the WAL write succeeds, <code>DBImpl</code> inserts the data into the active <code>MemTable</code> (<code>mem_-&gt;Add(...)</code> via <code>WriteBatchInternal::InsertInto</code>).</li>
<li><b>Return:</b> Control returns to your application.</li>
</ol>
<p>Here's a highly simplified view of the <code>Write</code> method:</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/db_impl.cc ---</span></div>
<div class="line"> </div>
<div class="line">Status DBImpl::Write(<span class="keyword">const</span> WriteOptions&amp; options, WriteBatch* updates) {</div>
<div class="line">  <span class="comment">// ... acquire mutex, manage writer queue (omitted) ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Step 4: Make sure there&#39;s space. This might trigger a MemTable switch</span></div>
<div class="line">  <span class="comment">// and schedule background work. May wait if MemTable is full or</span></div>
<div class="line">  <span class="comment">// too many L0 files exist.</span></div>
<div class="line">  Status status = MakeRoomForWrite(updates == <span class="keyword">nullptr</span> <span class="comment">/* force compact? */</span>);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (status.ok() &amp;&amp; updates != <span class="keyword">nullptr</span>) {</div>
<div class="line">    <span class="comment">// ... potentially group multiple concurrent writes (BuildBatchGroup) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 5: Add the batch to the Write-Ahead Log</span></div>
<div class="line">    status = log_-&gt;AddRecord(WriteBatchInternal::Contents(updates));</div>
<div class="line">    <span class="keywordflow">if</span> (status.ok() &amp;&amp; options.sync) {</div>
<div class="line">      <span class="comment">// Ensure log entry is on disk if requested</span></div>
<div class="line">      status = logfile_-&gt;Sync();</div>
<div class="line">      <span class="comment">// ... handle sync error by recording background error ...</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Step 6: Insert the batch into the active MemTable (only if WAL ok)</span></div>
<div class="line">    <span class="keywordflow">if</span> (status.ok()) {</div>
<div class="line">      status = WriteBatchInternal::InsertInto(updates, mem_);</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ... update sequence number, manage writer queue, release mutex ...</span></div>
<div class="line">  <span class="keywordflow">return</span> status; <span class="comment">// Step 7: Return status to caller</span></div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b> This code shows the core sequence: check/make room (<code>MakeRoomForWrite</code>), write to the log (<code>log_-&gt;AddRecord</code>), potentially sync the log (<code>logfile_-&gt;Sync</code>), and finally insert into the MemTable (<code>InsertInto(..., mem_)</code>). Error handling and writer coordination are omitted for clarity.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant App as Application</div>
<div class="line">    participant DBImpl</div>
<div class="line">    participant WriterQueue as Writer Queue</div>
<div class="line">    participant LogWriter as log::Writer (WAL)</div>
<div class="line">    participant MemTable as Active MemTable (RAM)</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;DBImpl: Put(&quot;key&quot;, &quot;value&quot;) / Write(batch)</div>
<div class="line">    DBImpl-&gt;&gt;WriterQueue: Add writer to queue</div>
<div class="line">    Note over DBImpl: Waits if not front of queue</div>
<div class="line">    DBImpl-&gt;&gt;DBImpl: MakeRoomForWrite()?</div>
<div class="line">    alt MemTable Full / L0 Trigger</div>
<div class="line">        DBImpl-&gt;&gt;DBImpl: Switch MemTable, Schedule Flush</div>
<div class="line">    end</div>
<div class="line">    DBImpl-&gt;&gt;LogWriter: AddRecord(batch_data)</div>
<div class="line">    opt Sync Option Enabled</div>
<div class="line">      DBImpl-&gt;&gt;LogWriter: Sync() Log File</div>
<div class="line">    end</div>
<div class="line">    LogWriter--&gt;&gt;DBImpl: Log Write Status</div>
<div class="line">    alt Log Write OK</div>
<div class="line">        DBImpl-&gt;&gt;MemTable: InsertInto(batch_data)</div>
<div class="line">        MemTable--&gt;&gt;DBImpl: Insert Status</div>
<div class="line">        DBImpl-&gt;&gt;WriterQueue: Remove writer, Signal next</div>
<div class="line">        DBImpl--&gt;&gt;App: Return OK</div>
<div class="line">    else Log Write Failed</div>
<div class="line">        DBImpl-&gt;&gt;WriterQueue: Remove writer, Signal next</div>
<div class="line">        DBImpl--&gt;&gt;App: Return Error Status</div>
<div class="line">    end</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2288"></a>
How DBImpl Handles Reads</h2>
<p>Reading data involves checking different places in a specific order to ensure the most recent value is found:</p>
<ol type="1">
<li><b>Request:</b> Your application calls <code>db-&gt;Get("mykey")</code>.</li>
<li><b>DBImpl Entry:</b> The call enters <code>DBImpl::Get</code>.</li>
<li><b>Snapshot:</b> <code>DBImpl</code> determines the sequence number to read up to (either from the provided <code>ReadOptions::snapshot</code> or the current latest sequence number).</li>
<li><b>Check MemTable:</b> It first checks the active <code>MemTable</code> (<code>mem_</code>). If the key is found (either a value or a deletion marker), the search stops, and the result is returned.</li>
<li><b>Check Immutable MemTable:</b> If not found in <code>mem_</code>, and if an immutable MemTable (<code>imm_</code>) exists (one that's waiting to be flushed), it checks <code>imm_</code>. If found, the search stops.</li>
<li><b>Check SSTables:</b> If the key wasn't found in memory, <code>DBImpl</code> asks the current <code>Version</code> (managed by <code>VersionSet</code>) to find the key in the SSTable files (<code>current-&gt;Get(...)</code>). The <code>Version</code> object knows which files might contain the key and uses the <code>TableCache</code> to access them efficiently.</li>
<li><b>Update <a class="el" href="../../db/df7/classStats.html">Stats</a> (Optional):</b> If the read involved checking SSTables, <code>DBImpl</code> might update internal statistics about file access (<code>current-&gt;UpdateStats</code>). If a file is read frequently, this might trigger a future compaction (<code>MaybeScheduleCompaction</code>).</li>
<li><b>Return:</b> The value found (or a "Not Found" status) is returned to the application.</li>
</ol>
<p>A simplified view of <code>Get</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/db_impl.cc ---</span></div>
<div class="line"> </div>
<div class="line">Status DBImpl::Get(<span class="keyword">const</span> ReadOptions&amp; options, <span class="keyword">const</span> Slice&amp; key,</div>
<div class="line">                   std::string* value) {</div>
<div class="line">  Status s;</div>
<div class="line">  SequenceNumber snapshot;</div>
<div class="line">  <span class="comment">// ... (Step 3) Determine snapshot sequence number ...</span></div>
<div class="line">  mutex_.Lock(); <span class="comment">// Need lock to access mem_, imm_, current version</span></div>
<div class="line">  MemTable* mem = mem_;</div>
<div class="line">  MemTable* imm = imm_;</div>
<div class="line">  Version* current = versions_-&gt;current();</div>
<div class="line">  mem-&gt;Ref(); <span class="comment">// Increase reference counts</span></div>
<div class="line">  <span class="keywordflow">if</span> (imm != <span class="keyword">nullptr</span>) imm-&gt;Ref();</div>
<div class="line">  current-&gt;Ref();</div>
<div class="line">  mutex_.Unlock(); <span class="comment">// Unlock for potentially slow lookups</span></div>
<div class="line"> </div>
<div class="line">  LookupKey lkey(key, snapshot); <span class="comment">// Internal key format for lookup</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Step 4: Check active MemTable</span></div>
<div class="line">  <span class="keywordflow">if</span> (mem-&gt;Get(lkey, value, &amp;s)) {</div>
<div class="line">    <span class="comment">// Found in mem_ (value or deletion marker)</span></div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Step 5: Check immutable MemTable (if it exists)</span></div>
<div class="line">  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (imm != <span class="keyword">nullptr</span> &amp;&amp; imm-&gt;Get(lkey, value, &amp;s)) {</div>
<div class="line">    <span class="comment">// Found in imm_</span></div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// Step 6: Check SSTables via current Version</span></div>
<div class="line">  <span class="keywordflow">else</span> {</div>
<div class="line">    Version::GetStats <a class="code hl_variable" href="../../da/d34/namespaceutils_1_1crawl__github__files.html#ab9de66a0f2178034cdca35bf3ee14eb2">stats</a>; <span class="comment">// To record file access stats</span></div>
<div class="line">    s = current-&gt;Get(options, lkey, value, &amp;stats);</div>
<div class="line">    <span class="comment">// Step 7: Maybe update stats and schedule compaction</span></div>
<div class="line">    <span class="keywordflow">if</span> (current-&gt;UpdateStats(stats)) {</div>
<div class="line">       mutex_.Lock();</div>
<div class="line">       MaybeScheduleCompaction(); <span class="comment">// Needs lock</span></div>
<div class="line">       mutex_.Unlock();</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Decrease reference counts</span></div>
<div class="line">  mutex_.Lock();</div>
<div class="line">  mem-&gt;Unref();</div>
<div class="line">  <span class="keywordflow">if</span> (imm != <span class="keyword">nullptr</span>) imm-&gt;Unref();</div>
<div class="line">  current-&gt;Unref();</div>
<div class="line">  mutex_.Unlock();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> s; <span class="comment">// Step 8: Return status</span></div>
<div class="line">}</div>
<div class="ttc" id="anamespaceutils_1_1crawl__github__files_html_ab9de66a0f2178034cdca35bf3ee14eb2"><div class="ttname"><a href="../../da/d34/namespaceutils_1_1crawl__github__files.html#ab9de66a0f2178034cdca35bf3ee14eb2">utils.crawl_github_files.stats</a></div><div class="ttdeci">stats</div><div class="ttdef"><b>Definition</b> <a href="../../d8/dd7/crawl__github__files_8py_source.html#l00366">crawl_github_files.py:366</a></div></div>
</div><!-- fragment --><p><b>Explanation:</b> This shows the order of checking: <code>mem-&gt;Get</code>, <code>imm-&gt;Get</code>, and finally <code>current-&gt;Get</code> (which searches SSTables). It also highlights the reference counting (<code>Ref</code>/<code>Unref</code>) needed because these components might be changed or deleted by background threads while the read is in progress. The lock is held only when accessing shared pointers, not during the actual data lookup.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant App as Application</div>
<div class="line">    participant DBImpl</div>
<div class="line">    participant MemTable as Active MemTable (RAM)</div>
<div class="line">    participant ImmMemTable as Immutable MemTable (RAM)</div>
<div class="line">    participant Version as Current Version</div>
<div class="line">    participant TableCache as TableCache (SSTables)</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;DBImpl: Get(&quot;key&quot;)</div>
<div class="line">    DBImpl-&gt;&gt;MemTable: Get(lkey)?</div>
<div class="line">    alt Key Found in MemTable</div>
<div class="line">        MemTable--&gt;&gt;DBImpl: Return value / deletion</div>
<div class="line">        DBImpl--&gt;&gt;App: Return value / NotFound</div>
<div class="line">    else Key Not Found in MemTable</div>
<div class="line">        MemTable--&gt;&gt;DBImpl: Not Found</div>
<div class="line">        DBImpl-&gt;&gt;ImmMemTable: Get(lkey)?</div>
<div class="line">        alt Key Found in ImmMemTable</div>
<div class="line">            ImmMemTable--&gt;&gt;DBImpl: Return value / deletion</div>
<div class="line">            DBImpl--&gt;&gt;App: Return value / NotFound</div>
<div class="line">        else Key Not Found in ImmMemTable</div>
<div class="line">            ImmMemTable--&gt;&gt;DBImpl: Not Found</div>
<div class="line">            DBImpl-&gt;&gt;Version: Get(lkey) from SSTables?</div>
<div class="line">            Version-&gt;&gt;TableCache: Find key in relevant SSTables</div>
<div class="line">            TableCache--&gt;&gt;Version: Return value / deletion / NotFound</div>
<div class="line">            Version--&gt;&gt;DBImpl: Return value / deletion / NotFound</div>
<div class="line">            DBImpl--&gt;&gt;App: Return value / NotFound</div>
<div class="line">        end</div>
<div class="line">    end</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2289"></a>
Managing Background Work (Compaction)</h2>
<p><code>DBImpl</code> is responsible for kicking off background work. It doesn't <em>do</em> the compaction itself (that logic is largely within <a class="el" href="../../df/d5d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_208__compaction.html">Compaction</a> and <a class="el" href="../../d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html">VersionSet</a>), but it manages the <em>triggering</em> and the background thread.</p>
<ul>
<li><b>When is work needed?</b> <code>DBImpl</code> checks if work is needed in a few places:<ul>
<li>After a MemTable switch (<code>MakeRoomForWrite</code> schedules flush of <code>imm_</code>).</li>
<li>After a read operation updates file stats (<code>Get</code> might call <code>MaybeScheduleCompaction</code>).</li>
<li>After a background compaction finishes (it checks if <em>more</em> compaction is needed).</li>
<li>When explicitly requested (<code>CompactRange</code>).</li>
</ul>
</li>
<li><b>Scheduling:</b> If work is needed and a background task isn't already running, <code>DBImpl::MaybeScheduleCompaction</code> sets a flag (<code>background_compaction_scheduled_</code>) and asks the <code>Env</code> (Environment object, handles OS interactions) to schedule a function (<code>DBImpl::BGWork</code>) to run on a background thread.</li>
<li><b>Performing Work:</b> The background thread eventually calls <code>DBImpl::BackgroundCall</code>, which locks the mutex and calls <code>DBImpl::BackgroundCompaction</code>. This method decides <em>what</em> work to do:<ul>
<li>If <code>imm_</code> exists, it calls <code>CompactMemTable</code> (which uses <code>WriteLevel0Table</code> -&gt; <code>BuildTable</code>) to flush it.</li>
<li>Otherwise, it asks the <code>VersionSet</code> to pick an appropriate SSTable compaction (<code>versions_-&gt;PickCompaction()</code>).</li>
<li>It then calls <code>DoCompactionWork</code> to perform the actual SSTable compaction (releasing the main lock during the heavy lifting).</li>
</ul>
</li>
<li><b>Signaling:</b> Once background work finishes, it signals (<code>background_work_finished_signal_.SignalAll()</code>) any foreground threads that might be waiting (e.g., a write operation waiting for <code>imm_</code> to be flushed).</li>
</ul>
<p>Here's the simplified scheduling logic:</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/db_impl.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> DBImpl::MaybeScheduleCompaction() {</div>
<div class="line">  mutex_.AssertHeld(); <span class="comment">// Must hold lock to check/change state</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (background_compaction_scheduled_) {</div>
<div class="line">    <span class="comment">// Already scheduled</span></div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shutting_down_.load(std::memory_order_acquire)) {</div>
<div class="line">    <span class="comment">// DB is closing</span></div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!bg_error_.ok()) {</div>
<div class="line">    <span class="comment">// Background error stopped activity</span></div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (imm_ == <span class="keyword">nullptr</span> &amp;&amp; <span class="comment">// No MemTable flush needed AND</span></div>
<div class="line">             manual_compaction_ == <span class="keyword">nullptr</span> &amp;&amp; <span class="comment">// No manual request AND</span></div>
<div class="line">             !versions_-&gt;NeedsCompaction()) { <span class="comment">// VersionSet says no work needed</span></div>
<div class="line">    <span class="comment">// No work to be done</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Work needs to be done! Schedule it.</span></div>
<div class="line">    background_compaction_scheduled_ = <span class="keyword">true</span>;</div>
<div class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>); <span class="comment">// Ask Env to run BGWork later</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b> This function checks several conditions under a lock. If there's an immutable MemTable to flush (<code>imm_ != nullptr</code>) or the <code>VersionSet</code> indicates compaction is needed (<code>versions_-&gt;NeedsCompaction()</code>) and no background task is already scheduled, it marks one as scheduled and tells the environment (<code>env_</code>) to run the <code>BGWork</code> function in the background.</p>
<div class="fragment"><div class="line">flowchart TD</div>
<div class="line">    A[&quot;Write/Read/Compact finishes&quot;] --&gt; B{&quot;Need Compaction?&quot;}</div>
<div class="line">    B --&gt;|Yes| C{&quot;BG Task Scheduled?&quot;}</div>
<div class="line">    B --&gt;|No| Z[&quot;Idle&quot;]</div>
<div class="line">    C --&gt;|Yes| Z</div>
<div class="line">    C --&gt;|No| D[&quot;Mark BG Scheduled = true&quot;]</div>
<div class="line">    D --&gt; E[&quot;Schedule BGWork&quot;]</div>
<div class="line">    E --&gt; F[&quot;Background Thread Pool&quot;]</div>
<div class="line">    F --&gt;|Runs| G[&quot;DBImpl::BGWork&quot;]</div>
<div class="line">    G --&gt; H[&quot;DBImpl::BackgroundCall&quot;]</div>
<div class="line">    H --&gt; I{&quot;Compact imm_ OR Pick/Run SSTable Compaction?&quot;}</div>
<div class="line">    I --&gt; J[&quot;Perform Compaction Work&quot;]</div>
<div class="line">    J --&gt; K[&quot;Mark BG Scheduled = false&quot;]</div>
<div class="line">    K --&gt; L[&quot;Signal Waiting Threads&quot;]</div>
<div class="line">    L --&gt; B</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2290"></a>
Recovery on Startup</h2>
<p>When you open a database, <code>DBImpl::Open</code> orchestrates the recovery process:</p>
<ol type="1">
<li><b>Lock:</b> It locks the database directory (<code>env_-&gt;LockFile</code>) to prevent other processes from using it.</li>
<li><b>Recover VersionSet:</b> It calls <code>versions_-&gt;Recover()</code>, which reads the <code>MANIFEST</code> file to understand the state of SSTables from the last clean run.</li>
<li><b>Find Logs:</b> It scans the database directory for any <code>.log</code> files (WAL files) that are newer than the ones recorded in the <code>MANIFEST</code>. These logs represent writes that might not have been flushed to SSTables before the last shutdown/crash.</li>
<li><b>Replay Logs:</b> For each relevant log file found, it calls <code>DBImpl::RecoverLogFile</code>.<ul>
<li>Inside <code>RecoverLogFile</code>, it creates a <code>log::Reader</code>.</li>
<li>It reads records (which are serialized <code>WriteBatch</code>es) from the log file one by one.</li>
<li>For each record, it applies the operations (<code>WriteBatchInternal::InsertInto</code>) to a temporary in-memory <code>MemTable</code>.</li>
<li>This effectively rebuilds the state of the MemTable(s) as they were just before the crash/shutdown.</li>
</ul>
</li>
<li><b>Finalize State:</b> Once all logs are replayed, the recovered MemTable becomes the active <code>mem_</code>. If the recovery process itself filled the MemTable, <code>RecoverLogFile</code> might even flush it to a Level-0 SSTable (<code>WriteLevel0Table</code>). <code>DBImpl</code> updates the <code>VersionSet</code> with the recovered sequence number and potentially writes a new <code>MANIFEST</code>.</li>
<li><b>Ready:</b> The database is now recovered and ready for new operations.</li>
</ol>
<p>Here's a conceptual snippet from the recovery logic:</p>
<div class="fragment"><div class="line"><span class="comment">// --- Conceptual, simplified from DBImpl::RecoverLogFile ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Inside loop processing a single log file during recovery:</span></div>
<div class="line"><span class="keywordflow">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; status.ok()) {</div>
<div class="line">  <span class="comment">// Check if record looks like a valid WriteBatch</span></div>
<div class="line">  <span class="keywordflow">if</span> (record.size() &lt; 12) { <span class="comment">/* report corruption */</span> <span class="keywordflow">continue</span>; }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Parse the raw log record back into a WriteBatch object</span></div>
<div class="line">  WriteBatchInternal::SetContents(&amp;batch, record);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a MemTable if we don&#39;t have one yet for this log</span></div>
<div class="line">  <span class="keywordflow">if</span> (mem == <span class="keyword">nullptr</span>) {</div>
<div class="line">    mem = <span class="keyword">new</span> MemTable(internal_comparator_);</div>
<div class="line">    mem-&gt;Ref();</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Apply the operations from the batch TO THE MEMTABLE</span></div>
<div class="line">  status = WriteBatchInternal::InsertInto(&amp;batch, mem);</div>
<div class="line">  <span class="comment">// ... handle error ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Keep track of the latest sequence number seen</span></div>
<div class="line">  <span class="keyword">const</span> SequenceNumber last_seq = <span class="comment">/* ... get sequence from batch ... */</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (last_seq &gt; *max_sequence) {</div>
<div class="line">    *max_sequence = last_seq;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If the MemTable gets full *during recovery*, flush it!</span></div>
<div class="line">  <span class="keywordflow">if</span> (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) {</div>
<div class="line">    status = WriteLevel0Table(mem, edit, <span class="keyword">nullptr</span>); <span class="comment">// Flush to L0 SSTable</span></div>
<div class="line">    mem-&gt;Unref();</div>
<div class="line">    mem = <span class="keyword">nullptr</span>; <span class="comment">// Will create a new one if needed</span></div>
<div class="line">    <span class="comment">// ... handle error ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"><span class="comment">// After loop, handle the final state of &#39;mem&#39;</span></div>
</div><!-- fragment --><p><b>Explanation:</b> This loop reads each record (a <code>WriteBatch</code>) from the log file using <code>reader.ReadRecord</code>. It then applies the batch's changes directly to an in-memory <code>MemTable</code> (<code>InsertInto(&amp;batch, mem)</code>), effectively replaying the lost writes. It even handles flushing this MemTable if it fills up during the recovery process.</p>
<h2><a class="anchor" id="autotoc_md2291"></a>
The DBImpl Class (Code Glimpse)</h2>
<p>The definition of <code>DBImpl</code> in <code>db_impl.h</code> shows the key components it manages:</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/db_impl.h ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>DBImpl : <span class="keyword">public</span> DB {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  DBImpl(<span class="keyword">const</span> Options&amp; options, <span class="keyword">const</span> std::string&amp; dbname);</div>
<div class="line">  ~DBImpl() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Public API methods (implementing DB interface)</span></div>
<div class="line">  Status Put(...) <span class="keyword">override</span>;</div>
<div class="line">  Status Delete(...) <span class="keyword">override</span>;</div>
<div class="line">  Status Write(...) <span class="keyword">override</span>;</div>
<div class="line">  Status Get(...) <span class="keyword">override</span>;</div>
<div class="line">  Iterator* NewIterator(...) <span class="keyword">override</span>;</div>
<div class="line">  <span class="keyword">const</span> Snapshot* GetSnapshot() <span class="keyword">override</span>;</div>
<div class="line">  <span class="keywordtype">void</span> ReleaseSnapshot(...) <span class="keyword">override</span>;</div>
<div class="line">  <span class="comment">// ... other public methods ...</span></div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="comment">// Friend classes allow access to private members</span></div>
<div class="line">  <span class="keyword">friend</span> <span class="keyword">class </span>DB;</div>
<div class="line">  <span class="keyword">struct </span>CompactionState; <span class="comment">// Helper struct for compactions</span></div>
<div class="line">  <span class="keyword">struct </span>Writer;          <span class="comment">// Helper struct for writer queue</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Core methods for internal operations</span></div>
<div class="line">  Status Recover(VersionEdit* edit, <span class="keywordtype">bool</span>* save_manifest);</div>
<div class="line">  <span class="keywordtype">void</span> CompactMemTable();</div>
<div class="line">  Status RecoverLogFile(...);</div>
<div class="line">  Status WriteLevel0Table(...);</div>
<div class="line">  Status MakeRoomForWrite(...);</div>
<div class="line">  <span class="keywordtype">void</span> MaybeScheduleCompaction();</div>
<div class="line">  <span class="keyword">static</span> <span class="keywordtype">void</span> BGWork(<span class="keywordtype">void</span>* db); <span class="comment">// Background task entry point</span></div>
<div class="line">  <span class="keywordtype">void</span> BackgroundCall();</div>
<div class="line">  <span class="keywordtype">void</span> BackgroundCompaction();</div>
<div class="line">  Status DoCompactionWork(...);</div>
<div class="line">  <span class="comment">// ... other private helpers ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// == Key Member Variables ==</span></div>
<div class="line">  Env* <span class="keyword">const</span> env_;                <span class="comment">// OS interaction layer</span></div>
<div class="line">  <span class="keyword">const</span> InternalKeyComparator internal_comparator_; <span class="comment">// For sorting keys</span></div>
<div class="line">  <span class="keyword">const</span> Options options_;         <span class="comment">// Database configuration options</span></div>
<div class="line">  <span class="keyword">const</span> std::string dbname_;      <span class="comment">// Database directory path</span></div>
<div class="line"> </div>
<div class="line">  TableCache* <span class="keyword">const</span> table_cache_; <span class="comment">// Cache for open SSTable files</span></div>
<div class="line"> </div>
<div class="line">  FileLock* db_lock_;             <span class="comment">// Lock file handle for DB directory</span></div>
<div class="line"> </div>
<div class="line">  port::Mutex mutex_;             <span class="comment">// Main mutex protecting shared state</span></div>
<div class="line">  std::atomic&lt;bool&gt; shutting_down_; <span class="comment">// Flag indicating DB closure</span></div>
<div class="line">  port::CondVar background_work_finished_signal_ GUARDED_BY(mutex_); <span class="comment">// For waiting</span></div>
<div class="line"> </div>
<div class="line">  MemTable* mem_ GUARDED_BY(mutex_); <span class="comment">// Active memtable (accepts writes)</span></div>
<div class="line">  MemTable* imm_ GUARDED_BY(mutex_); <span class="comment">// Immutable memtable (being flushed)</span></div>
<div class="line">  std::atomic&lt;bool&gt; has_imm_;        <span class="comment">// Fast check if imm_ is non-null</span></div>
<div class="line"> </div>
<div class="line">  WritableFile* logfile_;         <span class="comment">// Current WAL file handle</span></div>
<div class="line">  uint64_t logfile_number_ GUARDED_BY(mutex_); <span class="comment">// Current WAL file number</span></div>
<div class="line">  log::Writer* log_;              <span class="comment">// WAL writer object</span></div>
<div class="line"> </div>
<div class="line">  VersionSet* <span class="keyword">const</span> versions_ GUARDED_BY(mutex_); <span class="comment">// Manages SSTables/Versions</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Queue of writers waiting for their turn</span></div>
<div class="line">  std::deque&lt;Writer*&gt; writers_ GUARDED_BY(mutex_);</div>
<div class="line">  <span class="comment">// List of active snapshots</span></div>
<div class="line">  SnapshotList snapshots_ GUARDED_BY(mutex_);</div>
<div class="line">  <span class="comment">// Files being generated by compactions</span></div>
<div class="line">  std::set&lt;uint64_t&gt; pending_outputs_ GUARDED_BY(mutex_);</div>
<div class="line">  <span class="comment">// Is a background compaction scheduled/running?</span></div>
<div class="line">  <span class="keywordtype">bool</span> background_compaction_scheduled_ GUARDED_BY(mutex_);</div>
<div class="line">  <span class="comment">// Error status from background threads</span></div>
<div class="line">  Status bg_error_ GUARDED_BY(mutex_);</div>
<div class="line">  <span class="comment">// Compaction statistics</span></div>
<div class="line">  CompactionStats stats_[config::kNumLevels] GUARDED_BY(mutex_);</div>
<div class="line">};</div>
</div><!-- fragment --><p><b>Explanation:</b> This header shows <code>DBImpl</code> inheriting from the public <code>DB</code> interface. It contains references to essential components like the <code>Env</code>, <code>Options</code>, <code>TableCache</code>, <code>MemTable</code> (<code>mem_</code> and <code>imm_</code>), WAL (<code>log_</code>, <code>logfile_</code>), and <code>VersionSet</code>. Crucially, it also has a <code>mutex_</code> to protect shared state accessed by multiple threads (foreground application threads and background compaction threads) and condition variables (<code>background_work_finished_signal_</code>) to allow threads to wait for background work.</p>
<h2><a class="anchor" id="autotoc_md2292"></a>
Conclusion</h2>
<p><code>DBImpl</code> is the central nervous system of LevelDB. It doesn't store the data itself, but it acts as the <b>General Manager</b>, receiving requests and coordinating the actions of all the other specialized components like the MemTable, WAL, VersionSet, and TableCache. It handles the intricate dance between fast in-memory writes, durable logging, persistent disk storage, background maintenance, and safe recovery. Understanding <code>DBImpl</code>'s role is key to seeing how all the pieces of LevelDB fit together to create a functional database.</p>
<p>One tool <code>DBImpl</code> uses to make writes efficient and atomic is the <code>WriteBatch</code>. Let's see how that works next.</p>
<p>Next up: <a class="el" href="../../d1/dce/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_205__writebatch.html">Chapter 5: WriteBatch</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
