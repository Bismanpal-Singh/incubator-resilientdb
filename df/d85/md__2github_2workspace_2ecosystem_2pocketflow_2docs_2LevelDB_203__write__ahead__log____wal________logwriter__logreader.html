#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 03_write_ahead_log__wal____logwriter_logreader</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('df/d85/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_203__write__ahead__log____wal________logwriter__logreader.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">03_write_ahead_log__wal____logwriter_logreader</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2269"></a>
autotoc_md2269</h2>
<p>layout: default title: "Write-Ahead Log (WAL)" parent: "LevelDB" </p>
<h2><a class="anchor" id="autotoc_md2270"></a>
nav_order: 3</h2>
<h1><a class="anchor" id="autotoc_md2271"></a>
Chapter 3: Write-Ahead Log (WAL) &amp; LogWriter/LogReader</h1>
<p>In <a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">Chapter 2: MemTable</a>, we saw how LevelDB uses an in-memory <code>MemTable</code> (like a fast notepad) to quickly accept new writes (<code>Put</code> or <code>Delete</code>) before they are eventually flushed to an <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">SSTable</a> file on disk.</p>
<p>This is great for speed! But what if the unthinkable happens? Imagine you've just written some important data. It's sitting safely in the <code>MemTable</code> in RAM, but <em>before</em> LevelDB gets a chance to write it to a permanent SSTable file, the power cord gets kicked out, or the server crashes!</p>
<p>Uh oh. Since RAM is volatile, anything in the <code>MemTable</code> that hadn't been saved to disk is <b>gone</b> forever when the power goes out. That's not very reliable for a database!</p>
<h2><a class="anchor" id="autotoc_md2272"></a>
What's the Problem? Losing Data on Crashes</h2>
<p>How can LevelDB make sure that once your write operation <em>returns successfully</em>, the data is safe, even if the system crashes immediately afterwards? Relying only on the <code>MemTable</code> isn't enough because it lives in volatile RAM. We need a way to make writes durable (permanent) much sooner.</p>
<h2><a class="anchor" id="autotoc_md2273"></a>
Write-Ahead Log (WAL): The Database's Safety Journal</h2>
<p>LevelDB's solution is the <b>Write-Ahead Log (WAL)</b>, often just called the <b>log</b>.</p>
<p>Think of the WAL as a <b>ship's logbook</b> or a <b>court reporter's transcript</b>.</p>
<ol type="1">
<li><b>Write First:</b> Before the captain takes any significant action (like changing course), they write it down in the logbook <em>first</em>. Similarly, before LevelDB modifies the <code>MemTable</code> (which is in RAM), it <b>first appends</b> a description of the change (e.g., "Put key 'user1' with value 'dataA'") to a special file on disk – the WAL file.</li>
<li><b>Append-Only:</b> Like a logbook, entries are just added sequentially to the end. LevelDB doesn't go back and modify old entries in the current WAL file. This makes writing very fast – it's just adding to the end of a file.</li>
<li><b>On Disk:</b> Crucially, this WAL file lives on the persistent disk (HDD or SSD), not just in volatile RAM.</li>
<li><b>Durability:</b> By writing to the WAL <em>before</em> acknowledging a write to the user, LevelDB ensures that even if the server crashes immediately after, the record of the operation is safely stored on disk in the log.</li>
</ol>
<p>So, the write process looks like this:</p>
<p><em>Your Application</em> -&gt; <code>Put("user123", "data")</code> -&gt; <b>1. Append to WAL file (Disk)</b> -&gt; <b>2. Add to MemTable (RAM)</b> -&gt; <em>Return Success</em></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant App as Application</div>
<div class="line">    participant LevelDB</div>
<div class="line">    participant WAL as WAL File (Disk)</div>
<div class="line">    participant MemTable as MemTable (RAM)</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;LevelDB: Put(&quot;key&quot;, &quot;value&quot;)</div>
<div class="line">    LevelDB-&gt;&gt;WAL: Append Put(&quot;key&quot;, &quot;value&quot;) Record</div>
<div class="line">    Note right of WAL: Physical disk write</div>
<div class="line">    WAL--&gt;&gt;LevelDB: Append successful</div>
<div class="line">    LevelDB-&gt;&gt;MemTable: Add(&quot;key&quot;, &quot;value&quot;)</div>
<div class="line">    MemTable--&gt;&gt;LevelDB: Add successful</div>
<div class="line">    LevelDB--&gt;&gt;App: Write successful</div>
</div><!-- fragment --><p>This "write-ahead" step ensures durability.</p>
<h2><a class="anchor" id="autotoc_md2274"></a>
What Happens During Recovery? Replaying the Logbook</h2>
<p>Now, let's say the server crashes and restarts. LevelDB needs to recover its state. How does the WAL help?</p>
<ol type="1">
<li><b>Check for Log:</b> When LevelDB starts up, it looks for a WAL file.</li>
<li><b>Read the Log:</b> If a WAL file exists, it means the database might not have shut down cleanly, and the last <code>MemTable</code>'s contents (which were only in RAM) were lost. LevelDB creates a <code>LogReader</code> to read through the WAL file from beginning to end.</li>
<li><b>Rebuild MemTable:</b> For each operation record found in the WAL (like "Put key 'user1' value 'dataA'", "Delete key 'user2'"), LevelDB re-applies that operation to a <em>new</em>, empty <code>MemTable</code> in memory. It's like rereading the ship's logbook to reconstruct what happened right before the incident.</li>
<li><b>Recovery Complete:</b> Once the entire WAL is replayed, the <code>MemTable</code> is back to the state it was in right before the crash. LevelDB can now continue operating normally, accepting new reads and writes. The data from the WAL is now safely in the new <code>MemTable</code>, ready to be flushed to an SSTable later.</li>
</ol>
<p>The WAL file essentially acts as a temporary backup for the <code>MemTable</code> until the <code>MemTable</code>'s contents are permanently stored in an SSTable. Once a <code>MemTable</code> is successfully flushed to an SSTable, the corresponding WAL file is no longer needed and can be deleted.</p>
<h2><a class="anchor" id="autotoc_md2275"></a>
LogWriter: Appending to the Log</h2>
<p>The component responsible for writing records to the WAL file is <code>log::Writer</code>. Think of it as the dedicated writer making entries in our ship's logbook.</p>
<p>When LevelDB processes a write operation (often coming from a <a class="el" href="../../d1/dce/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_205__writebatch.html">WriteBatch</a>, which we'll see later), it serializes the batch of changes into a single chunk of data (a <code>Slice</code>) and asks the <code>log::Writer</code> to add it to the current log file.</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/db_impl.cc ---</span></div>
<div class="line"><span class="comment">// Inside DBImpl::Write(...) after preparing the batch:</span></div>
<div class="line"> </div>
<div class="line">Status status = log_-&gt;AddRecord(WriteBatchInternal::Contents(write_batch));</div>
<div class="line"><span class="comment">// ... check status ...</span></div>
<div class="line"><span class="keywordflow">if</span> (status.ok() &amp;&amp; options.sync) {</div>
<div class="line">  <span class="comment">// Optionally ensure the data hits the physical disk</span></div>
<div class="line">  status = logfile_-&gt;Sync();</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span> (status.ok()) {</div>
<div class="line">  <span class="comment">// Only if WAL write succeeded, apply to MemTable</span></div>
<div class="line">  status = WriteBatchInternal::InsertInto(write_batch, mem_);</div>
<div class="line">}</div>
<div class="line"><span class="comment">// ... handle status ...</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li><code>WriteBatchInternal::Contents(write_batch)</code>: Gets the serialized representation of the write operations (like one or more Puts/Deletes).</li>
<li><code>log_-&gt;AddRecord(...)</code>: Calls the <code>log::Writer</code> instance (<code>log_</code>) to append this serialized data as a single record to the current WAL file (<code>logfile_</code>).</li>
<li><code>logfile_-&gt;Sync()</code>: If the <code>sync</code> option is set (which is the default for ensuring durability), this command tells the operating system to <em>really</em> make sure the data written to the log file has reached the physical disk platters/flash, not just sitting in some OS buffer. This is crucial for surviving power loss.</li>
<li><code>WriteBatchInternal::InsertInto(write_batch, mem_)</code>: Only <em>after</em> the log write is confirmed (and synced, if requested) does LevelDB apply the changes to the in-memory <code>MemTable</code>.</li>
</ol>
<p>The <code>log::Writer</code> itself handles the details of how records are actually formatted within the log file. Log files are composed of fixed-size blocks (e.g., 32KB). A single record from <code>AddRecord</code> might be small enough to fit entirely within the remaining space in the current block, or it might be large and need to be split (fragmented) across multiple physical records spanning block boundaries.</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/log_writer.cc ---</span></div>
<div class="line"> </div>
<div class="line">Status Writer::AddRecord(<span class="keyword">const</span> Slice&amp; slice) {</div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">char</span>* ptr = slice.data();</div>
<div class="line">  <span class="keywordtype">size_t</span> left = slice.size(); <span class="comment">// How much data is left to write?</span></div>
<div class="line">  Status s;</div>
<div class="line">  <span class="keywordtype">bool</span> begin = <span class="keyword">true</span>; <span class="comment">// Is this the first fragment of this record?</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span> leftover = kBlockSize - block_offset_; <span class="comment">// Space left in current block</span></div>
<div class="line">    <span class="comment">// ... if leftover &lt; kHeaderSize, fill trailer and start new block ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Calculate how much of the data can fit in this block</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> avail = kBlockSize - block_offset_ - kHeaderSize;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">size_t</span> fragment_length = (left &lt; avail) ? left : avail;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Determine the type of this physical record (fragment)</span></div>
<div class="line">    RecordType type;</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> end = (left == fragment_length); <span class="comment">// Is this the last fragment?</span></div>
<div class="line">    <span class="keywordflow">if</span> (begin &amp;&amp; end) {</div>
<div class="line">      type = kFullType;     <span class="comment">// Fits entirely in one piece</span></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (begin) {</div>
<div class="line">      type = kFirstType;    <span class="comment">// First piece of a multi-piece record</span></div>
<div class="line">    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (end) {</div>
<div class="line">      type = kLastType;     <span class="comment">// Last piece of a multi-piece record</span></div>
<div class="line">    } <span class="keywordflow">else</span> {</div>
<div class="line">      type = kMiddleType;   <span class="comment">// Middle piece of a multi-piece record</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Write this physical record (header + data fragment) to the file</span></div>
<div class="line">    s = EmitPhysicalRecord(type, ptr, fragment_length);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Advance pointers and update remaining size</span></div>
<div class="line">    ptr += fragment_length;</div>
<div class="line">    left -= fragment_length;</div>
<div class="line">    begin = <span class="keyword">false</span>; <span class="comment">// Subsequent fragments are not the &#39;begin&#39; fragment</span></div>
<div class="line"> </div>
<div class="line">  } <span class="keywordflow">while</span> (s.ok() &amp;&amp; left &gt; 0); <span class="comment">// Loop until all data is written or error</span></div>
<div class="line">  <span class="keywordflow">return</span> s;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Simplified - Writes header (checksum, length, type) and payload</span></div>
<div class="line">Status Writer::EmitPhysicalRecord(RecordType t, <span class="keyword">const</span> <span class="keywordtype">char</span>* ptr, <span class="keywordtype">size_t</span> length) {</div>
<div class="line">  <span class="comment">// ... format header (buf) with checksum, length, type ...</span></div>
<div class="line">  <span class="comment">// ... compute checksum ...</span></div>
<div class="line">  <span class="comment">// ... Encode checksum into header ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Write header and payload fragment</span></div>
<div class="line">  Status s = dest_-&gt;Append(Slice(buf, kHeaderSize));</div>
<div class="line">  <span class="keywordflow">if</span> (s.ok()) {</div>
<div class="line">    s = dest_-&gt;Append(Slice(ptr, length));</div>
<div class="line">    <span class="comment">// LevelDB might Flush() here or let the caller Sync() later</span></div>
<div class="line">  }</div>
<div class="line">  block_offset_ += kHeaderSize + length; <span class="comment">// Update position in current block</span></div>
<div class="line">  <span class="keywordflow">return</span> s;</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>The <code>AddRecord</code> method takes the user's data (<code>slice</code>) and potentially breaks it into smaller <code>fragment_length</code> chunks.</li>
<li>Each chunk is written as a "physical record" using <code>EmitPhysicalRecord</code>.</li>
<li><code>EmitPhysicalRecord</code> prepends a small header (<code>kHeaderSize</code>, 7 bytes) containing a checksum (for detecting corruption), the length of this fragment, and the <code>RecordType</code> (<code>kFullType</code>, <code>kFirstType</code>, <code>kMiddleType</code>, or <code>kLastType</code>).</li>
<li>The <code>RecordType</code> tells the <code>LogReader</code> later how to reassemble these fragments back into the original complete record.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2276"></a>
LogReader: Reading the Log for Recovery</h2>
<p>The counterpart to <code>LogWriter</code> is <code>log::Reader</code>. This is the component used during database startup (recovery) to read the records back from a WAL file. Think of it as the person carefully reading the ship's logbook after an incident.</p>
<p>The <code>log::Reader</code> reads the log file sequentially, block by block. It parses the physical record headers, verifies checksums, and pieces together the fragments (<code>kFirstType</code>, <code>kMiddleType</code>, <code>kLastType</code>) to reconstruct the original data records that were passed to <code>AddRecord</code>.</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/db_impl.cc ---</span></div>
<div class="line"><span class="comment">// Inside DBImpl::RecoverLogFile(...)</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create the log reader for the specific log file number</span></div>
<div class="line">std::string fname = LogFileName(dbname_, log_number);</div>
<div class="line">SequentialFile* file;</div>
<div class="line">Status status = env_-&gt;NewSequentialFile(fname, &amp;file);</div>
<div class="line"><span class="comment">// ... check status ...</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Set up reporter for corruption errors</span></div>
<div class="line">log::Reader::Reporter reporter;</div>
<div class="line"><span class="comment">// ... initialize reporter ...</span></div>
<div class="line">log::Reader reader(file, &amp;reporter, <span class="keyword">true</span> <span class="comment">/*checksum*/</span>, 0 <span class="comment">/*initial_offset*/</span>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Read records one by one and apply them to a temporary MemTable</span></div>
<div class="line">std::string scratch;</div>
<div class="line">Slice record;</div>
<div class="line">WriteBatch batch;</div>
<div class="line">MemTable* mem = <span class="keyword">new</span> MemTable(internal_comparator_);</div>
<div class="line">mem-&gt;Ref();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (reader.ReadRecord(&amp;record, &amp;scratch) &amp;&amp; status.ok()) {</div>
<div class="line">  <span class="comment">// record now holds a complete record originally passed to AddRecord</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Parse the record back into a WriteBatch</span></div>
<div class="line">  WriteBatchInternal::SetContents(&amp;batch, record);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Apply the operations from the batch to the MemTable</span></div>
<div class="line">  status = WriteBatchInternal::InsertInto(&amp;batch, mem);</div>
<div class="line">  <span class="comment">// ... check status ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Update the max sequence number seen</span></div>
<div class="line">  <span class="keyword">const</span> SequenceNumber last_seq = <span class="comment">/* ... get from batch ... */</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (last_seq &gt; *max_sequence) {</div>
<div class="line">    *max_sequence = last_seq;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Optional: If MemTable gets too big during recovery, flush it</span></div>
<div class="line">  <span class="keywordflow">if</span> (mem-&gt;ApproximateMemoryUsage() &gt; options_.write_buffer_size) {</div>
<div class="line">    status = WriteLevel0Table(mem, edit, <span class="keyword">nullptr</span>); <span class="comment">// Flush to SSTable</span></div>
<div class="line">    mem-&gt;Unref();</div>
<div class="line">    mem = <span class="keyword">new</span> MemTable(internal_comparator_);</div>
<div class="line">    mem-&gt;Ref();</div>
<div class="line">    <span class="comment">// ... check status ...</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">delete</span> <a class="code hl_variable" href="../../d8/dc3/namespaceupdate__mdx__section.html#a2b592aa898cb6a422bc0b4e038f9cebd">file</a>; <span class="comment">// Close the log file</span></div>
<div class="line"><span class="comment">// ... handle final MemTable (mem) if not null ...</span></div>
<div class="ttc" id="anamespaceupdate__mdx__section_html_a2b592aa898cb6a422bc0b4e038f9cebd"><div class="ttname"><a href="../../d8/dc3/namespaceupdate__mdx__section.html#a2b592aa898cb6a422bc0b4e038f9cebd">update_mdx_section.file</a></div><div class="ttdeci">file</div><div class="ttdef"><b>Definition</b> <a href="../../d2/d91/update__mdx__section_8py_source.html#l00138">update_mdx_section.py:138</a></div></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ol type="1">
<li>A <code>log::Reader</code> is created, pointing to the WAL file (<code>.log</code>) that needs recovery.</li>
<li>The code loops using <code>reader.ReadRecord(&amp;record, &amp;scratch)</code>.<ul>
<li><code>record</code>: This <code>Slice</code> will point to the reassembled data of the next complete logical record found in the log.</li>
<li><code>scratch</code>: A temporary string buffer the reader might use if a record spans multiple blocks.</li>
</ul>
</li>
<li>Inside the loop:<ul>
<li>The <code>record</code> (which contains a serialized <code>WriteBatch</code>) is parsed back into a <code>WriteBatch</code> object.</li>
<li><code>WriteBatchInternal::InsertInto(&amp;batch, mem)</code> applies the operations (Puts/Deletes) from the recovered batch to the in-memory <code>MemTable</code> (<code>mem</code>).</li>
<li>The code keeps track of the latest sequence number encountered.</li>
<li>Optionally, if the <code>MemTable</code> fills up <em>during</em> recovery, it can be flushed to an SSTable just like during normal operation.</li>
</ul>
</li>
<li>This continues until <code>ReadRecord</code> returns <code>false</code> (end of log file) or an error occurs.</li>
</ol>
<p>The <code>log::Reader::ReadRecord</code> implementation handles the details of reading blocks, finding headers, checking checksums, and combining <code>kFirstType</code>, <code>kMiddleType</code>, <code>kLastType</code> fragments.</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/log_reader.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reads the next complete logical record. Returns true if successful.</span></div>
<div class="line"><span class="keywordtype">bool</span> Reader::ReadRecord(Slice* record, std::string* scratch) {</div>
<div class="line">  <span class="comment">// ... skip records before initial_offset if necessary ...</span></div>
<div class="line"> </div>
<div class="line">  scratch-&gt;clear();</div>
<div class="line">  record-&gt;clear();</div>
<div class="line">  <span class="keywordtype">bool</span> in_fragmented_record = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  Slice fragment; <span class="comment">// To hold data from one physical record</span></div>
<div class="line">  <span class="keywordflow">while</span> (<span class="keyword">true</span>) {</div>
<div class="line">    <span class="comment">// Reads the next physical record (header + data fragment) from the file blocks.</span></div>
<div class="line">    <span class="comment">// Handles reading across block boundaries internally.</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> record_type = ReadPhysicalRecord(&amp;fragment);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ... handle resyncing logic after seeking ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">switch</span> (record_type) {</div>
<div class="line">      <span class="keywordflow">case</span> kFullType:</div>
<div class="line">        <span class="comment">// ... sanity check for unexpected fragments ...</span></div>
<div class="line">        *record = fragment; <span class="comment">// Got a complete record in one piece</span></div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> kFirstType:</div>
<div class="line">        <span class="comment">// ... sanity check for unexpected fragments ...</span></div>
<div class="line">        scratch-&gt;assign(fragment.data(), fragment.size()); <span class="comment">// Start of a new fragmented record</span></div>
<div class="line">        in_fragmented_record = <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> kMiddleType:</div>
<div class="line">        <span class="keywordflow">if</span> (!in_fragmented_record) { <span class="comment">/* Report corruption */</span> }</div>
<div class="line">        <span class="keywordflow">else</span> { scratch-&gt;append(fragment.data(), fragment.size()); } <span class="comment">// Append middle piece</span></div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> kLastType:</div>
<div class="line">        <span class="keywordflow">if</span> (!in_fragmented_record) { <span class="comment">/* Report corruption */</span> }</div>
<div class="line">        <span class="keywordflow">else</span> {</div>
<div class="line">          scratch-&gt;append(fragment.data(), fragment.size()); <span class="comment">// Append final piece</span></div>
<div class="line">          *record = Slice(*scratch); <span class="comment">// Reassembled record is complete</span></div>
<div class="line">          <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
<div class="line">        <span class="keywordflow">break</span>;</div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> kEof:</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>; <span class="comment">// End of log file</span></div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">case</span> kBadRecord:</div>
<div class="line">        <span class="comment">// ... report corruption, clear state ...</span></div>
<div class="line">        in_fragmented_record = <span class="keyword">false</span>;</div>
<div class="line">        scratch-&gt;clear();</div>
<div class="line">        <span class="keywordflow">break</span>; <span class="comment">// Try to find the next valid record</span></div>
<div class="line"> </div>
<div class="line">      <span class="keywordflow">default</span>:</div>
<div class="line">        <span class="comment">// ... report corruption ...</span></div>
<div class="line">        in_fragmented_record = <span class="keyword">false</span>;</div>
<div class="line">        scratch-&gt;clear();</div>
<div class="line">        <span class="keywordflow">break</span>; <span class="comment">// Try to find the next valid record</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li><code>ReadRecord</code> calls <code>ReadPhysicalRecord</code> repeatedly in a loop.</li>
<li><code>ReadPhysicalRecord</code> (internal helper, not shown in full) reads from the file, parses the 7-byte header, checks the CRC, and returns the type and the data fragment (<code>result</code>). It handles skipping block trailers and reading new blocks as needed.</li>
<li>Based on the <code>record_type</code>, <code>ReadRecord</code> either returns the complete record (<code>kFullType</code>), starts assembling fragments (<code>kFirstType</code>), appends fragments (<code>kMiddleType</code>), or finishes assembling and returns the record (<code>kLastType</code>).</li>
<li>It manages the <code>scratch</code> buffer to hold the fragments being assembled.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2277"></a>
Recovery Process Diagram</h2>
<p>Here's how the WAL is used during database startup if a crash occurred:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant App as Application Startup</div>
<div class="line">    participant LevelDB as DB::Open()</div>
<div class="line">    participant Env as Environment (OS/FS)</div>
<div class="line">    participant LogReader as log::Reader</div>
<div class="line">    participant MemTable as New MemTable (RAM)</div>
<div class="line"> </div>
<div class="line">    App-&gt;&gt;LevelDB: Open Database</div>
<div class="line">    LevelDB-&gt;&gt;Env: Check for CURRENT file, MANIFEST, etc.</div>
<div class="line">    LevelDB-&gt;&gt;Env: Look for .log files &gt;= Manifest LogNumber</div>
<div class="line">    alt Log file(s) found</div>
<div class="line">        LevelDB-&gt;&gt;LogReader : Create Reader for log file</div>
<div class="line">        loop Read Log Records</div>
<div class="line">            LogReader -&gt;&gt; Env: Read next block(s) from log file</div>
<div class="line">            Env--&gt;&gt;LogReader: Return data</div>
<div class="line">            LogReader -&gt;&gt; LogReader : Parse physical records, reassemble logical record</div>
<div class="line">            alt Record Found</div>
<div class="line">                LogReader --&gt;&gt; LevelDB: Return next record (WriteBatch data)</div>
<div class="line">                LevelDB -&gt;&gt; MemTable: Apply WriteBatch to MemTable</div>
<div class="line">            else End of Log or Error</div>
<div class="line">                LogReader --&gt;&gt; LevelDB: Indicate EOF / Error</div>
<div class="line">                Note right of LevelDB: Loop will exit</div>
<div class="line">            end</div>
<div class="line">        end</div>
<div class="line">        LevelDB -&gt;&gt; LogReader : Destroy Reader</div>
<div class="line">        Note right of LevelDB: MemTable now holds recovered state.</div>
<div class="line">    else No relevant log files</div>
<div class="line">        Note right of LevelDB: Clean shutdown or new DB. No log replay needed.</div>
<div class="line">    end</div>
<div class="line">    LevelDB--&gt;&gt;App: Database Opened Successfully</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2278"></a>
Conclusion</h2>
<p>The <b>Write-Ahead Log (WAL)</b> is a critical component for ensuring <b>durability</b> in LevelDB. By writing every operation to an append-only log file on disk <em>before</em> applying it to the in-memory <code>MemTable</code> and acknowledging the write, LevelDB guarantees that no acknowledged data is lost even if the server crashes.</p>
<ul>
<li>The <code>log::Writer</code> handles appending records to the current WAL file, dealing with block formatting and fragmentation.</li>
<li>The <code>log::Reader</code> handles reading records back from the WAL file during recovery, verifying checksums and reassembling fragmented records.</li>
<li>This recovery process replays the logged operations to rebuild the <code>MemTable</code> state that was lost in the crash.</li>
</ul>
<p>The WAL, MemTable, and SSTables work together: WAL provides fast durability for recent writes, MemTable provides fast access to those recent writes in memory, and SSTables provide persistent, sorted storage for the bulk of the data.</p>
<p>Now that we understand the core storage structures (SSTables, MemTable, WAL), we can start looking at how they are managed and coordinated.</p>
<p>Next up: <a class="el" href="../../df/dc9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_204__dbimpl.html">Chapter 4: DBImpl</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
