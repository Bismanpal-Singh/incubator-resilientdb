#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 08_compaction</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('df/d5d/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_208__compaction.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">08_compaction</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2300"></a>
autotoc_md2300</h2>
<p>layout: default title: "Compaction" parent: "LevelDB" </p>
<h2><a class="anchor" id="autotoc_md2301"></a>
nav_order: 8</h2>
<h1><a class="anchor" id="autotoc_md2302"></a>
Chapter 8: Compaction - Keeping the Library Tidy</h1>
<p>In <a class="el" href="../../d8/dd9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_207__iterator.html">Chapter 7: Iterator</a>, we saw how LevelDB provides iterators to give us a unified, sorted view of our data, cleverly merging information from the in-memory <a class="el" href="../../d4/de4/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_202__memtable.html">MemTable</a> and the various <a class="el" href="../../d2/dbb/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_201__table______sstable______tablecache.html">SSTable</a> files on disk.</p>
<p>This works great, but think about what happens over time. Every time a MemTable fills up, it gets flushed to a <em>new</em> SSTable file in Level-0. If you have lots of writes, you'll quickly accumulate many small files in Level-0. Also, when you update or delete a key, LevelDB doesn't modify old SSTables; it just writes a <em>new</em> entry (a new value or a deletion marker) in a newer MemTable or SSTable. This means older files contain outdated or deleted data that's just taking up space.</p>
<h2><a class="anchor" id="autotoc_md2303"></a>
What's the Problem? A Messy, Inefficient Library</h2>
<p>Imagine our library again. New notes and pamphlets (MemTable flushes) keep arriving and get dumped in a temporary pile (Level-0). Meanwhile, older books on the main shelves (higher levels) contain crossed-out paragraphs (deleted data) or outdated information (overwritten data).</p>
<p>This leads to several problems:</p>
<ol type="1">
<li><b>Slow Reads:</b> To find a specific piece of information, the librarian might have to check <em>many</em> different pamphlets in the temporary pile (Level-0) before even getting to the main shelves. Reading from many files is slow.</li>
<li><b>Wasted Space:</b> The library shelves are cluttered with books containing crossed-out sections or old editions that are no longer needed. This wastes valuable shelf space.</li>
<li><b>Growing Number of Files:</b> The temporary pile (Level-0) just keeps growing, making it harder and harder to manage.</li>
</ol>
<p>We need a process to periodically tidy up this library, organize the temporary pile into the main shelves, and remove the outdated information.</p>
<h2><a class="anchor" id="autotoc_md2304"></a>
Compaction: The Background Tidy-Up Crew</h2>
<p><b>Compaction</b> is LevelDB's background process that solves these problems. It's like the library staff who work quietly behind the scenes to keep the library organized and efficient.</p>
<p>Here's what compaction does:</p>
<ol type="1">
<li><b>Selects Files:</b> It picks one or more SSTable files from a specific level (let's say Level-N). Often, this starts with files in Level-0.</li>
<li><b>Finds Overlapping Files:</b> It identifies the files in the <em>next</em> level (Level-N+1) whose key ranges overlap with the selected files from Level-N.</li>
<li><b>Merges and Filters:</b> It reads the key-value pairs from <em>all</em> these selected files (from both Level-N and Level-N+1) using iterators, much like the merging process we saw in <a class="el" href="../../d8/dd9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_207__iterator.html">Chapter 7: Iterator</a>. As it merges, it performs crucial filtering:<ul>
<li>It keeps only the <em>latest</em> version of each key (based on sequence numbers).</li>
<li>It completely discards keys that have been deleted.</li>
<li>It discards older versions of keys that have been updated.</li>
</ul>
</li>
<li><b>Writes New Files:</b> It writes the resulting stream of filtered, sorted key-value pairs into <em>new</em> SSTable files at Level-N+1. These new files are typically larger and contain only live data.</li>
<li><b>Updates Catalog:</b> It updates the database's catalog (<a class="el" href="../../d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html">Version &amp; VersionSet</a>) to reflect the changes: the old input files (from Level-N and Level-N+1) are marked for deletion, and the new output files (in Level-N+1) are added.</li>
<li><b>Deletes Old Files:</b> Finally, the old, now-obsolete input SSTable files are deleted from the disk.</li>
</ol>
<p><b>Analogy:</b> The library staff takes a batch of pamphlets from the temporary pile (Level-0) and finds the corresponding books on the main shelves (Level-1). They go through both, creating a new, clean edition of the book (new Level-1 SSTable) that incorporates the new information from the pamphlets, removes any crossed-out entries, and keeps only the latest version of each topic. Then, they discard the original pamphlets and the old version of the book.</p>
<p>This process happens continuously in the background, keeping the database structure efficient.</p>
<h2><a class="anchor" id="autotoc_md2305"></a>
Triggering Compaction: When to Tidy Up?</h2>
<p>How does LevelDB decide when to run a compaction? The <a class="el" href="../../df/dc9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_204__dbimpl.html">DBImpl</a> checks if compaction is needed after writes or reads, or when background work finishes. It uses the <a class="el" href="../../d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html">VersionSet</a> to determine this, primarily based on two conditions:</p>
<ol type="1">
<li><b>Size Compaction:</b> Each level (except Level-0) has a target size limit. If the total size of files in a level exceeds its limit, the <code>VersionSet</code> calculates a "compaction score". If the score is &gt;= 1, a size compaction is needed. This is the most common trigger. Level-0 is special: it triggers compaction based on the <em>number</em> of files, not their total size, because too many files there significantly slows down reads.<ul>
<li><code>config::kL0_CompactionTrigger</code>: Default is 4 files.</li>
<li>Higher levels (1+): Trigger based on total bytes (<code>MaxBytesForLevel</code>).</li>
</ul>
</li>
<li><b>Seek Compaction:</b> To avoid performance issues caused by reading very wide (many keys) but shallow (few overwrites/deletions) files repeatedly, LevelDB tracks how many times a file is "seeked" during reads. If a file receives too many seeks (<code>allowed_seeks</code> counter drops to zero), it might be chosen for compaction even if the level size limit isn't reached. This helps rewrite files that are frequently accessed, potentially merging them or breaking them up.</li>
</ol>
<p>When <code>DBImpl::MaybeScheduleCompaction</code> detects that work is needed (and no other background work is running), it schedules the <code>DBImpl::BGWork</code> function to run on a background thread.</p>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/db_impl.cc ---</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> DBImpl::MaybeScheduleCompaction() {</div>
<div class="line">  mutex_.AssertHeld(); <span class="comment">// Must hold lock to check/change state</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (background_compaction_scheduled_) {</div>
<div class="line">    <span class="comment">// Already scheduled</span></div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (shutting_down_.load(std::memory_order_acquire)) {</div>
<div class="line">    <span class="comment">// DB is closing</span></div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!bg_error_.ok()) {</div>
<div class="line">    <span class="comment">// Background error stopped activity</span></div>
<div class="line">  } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (imm_ == <span class="keyword">nullptr</span> &amp;&amp; <span class="comment">// No MemTable flush needed AND</span></div>
<div class="line">             manual_compaction_ == <span class="keyword">nullptr</span> &amp;&amp; <span class="comment">// No manual request AND</span></div>
<div class="line">             !versions_-&gt;NeedsCompaction()) { <span class="comment">// &lt;&lt;-- VersionSet check!</span></div>
<div class="line">    <span class="comment">// No work to be done: VersionSet says size/seek limits are okay.</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Work needs to be done! Schedule it.</span></div>
<div class="line">    background_compaction_scheduled_ = <span class="keyword">true</span>;</div>
<div class="line">    env_-&gt;Schedule(&amp;DBImpl::BGWork, <span class="keyword">this</span>); <span class="comment">// Ask Env to run BGWork later</span></div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// --- Simplified from db/version_set.h ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// In VersionSet::NeedsCompaction()</span></div>
<div class="line"><span class="keywordtype">bool</span> NeedsCompaction()<span class="keyword"> const </span>{</div>
<div class="line">  Version* v = current_;</div>
<div class="line">  <span class="comment">// Check score (size trigger) OR if a file needs compaction due to seeks</span></div>
<div class="line">  <span class="keywordflow">return</span> (v-&gt;compaction_score_ &gt;= 1) || (v-&gt;file_to_compact_ != <span class="keyword">nullptr</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2306"></a>
The Compaction Process: A Closer Look</h2>
<p>Let's break down the steps involved when a background compaction runs (specifically a major compaction between levels N and N+1):</p>
<p><b>1. Picking the Compaction (<code>VersionSet::PickCompaction</code>)</b></p>
<p>The first step is deciding <em>what</em> to compact. <code>VersionSet::PickCompaction</code> is responsible for this:</p>
<ul>
<li>It checks if a seek-based compaction is pending (<code>file_to_compact_ != nullptr</code>). If so, it chooses that file and its level.</li>
<li>Otherwise, it looks at the <code>compaction_score_</code> and <code>compaction_level_</code> pre-calculated for the current <a class="el" href="../../d2/d8f/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_206__version______versionset.html">Version</a>. If the score is &gt;= 1, it chooses that level for a size-based compaction.</li>
<li>It creates a <code>Compaction</code> object to hold information about this task.</li>
<li>It selects an initial set of files from the chosen level (Level-N) to compact. For size compactions, it often picks the file just after the <code>compact_pointer_</code> for that level (a bookmark remembering where the last compaction ended) to ensure work spreads across the key range over time.</li>
<li>For Level-0, since files can overlap, it expands this initial set to include <em>all</em> Level-0 files that overlap with the initially chosen file(s).</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// --- Simplified from db/version_set.cc ---</span></div>
<div class="line"> </div>
<div class="line">Compaction* VersionSet::PickCompaction() {</div>
<div class="line">  Compaction* c = <span class="keyword">nullptr</span>;</div>
<div class="line">  <span class="keywordtype">int</span> level;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Check for seek-triggered compaction first</span></div>
<div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span> seek_compaction = (current_-&gt;file_to_compact_ != <span class="keyword">nullptr</span>);</div>
<div class="line">  <span class="keywordflow">if</span> (seek_compaction) {</div>
<div class="line">    level = current_-&gt;file_to_compact_level_;</div>
<div class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</div>
<div class="line">    c-&gt;inputs_[0].push_back(current_-&gt;file_to_compact_); <span class="comment">// Add the specific file</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Check for size-triggered compaction</span></div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span> size_compaction = (current_-&gt;compaction_score_ &gt;= 1);</div>
<div class="line">    <span class="keywordflow">if</span> (!size_compaction) {</div>
<div class="line">      <span class="keywordflow">return</span> <span class="keyword">nullptr</span>; <span class="comment">// No compaction needed</span></div>
<div class="line">    }</div>
<div class="line">    <a class="code hl_variable" href="../../d7/d70/namespaceresilient__python__cache_1_1cache.html#a2ffd04c52c557ee2bffcd2fe8449182b">level</a> = current_-&gt;compaction_level_;</div>
<div class="line">    c = <span class="keyword">new</span> Compaction(options_, level);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Pick starting file in chosen level (often based on compact_pointer_)</span></div>
<div class="line">    <span class="comment">// ... logic to select initial file(s) ...</span></div>
<div class="line">    <span class="comment">// c-&gt;inputs_[0].push_back(chosen_file);</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  c-&gt;input_version_ = current_; <span class="comment">// Remember which Version we are compacting</span></div>
<div class="line">  c-&gt;input_version_-&gt;Ref();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Expand Level-0 inputs if necessary due to overlap</span></div>
<div class="line">  <span class="keywordflow">if</span> (level == 0) {</div>
<div class="line">    InternalKey smallest, largest;</div>
<div class="line">    GetRange(c-&gt;inputs_[0], &amp;smallest, &amp;largest); <span class="comment">// Find range of initial file(s)</span></div>
<div class="line">    <span class="comment">// Find ALL L0 files overlapping that range</span></div>
<div class="line">    current_-&gt;GetOverlappingInputs(0, &amp;smallest, &amp;largest, &amp;c-&gt;inputs_[0]);</div>
<div class="line">    assert(!c-&gt;inputs_[0].empty());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Now figure out the overlapping files in the next level (Level+1)</span></div>
<div class="line">  SetupOtherInputs(c);</div>
<div class="line">  <span class="keywordflow">return</span> c;</div>
<div class="line">}</div>
<div class="ttc" id="anamespaceresilient__python__cache_1_1cache_html_a2ffd04c52c557ee2bffcd2fe8449182b"><div class="ttname"><a href="../../d7/d70/namespaceresilient__python__cache_1_1cache.html#a2ffd04c52c557ee2bffcd2fe8449182b">resilient_python_cache.cache.level</a></div><div class="ttdeci">level</div><div class="ttdef"><b>Definition</b> <a href="../../da/dd2/cache_8py_source.html#l00035">cache.py:35</a></div></div>
</div><!-- fragment --><p><b>2. Setting Up Inputs (<code>VersionSet::SetupOtherInputs</code>)</b></p>
<p>Once the initial Level-N files are chosen, <code>SetupOtherInputs</code> figures out the rest:</p>
<ul>
<li>It determines the smallest and largest keys covered by the Level-N input files.</li>
<li>It finds all files in Level-(N+1) that overlap this key range. These become <code>c-&gt;inputs_[1]</code>.</li>
<li>It might slightly expand the Level-N inputs if doing so allows including more Level-N files without pulling in any <em>additional</em> Level-(N+1) files (this can make compactions more efficient).</li>
<li>It finds all files in Level-(N+2) that overlap the <em>total</em> key range of the compaction. These are the "grandparents". This is important to prevent creating huge files in Level-(N+1) that would overlap too much data in Level-(N+2), making future compactions expensive.</li>
</ul>
<p><b>3. Performing the Work (<code>DBImpl::DoCompactionWork</code>)</b></p>
<p>This is where the main merging happens. It runs on the background thread, and importantly, it <b>releases the main database lock</b> (<code>mutex_.Unlock()</code>) while doing the heavy I/O.</p>
<ul>
<li><b>Input Iterator:</b> Creates a <code>MergingIterator</code> (<a class="el" href="../../d8/dd9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_207__iterator.html">Chapter 7: Iterator</a>) that reads from all input files (Level-N and Level-N+1) as a single sorted stream (<code>versions_-&gt;MakeInputIterator(compact)</code>).</li>
<li><b>Snapshot:</b> Determines the oldest sequence number needed by any existing snapshot (<code>compact-&gt;smallest_snapshot</code>). Entries older than this can potentially be dropped even if not deleted.</li>
<li><b>Loop:</b> Iterates through the <code>MergingIterator</code>:<ul>
<li>Reads the next internal key/value.</li>
<li><b>Parses Key:</b> Extracts user key, sequence number, and type.</li>
<li><b>Checks for Stop:</b> Decides if the current output file should be finished and a new one started (e.g., due to size limits or too much overlap with grandparents).</li>
<li><b>Drop Logic:</b> Determines if the current entry should be dropped:<ul>
<li>Is it a deletion marker for a key that has no older data in lower levels (<code>IsBaseLevelForKey</code>) and is older than the oldest snapshot? (Obsolete deletion marker).</li>
<li>Is it an entry for a key where we've already seen a <em>newer</em> entry during this same compaction?</li>
<li>Is it older than the <code>smallest_snapshot</code> AND we've already seen a newer entry for this key (even if that newer entry was also dropped)?</li>
</ul>
</li>
<li><b>Keep Logic:</b> If the entry is not dropped:<ul>
<li>Opens a new output SSTable file in Level-(N+1) if one isn't already open (<code>OpenCompactionOutputFile</code>).</li>
<li>Adds the key/value pair to the <code>TableBuilder</code> (<code>compact-&gt;builder-&gt;Add</code>).</li>
<li>Updates the smallest/largest keys for the output file metadata.</li>
<li>Closes the output file if it reaches the target size (<code>FinishCompactionOutputFile</code>).</li>
</ul>
</li>
<li>Moves to the next input entry (<code>input-&gt;Next()</code>).</li>
</ul>
</li>
<li><b>Finish:</b> Writes the last output file.</li>
<li><b>Status:</b> Checks for errors from the input iterator or file writes.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// --- Highly simplified loop from db/db_impl.cc DoCompactionWork ---</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create iterator over Level-N and Level-N+1 input files</span></div>
<div class="line">Iterator* input = versions_-&gt;MakeInputIterator(compact-&gt;compaction);</div>
<div class="line">input-&gt;SeekToFirst();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... Release Mutex ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">while</span> (input-&gt;Valid() &amp;&amp; !shutting_down_) {</div>
<div class="line">  Slice key = input-&gt;key();</div>
<div class="line">  Slice value = input-&gt;value();</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Should we finish the current output file and start a new one?</span></div>
<div class="line">  <span class="keywordflow">if</span> (compact-&gt;compaction-&gt;ShouldStopBefore(key) &amp;&amp; compact-&gt;builder != <span class="keyword">nullptr</span>) {</div>
<div class="line">    status = FinishCompactionOutputFile(compact, input);</div>
<div class="line">    <span class="comment">// ... handle status ...</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Should we drop this key/value pair?</span></div>
<div class="line">  <span class="keywordtype">bool</span> drop = <span class="keyword">false</span>;</div>
<div class="line">  <span class="keywordflow">if</span> (ParseInternalKey(key, &amp;ikey)) {</div>
<div class="line">      <span class="comment">// Logic based on ikey.sequence, ikey.type, smallest_snapshot,</span></div>
<div class="line">      <span class="comment">// last_sequence_for_key, IsBaseLevelForKey...</span></div>
<div class="line">      <span class="comment">// drop = true if this entry is deleted, shadowed, or obsolete.</span></div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">      <span class="comment">// Corrupt key? Maybe keep it? (See actual code for details)</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!drop) {</div>
<div class="line">    <span class="comment">// Open output file if needed</span></div>
<div class="line">    <span class="keywordflow">if</span> (compact-&gt;builder == <span class="keyword">nullptr</span>) {</div>
<div class="line">      status = OpenCompactionOutputFile(compact);</div>
<div class="line">      <span class="comment">// ... handle status ...</span></div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Add key/value to the output file being built</span></div>
<div class="line">    compact-&gt;builder-&gt;Add(key, value);</div>
<div class="line">    <span class="comment">// ... update output file metadata (smallest/largest key) ...</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Close output file if it&#39;s big enough</span></div>
<div class="line">    <span class="keywordflow">if</span> (compact-&gt;builder-&gt;FileSize() &gt;= compact-&gt;compaction-&gt;MaxOutputFileSize()) {</div>
<div class="line">      status = FinishCompactionOutputFile(compact, input);</div>
<div class="line">      <span class="comment">// ... handle status ...</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Advance to the next key in the merged input stream</span></div>
<div class="line">  input-&gt;Next();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... Finish the last output file ...</span></div>
<div class="line"><span class="comment">// ... Check input iterator status ...</span></div>
<div class="line"><span class="keyword">delete</span> input;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ... Re-acquire Mutex ...</span></div>
</div><!-- fragment --><p><b>4. Installing Results (<code>DBImpl::InstallCompactionResults</code>)</b></p>
<p>If the compaction work finished successfully:</p>
<ul>
<li>A <code>VersionEdit</code> is created.</li>
<li>It records the deletion of all input files (from Level-N and Level-N+1).</li>
<li>It records the addition of all the newly created output files (in Level-N+1), including their file numbers, sizes, and key ranges.</li>
<li><code>VersionSet::LogAndApply</code> is called to:<ul>
<li>Write the <code>VersionEdit</code> to the <code>MANIFEST</code> file.</li>
<li>Create a new <code>Version</code> reflecting these changes.</li>
<li>Make this new <code>Version</code> the <code>current</code> one.</li>
</ul>
</li>
</ul>
<p><b>5. Cleaning Up (<code>DBImpl::RemoveObsoleteFiles</code>)</b></p>
<p>After the new <code>Version</code> is successfully installed:</p>
<ul>
<li><code>DBImpl</code> calls <code>RemoveObsoleteFiles</code>.</li>
<li>This function gets the list of all files needed by <em>any</em> live <code>Version</code> (including those held by snapshots or iterators).</li>
<li>It compares this list with the actual files in the database directory.</li>
<li>Any file that exists on disk but is <em>not</em> in the live set (like the input files from the just-completed compaction) is deleted from the filesystem.</li>
</ul>
<p><b>Compaction Flow Diagram:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant DBImplBG as Background Thread</div>
<div class="line">    participant VS as VersionSet</div>
<div class="line">    participant Version as Current Version</div>
<div class="line">    participant InputIter as Merging Iterator</div>
<div class="line">    participant Builder as TableBuilder</div>
<div class="line">    participant Manifest as MANIFEST Log</div>
<div class="line">    participant FS as File System</div>
<div class="line"> </div>
<div class="line">    DBImplBG-&gt;&gt;VS: PickCompaction()</div>
<div class="line">    VS-&gt;&gt;Version: Find files based on score/seeks</div>
<div class="line">    VS--&gt;&gt;DBImplBG: Return Compaction object &#39;c&#39;</div>
<div class="line">    DBImplBG-&gt;&gt;VS: MakeInputIterator(c)</div>
<div class="line">    VS-&gt;&gt;Version: Get iterators for input files (L-N, L-N+1)</div>
<div class="line">    VS--&gt;&gt;DBImplBG: Return InputIter</div>
<div class="line">    DBImplBG-&gt;&gt;InputIter: SeekToFirst()</div>
<div class="line">    Note over DBImplBG: Releases DB Mutex</div>
<div class="line">    loop While InputIter.Valid()</div>
<div class="line">        DBImplBG-&gt;&gt;InputIter: key(), value()</div>
<div class="line">        alt Keep Entry</div>
<div class="line">            DBImplBG-&gt;&gt;Builder: Open File / Add(key, value)</div>
<div class="line">            DBImplBG-&gt;&gt;Builder: Finish File if needed</div>
<div class="line">        else Drop Entry</div>
<div class="line">            Note over DBImplBG: Skip Add() call</div>
<div class="line">        end</div>
<div class="line">        DBImplBG-&gt;&gt;InputIter: Next()</div>
<div class="line">    end</div>
<div class="line">    Note over DBImplBG: Re-acquires DB Mutex</div>
<div class="line">    DBImplBG-&gt;&gt;VS: LogAndApply(edit describing changes)</div>
<div class="line">    VS-&gt;&gt;Manifest: AddRecord(edit)</div>
<div class="line">    Manifest--&gt;&gt;VS: OK</div>
<div class="line">    VS-&gt;&gt;VS: Create New Version, make it current</div>
<div class="line">    VS--&gt;&gt;DBImplBG: OK</div>
<div class="line">    DBImplBG-&gt;&gt;DBImplBG: RemoveObsoleteFiles()</div>
<div class="line">    DBImplBG-&gt;&gt;FS: Delete old input SSTables</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md2307"></a>
Conclusion</h2>
<p>Compaction is the essential background process that keeps LevelDB performant and prevents space usage from growing indefinitely due to old data. It intelligently merges files between levels, filtering out deleted and overwritten entries while preserving a consistent view for readers.</p>
<ul>
<li>It's triggered by level size or file access patterns.</li>
<li>It uses iterators to merge input files efficiently.</li>
<li>It drops obsolete data based on sequence numbers and deletion markers.</li>
<li>It writes new, clean SSTable files to the next level.</li>
<li>It atomically updates the database state using <code>VersionEdit</code>s, the <code>MANIFEST</code>, and the <code>VersionSet</code>.</li>
</ul>
<p>Understanding compaction helps explain how LevelDB achieves good performance despite its append-only (immutable SSTable) design.</p>
<p>But how does LevelDB manage those sequence numbers and deletion markers internally? How does it combine a user's key with this metadata?</p>
<p>Next up: <a class="el" href="../../d6/d38/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LevelDB_209__internalkey______dbformat.html">Chapter 9: InternalKey &amp; DBFormat</a></p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
