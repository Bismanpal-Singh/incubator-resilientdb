#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 06_pythonexecutor</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('df/dec/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_206__pythonexecutor.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">06_pythonexecutor</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md3126"></a>
autotoc_md3126</h2>
<p>layout: default title: "PythonExecutor" parent: "SmolaAgents" </p>
<h2><a class="anchor" id="autotoc_md3127"></a>
nav_order: 6</h2>
<h1><a class="anchor" id="autotoc_md3128"></a>
Chapter 6: PythonExecutor - Running Code Safely</h1>
<p>Welcome back! In <a class="el" href="../../d3/d9e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_205__prompttemplates.html">Chapter 5: PromptTemplates</a>, we saw how agents use templates to create clear instructions for their LLM brain. These instructions often involve asking the LLM to generate code, especially for agents like <code>CodeAgent</code>, which are designed to solve problems by writing and running Python.</p>
<p>But wait... running code generated by an AI? Isn't that risky? What if the AI generates code that tries to delete your files, access sensitive information, or just crashes?</p>
<p>This is a very valid concern! You wouldn't want an AI assistant to accidentally (or intentionally!) cause harm to your computer. We need a secure way to run this generated code.</p>
<p>This is exactly the problem the <b><code>PythonExecutor</code></b> solves!</p>
<h2><a class="anchor" id="autotoc_md3129"></a>
The Problem: Running Untrusted Code</h2>
<p>Imagine you have a brilliant but slightly unpredictable scientist (the <code>CodeAgent</code>) who comes up with new experiments (Python code snippets) to solve problems. You want the results of these experiments, but you can't let the scientist run them directly in your main lab (your computer) because they might spill dangerous chemicals or break expensive equipment.</p>
<p><img src="https://img.icons8.com/external-flaticons-lineal-color-flat-icons/64/external-scientist-professions-man-flaticons-lineal-color-flat-icons-3.png" alt="Risky Scientist" class="inline"/> ‚û°Ô∏è üî•üíª (Danger!)</p>
<p>Directly executing AI-generated code is like letting that unpredictable scientist run wild. We need a controlled environment.</p>
<h2><a class="anchor" id="autotoc_md3130"></a>
The Solution: The Secure Laboratory (<code>PythonExecutor</code>)</h2>
<p>The <code>PythonExecutor</code> acts like a <b>secure, isolated laboratory</b> or a <b>sandbox</b> for the code generated by the <code>CodeAgent</code>.</p>
<p><img src="https://img.icons8.com/external-flaticons-flat-flat-icons/64/external-laboratory-science-flaticons-flat-flat-icons.png" alt="Safe Lab" class="inline"/> &lt;-&gt; üë®‚Äçüî¨ CodeAgent</p>
<p>Think of it this way:</p>
<ol type="1">
<li><b>Isolation:</b> The <code>PythonExecutor</code> creates a safe space, separate from your main system, where the code can run. If the code tries to do something harmful, the damage is contained within this sandbox and doesn't affect your computer.</li>
<li><b>Execution:</b> It takes the Python code snippet provided by the <code>CodeAgent</code> and runs it within this safe environment.</li>
<li><b>State Management:</b> Just like a real lab keeps track of ongoing experiments, the <code>PythonExecutor</code> can remember variables and the state <em>between</em> different code snippets run in sequence. If one snippet calculates <code>x = 5</code>, the next snippet run by the same executor will know the value of <code>x</code>.</li>
<li><b>Capture Results:</b> It carefully observes what happens inside the sandbox, capturing any output produced by the code (like results from <code>print()</code> statements) and the final result of the code snippet.</li>
<li><b>Handle Errors:</b> If the code crashes or produces an error, the <code>PythonExecutor</code> catches the error message instead of letting it crash the whole agent.</li>
</ol>
<p>Essentially, the <code>PythonExecutor</code> allows the <code>CodeAgent</code> to "run experiments" safely and report back the findings (or failures) without endangering the outside world.</p>
<h2><a class="anchor" id="autotoc_md3131"></a>
How Does the <code>CodeAgent</code> Use It? (Mostly Automatic!)</h2>
<p>For beginners, the great news is that the <code>CodeAgent</code> handles the <code>PythonExecutor</code> automatically! When you create a <code>CodeAgent</code>, it usually sets up a <code>PythonExecutor</code> behind the scenes.</p>
<div class="fragment"><div class="line"><span class="comment"># --- File: create_code_agent.py ---</span></div>
<div class="line"><span class="keyword">from</span> smolagents <span class="keyword">import</span> CodeAgent</div>
<div class="line"><span class="keyword">from</span> smolagents.models <span class="keyword">import</span> LiteLLMModel <span class="comment"># From Chapter 2</span></div>
<div class="line"><span class="comment"># Assume we have some tools defined, maybe a search tool</span></div>
<div class="line"><span class="keyword">from</span> smolagents.tools <span class="keyword">import</span> DuckDuckGoSearchTool</div>
<div class="line"> </div>
<div class="line">search_tool = DuckDuckGoSearchTool()</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Choose a language model</span></div>
<div class="line">llm = LiteLLMModel(model_id=<span class="stringliteral">&quot;gpt-4-turbo&quot;</span>) <span class="comment"># Needs API key setup</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create the CodeAgent</span></div>
<div class="line"><span class="comment"># It automatically creates a PythonExecutor internally!</span></div>
<div class="line">agent = CodeAgent(</div>
<div class="line">    model=llm,</div>
<div class="line">    tools=[search_tool],</div>
<div class="line">    <span class="comment"># By default, executor_type=&quot;local&quot; is used</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">print(<span class="stringliteral">&quot;CodeAgent created with an internal PythonExecutor.&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Now, when you run the agent:</span></div>
<div class="line"><span class="comment"># task = &quot;Calculate the square root of 1764 and tell me the result.&quot;</span></div>
<div class="line"><span class="comment"># result = agent.run(task)</span></div>
<div class="line"><span class="comment"># print(f&quot;Result: {result}&quot;)</span></div>
<div class="line"><span class="comment"># --&gt; The agent will generate code like &quot;import math; result = math.sqrt(1764); final_answer(result)&quot;</span></div>
<div class="line"><span class="comment"># --&gt; It will pass this code to its PythonExecutor to run safely.</span></div>
<div class="line"><span class="comment"># --&gt; The executor runs it, captures the result (42.0), and returns it to the agent.</span></div>
<div class="line"><span class="comment"># --&gt; The agent then uses the final_answer tool.</span></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>When we create <code>CodeAgent</code>, we don't explicitly create a <code>PythonExecutor</code>. The <code>CodeAgent</code>'s initialization logic does this for us.</li>
<li>By default, it uses a <code>LocalPythonExecutor</code>, which runs the code in a restricted local environment.</li>
<li>When <code>agent.run()</code> is called, and the LLM generates Python code, the <code>CodeAgent</code> automatically passes that code to its internal <code>python_executor</code> instance for execution.</li>
</ul>
<h2><a class="anchor" id="autotoc_md3132"></a>
Local vs. Remote Execution</h2>
<p><code>SmolaAgents</code> offers different types of executors for varying levels of security and environment needs:</p>
<ol type="1">
<li><b><code>LocalPythonExecutor</code> (Default):</b><ul>
<li>Runs the code within the same Python process as your agent, but uses clever techniques (like parsing the code's Abstract Syntax Tree - AST) to restrict dangerous operations (like file system access or arbitrary imports).</li>
<li>It's the simplest to set up (usually requires no extra installation).</li>
<li>It's generally safe for many tasks, but a very complex or malicious piece of code <em>might</em> potentially find ways around the restrictions (though this is difficult).</li>
</ul>
</li>
<li><b><code>DockerExecutor</code>:</b><ul>
<li>Runs the code inside a separate Docker container. Docker provides strong isolation from your main system.</li>
<li>Requires Docker to be installed and running on your machine.</li>
<li>Offers better security than the local executor.</li>
</ul>
</li>
<li><b><code>E2BExecutor</code> (Environment-to-Behavior):</b><ul>
<li>Uses a cloud service (E2B.dev) to provide secure, sandboxed cloud environments for code execution.</li>
<li>Requires an E2B account and API key.</li>
<li>Offers very strong security and avoids needing Docker locally, but relies on an external service.</li>
</ul>
</li>
</ol>
<p><b>How to Choose?</b></p>
<ul>
<li><b>Beginners:</b> Stick with the default <code>LocalPythonExecutor</code>. It's usually sufficient and requires no extra setup.</li>
<li><b>Need Higher Security:</b> If you're running potentially riskier code or need stronger guarantees, consider <code>DockerExecutor</code> (if you have Docker) or <code>E2BExecutor</code>.</li>
</ul>
<p>You can specify the executor type when creating the <code>CodeAgent</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># Example: Using a Docker executor (if Docker is installed and running)</span></div>
<div class="line">docker_agent = CodeAgent(</div>
<div class="line">    model=llm,</div>
<div class="line">    tools=[search_tool],</div>
<div class="line">    executor_type=<span class="stringliteral">&quot;docker&quot;</span> <span class="comment"># Tell the agent to use Docker</span></div>
<div class="line">    <span class="comment"># You might need to pass executor_kwargs for specific configurations</span></div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Example: Using E2B (requires E2B setup and API key in environment)</span></div>
<div class="line"><span class="comment"># pip install &#39;smolagents[e2b]&#39;</span></div>
<div class="line">e2b_agent = CodeAgent(</div>
<div class="line">    model=llm,</div>
<div class="line">    tools=[search_tool],</div>
<div class="line">    executor_type=<span class="stringliteral">&quot;e2b&quot;</span> <span class="comment"># Tell the agent to use E2B</span></div>
<div class="line">)</div>
</div><!-- fragment --><p>For the rest of this chapter, we'll mostly focus on the concepts common to all executors, using the default <code>LocalPythonExecutor</code> as the main example.</p>
<h2><a class="anchor" id="autotoc_md3133"></a>
Under the Hood: How Execution Works</h2>
<p>Let's trace what happens when <code>CodeAgent</code> decides to run a piece of code:</p>
<ol type="1">
<li><b>Agent (Think):</b> The LLM generates a response containing Python code, like: <code>python @section autotoc_md3134 Thought: I need to calculate 5 * 10. result = 5 * 10 print(f"The intermediate result is: {result}") final_answer(result) </code></li>
<li><b>Agent (Act - Parse):</b> The <code>CodeAgent</code> extracts the Python code block.</li>
<li><b>Agent (Act - Execute):</b> The <code>CodeAgent</code> calls its <code>python_executor</code> instance, passing the code string. <code>output, logs, is_final = self.python_executor(code_string)</code></li>
<li><b>Executor (Prepare):</b> The <code>PythonExecutor</code> (e.g., <code>LocalPythonExecutor</code>) gets ready. It knows the current state (variables defined in previous steps).</li>
<li><b>Executor (Run Safely):</b><ul>
<li><code>LocalPythonExecutor</code>: Parses the code into an Abstract Syntax Tree (AST). It walks through the tree, evaluating allowed operations (math, variable assignments, safe function calls) and blocking dangerous ones (like <code>os.system</code>). It executes the code within the current <code>state</code>.</li>
<li><code>DockerExecutor</code>/<code>E2BExecutor</code>: Sends the code to the remote environment (Docker container or E2B sandbox) for execution.</li>
</ul>
</li>
<li><b>Executor (Capture):</b> It intercepts any output sent to <code>print()</code> (captured in <code>logs</code>) and gets the final value returned by the code block (if any, captured in <code>output</code>). It also checks if the special <code>final_answer()</code> function was called (indicated by <code>is_final</code>).</li>
<li><b>Executor (Update State):</b> If the code assigned variables (like <code>result = 50</code>), the executor updates its internal <code>state</code> dictionary.</li>
<li><b>Agent (Observe):</b> The <code>CodeAgent</code> receives the <code>output</code>, <code>logs</code>, and <code>is_final</code> flag from the executor. This becomes the "Observation" for the current step. If <code>is_final</code> is true, the agent knows the task is complete.</li>
</ol>
<p><b>Diagram:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Agent as CodeAgent</div>
<div class="line">    participant Executor as PythonExecutor (e.g., Local)</div>
<div class="line">    participant SafeEnv as Safe Execution Env (AST walk / Docker / E2B)</div>
<div class="line">    participant State as Executor State</div>
<div class="line"> </div>
<div class="line">    Agent-&gt;&gt;Executor: execute(code_string)</div>
<div class="line">    Executor-&gt;&gt;State: Get current variables</div>
<div class="line">    Executor-&gt;&gt;SafeEnv: Run code_string safely</div>
<div class="line">    SafeEnv-&gt;&gt;SafeEnv: Execute line by line (e.g., result = 5 * 10)</div>
<div class="line">    SafeEnv--&gt;&gt;State: Update variable &#39;result&#39; = 50</div>
<div class="line">    SafeEnv-&gt;&gt;Executor: Capture print() output (&quot;The intermediate result is: 50&quot;)</div>
<div class="line">    SafeEnv-&gt;&gt;Executor: Capture final result (50)</div>
<div class="line">    SafeEnv-&gt;&gt;Executor: Indicate if final_answer() was called</div>
<div class="line">    Executor--&gt;&gt;Agent: Return: output=50, logs=&quot;...&quot;, is_final=True</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3135"></a>
Code Glimpse: Where is the Executor Used?</h2>
<p>Let's look at simplified snippets showing the key interactions.</p>
<ul>
<li><p class="startli"><b><code>CodeAgent</code> Initialization (<code>agents.py</code>):</b> Creates the executor instance.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3136"></a>
&mdash; File: agents.py (Simplified CodeAgent <b>init</b>) &mdash;</h1>
<p>from .local_python_executor import LocalPythonExecutor, PythonExecutor from .remote_executors import DockerExecutor, E2BExecutor</p>
<p>class CodeAgent(MultiStepAgent): def <b>init</b>( self, </p>
<h1><a class="anchor" id="autotoc_md3137"></a>
... model, tools, etc. ...</h1>
<p>executor_type: str | None = "local", # Default is local executor_kwargs: Optional[Dict[str, Any]] = None, additional_authorized_imports: Optional[List[str]] = None, max_print_outputs_length: Optional[int] = None, </p>
<h1><a class="anchor" id="autotoc_md3138"></a>
... other kwargs ...</h1>
<p>): </p>
<h1><a class="anchor" id="autotoc_md3139"></a>
... setup basic agent parts ...</h1>
<p>self.executor_type = executor_type or "local" self.executor_kwargs = executor_kwargs or {} self.additional_authorized_imports = additional_authorized_imports or [] self.max_print_outputs_length = max_print_outputs_length</p>
<h1><a class="anchor" id="autotoc_md3140"></a>
Create the appropriate executor instance based on type</h1>
<p>self.python_executor: PythonExecutor = self.create_python_executor()</p>
<h1><a class="anchor" id="autotoc_md3141"></a>
... rest of setup ...</h1>
<h1><a class="anchor" id="autotoc_md3142"></a>
Send initial state/tools to executor if needed</h1>
<p>if getattr(self, "python_executor", None): self.python_executor.send_variables(variables=self.state) self.python_executor.send_tools({**self.tools, **self.managed_agents})</p>
<pre class="fragment">    def create_python_executor(self) -&gt; PythonExecutor:
        """Helper method to create the executor instance."""
        match self.executor_type:
            case "e2b":
                return E2BExecutor(self.additional_authorized_imports, self.logger, **self.executor_kwargs)
            case "docker":
                return DockerExecutor(self.additional_authorized_imports, self.logger, **self.executor_kwargs)
            case "local":
                return LocalPythonExecutor(
                    self.additional_authorized_imports,
                    max_print_outputs_length=self.max_print_outputs_length,
                )
            case _:
                raise ValueError(f"Unsupported executor type: {self.executor_type}")
```
*   The `CodeAgent` takes `executor_type` and related arguments.
*   The `create_python_executor` method instantiates the correct class (`LocalPythonExecutor`, `DockerExecutor`, or `E2BExecutor`).
*   Initial tools and state might be sent to the executor using `send_tools` and `send_variables`.
</pre><ul>
<li><p class="startli"><b><code>CodeAgent</code> Step Execution (<code>agents.py</code>):</b> Uses the executor instance.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3143"></a>
&mdash; File: agents.py (Simplified CodeAgent step) &mdash;</h1>
<p>from .utils import parse_code_blobs # Helper to extract code from .local_python_executor import fix_final_answer_code # Helper</p>
<p>class CodeAgent(MultiStepAgent): def step(self, memory_step: ActionStep) -&gt; Union[None, Any]: </p>
<h1><a class="anchor" id="autotoc_md3144"></a>
... (Agent thinks, gets LLM response with code) ...</h1>
<p>model_output = chat_message.content</p>
<h1><a class="anchor" id="autotoc_md3145"></a>
Parse the code from the LLM response</h1>
<p>try: </p>
<h1><a class="anchor" id="autotoc_md3146"></a>
parse_code_blobs finds <code>python ...</code> blocks</h1>
<h1><a class="anchor" id="autotoc_md3147"></a>
fix_final_answer ensures <code>final_answer = x</code> becomes <code>final_answer(x)</code></h1>
<p>code_action = fix_final_answer_code(parse_code_blobs(model_output)) except Exception as e: </p>
<h1><a class="anchor" id="autotoc_md3148"></a>
Handle parsing errors</h1>
<p>raise AgentParsingError(...)</p>
<h1><a class="anchor" id="autotoc_md3149"></a>
=== Execute the code using the PythonExecutor ===</h1>
<p>self.logger.log_code(title="Executing parsed code:", content=code_action, ...) try: </p>
<h1><a class="anchor" id="autotoc_md3150"></a>
THE CORE CALL to the executor</h1>
<p>output, execution_logs, is_final_answer = self.python_executor(code_action)</p>
<h1><a class="anchor" id="autotoc_md3151"></a>
Store results in memory step</h1>
<p>memory_step.observations = f"Execution logs:\n{execution_logs}\nLast output:\n{output}" memory_step.action_output = output</p>
<p>except Exception as e: </p>
<h1><a class="anchor" id="autotoc_md3152"></a>
Handle execution errors reported by the executor</h1>
<p>raise AgentExecutionError(...)</p>
<h1><a class="anchor" id="autotoc_md3153"></a>
Return the output if it's the final answer, otherwise None</h1>
<p>return output if is_final_answer else None </p>
<h1><a class="anchor" id="autotoc_md3154"></a>
...</h1>
<p>``<code></p><ul>
<li>The</li>
</ul>
<p></code>step<code>method gets code from the LLM.</p><ul>
<li>It calls</li>
</ul>
<p></code>self.python_executor(code_action)<code>. This triggers the executor's</code>__call__<code>method.</p><ul>
<li>It receives the</li>
</ul>
<p></code>output<code>,</code>logs<code>, and</code>is_final_answer` flag back from the executor.</p>
<ul>
<li><p class="startli"><b><code>LocalPythonExecutor</code> Execution (<code>local_python_executor.py</code>):</b> The core logic for local execution.</p>
<p class="startli">```python </p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md3155"></a>
&mdash; File: local_python_executor.py (Simplified LocalPythonExecutor <b>call</b>) &mdash;</h1>
<p>from .local_python_executor import evaluate_python_code # The safe evaluation function from .tools import Tool # For type hinting</p>
<p>class LocalPythonExecutor(PythonExecutor): def <b>init</b>(self, additional_authorized_imports, max_print_outputs_length=None): self.custom_tools = {} # Stores functions defined in code self.state = {} # Stores variables self.max_print_outputs_length = max_print_outputs_length or 50000 self.additional_authorized_imports = additional_authorized_imports self.authorized_imports = # ... combine base and additional imports ... self.static_tools = None # Will hold agent tools + safe builtins</p>
<p>def <b>call</b>(self, code_action: str) -&gt; Tuple[Any, str, bool]: """Runs the code using the safe evaluate_python_code function.""" output, is_final_answer = evaluate_python_code( code=code_action, static_tools=self.static_tools, # Tools provided by the agent custom_tools=self.custom_tools, # Functions defined during execution state=self.state, # Current variables authorized_imports=self.authorized_imports, # Allowed imports max_print_outputs_length=self.max_print_outputs_length, ) </p>
<h1><a class="anchor" id="autotoc_md3156"></a>
Get captured print logs from the state</h1>
<p>logs = str(self.state.get("_print_outputs", "")) return output, logs, is_final_answer</p>
<p>def send_variables(self, variables: dict): """Adds external variables to the executor's state.""" self.state.update(variables)</p>
<p>def send_tools(self, tools: Dict[str, Tool]): """Makes agent tools available to the executed code.""" </p>
<h1><a class="anchor" id="autotoc_md3157"></a>
Combine agent tools with safe Python builtins (like len, str, math functions)</h1>
<p>from .local_python_executor import BASE_PYTHON_TOOLS self.static_tools = {**tools, **BASE_PYTHON_TOOLS.copy()}</p>
<h1><a class="anchor" id="autotoc_md3158"></a>
&mdash; Also in local_python_executor.py &mdash;</h1>
<p>def evaluate_python_code(code, static_tools, custom_tools, state, authorized_imports, ...): """
        Safely evaluates code by parsing to AST and walking the tree.
        - Parses &lt;tt&gt;code&lt;/tt&gt; string into an Abstract Syntax Tree (AST).
        - Initializes &amp;lsquo;state[&amp;rsquo;_print_outputs']&lt;tt&gt;to capture prints.
        - Defines a&lt;/tt&gt;final_answer&lt;tt&gt;wrapper to signal completion.
        - Iterates through AST nodes using&lt;/tt&gt;evaluate_ast&lt;tt&gt;.
        -&lt;/tt&gt;evaluate_ast&lt;tt&gt;recursively handles different node types (assignments, calls, loops etc.)
            - It uses&lt;/tt&gt;state&lt;tt&gt;to read/write variables.
            - It checks calls against&lt;/tt&gt;static_tools&lt;tt&gt;and&lt;/tt&gt;custom_tools&lt;tt&gt;.
            - It enforces&lt;/tt&gt;authorized_imports&lt;tt&gt;.
            - It blocks dangerous operations (e.g., direct&lt;/tt&gt;eval&lt;tt&gt;, certain imports).
        - Returns the final&lt;/tt&gt;result&lt;tt&gt;and&lt;/tt&gt;is_final_answer&lt;tt&gt;flag.
        - Captures print outputs in&lt;/tt&gt;state['_print_outputs']`.
        - Handles errors gracefully.
        """ </p>
<h1><a class="anchor" id="autotoc_md3159"></a>
... implementation details ...</h1>
<p>try: expression = ast.parse(code) # Parse code to AST </p>
<h1><a class="anchor" id="autotoc_md3160"></a>
... setup state, wrap final_answer ...</h1>
<p>for node in expression.body: result = evaluate_ast(node, state, static_tools, custom_tools, authorized_imports) # Evaluate node-by-node </p>
<h1><a class="anchor" id="autotoc_md3161"></a>
... capture logs, handle exceptions ...</h1>
<p>return result, is_final_answer except FinalAnswerException as e: </p>
<h1><a class="anchor" id="autotoc_md3162"></a>
... capture logs ...</h1>
<p>return e.value, True # Special exception for final_answer except Exception as e: </p>
<h1><a class="anchor" id="autotoc_md3163"></a>
... capture logs, wrap error ...</h1>
<p>raise InterpreterError(...)</p>
<p>def evaluate_ast(expression: ast.AST, state, static_tools, custom_tools, authorized_imports): """Recursive function to evaluate a single AST node safely.""" </p>
<h1><a class="anchor" id="autotoc_md3164"></a>
... checks node type (ast.Assign, ast.Call, ast.Import, etc.) ...</h1>
<h1><a class="anchor" id="autotoc_md3165"></a>
... performs the corresponding safe operation using state and tools ...</h1>
<h1><a class="anchor" id="autotoc_md3166"></a>
... raises InterpreterError for disallowed operations ...</h1>
<p>pass ``<code></p><ul>
<li>The</li>
</ul>
<p></code>LocalPythonExecutor<code>'s</code>__call__<code>method relies heavily on</code>evaluate_python_code<code>. *</code>evaluate_python_code<code>parses the code into an AST and evaluates it node by node using</code>evaluate_ast<code>, maintaining</code>state<code>and respecting allowed</code>tools<code>and</code>authorized_imports<code>.</p><ul>
<li>The</li>
</ul>
<p></code>send_variables<code>and</code>send_tools<code>methods prepare the</code>state` and available functions for the executor.</p>
<h2><a class="anchor" id="autotoc_md3167"></a>
Conclusion</h2>
<p>The <code>PythonExecutor</code> is a critical safety component in <code>SmolaAgents</code>, especially when using <code>CodeAgent</code>. It provides a secure sandbox (local or remote) to execute AI-generated Python code, preventing potential harm while still allowing the agent to leverage code for complex calculations, data manipulation, and interacting with tools.</p>
<p>You've learned:</p>
<ul>
<li>Why safe code execution is essential when dealing with AI-generated code.</li>
<li>The "secure laboratory" analogy for <code>PythonExecutor</code>.</li>
<li>Its key responsibilities: isolation, execution, state management, and capturing output/errors.</li>
<li>How <code>CodeAgent</code> uses it automatically (usually the <code>LocalPythonExecutor</code> by default).</li>
<li>The difference between <code>LocalPythonExecutor</code>, <code>DockerExecutor</code>, and <code>E2BExecutor</code>.</li>
<li>The basic flow of execution: Agent -&gt; Executor -&gt; Safe Environment -&gt; State -&gt; Executor -&gt; Agent.</li>
<li>Where the executor is created and used within the <code>CodeAgent</code> code.</li>
</ul>
<p>While you might not interact with the <code>PythonExecutor</code> directly very often as a beginner, understanding its role is crucial for trusting your agents and knowing how they perform code-based actions safely.</p>
<p>So far, we've seen <code>CodeAgent</code> and <code>ToolCallingAgent</code>. Are these the only types of agents? How can we define different agent behaviors?</p>
<p><b>Next Chapter:</b> <a class="el" href="../../d6/df3/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2SmolaAgents_207__agenttype.html">Chapter 7: AgentType</a> - Defining Agent Behaviors.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
