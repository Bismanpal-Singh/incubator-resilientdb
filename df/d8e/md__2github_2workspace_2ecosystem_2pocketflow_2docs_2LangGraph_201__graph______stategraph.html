#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 01_graph___stategraph</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('df/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_201__graph______stategraph.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">01_graph___stategraph</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2056"></a>
autotoc_md2056</h2>
<p>layout: default title: "Graph &amp; StateGraph" parent: "LangGraph" </p>
<h2><a class="anchor" id="autotoc_md2057"></a>
nav_order: 1</h2>
<h1><a class="anchor" id="autotoc_md2058"></a>
Chapter 1: Graph / StateGraph - The Blueprint of Your Application</h1>
<p>Welcome to the LangGraph tutorial! We're excited to help you learn how to build powerful, stateful applications with Large Language Models (LLMs).</p>
<p>Imagine you're building an application, maybe a chatbot, an agent that performs tasks, or something that processes data in multiple steps. As these applications get more complex, just calling an LLM once isn't enough. You need a way to structure the flow – maybe call an LLM, then a tool, then another LLM based on the result. How do you manage this sequence of steps and the information passed between them?</p>
<p>That's where <b>Graphs</b> come in!</p>
<h2><a class="anchor" id="autotoc_md2059"></a>
What Problem Do Graphs Solve?</h2>
<p>Think of a complex task like baking a cake. You don't just throw all the ingredients in the oven. There's a sequence: mix dry ingredients, mix wet ingredients, combine them, pour into a pan, bake, cool, frost. Each step depends on the previous one.</p>
<p>LangGraph helps you define these steps and the order they should happen in. It provides a way to create a <b>flowchart</b> or a <b>blueprint</b> for your application's logic.</p>
<p>The core idea is to break down your application into:</p>
<ol type="1">
<li><b>Nodes:</b> These are the individual steps or actions (like "mix dry ingredients" or "call the LLM").</li>
<li><b>Edges:</b> These are the connections or transitions between the steps, defining the order (after mixing dry ingredients, mix wet ingredients).</li>
</ol>
<p>LangGraph provides different types of graphs, but the most common and useful one for building stateful applications is the <code>StateGraph</code>.</p>
<h2><a class="anchor" id="autotoc_md2060"></a>
Core Concepts: <code>Graph</code>, <code>StateGraph</code>, and <code>MessageGraph</code></h2>
<p>Let's look at the main types of graphs you'll encounter:</p>
<ol type="1">
<li><p class="startli"><b><code>Graph</code> (The Basic Blueprint)</b></p><ul>
<li>This is the most fundamental type. You define nodes (steps) and edges (connections).</li>
<li>It's like a basic flowchart diagram.</li>
<li>You explicitly define how information passes from one node to the next.</li>
<li>While foundational, you'll often use the more specialized <code>StateGraph</code> for convenience.</li>
</ul>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md2061"></a>
This is a conceptual example - we usually use StateGraph</h1>
<p>from langgraph.graph import Graph</p>
<h1><a class="anchor" id="autotoc_md2062"></a>
Define simple functions or Runnables as nodes</h1>
<p>def step_one(input_data): print("Running Step 1") return input_data * 2</p>
<p>def step_two(processed_data): print("Running Step 2") return processed_data + 5</p>
<h1><a class="anchor" id="autotoc_md2063"></a>
Create a basic graph</h1>
<p>basic_graph_builder = Graph()</p>
<h1><a class="anchor" id="autotoc_md2064"></a>
Add nodes</h1>
<p>basic_graph_builder.add_node("A", step_one) basic_graph_builder.add_node("B", step_two)</p>
<h1><a class="anchor" id="autotoc_md2065"></a>
Add edges (connections)</h1>
<p>basic_graph_builder.add_edge("A", "B") # Run B after A basic_graph_builder.set_entry_point("A") # Start at A </p>
<h1><a class="anchor" id="autotoc_md2066"></a>
basic_graph_builder.set_finish_point("B") # Not needed for this simple Graph type</h1>
<p>```</p>
<ol type="1">
<li><b><code>StateGraph</code> (The Collaborative Whiteboard)</b><ul>
<li>This is the workhorse for most LangGraph applications. It's a specialized <code>Graph</code>.</li>
<li><b>Key Idea:</b> Nodes communicate <em>implicitly</em> by reading from and writing to a shared <b>State</b> object.</li>
<li><b>Analogy:</b> Imagine a central whiteboard (the State). Each node (person) can read what's on the whiteboard, do some work, and then update the whiteboard with new information or changes.</li>
<li>You define the <em>structure</em> of this shared state first (e.g., what keys it holds).</li>
<li>Each node receives the <em>current</em> state and returns a <em>dictionary</em> containing only the parts of the state it wants to <em>update</em>. LangGraph handles merging these updates into the main state.</li>
</ul>
</li>
<li><b><code>MessageGraph</code> (The Chatbot Specialist)</b><ul>
<li>This is a further specialization of <code>StateGraph</code>, designed specifically for building chatbots or conversational agents.</li>
<li>It automatically manages a <code>messages</code> list within its state.</li>
<li>Nodes typically take the current list of messages and return new messages to be added.</li>
<li>It uses a special function (<code>add_messages</code>) to append messages while handling potential duplicates or updates based on message IDs. This makes building chat flows much simpler.</li>
</ul>
</li>
</ol>
<p>For the rest of this chapter, we'll focus on <code>StateGraph</code> as it introduces the core concepts most clearly.</p>
<h2><a class="anchor" id="autotoc_md2067"></a>
Building a Simple <code>StateGraph</code></h2>
<p>Let's build a tiny application that takes a number, adds 1 to it, and then multiplies it by 2.</p>
<p><b>Step 1: Define the State</b></p>
<p>First, we define the "whiteboard" – the structure of the data our graph will work with. We use Python's <code>TypedDict</code> for this.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypedDict</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyState(TypedDict):</div>
<div class="line">    <span class="comment"># Our state will hold a single number called &#39;value&#39;</span></div>
<div class="line">    value: int</div>
</div><!-- fragment --><p>This tells our <code>StateGraph</code> that the shared information will always contain an integer named <code>value</code>.</p>
<p><b>Step 2: Define the Nodes</b></p>
<p>Nodes are functions (or LangChain Runnables) that perform the work. They take the current <code>State</code> as input and return a dictionary containing the <em>updates</em> to the state.</p>
<div class="fragment"><div class="line"><span class="comment"># Node 1: Adds 1 to the value</span></div>
<div class="line"><span class="keyword">def </span>add_one(state: MyState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Running Adder Node ---&quot;</span>)</div>
<div class="line">    current_value = state[<span class="stringliteral">&#39;value&#39;</span>]</div>
<div class="line">    new_value = current_value + 1</div>
<div class="line">    print(f<span class="stringliteral">&quot;Input value: {current_value}, Output value: {new_value}&quot;</span>)</div>
<div class="line">    <span class="comment"># Return *only* the key we want to update</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;value&quot;</span>: new_value}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Node 2: Multiplies the value by 2</span></div>
<div class="line"><span class="keyword">def </span>multiply_by_two(state: MyState) -&gt; dict:</div>
<div class="line">    print(<span class="stringliteral">&quot;--- Running Multiplier Node ---&quot;</span>)</div>
<div class="line">    current_value = state[<span class="stringliteral">&#39;value&#39;</span>]</div>
<div class="line">    new_value = current_value * 2</div>
<div class="line">    print(f<span class="stringliteral">&quot;Input value: {current_value}, Output value: {new_value}&quot;</span>)</div>
<div class="line">    <span class="comment"># Return the update</span></div>
<div class="line">    <span class="keywordflow">return</span> {<span class="stringliteral">&quot;value&quot;</span>: new_value}</div>
</div><!-- fragment --><p>Notice how each function takes <code>state</code> and returns a <code>dict</code> specifying which part of the state (<code>"value"</code>) should be updated and with what new value.</p>
<p><b>Step 3: Create the Graph and Add Nodes/Edges</b></p>
<p>Now we assemble our blueprint using <code>StateGraph</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">from</span> langgraph.graph <span class="keyword">import</span> StateGraph, END, START</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a StateGraph instance linked to our state definition</span></div>
<div class="line">workflow = StateGraph(MyState)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Add the nodes to the graph</span></div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;adder&quot;</span>, add_one)</div>
<div class="line">workflow.add_node(<span class="stringliteral">&quot;multiplier&quot;</span>, multiply_by_two)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Set the entry point --&gt; where does the flow start?</span></div>
<div class="line">workflow.set_entry_point(<span class="stringliteral">&quot;adder&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Add edges --&gt; how do the nodes connect?</span></div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;adder&quot;</span>, <span class="stringliteral">&quot;multiplier&quot;</span>) <span class="comment"># After adder, run multiplier</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Set the finish point --&gt; where does the flow end?</span></div>
<div class="line"><span class="comment"># We use the special identifier END</span></div>
<div class="line">workflow.add_edge(<span class="stringliteral">&quot;multiplier&quot;</span>, END)</div>
</div><!-- fragment --><ul>
<li><code>StateGraph(MyState)</code>: Creates the graph, telling it to use our <code>MyState</code> structure.</li>
<li><code>add_node("name", function)</code>: Registers our functions as steps in the graph with unique names.</li>
<li><code>set_entry_point("adder")</code>: Specifies that the <code>adder</code> node should run first. This implicitly creates an edge from a special <code>START</code> point to <code>adder</code>.</li>
<li><code>add_edge("adder", "multiplier")</code>: Creates a connection. After <code>adder</code> finishes, <code>multiplier</code> will run.</li>
<li><code>add_edge("multiplier", END)</code>: Specifies that after <code>multiplier</code> finishes, the graph execution should stop. <code>END</code> is a special marker for the graph's conclusion.</li>
</ul>
<p><b>Step 4: Compile the Graph</b></p>
<p>Before we can run it, we need to <code>compile</code> the graph. This finalizes the structure and makes it executable.</p>
<div class="fragment"><div class="line"><span class="comment"># Compile the workflow into an executable object</span></div>
<div class="line">app = workflow.compile()</div>
</div><!-- fragment --><p><b>Step 5: Run It!</b></p>
<p>Now we can invoke our compiled graph (<code>app</code>) with some initial state.</p>
<div class="fragment"><div class="line"><span class="comment"># Define the initial state</span></div>
<div class="line">initial_state = {<span class="stringliteral">&quot;value&quot;</span>: 5}</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Run the graph</span></div>
<div class="line">final_state = app.invoke(initial_state)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Print the final result</span></div>
<div class="line">print(<span class="stringliteral">&quot;\n--- Final State ---&quot;</span>)</div>
<div class="line">print(final_state)</div>
</div><!-- fragment --><p><b>Expected Output:</b></p>
<div class="fragment"><div class="line">--- Running Adder Node ---</div>
<div class="line">Input value: 5, Output value: 6</div>
<div class="line">--- Running Multiplier Node ---</div>
<div class="line">Input value: 6, Output value: 12</div>
<div class="line"> </div>
<div class="line">--- Final State ---</div>
<div class="line">{&#39;value&#39;: 12}</div>
</div><!-- fragment --><p>As you can see, the graph executed the nodes in the defined order (<code>adder</code> then <code>multiplier</code>), automatically passing the updated state between them!</p>
<h2><a class="anchor" id="autotoc_md2068"></a>
How Does <code>StateGraph</code> Work Under the Hood?</h2>
<p>You defined the nodes and edges, but what actually happens when you call <code>invoke()</code>?</p>
<ol type="1">
<li><b>Initialization:</b> LangGraph takes your initial input (<code>{"value": 5}</code>) and puts it onto the "whiteboard" (the internal state).</li>
<li><b>Execution Engine:</b> A powerful internal component called the <a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel Execution Engine</a> takes over. It looks at the current state and the graph structure.</li>
<li><b>Following Edges:</b> It starts at the <code>START</code> node and follows the edge to the entry point (<code>adder</code>).</li>
<li><b>Node Execution:</b> It runs the <code>adder</code> function, passing it the current state (<code>{"value": 5}</code>).</li>
<li><b>State Update:</b> The <code>adder</code> function returns <code>{"value": 6}</code>. The Pregel engine uses special mechanisms called <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a> to update the value associated with the <code>"value"</code> key on the "whiteboard". The state is now <code>{"value": 6}</code>.</li>
<li><b>Next Step:</b> The engine sees the edge from <code>adder</code> to <code>multiplier</code>.</li>
<li><b>Node Execution:</b> It runs the <code>multiplier</code> function, passing it the <em>updated</em> state (<code>{"value": 6}</code>).</li>
<li><b>State Update:</b> <code>multiplier</code> returns <code>{"value": 12}</code>. The engine updates the state again via the <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a>. The state is now <code>{"value": 12}</code>.</li>
<li><b>Following Edges:</b> The engine sees the edge from <code>multiplier</code> to <code>END</code>.</li>
<li><b>Finish:</b> Reaching <code>END</code> signals the execution is complete. The final state (<code>{"value": 12}</code>) is returned.</li>
</ol>
<p>Here's a simplified visual:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant App (CompiledGraph)</div>
<div class="line">    participant State</div>
<div class="line">    participant AdderNode as adder</div>
<div class="line">    participant MultiplierNode as multiplier</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;App: invoke({&quot;value&quot;: 5})</div>
<div class="line">    App-&gt;&gt;State: Initialize state = {&quot;value&quot;: 5}</div>
<div class="line">    App-&gt;&gt;AdderNode: Execute(state)</div>
<div class="line">    AdderNode-&gt;&gt;State: Read value (5)</div>
<div class="line">    AdderNode--&gt;&gt;App: Return {&quot;value&quot;: 6}</div>
<div class="line">    App-&gt;&gt;State: Update state = {&quot;value&quot;: 6}</div>
<div class="line">    App-&gt;&gt;MultiplierNode: Execute(state)</div>
<div class="line">    MultiplierNode-&gt;&gt;State: Read value (6)</div>
<div class="line">    MultiplierNode--&gt;&gt;App: Return {&quot;value&quot;: 12}</div>
<div class="line">    App-&gt;&gt;State: Update state = {&quot;value&quot;: 12}</div>
<div class="line">    App-&gt;&gt;User: Return final state {&quot;value&quot;: 12}</div>
</div><!-- fragment --><p>Don't worry too much about the details of Pregel or Channels yet – we'll cover them in later chapters. The key takeaway is that <code>StateGraph</code> manages the state and orchestrates the execution based on your defined nodes and edges.</p>
<h2><a class="anchor" id="autotoc_md2069"></a>
A Peek at the Code (<code>graph/state.py</code>, <code>graph/graph.py</code>)</h2>
<p>Let's briefly look at the code snippets provided to see how these concepts map to the implementation:</p>
<ul>
<li><b><code>StateGraph.__init__</code> (<code>graph/state.py</code>)</b>: <code>python @section autotoc_md2070 Simplified view class StateGraph(Graph): def __init__(self, state_schema: Optional[Type[Any]] = None, ...): super().__init__() @section autotoc_md2071 ... stores the state_schema ... self.schema = state_schema @section autotoc_md2072 ... analyzes the schema to understand state keys and how to update them ... self._add_schema(state_schema) @section autotoc_md2073 ... sets up internal dictionaries for channels, nodes etc. ... </code> This code initializes the graph, crucially storing the <code>state_schema</code> you provide. It analyzes this schema to figure out the "keys" on your whiteboard (like <code>"value"</code>) and sets up the internal structures (<a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a>) needed to manage updates to each key.</li>
<li><b><code>StateGraph.add_node</code> (<code>graph/state.py</code>)</b>: <code>python @section autotoc_md2074 Simplified view def add_node(self, node: str, action: RunnableLike, ...): @section autotoc_md2075 ... basic checks for name conflicts, reserved names (START, END) ... if node in self.channels: # Cannot use a state key name as a node name raise ValueError(...) @section autotoc_md2076 ... wrap the provided action (function/runnable) ... runnable = coerce_to_runnable(action, ...) @section autotoc_md2077 ... store the node details (runnable, input type etc.) ... self.nodes[node] = StateNodeSpec(runnable, ..., input=input or self.schema, ...) return self </code> When you add a node, it stores the associated function (<code>action</code>) and links it to the provided <code>node</code> name. It also figures out what input schema the node expects (usually the main graph state schema).</li>
<li><b><code>Graph.add_edge</code> (<code>graph/graph.py</code>)</b>: <code>python @section autotoc_md2078 Simplified view from the base Graph class def add_edge(self, start_key: str, end_key: str): @section autotoc_md2079 ... checks for invalid edges (e.g., starting from END) ... @section autotoc_md2080 ... basic validation ... @section autotoc_md2081 Stores the connection as a simple pair self.edges.add((start_key, end_key)) return self </code> Adding an edge is relatively simple – it just records the <code>(start_key, end_key)</code> pair in a set, representing the connection.</li>
<li><b><code>StateGraph.compile</code> (<code>graph/state.py</code>)</b>: <code>python @section autotoc_md2082 Simplified view def compile(self, ...): @section autotoc_md2083 ... validation checks ... self.validate(...) @section autotoc_md2084 ... create the CompiledStateGraph instance ... compiled = CompiledStateGraph(builder=self, ...) @section autotoc_md2085 ... add nodes, edges, branches to the compiled version ... for key, node in self.nodes.items(): compiled.attach_node(key, node) for start, end in self.edges: compiled.attach_edge(start, end) @section autotoc_md2086 ... more setup for branches, entry/exit points ... @section autotoc_md2087 ... finalize and return the compiled graph ... return compiled.validate() </code> Compilation takes your defined nodes and edges and builds the final, executable <code>CompiledStateGraph</code>. It sets up the internal machinery (<a class="el" href="../../de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html">Pregel</a>, <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a>) based on your blueprint.</li>
</ul>
<h2><a class="anchor" id="autotoc_md2088"></a>
Conclusion</h2>
<p>You've learned the fundamental concept in LangGraph: the <b>Graph</b>.</p>
<ul>
<li>Graphs define the structure and flow of your application using <b>Nodes</b> (steps) and <b>Edges</b> (connections).</li>
<li><b><code>StateGraph</code></b> is the most common type, where nodes communicate implicitly by reading and updating a shared <b>State</b> object (like a whiteboard).</li>
<li><b><code>MessageGraph</code></b> is a specialized <code>StateGraph</code> for easily building chatbots.</li>
<li>You define the state structure, write node functions that update parts of the state, connect them with edges, and <code>compile</code> the graph to make it runnable.</li>
</ul>
<p>Now that you understand how to define the overall <em>structure</em> of your application using <code>StateGraph</code>, the next step is to dive deeper into what constitutes a <b>Node</b>.</p>
<p>Let's move on to <a class="el" href="../../dc/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_202__nodes______pregelnode____.html">Chapter 2: Nodes (<code>PregelNode</code>)</a> to explore how individual steps are defined and executed.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
