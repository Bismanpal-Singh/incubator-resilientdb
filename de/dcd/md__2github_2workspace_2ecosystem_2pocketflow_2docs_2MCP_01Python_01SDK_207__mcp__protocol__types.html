#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 07_mcp_protocol_types</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/dcd/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_207__mcp__protocol__types.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">07_mcp_protocol_types</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2457"></a>
autotoc_md2457</h2>
<p>layout: default title: "MCP Protocol Types" parent: "MCP Python SDK" </p>
<h2><a class="anchor" id="autotoc_md2458"></a>
nav_order: 7</h2>
<h1><a class="anchor" id="autotoc_md2459"></a>
Chapter 7: MCP Protocol Types - The Standard Language</h1>
<p>In the previous chapter, <a class="el" href="../../d2/de0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_206__fastmcp__context______context____.html">Chapter 6: Talking Back - FastMCP Context (<code>Context</code>)</a>, we saw how the <code>Context</code> object gives our tools and resources a "backstage pass" to send logs, report progress, and access other server features during a request. We've built up a good understanding of how <code>FastMCP</code> helps us create powerful servers with tools (<a class="el" href="../../dc/df6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_204__fastmcp__tools______tool________toolmanager____.html">Chapter 4</a>), resources (<a class="el" href="../../d9/dfc/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_203__fastmcp__resources_95757cc8f176683b04c22ceeac7ea1d5.html">Chapter 3</a>), and prompts (<a class="el" href="../../d5/de9/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_205__fastmcp__prompts___e380d8fca08b641e7632fcc5814680b7.html">Chapter 5</a>).</p>
<p>But have you ever wondered <em>how</em> the client and server actually talk to each other under the hood? When your tool function uses <code>ctx.report_progress()</code>, how does that message get sent? When a client asks to call a tool, what does that request <em>look like</em> electronically?</p>
<p>Imagine trying to send mail internationally. If everyone used different envelope sizes, address formats, and languages, it would be chaos! Postal services rely on standards. Similarly, for a client (like a chatbot interface) and your MCP server (like your <code>CalculatorServer</code>) to communicate reliably, they need a <b>standard language</b> and <b>standard formats</b> for their messages.</p>
<p>This is where <b>MCP Protocol Types</b> come in. They are the fundamental, standardized data structures – the "digital forms" or "letter formats" – defined by the Model Context Protocol (MCP) specification itself.</p>
<h2><a class="anchor" id="autotoc_md2460"></a>
What are MCP Protocol Types?</h2>
<p>Think of MCP Protocol Types as the official <b>blueprints</b> for all the different kinds of messages that can be sent between an MCP client and server. They define precisely what information should be included in each type of message.</p>
<p>These types cover all the interactions we've implicitly seen:</p>
<ul>
<li><b>Requests:</b> Messages asking the other side to do something (e.g., "Initialize our connection", "List the available tools", "Read this resource", "Call that tool").</li>
<li><b>Responses:</b> Messages sent back after a request, containing either the result or an error (e.g., "Here are the tools", "Here is the resource content", "Here is the result of the tool call", "Sorry, an error occurred").</li>
<li><b>Notifications:</b> Messages sent one-way, just to inform the other side about something without expecting a direct reply (e.g., "Initialization is complete", "Here's a progress update", "Here's a log message").</li>
<li><b>Errors:</b> A specific kind of response indicating something went wrong with a request.</li>
</ul>
<p>These types have specific names defined in the <code>MCP Python SDK</code>, usually found in the <code>mcp.types</code> module. You'll see names that clearly indicate their purpose:</p>
<ul>
<li><code>InitializeRequest</code>: The "form" a client sends to start communication.</li>
<li><code>InitializeResult</code>: The "form" a server sends back confirming initialization.</li>
<li><code>ListToolsResult</code>: The "form" containing the list of tools sent by the server.</li>
<li><code>CallToolRequest</code>: The "form" a client uses to ask the server to run a tool.</li>
<li><code>CallToolResult</code>: The "form" the server sends back with the tool's output.</li>
<li><code>ProgressNotification</code>: The "form" used to send progress updates (like when we used <code>ctx.report_progress</code>).</li>
<li><code>JSONRPCError</code>: The standard "form" for reporting errors.</li>
</ul>
<p>These are just a few examples; the MCP specification defines many such types to cover all standard interactions.</p>
<h2><a class="anchor" id="autotoc_md2461"></a>
Why Standardized Types? Meet Pydantic</h2>
<p>Why go to the trouble of defining all these specific types? Why not just send messages like "Hey server, run the add tool with 5 and 7"?</p>
<p>Without standards, communication quickly breaks down:</p><ul>
<li>Did the client send integers or strings for the numbers?</li>
<li>Did the server send the result back as a number or text?</li>
<li>How does the client know if the server understood the request or if an error happened?</li>
</ul>
<p>Standardized types solve these problems by ensuring both the client and server agree on the exact structure and data types for every message.</p>
<p>The <code>MCP Python SDK</code> uses a popular Python library called <b>Pydantic</b> to define and manage these protocol types. Think of Pydantic as both the <b>form designer</b> and the <b>quality control inspector</b>:</p>
<ol type="1">
<li><b>Definition:</b> Pydantic allows the SDK developers to define each protocol type (like <code>CallToolRequest</code>) using simple Python classes with type hints. This creates a clear, code-based blueprint for each "form".</li>
<li><b>Validation:</b> When your server receives a message, Pydantic automatically checks if it perfectly matches the expected structure defined by the corresponding protocol type. Does the <code>CallToolRequest</code> actually have a <code>name</code> field that's a string? Does it have an <code>arguments</code> field that's a dictionary? If not, Pydantic raises an error immediately, preventing bad data from causing problems later. It does the same when your server sends messages back.</li>
<li><b>Type Safety &amp; Developer Experience:</b> Because the types are clearly defined, your code editor can help you! It knows what fields exist on an <code>InitializeResult</code> object, reducing typos and making development faster and less error-prone.</li>
</ol>
<p>Pydantic makes the communication reliable and robust by enforcing the MCP standard for every message.</p>
<h2><a class="anchor" id="autotoc_md2462"></a>
Examples in Action: Connecting High-Level to Low-Level</h2>
<p>While <code>FastMCP</code> does a great job hiding these low-level details, let's peek behind the curtain and see how our previous examples relate to these protocol types.</p>
<p><b>Scenario 1: Client Listing Tools</b></p>
<ol type="1">
<li>A client wants to know what tools your <code>CalculatorServer</code> offers.</li>
<li>Client sends a message. Under the hood, this message is structured according to the <code>JSONRPCRequest</code> format, specifying the method <code>tools/list</code>.</li>
<li>Your <code>FastMCP</code> server receives this raw message. Pydantic validates it.</li>
<li><code>FastMCP</code> understands it's a request for <code>tools/list</code> and asks the <code>ToolManager</code> (<a class="el" href="../../dc/df6/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_204__fastmcp__tools______tool________toolmanager____.html">Chapter 4</a>) for the list of tools.</li>
<li>The <code>ToolManager</code> provides the tool information (name, description, input schema).</li>
<li><p class="startli"><code>FastMCP</code> takes this information and constructs a <code>ListToolsResult</code> object. This object is a Pydantic model defined in <code>mcp.types</code>.</p>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md2463"></a>
Simplified example of creating a ListToolsResult object</h1>
<h1><a class="anchor" id="autotoc_md2464"></a>
(FastMCP does this automatically for you!)</h1>
<p>from mcp.types import ListToolsResult, Tool</p>
<h1><a class="anchor" id="autotoc_md2465"></a>
ToolManager gathered this info from your @server.tool decorator</h1>
<p>add_tool_info = Tool( name="add", description="Adds two numbers together.", inputSchema={ # JSON Schema describing expected input "type": "object", "properties": { "num1": {"type": "integer"}, "num2": {"type": "integer"} }, "required": ["num1", "num2"] } )</p>
<h1><a class="anchor" id="autotoc_md2466"></a>
FastMCP creates the result object</h1>
<p>result_data = ListToolsResult( tools=[add_tool_info] </p>
<h1><a class="anchor" id="autotoc_md2467"></a>
nextCursor would be set if paginating</h1>
<p>)</p>
<h1><a class="anchor" id="autotoc_md2468"></a>
This result_data object is then packaged into a</h1>
<h1><a class="anchor" id="autotoc_md2469"></a>
standard JSONRPCResponse and sent to the client.</h1>
<p>print(result_data.model_dump_json(indent=2)) # See its JSON form ```</p>
<p><b>Example Output (JSON representation):</b> <code>json { "_meta": null, "nextCursor": null, "tools": [ { "name": "add", "description": "Adds two numbers together.", "inputSchema": { "type": "object", "properties": { "num1": { "type": "integer" }, "num2": { "type": "integer" } }, "required": [ "num1", "num2" ] } } ] } </code> This structured JSON, based on the <code>ListToolsResult</code> model, is what gets sent back to the client.</p>
<p><b>Scenario 2: Reporting Progress with <code>Context</code></b></p>
<ol type="1">
<li>Your tool function calls <code>await ctx.report_progress(step, total_steps)</code> (<a class="el" href="../../d2/de0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_206__fastmcp__context______context____.html">Chapter 6</a>).</li>
<li>The <code>Context</code> object uses the provided <code>step</code> and <code>total_steps</code> values.</li>
<li>It looks up the unique <code>progressToken</code> associated with the original request that started this tool call.</li>
<li>It creates a <code>ProgressNotificationParams</code> object containing the token and progress values.</li>
<li><p class="startli">It wraps this in a <code>ProgressNotification</code> object.</p>
<p class="startli">```python </p>
</li>
</ol>
<h1><a class="anchor" id="autotoc_md2470"></a>
Simplified example of creating a ProgressNotification</h1>
<h1><a class="anchor" id="autotoc_md2471"></a>
(Context object does this for you!)</h1>
<p>from mcp.types import ProgressNotification, ProgressNotificationParams</p>
<h1><a class="anchor" id="autotoc_md2472"></a>
Context gets these values</h1>
<p>token_from_request = "client_progress_token_123" current_step = 2 total_steps = 5 progress_value = current_step / total_steps # 0.4</p>
<h1><a class="anchor" id="autotoc_md2473"></a>
Context creates the notification object</h1>
<p>notification_data = ProgressNotification( method="notifications/progress", # Standard MCP method name params=ProgressNotificationParams( progressToken=token_from_request, progress=progress_value, total=float(total_steps) ) )</p>
<h1><a class="anchor" id="autotoc_md2474"></a>
This notification_data is then packaged into a</h1>
<h1><a class="anchor" id="autotoc_md2475"></a>
JSONRPCNotification message and sent to the client.</h1>
<p>print(notification_data.model_dump_json(indent=2)) ```</p>
<p><b>Example Output (JSON representation):</b> <code>json { "method": "notifications/progress", "params": { "_meta": null, "progressToken": "client_progress_token_123", "progress": 0.4, "total": 5.0 } } </code> This structured JSON notification, based on the <code>ProgressNotification</code> model, is sent to the client to update its UI.</p>
<h2><a class="anchor" id="autotoc_md2476"></a>
Do I Need to Use These Directly?</h2>
<p>Probably not, especially when you're starting out and using <code>FastMCP</code>!</p>
<p>The beauty of <code>FastMCP</code> and its decorators (<code>@server.tool</code>, <code>@server.resource</code>) and helpers (<code>Context</code>) is that they <b>abstract away</b> these low-level protocol types. You work with regular Python functions, arguments, and return values, and <code>FastMCP</code> handles the conversion to and from the appropriate MCP Protocol Types automatically using Pydantic.</p>
<p>However, understanding that these types exist is valuable:</p>
<ul>
<li><b>Debugging:</b> If you encounter communication errors, the error messages might refer to fields within these specific types (e.g., "Invalid params in CallToolRequest"). Knowing the structure helps diagnose the problem.</li>
<li><b>Advanced Use:</b> If you ever need to build a custom MCP client, or interact with an MCP server without using the <code>MCP Python SDK</code>'s client helpers, you'll need to construct and parse these types yourself.</li>
<li><b>Understanding the Protocol:</b> Reading the official MCP specification or the SDK's <code>mcp/types.py</code> file gives you the ground truth about how communication works.</li>
</ul>
<p>Think of it like driving a car. You mostly use the steering wheel, pedals, and shifter (like <code>FastMCP</code> abstractions). You don't usually interact directly with the engine pistons or fuel injectors (like MCP Protocol Types). But knowing they exist helps you understand how the car works and what might be wrong if it breaks down.</p>
<h2><a class="anchor" id="autotoc_md2477"></a>
Under the Hood: Messages in Transit</h2>
<p>Let's visualize where these types fit into a simple <code>callTool</code> interaction.</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant ClientApp as Client Application</div>
<div class="line">    participant ClientSDK as MCP Client SDK</div>
<div class="line">    participant ServerSDK as MCP Server SDK (FastMCP)</div>
<div class="line">    participant YourTool as Your @server.tool Function</div>
<div class="line"> </div>
<div class="line">    ClientApp-&gt;&gt;+ClientSDK: Request tool &quot;add&quot; with {num1: 5, num2: 7}</div>
<div class="line">    ClientSDK-&gt;&gt;ClientSDK: Create CallToolRequest object (Pydantic model)</div>
<div class="line">    ClientSDK-&gt;&gt;+ServerSDK: Send JSON message (based on CallToolRequest)</div>
<div class="line">    ServerSDK-&gt;&gt;ServerSDK: Receive JSON, parse into CallToolRequest object (Pydantic validation)</div>
<div class="line">    ServerSDK-&gt;&gt;+YourTool: Call add_numbers(num1=5, num2=7)</div>
<div class="line">    YourTool--&gt;&gt;-ServerSDK: Return 12</div>
<div class="line">    ServerSDK-&gt;&gt;ServerSDK: Create CallToolResult object (Pydantic model, content=[TextContent(text=&quot;12&quot;)])</div>
<div class="line">    ServerSDK-&gt;&gt;-ClientSDK: Send JSON message (based on CallToolResult)</div>
<div class="line">    ClientSDK-&gt;&gt;ClientSDK: Receive JSON, parse into CallToolResult object (Pydantic validation)</div>
<div class="line">    ClientSDK--&gt;&gt;-ClientApp: Return result &quot;12&quot;</div>
</div><!-- fragment --><p>This shows that the <code>CallToolRequest</code> and <code>CallToolResult</code> (which are MCP Protocol Types defined as Pydantic models in <code>mcp/types.py</code>) are the actual structures being serialized into JSON messages for transmission and parsed back upon receipt.</p>
<p>You can find the definitions for all these types within the SDK:</p>
<p><b>Inside <code>mcp/types.py</code> (Example Snippet):</b></p>
<div class="fragment"><div class="line"><span class="comment"># This file defines all the standard MCP types using Pydantic</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Literal, Any</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the base for parameters of progress notifications</span></div>
<div class="line"><span class="keyword">class </span>ProgressNotificationParams(NotificationParams):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;Parameters for progress notifications.&quot;&quot;&quot;</span></div>
<div class="line">    progressToken: ProgressToken <span class="comment"># Defined elsewhere as str | int</span></div>
<div class="line">    progress: float</div>
<div class="line">    total: float | <span class="keywordtype">None</span> = <span class="keywordtype">None</span></div>
<div class="line">    model_config = ConfigDict(extra=<span class="stringliteral">&quot;allow&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define the notification itself, using the params above</span></div>
<div class="line"><span class="keyword">class </span>ProgressNotification(</div>
<div class="line">    Notification[ProgressNotificationParams, Literal[<span class="stringliteral">&quot;notifications/progress&quot;</span>]]</div>
<div class="line">):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;</span></div>
<div class="line"><span class="stringliteral">    An out-of-band notification used to inform the receiver of a progress update...</span></div>
<div class="line"><span class="stringliteral">    &quot;&quot;&quot;</span></div>
<div class="line">    method: Literal[<span class="stringliteral">&quot;notifications/progress&quot;</span>]</div>
<div class="line">    params: ProgressNotificationParams</div>
<div class="line"> </div>
<div class="line"><span class="comment"># --- Other definitions like Tool, Resource, CallToolRequest etc. ---</span></div>
</div><!-- fragment --><p> This snippet shows how Pydantic <code>BaseModel</code> is used with standard Python type hints (<code>float</code>, <code>str | int</code>, <code>Literal["..."]</code>) to define the structure and expected data types for the <code>ProgressNotification</code>.</p>
<h2><a class="anchor" id="autotoc_md2478"></a>
Conclusion</h2>
<p>You've learned about MCP Protocol Types – the standardized "digital forms" that define the structure of all communication (requests, responses, notifications, errors) between MCP clients and servers.</p>
<ul>
<li>They are defined by the <b>MCP specification</b>.</li>
<li>The <code>MCP Python SDK</code> uses <b>Pydantic</b> models (<code>mcp/types.py</code>) to represent these types, providing clear definitions and automatic validation for reliable communication.</li>
<li>Examples include <code>InitializeRequest</code>, <code>ListToolsResult</code>, <code>CallToolRequest</code>, <code>ProgressNotification</code>, and <code>JSONRPCError</code>.</li>
<li>While <b><code>FastMCP</code> largely hides these details</b>, understanding them provides valuable context for debugging and appreciating the underlying communication mechanics.</li>
</ul>
<p>These types form the bedrock of MCP communication. Now that we understand the messages themselves, we can look at how connections are managed over time. In the next chapter, we'll explore how the SDK manages the ongoing conversation between a client and server using <a class="el" href="../../da/d7b/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2MCP_01Python_01SDK_208__client__server__sesd1331743b9f6969725fa6462195d377b.html">Chapter 8: Client/Server Sessions (<code>ClientSession</code>, <code>ServerSession</code>)</a>.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
