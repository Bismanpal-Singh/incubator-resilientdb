#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 05_pregel_execution_engine</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/d73/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_205__pregel__execution__engine.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">05_pregel_execution_engine</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2184"></a>
autotoc_md2184</h2>
<p>layout: default title: "Pregel Execution Engine" parent: "LangGraph" </p>
<h2><a class="anchor" id="autotoc_md2185"></a>
nav_order: 5</h2>
<h1><a class="anchor" id="autotoc_md2186"></a>
Chapter 5: Pregel Execution Engine - The Engine Room</h1>
<p>In the previous chapters, we learned how to build the blueprint of our application using <a class="el" href="../../df/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_201__graph______stategraph.html"><code>StateGraph</code></a>, define the workers with <a class="el" href="../../dc/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_202__nodes______pregelnode____.html"><code>Nodes</code></a>, manage the shared state with <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html"><code>Channels</code></a>, and direct the traffic using <a class="el" href="../../d0/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_204__control__flow__primitives___bda35fdc89636f8ab61738c1940513a5.html">Control Flow Primitives</a>.</p>
<p>But what actually takes all these pieces – the blueprint, the workers, the communication rules, the traffic signals – and makes them <em>run</em>? What ensures Node A runs, its output updates the state correctly via channels, and then Node B (or maybe Node C based on a Branch) runs with that updated state?</p>
<p>Meet the <b>Pregel Execution Engine</b>. This is the heart of LangGraph, the engine room that drives your graph forward.</p>
<h2><a class="anchor" id="autotoc_md2187"></a>
What Problem Does Pregel Solve?</h2>
<p>Imagine you've designed a complex assembly line (your <code>StateGraph</code>). You have different stations (Nodes) where specific tasks are done, conveyor belts (Channels) moving parts between stations, and switches (Branches) directing parts down different paths.</p>
<p>How do you ensure the line runs smoothly? You need a manager! Someone who:</p>
<ol type="1">
<li>Knows the overall plan (the graph structure).</li>
<li>Knows which station should work next based on what just finished.</li>
<li>Delivers the right parts (state) to the right station.</li>
<li>Collects the finished work from a station.</li>
<li>Updates the central inventory (the shared state via Channels).</li>
<li>Deals with decisions (Branches) and special instructions (Sends, Interrupts).</li>
<li>Handles multiple stations working at the same time if possible (parallelism).</li>
<li>Keeps track of progress and can save the state (Checkpointing).</li>
</ol>
<p>The <b>Pregel Execution Engine</b> is this assembly line manager for your LangGraph application. It takes your compiled graph definition and orchestrates its execution step-by-step.</p>
<h2><a class="anchor" id="autotoc_md2188"></a>
Key Concepts: How Pregel Manages the Flow</h2>
<p>Pregel is inspired by a system developed at Google for processing large graphs. LangGraph adapts these ideas for executing AI agents and multi-step workflows. Here's how it works conceptually:</p>
<ol type="1">
<li><b>Step-by-Step Execution ("Supersteps"):</b> Pregel runs the graph in discrete steps, often called "supersteps." Think of it like turns in a board game.</li>
<li><b>Scheduling Nodes:</b> In each step, Pregel looks at the current state and the graph structure (edges, branches) to figure out which <a class="el" href="../../dc/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_202__nodes______pregelnode____.html">Nodes (<code>PregelNode</code>)</a> should run <em>in this turn</em>. This could be the entry point node at the start, nodes triggered by the previous step's output, or nodes activated by a <code>Send</code> command.</li>
<li><b>Executing Nodes:</b> It runs the scheduled nodes. If multiple nodes are scheduled for the same step and they don't directly depend on each other <em>within that step</em>, Pregel might run them in parallel using background threads or asyncio tasks.</li>
<li><b>Gathering Updates:</b> As each node finishes, it returns a dictionary of updates (like <code>{"value": 6}</code>). Pregel collects all these updates from all the nodes that ran in the current step.</li>
<li><b>Updating State via Channels:</b> Pregel takes the collected updates and applies them to the shared state using the appropriate <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html"><code>Channels</code></a>. For example, it sends <code>6</code> to the <code>"value"</code> channel, which might overwrite the old value (if it's <code>LastValue</code>) or add to it (if it's <code>BinaryOperatorAggregate</code>).</li>
<li><b>Looping:</b> After updating the state, Pregel checks if there are more nodes to run (e.g., nodes connected by edges from the ones that just finished) or if the graph has reached the <code>END</code>. If there's more work, it starts the next step (superstep).</li>
<li><b>Handling Control Flow:</b> It seamlessly integrates <a class="el" href="../../d0/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_204__control__flow__primitives___bda35fdc89636f8ab61738c1940513a5.html">Control Flow Primitives</a>. When a <code>Branch</code> needs to run, Pregel executes the routing function and schedules the next node accordingly. When <code>Send</code> is used, Pregel schedules the target node with the specific data. When <code>Interrupt</code> occurs, Pregel pauses execution (and relies on a <a class="el" href="../../d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html">Checkpointer</a> to save state).</li>
<li><b>Checkpointing:</b> At configurable points (often after each step), Pregel interacts with the <a class="el" href="../../d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html">Checkpointer (<code>BaseCheckpointSaver</code>)</a> to save the current state of all channels. This allows the graph to be paused and resumed later.</li>
</ol>
<p>Essentially, Pregel is the <b>orchestrator</b> that manages the entire lifecycle of a graph's execution.</p>
<h2><a class="anchor" id="autotoc_md2189"></a>
How Pregel Executes Our Simple Graph</h2>
<p>Let's revisit the simple <code>adder -&gt; multiplier</code> graph from <a class="el" href="../../df/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_201__graph______stategraph.html">Chapter 1: Graph / StateGraph</a> and see how Pregel runs it when you call <code>app.invoke({"value": 5})</code>.</p>
<p><b>Graph:</b></p>
<ul>
<li>State: &lsquo;{'value&rsquo;: int}<code>(uses</code>LastValue<code>channel by default)</code></li>
<li><code> Nodes:</code>adder<code>(value+1),</code>multiplier&lt;tt&gt;(value*2)</li>
<li>Edges:</li>
</ul>
<p>START -&gt; adder<code>,</code>adder -&gt; multiplier<code>,</code>multiplier -&gt; END`</p>
<p><b>Execution Flow:</b></p>
<ol type="1">
<li><b>Start:</b> <code>app.invoke({"value": 5})</code> is called. The Pregel engine inside the compiled <code>app</code> takes over.</li>
<li><b>Initialization:</b> Pregel sets the initial state in the <code>"value"</code> <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channel</a> to <code>5</code>. <code>step = 0</code>.</li>
<li><b>Step 1 Begins:</b><ul>
<li><b>Scheduling:</b> Pregel sees the edge from <code>START</code> to <code>adder</code>. It schedules the <code>adder</code> node to run in this step.</li>
<li><b>Execution:</b> Pregel retrieves the current state (&lsquo;{'value&rsquo;: 5}<code>) from the [Channel](<a class="el" href="../../d5/d9b/03__channels_8md.html">03_channels.md</a>) and runs the</code>add_one<code>function associated with the</code>adder<code>node.</code></li>
<li><code> **Gathering Updates:** The</code>add_one<code>function returns</code>{"value": 6}<code>. Pregel gathers this write.</code></li>
<li><code> **Applying Updates:** Pregel sends the update</code>6<code>to the</code>"value"<code>[Channel](<a class="el" href="../../d5/d9b/03__channels_8md.html">03_channels.md</a>). Since it's a</code>LastValue<code>channel, its state becomes</code>6<code>.</code></li>
<li><code> **(Checkpointing):** If a checkpointer is configured (and enabled for this step), Pregel saves the state (</code>{'value': 6}<code>). *</code>step<code>increments to</code>1<code>.</code></li>
</ul>
</li>
<li><code> **Step 2 Begins:**<ul>
<li>**Scheduling:** Pregel looks at edges originating from nodes that completed in Step 1 (</li>
</ul>
</code>adder<code>). It finds the edge</code>adder -&gt; multiplier<code>. It schedules the</code>multiplier<code>node.<ul>
<li>**Execution:** Pregel retrieves the current state (</li>
</ul>
</code>{'value': 6}<code>) from the</code>"value"<code>[Channel](<a class="el" href="../../d5/d9b/03__channels_8md.html">03_channels.md</a>) and runs the</code>multiply_by_two<code>function.<ul>
<li>**Gathering Updates:** The</li>
</ul>
</code>multiply_by_two<code>function returns</code>{"value": 12}<code>. Pregel gathers this write.<ul>
<li>**Applying Updates:** Pregel sends the update</li>
</ul>
</code>12<code>to the</code>"value"<code>[Channel](<a class="el" href="../../d5/d9b/03__channels_8md.html">03_channels.md</a>). The channel's state becomes</code>12<code>.<ul>
<li>**(Checkpointing):** Pregel saves the state (</li>
</ul>
</code>{'value': 12}<code>). *</code>step<code>increments to</code>2<code>.</code></li>
<li><code> **Step 3 Begins:**<ul>
<li>**Scheduling:** Pregel looks at edges from</li>
</ul>
</code>multiplier<code>. It finds the edge</code>multiplier -&gt; END<code>. Reaching</code>END<code>means no more application nodes are scheduled.<ul>
<li>**(Execution, Gathering, Applying):** No application nodes run.</li>
<li>**(Checkpointing):** Pregel saves the final state (</li>
</ul>
</code>{'value': 12}<code>).</code></li>
<li><code> **Finish:** Pregel detects the</code>END<code>state. Execution halts.</code></li>
<li><code> **Return:** The final state (</code>{'value': 12}<code>) is read from the channels and returned by</code>app.invoke()`.</li>
</ol>
<p><b>Visualizing the Flow:</b></p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant User</div>
<div class="line">    participant App as CompiledGraph</div>
<div class="line">    participant PregelEngine as Pregel Engine</div>
<div class="line">    participant StateChannels as Channels</div>
<div class="line">    participant AdderNode as adder</div>
<div class="line">    participant MultiplierNode as multiplier</div>
<div class="line"> </div>
<div class="line">    User-&gt;&gt;App: invoke({&quot;value&quot;: 5})</div>
<div class="line">    App-&gt;&gt;PregelEngine: Start Execution</div>
<div class="line">    PregelEngine-&gt;&gt;StateChannels: Initialize state {&quot;value&quot;: 5}</div>
<div class="line">    Note over PregelEngine: Step 1</div>
<div class="line">    PregelEngine-&gt;&gt;PregelEngine: Schedule &#39;adder&#39; (from START)</div>
<div class="line">    PregelEngine-&gt;&gt;StateChannels: Read state ({&#39;value&#39;: 5})</div>
<div class="line">    PregelEngine-&gt;&gt;AdderNode: Run add_one({&#39;value&#39;: 5})</div>
<div class="line">    AdderNode--&gt;&gt;PregelEngine: Return {&quot;value&quot;: 6}</div>
<div class="line">    PregelEngine-&gt;&gt;StateChannels: Apply update {&quot;value&quot;: 6}</div>
<div class="line">    StateChannels--&gt;&gt;PregelEngine: State is now {&#39;value&#39;: 6}</div>
<div class="line">    Note over PregelEngine: Step 2</div>
<div class="line">    PregelEngine-&gt;&gt;PregelEngine: Schedule &#39;multiplier&#39; (from &#39;adder&#39;)</div>
<div class="line">    PregelEngine-&gt;&gt;StateChannels: Read state ({&#39;value&#39;: 6})</div>
<div class="line">    PregelEngine-&gt;&gt;MultiplierNode: Run multiply_by_two({&#39;value&#39;: 6})</div>
<div class="line">    MultiplierNode--&gt;&gt;PregelEngine: Return {&quot;value&quot;: 12}</div>
<div class="line">    PregelEngine-&gt;&gt;StateChannels: Apply update {&quot;value&quot;: 12}</div>
<div class="line">    StateChannels--&gt;&gt;PregelEngine: State is now {&#39;value&#39;: 12}</div>
<div class="line">    Note over PregelEngine: Step 3</div>
<div class="line">    PregelEngine-&gt;&gt;PregelEngine: Check edges from &#39;multiplier&#39; (sees END)</div>
<div class="line">    PregelEngine-&gt;&gt;PregelEngine: No more nodes to schedule. Finish.</div>
<div class="line">    PregelEngine-&gt;&gt;StateChannels: Read final state ({&#39;value&#39;: 12})</div>
<div class="line">    PregelEngine-&gt;&gt;App: Return final state {&#39;value&#39;: 12}</div>
<div class="line">    App-&gt;&gt;User: Return {&#39;value&#39;: 12}</div>
</div><!-- fragment --><p>Pregel acts as the hidden conductor ensuring each part plays at the right time with the right information.</p>
<h2><a class="anchor" id="autotoc_md2190"></a>
Internal Implementation: A Glimpse Under the Hood</h2>
<p>You don't typically interact with the Pregel engine directly; it's encapsulated within the compiled graph object you get from <code>graph.compile()</code>. However, understanding its core components helps clarify how LangGraph works. The main logic resides in the <code>langgraph/pregel/</code> directory.</p>
<ol type="1">
<li><b>Compilation:</b> When you call <code>graph.compile()</code>, LangGraph analyzes your nodes, edges, branches, and state schema. It translates your high-level graph definition into an internal representation suitable for the Pregel engine. This includes creating the actual <a class="el" href="../../dc/d09/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_202__nodes______pregelnode____.html"><code>PregelNode</code></a> objects which contain information about which channels to read, which function to run, and how to write outputs back.</li>
<li><b>The Loop (<code>pregel/loop.py</code>):</b> The core execution happens within a loop (managed by classes like <code>SyncPregelLoop</code> or <code>AsyncPregelLoop</code>). Each iteration of this loop represents one "superstep".</li>
<li><b>Task Preparation (<code>pregel/algo.py::prepare_next_tasks</code>):</b> At the start of each step, this function determines which tasks (nodes) are ready to run. It checks:<ul>
<li>Which <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a> were updated in the previous step.</li>
<li>Which nodes are triggered by those updated channels (based on edges and branches).</li>
<li>Are there any pending <code>Send</code> messages (<a class="el" href="../../d0/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_204__control__flow__primitives___bda35fdc89636f8ab61738c1940513a5.html">Control Flow Primitives</a>) targeting specific nodes?</li>
<li>It uses internal versioning on channels to avoid re-running nodes unnecessarily if their inputs haven't changed.</li>
</ul>
</li>
<li><b>Task Execution (<code>pregel/runner.py::PregelRunner</code>):</b> This component takes the list of tasks scheduled for the current step and executes them.<ul>
<li>It uses an executor (like Python's <code>concurrent.futures.ThreadPoolExecutor</code> for sync code or <code>asyncio</code> for async code) to potentially run independent tasks in parallel.</li>
<li>For each task, it reads the required state from the <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channels</a>, executes the node's function/Runnable, and collects the returned writes (the update dictionary).</li>
<li>It handles retries if configured for a node.</li>
</ul>
</li>
<li><b>Applying Writes (<code>pregel/algo.py::apply_writes</code>):</b> After tasks in a step complete (or fail), this function gathers all the writes returned by those tasks.<ul>
<li>It groups writes by channel name.</li>
<li>It calls the <code>.update()</code> method on each corresponding <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html">Channel</a> object, passing the collected updates for that channel. The channel itself enforces its update logic (e.g., <code>LastValue</code> overwrites, <code>Topic</code> appends).</li>
<li>It updates the internal checkpoint state with new channel versions.</li>
</ul>
</li>
<li><b>Checkpointing (<code>pregel/loop.py</code>, <code>checkpoint/base.py</code>):</b> The loop interacts with the configured <a class="el" href="../../d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html">Checkpointer (<code>BaseCheckpointSaver</code>)</a> to save the graph's state (the values and versions of all channels) at appropriate times (e.g., after each step).</li>
<li><b>Interrupt Handling (<code>pregel/loop.py</code>, <code>types.py::interrupt</code>):</b> If a node calls <code>interrupt()</code>, the <code>PregelRunner</code> catches the <code>GraphInterrupt</code> exception. The <code>PregelLoop</code> then coordinates with the <a class="el" href="../../d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html">Checkpointer</a> to save state and pause execution, returning control to the user. Resuming involves loading the checkpoint and providing the resume value back to the waiting <code>interrupt()</code> call.</li>
</ol>
<p><b>Simplified Code Snippets:</b></p>
<ul>
<li><b>Task Preparation (Conceptual):</b> ```python </li>
</ul>
<h1><a class="anchor" id="autotoc_md2191"></a>
pregel/algo.py (Simplified Concept)</h1>
<p>def prepare_next_tasks(checkpoint, processes, channels, config, step, ...): tasks = {} </p>
<h1><a class="anchor" id="autotoc_md2192"></a>
Check PUSH tasks (from Send)</h1>
<p>for packet in checkpoint["pending_sends"]: </p>
<h1><a class="anchor" id="autotoc_md2193"></a>
... create task if node exists ...</h1>
<p>task = create_task_for_send(packet, ...) tasks[task.id] = task</p>
<h1><a class="anchor" id="autotoc_md2194"></a>
Check PULL tasks (from edges/triggers)</h1>
<p>for name, proc in processes.items(): </p>
<h1><a class="anchor" id="autotoc_md2195"></a>
Check if any trigger channel for 'proc' was updated since last seen</h1>
<p>if _triggers(channels, checkpoint["channel_versions"], proc): </p>
<h1><a class="anchor" id="autotoc_md2196"></a>
... read input for the node ...</h1>
<p>task = create_task_for_pull(name, proc, ...) tasks[task.id] = task return tasks ``<code> This function checks both explicit</code>Send` commands and regular node triggers based on updated channels to build the list of tasks for the next step.</p>
<ul>
<li><b>Applying Writes (Conceptual):</b> ```python </li>
</ul>
<h1><a class="anchor" id="autotoc_md2197"></a>
pregel/algo.py (Simplified Concept)</h1>
<p>def apply_writes(checkpoint, channels, tasks: list[PregelExecutableTask], get_next_version): </p>
<h1><a class="anchor" id="autotoc_md2198"></a>
... (sort tasks for determinism, update seen versions) ...</h1>
<p>pending_writes_by_channel = defaultdict(list) for task in tasks: for chan, val in task.writes: # task.writes is the dict returned by the node if chan in channels: pending_writes_by_channel[chan].append(val) </p>
<h1><a class="anchor" id="autotoc_md2199"></a>
... (handle TASKS, PUSH, managed values etc.) ...</h1>
<p>updated_channels = <a class="el" href="../../d7/da6/pybind__kv__service_8cpp.html#a26ae8807a2b3217bb2339bd18aaaa4e6">set()</a> </p>
<h1><a class="anchor" id="autotoc_md2200"></a>
Apply writes to channels</h1>
<p>for chan_name, values_to_update in pending_writes_by_channel.items(): channel_obj = channels[chan_name] if channel_obj.update(values_to_update): # Channel applies its logic here! </p>
<h1><a class="anchor" id="autotoc_md2201"></a>
If updated, bump the version in the checkpoint</h1>
<p>checkpoint["channel_versions"][chan_name] = get_next_version(...) updated_channels.add(chan_name)</p>
<h1><a class="anchor" id="autotoc_md2202"></a>
... (handle channels that weren't written to but need bumping) ...</h1>
<p>return updated_channels ``<code> This function takes the results from all nodes in a step and uses the</code>channel.update()` method to modify the state according to each channel's rules.</p>
<ul>
<li><b>The Main Loop (Conceptual):</b> <code>python @section autotoc_md2203 pregel/loop.py (Simplified Concept - SyncPregelLoop/AsyncPregelLoop) class PregelLoop: def run(self): # Simplified invoke/stream logic with self: # Enters context (loads checkpoint, sets up channels) while self.tick(): # tick executes one step @section autotoc_md2204 Start tasks for the current step using PregelRunner runner = PregelRunner(...) for _ in runner.tick(self.tasks): @section autotoc_md2205 Yield control back, allowing writes/outputs to be streamed pass # (actual stream logic happens via callbacks) return self.output # Return final result </code> The loop repeatedly calls <code>tick()</code>. Inside <code>tick()</code>, it prepares tasks, runs them using <code>PregelRunner</code>, applies the resulting writes, handles checkpoints/interrupts, and determines if another step is needed.</li>
</ul>
<p>You don't need to know the deep implementation details, but understanding this step-by-step process managed by Pregel helps visualize how your graph comes alive.</p>
<h2><a class="anchor" id="autotoc_md2206"></a>
Conclusion</h2>
<p>The <b>Pregel Execution Engine</b> is the powerful, yet hidden, coordinator that runs your LangGraph graphs.</p>
<ul>
<li>It executes the graph <b>step-by-step</b> (supersteps).</li>
<li>In each step, it <b>schedules</b> which nodes run based on the graph structure and current state.</li>
<li>It <b>runs</b> the nodes (potentially in parallel).</li>
<li>It <b>gathers</b> node outputs and <b>updates</b> the shared state using <a class="el" href="../../df/dc1/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_203__channels.html"><code>Channels</code></a>.</li>
<li>It seamlessly integrates <a class="el" href="../../d0/d59/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_204__control__flow__primitives___bda35fdc89636f8ab61738c1940513a5.html"><code>Control Flow Primitives</code></a> like <code>Branch</code>, <code>Send</code>, and <code>Interrupt</code>.</li>
<li>It works with a <a class="el" href="../../d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html"><code>Checkpointer</code></a> to save and resume state.</li>
</ul>
<p>Think of it as the engine ensuring your application's logic flows correctly, state is managed reliably, and complex operations are orchestrated smoothly.</p>
<p>We've mentioned checkpointing several times – the ability to save and load the graph's state. This is crucial for long-running processes, human-in-the-loop workflows, and resilience. How does that work?</p>
<p>Let's dive into <a class="el" href="../../d8/d4c/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2LangGraph_206__checkpointer______basecheckpointsaver____.html">Chapter 6: Checkpointer (<code>BaseCheckpointSaver</code>)</a> to understand how LangGraph persists and resumes state.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
