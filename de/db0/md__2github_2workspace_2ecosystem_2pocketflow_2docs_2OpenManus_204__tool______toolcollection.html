#
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
#
<!-- HTML header for doxygen 1.9.8-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ResilientDB: 04_tool___toolcollection</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen_html_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('de/db0/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_204__tool______toolcollection.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">04_tool___toolcollection</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="autotoc_md2642"></a>
autotoc_md2642</h2>
<p>layout: default title: "Tool &amp; ToolCollection" parent: "OpenManus" </p>
<h2><a class="anchor" id="autotoc_md2643"></a>
nav_order: 4</h2>
<h1><a class="anchor" id="autotoc_md2644"></a>
Chapter 4: Tool / ToolCollection - Giving Your Agent Skills</h1>
<p>In <a class="el" href="../../d0/d71/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_203__baseagent.html">Chapter 3: BaseAgent - The Agent Blueprint</a>, we learned how <code>BaseAgent</code> provides the standard structure for our agents, including a brain (<a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">LLM</a>) and memory (<a class="el" href="../../dc/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_202__message______memory.html">Message / Memory</a>). But what if we want our agent to do more than just <em>think</em> and <em>remember</em>? What if we want it to <em>act</em> in the world – like searching the web, running code, or editing files?</p>
<p>This is where <b>Tools</b> come in!</p>
<h2><a class="anchor" id="autotoc_md2645"></a>
What Problem Do They Solve?</h2>
<p>Imagine an agent trying to answer the question: "What's the weather like in Tokyo *right now*?"</p>
<p>The agent's LLM brain has a lot of general knowledge, but it doesn't have <em>real-time</em> access to the internet. It can't check the current weather. It needs a specific <b>capability</b> or <b>skill</b> to do that.</p>
<p>Similarly, if you ask an agent to "Write a python script that prints 'hello world' and save it to a file named `hello.py`," the agent needs the ability to:</p><ol type="1">
<li>Understand the request (using its LLM).</li>
<li>Write the code (using its LLM).</li>
<li>Actually <em>execute</em> code to create and write to a file.</li>
</ol>
<p>Steps 1 and 2 are handled by the LLM, but step 3 requires interacting with the computer's file system – something the LLM can't do directly.</p>
<p><b>Tools</b> give agents these specific, actionable skills. A <code>ToolCollection</code> organizes these skills so the agent knows what it can do.</p>
<p><b>Use Case:</b> Let's build towards an agent that can:</p><ol type="1">
<li>Search the web for today's date.</li>
<li>Tell the user the date.</li>
</ol>
<p>This agent needs a "Web Search" tool.</p>
<h2><a class="anchor" id="autotoc_md2646"></a>
Key Concepts: Tools and Toolboxes</h2>
<p>Let's break down the two main ideas:</p>
<h3><a class="anchor" id="autotoc_md2647"></a>
1. <code>BaseTool</code>: The Blueprint for a Skill</h3>
<p>Think of <code>BaseTool</code> (<code>app/tool/base.py</code>) as the <em>template</em> or <em>design specification</em> for any tool. It doesn't <em>do</em> anything itself, but it defines what every tool needs to have:</p>
<ul>
<li><b><code>name</code> (str):</b> A short, descriptive name for the tool (e.g., <code>web_search</code>, <code>file_writer</code>, <code>code_runner</code>). This is how the agent (or LLM) identifies the tool.</li>
<li><b><code>description</code> (str):</b> A clear explanation of what the tool does, what it's good for, and when to use it. This is crucial for the LLM to decide <em>which</em> tool to use for a given task.</li>
<li><b><code>parameters</code> (dict):</b> A definition of the inputs the tool expects. For example, a <code>web_search</code> tool needs a <code>query</code> input, and a <code>file_writer</code> needs a <code>path</code> and <code>content</code>. This is defined using a standard format called JSON Schema.</li>
<li><b><code>execute</code> method:</b> An <b>abstract</b> method. This means <code>BaseTool</code> says "every tool *must* have an execute method", but each specific tool needs to provide its <em>own</em> instructions for how to actually perform the action.</li>
</ul>
<p>You almost never use <code>BaseTool</code> directly. You use it as a starting point to create <em>actual</em>, usable tools.</p>
<h3><a class="anchor" id="autotoc_md2648"></a>
2. Concrete Tools: The Actual Skills</h3>
<p>These are specific classes that <em>inherit</em> from <code>BaseTool</code> and provide the real implementation for the <code>execute</code> method. OpenManus comes with several pre-built tools:</p>
<ul>
<li><b><code>WebSearch</code> (<code>app/tool/web_search.py</code>):</b> Searches the web using engines like Google, Bing, etc.</li>
<li><b><code>Bash</code> (<code>app/tool/bash.py</code>):</b> Executes shell commands (like <code>ls</code>, <code>pwd</code>, <code>python script.py</code>).</li>
<li><b><code>StrReplaceEditor</code> (<code>app/tool/str_replace_editor.py</code>):</b> Views, creates, and edits files by replacing text.</li>
<li><b><code>BrowserUseTool</code> (<code>app/tool/browser_use_tool.py</code>):</b> Interacts with web pages like a user (clicking, filling forms, etc.).</li>
<li><b><code>Terminate</code> (<code>app/tool/terminate.py</code>):</b> A special tool used by agents to signal they have finished their task.</li>
</ul>
<p>Each of these defines its specific <code>name</code>, <code>description</code>, <code>parameters</code>, and implements the <code>execute</code> method to perform its unique action.</p>
<h3><a class="anchor" id="autotoc_md2649"></a>
3. <code>ToolCollection</code>: The Agent's Toolbox</h3>
<p>Think of a handyman. They don't just carry one tool; they have a toolbox filled with hammers, screwdrivers, wrenches, etc.</p>
<p>A <code>ToolCollection</code> (<code>app/tool/tool_collection.py</code>) is like that toolbox for an agent.</p>
<ul>
<li>It holds a list of specific tool instances (like <code>WebSearch</code>, <code>Bash</code>).</li>
<li>It allows the agent (and its LLM) to see all the available tools and their descriptions.</li>
<li>It provides a way to execute a specific tool by its name.</li>
</ul>
<p>When an agent needs to perform an action, its LLM can look at the <code>ToolCollection</code>, read the descriptions of the available tools, choose the best one for the job, figure out the necessary inputs based on the tool's <code>parameters</code>, and then ask the <code>ToolCollection</code> to execute that tool with those inputs.</p>
<h2><a class="anchor" id="autotoc_md2650"></a>
How Do We Use Them?</h2>
<p>Let's see how we can equip an agent with a simple tool. We'll create a basic "EchoTool" first.</p>
<p><b>1. Creating a Concrete Tool (Inheriting from <code>BaseTool</code>):</b></p>
<div class="fragment"><div class="line"><span class="comment"># Import the necessary base class</span></div>
<div class="line"><span class="keyword">from</span> app.tool.base <span class="keyword">import</span> BaseTool, ToolResult</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Define our simple tool</span></div>
<div class="line"><span class="keyword">class </span>EchoTool(BaseTool):</div>
<div class="line">    <span class="stringliteral">&quot;&quot;&quot;A simple tool that echoes the input text.&quot;&quot;&quot;</span></div>
<div class="line"> </div>
<div class="line">    name: str = <span class="stringliteral">&quot;echo_message&quot;</span></div>
<div class="line">    description: str = <span class="stringliteral">&quot;Repeats back the text provided in the &#39;message&#39; parameter.&quot;</span></div>
<div class="line">    parameters: dict = {</div>
<div class="line">        <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;object&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;properties&quot;</span>: {</div>
<div class="line">            <span class="stringliteral">&quot;message&quot;</span>: {</div>
<div class="line">                <span class="stringliteral">&quot;type&quot;</span>: <span class="stringliteral">&quot;string&quot;</span>,</div>
<div class="line">                <span class="stringliteral">&quot;description&quot;</span>: <span class="stringliteral">&quot;The text to be echoed back.&quot;</span>,</div>
<div class="line">            },</div>
<div class="line">        },</div>
<div class="line">        <span class="stringliteral">&quot;required&quot;</span>: [<span class="stringliteral">&quot;message&quot;</span>], <span class="comment"># Tells the LLM &#39;message&#39; must be provided</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># Implement the actual action</span></div>
<div class="line">    <span class="keyword">async def </span>execute(self, message: str) -&gt; ToolResult:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Takes a message and returns it.&quot;&quot;&quot;</span></div>
<div class="line">        print(f<span class="stringliteral">&quot;EchoTool executing with message: &#39;{message}&#39;&quot;</span>)</div>
<div class="line">        <span class="comment"># ToolResult is a standard way to return tool output</span></div>
<div class="line">        <span class="keywordflow">return</span> ToolResult(output=f<span class="stringliteral">&quot;You said: {message}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create an instance of our tool</span></div>
<div class="line">echo_tool_instance = EchoTool()</div>
<div class="line"> </div>
<div class="line">print(f<span class="stringliteral">&quot;Tool Name: {echo_tool_instance.name}&quot;</span>)</div>
<div class="line">print(f<span class="stringliteral">&quot;Tool Description: {echo_tool_instance.description}&quot;</span>)</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>We import <code>BaseTool</code> and <code>ToolResult</code> (a standard object for wrapping tool outputs).</li>
<li><code>class EchoTool(BaseTool):</code> declares that our <code>EchoTool</code> <em>is a type of</em> <code>BaseTool</code>.</li>
<li>We define the <code>name</code>, <code>description</code>, and <code>parameters</code> according to the <code>BaseTool</code> template. The <code>parameters</code> structure tells the LLM what input is expected (<code>message</code> as a string) and that it's required.</li>
<li>We implement <code>async def execute(self, message: str) -&gt; ToolResult:</code>. This is the <em>specific</em> logic for our tool. It takes the <code>message</code> input and returns it wrapped in a <code>ToolResult</code>.</li>
</ul>
<p><b>Example Output:</b></p>
<div class="fragment"><div class="line">Tool Name: echo_message</div>
<div class="line">Tool Description: Repeats back the text provided in the &#39;message&#39; parameter.</div>
</div><!-- fragment --><p><b>2. Creating a ToolCollection:</b></p>
<p>Now, let's put our <code>EchoTool</code> and the built-in <code>WebSearch</code> tool into a toolbox.</p>
<div class="fragment"><div class="line"><span class="comment"># Import ToolCollection and the tools we want</span></div>
<div class="line"><span class="keyword">from</span> app.tool <span class="keyword">import</span> ToolCollection, WebSearch</div>
<div class="line"><span class="comment"># Assume EchoTool class is defined as above</span></div>
<div class="line"><span class="comment"># from your_module import EchoTool # Or wherever EchoTool is defined</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create instances of the tools</span></div>
<div class="line">echo_tool = EchoTool()</div>
<div class="line">web_search_tool = WebSearch() <span class="comment"># Uses default settings</span></div>
<div class="line"> </div>
<div class="line"><span class="comment"># Create a ToolCollection containing these tools</span></div>
<div class="line">my_toolbox = ToolCollection(echo_tool, web_search_tool)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># See the names of the tools in the collection</span></div>
<div class="line">tool_names = [tool.name <span class="keywordflow">for</span> tool <span class="keywordflow">in</span> my_toolbox]</div>
<div class="line">print(f<span class="stringliteral">&quot;Tools in the toolbox: {tool_names}&quot;</span>)</div>
<div class="line"> </div>
<div class="line"><span class="comment"># Get the parameters needed for the LLM</span></div>
<div class="line">tool_params_for_llm = my_toolbox.to_params()</div>
<div class="line">print(f<span class="stringliteral">&quot;\nParameters for LLM (showing first tool):&quot;</span>)</div>
<div class="line"><span class="keyword">import</span> json</div>
<div class="line">print(json.dumps(tool_params_for_llm[0], indent=2))</div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>We import <code>ToolCollection</code> and the specific tools (<code>WebSearch</code>, <code>EchoTool</code>).</li>
<li>We create instances of the tools we need.</li>
<li><code>my_toolbox = ToolCollection(echo_tool, web_search_tool)</code> creates the collection, holding our tool instances.</li>
<li>We can access the tools inside using <code>my_toolbox.tools</code> or iterate over <code>my_toolbox</code>.</li>
<li><code>my_toolbox.to_params()</code> is a crucial method. It formats the <code>name</code>, <code>description</code>, and <code>parameters</code> of <em>all</em> tools in the collection into a list of dictionaries. This specific format is exactly what the agent's <a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">LLM</a> needs (when using its <code>ask_tool</code> method) to understand which tools are available and how to use them.</li>
</ul>
<p><b>Example Output:</b></p>
<div class="fragment"><div class="line">Tools in the toolbox: [&#39;echo_message&#39;, &#39;web_search&#39;]</div>
<div class="line"> </div>
<div class="line">Parameters for LLM (showing first tool):</div>
<div class="line">{</div>
<div class="line">  &quot;type&quot;: &quot;function&quot;,</div>
<div class="line">  &quot;function&quot;: {</div>
<div class="line">    &quot;name&quot;: &quot;echo_message&quot;,</div>
<div class="line">    &quot;description&quot;: &quot;Repeats back the text provided in the &#39;message&#39; parameter.&quot;,</div>
<div class="line">    &quot;parameters&quot;: {</div>
<div class="line">      &quot;type&quot;: &quot;object&quot;,</div>
<div class="line">      &quot;properties&quot;: {</div>
<div class="line">        &quot;message&quot;: {</div>
<div class="line">          &quot;type&quot;: &quot;string&quot;,</div>
<div class="line">          &quot;description&quot;: &quot;The text to be echoed back.&quot;</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line">      &quot;required&quot;: [</div>
<div class="line">        &quot;message&quot;</div>
<div class="line">      ]</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><p><b>3. Agent Using the ToolCollection:</b></p>
<p>Now, how does an agent like <code>ToolCallAgent</code> (a specific type of <a class="el" href="../../d0/d71/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_203__baseagent.html">BaseAgent</a>) use this?</p>
<p>Conceptually (the real agent code is more complex):</p>
<ol type="1">
<li>The agent is configured with a <code>ToolCollection</code> (like <code>my_toolbox</code>).</li>
<li>When the agent needs to figure out the next step, it calls its LLM's <code>ask_tool</code> method.</li>
<li>It passes the conversation history (<a class="el" href="../../dc/d8e/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_202__message______memory.html">Message / Memory</a>) AND the output of <code>my_toolbox.to_params()</code> to the LLM.</li>
<li>The LLM looks at the conversation and the list of available tools (from <code>to_params()</code>). It reads the <code>description</code> of each tool to understand what it does.</li>
<li>If the LLM decides a tool is needed (e.g., the user asked "What's today's date?", the LLM sees the <code>web_search</code> tool is available and appropriate), it will generate a special response indicating:<ul>
<li>The <code>name</code> of the tool to use (e.g., <code>"web_search"</code>).</li>
<li>The <code>arguments</code> (inputs) for the tool, based on its <code>parameters</code> (e.g., <code>{"query": "today's date"}</code>).</li>
</ul>
</li>
<li>The agent receives this response from the LLM.</li>
<li>The agent then uses the <code>ToolCollection</code>'s <code>execute</code> method: <code>await my_toolbox.execute(name="web_search", tool_input={"query": "today's date"})</code>.</li>
<li>The <code>ToolCollection</code> finds the <code>WebSearch</code> tool instance in its internal <code>tool_map</code> and calls <em>its</em> <code>execute</code> method with the provided input.</li>
<li>The <code>WebSearch</code> tool runs, performs the actual web search, and returns the results (as a <code>ToolResult</code> or similar).</li>
<li>The agent takes this result, formats it as a <code>tool</code> message, adds it to its memory, and continues its thinking process (often asking the LLM again, now with the tool's result as context).</li>
</ol>
<p>The <code>ToolCollection</code> acts as the crucial bridge between the LLM's <em>decision</em> to use a tool and the <em>actual execution</em> of that tool's code.</p>
<h2><a class="anchor" id="autotoc_md2651"></a>
Under the Hood: How <code>ToolCollection.execute</code> Works</h2>
<p>Let's trace the flow when an agent asks its <code>ToolCollection</code> to run a tool:</p>
<div class="fragment"><div class="line">sequenceDiagram</div>
<div class="line">    participant Agent as ToolCallAgent</div>
<div class="line">    participant LLM as LLM (Deciding Step)</div>
<div class="line">    participant Toolbox as ToolCollection</div>
<div class="line">    participant SpecificTool as e.g., WebSearch Tool</div>
<div class="line"> </div>
<div class="line">    Agent-&gt;&gt;+LLM: ask_tool(messages, tools=Toolbox.to_params())</div>
<div class="line">    LLM-&gt;&gt;LLM: Analyzes messages &amp; available tools</div>
<div class="line">    LLM--&gt;&gt;-Agent: Response indicating tool call: name=&#39;web_search&#39;, arguments={&#39;query&#39;: &#39;...&#39;}</div>
<div class="line">    Agent-&gt;&gt;+Toolbox: execute(name=&#39;web_search&#39;, tool_input={&#39;query&#39;: &#39;...&#39;})</div>
<div class="line">    Toolbox-&gt;&gt;Toolbox: Look up &#39;web_search&#39; in internal tool_map</div>
<div class="line">    Note right of Toolbox: Finds the WebSearch instance</div>
<div class="line">    Toolbox-&gt;&gt;+SpecificTool: Calls execute(**tool_input) on the found tool</div>
<div class="line">    SpecificTool-&gt;&gt;SpecificTool: Performs actual web search action</div>
<div class="line">    SpecificTool--&gt;&gt;-Toolbox: Returns ToolResult (output=&quot;...&quot;, error=None)</div>
<div class="line">    Toolbox--&gt;&gt;-Agent: Returns the ToolResult</div>
<div class="line">    Agent-&gt;&gt;Agent: Processes the result (adds to memory, etc.)</div>
</div><!-- fragment --><p><b>Code Glimpse:</b></p>
<p>Let's look at the <code>ToolCollection</code> itself in <code>app/tool/tool_collection.py</code>:</p>
<div class="fragment"><div class="line"><span class="comment"># Simplified snippet from app/tool/tool_collection.py</span></div>
<div class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any, Dict, List, Tuple</div>
<div class="line"><span class="keyword">from</span> app.tool.base <span class="keyword">import</span> BaseTool, ToolResult, ToolFailure</div>
<div class="line"><span class="keyword">from</span> app.exceptions <span class="keyword">import</span> ToolError</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ToolCollection:</div>
<div class="line">    <span class="comment"># ... (Config class) ...</span></div>
<div class="line"> </div>
<div class="line">    tools: Tuple[BaseTool, ...] <span class="comment"># Holds the tool instances</span></div>
<div class="line">    tool_map: Dict[str, BaseTool] <span class="comment"># Maps name to tool instance for quick lookup</span></div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>__init__(self, *tools: BaseTool):</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Initializes with a sequence of tools.&quot;&quot;&quot;</span></div>
<div class="line">        self.tools = tools</div>
<div class="line">        <span class="comment"># Create the map for easy lookup by name</span></div>
<div class="line">        self.tool_map = {tool.name: tool <span class="keywordflow">for</span> tool <span class="keywordflow">in</span> tools}</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">def </span>to_params(self) -&gt; List[Dict[str, Any]]:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Formats tools for the LLM API.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># Calls the &#39;to_param()&#39; method on each tool</span></div>
<div class="line">        <span class="keywordflow">return</span> [tool.to_param() <span class="keywordflow">for</span> tool <span class="keywordflow">in</span> self.tools]</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">async def </span>execute(</div>
<div class="line">        self, *, name: str, tool_input: Dict[str, Any] = <span class="keywordtype">None</span></div>
<div class="line">    ) -&gt; ToolResult:</div>
<div class="line">        <span class="stringliteral">&quot;&quot;&quot;Finds a tool by name and executes it.&quot;&quot;&quot;</span></div>
<div class="line">        <span class="comment"># 1. Find the tool instance using the name</span></div>
<div class="line">        tool = self.tool_map.<a class="code hl_function" href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get</a>(name)</div>
<div class="line">        <span class="keywordflow">if</span> <span class="keywordflow">not</span> tool:</div>
<div class="line">            <span class="comment"># Return a standard failure result if tool not found</span></div>
<div class="line">            <span class="keywordflow">return</span> ToolFailure(error=f<span class="stringliteral">&quot;Tool {name} is invalid&quot;</span>)</div>
<div class="line"> </div>
<div class="line">        <span class="comment"># 2. Execute the tool&#39;s specific method</span></div>
<div class="line">        <span class="keywordflow">try</span>:</div>
<div class="line">            <span class="comment"># The &#39;tool(**tool_input)&#39; calls the tool instance&#39;s __call__ method,</span></div>
<div class="line">            <span class="comment"># which in BaseTool, calls the tool&#39;s &#39;execute&#39; method.</span></div>
<div class="line">            <span class="comment"># The ** unpacks the dictionary into keyword arguments.</span></div>
<div class="line">            result = await tool(**(tool_input <span class="keywordflow">or</span> {}))</div>
<div class="line">            <span class="comment"># Ensure the result is a ToolResult (or subclass)</span></div>
<div class="line">            <span class="keywordflow">return</span> result <span class="keywordflow">if</span> isinstance(result, ToolResult) <span class="keywordflow">else</span> ToolResult(output=str(result))</div>
<div class="line">        <span class="keywordflow">except</span> ToolError <span class="keyword">as</span> e:</div>
<div class="line">             <span class="comment"># Handle errors specific to tools</span></div>
<div class="line">            <span class="keywordflow">return</span> ToolFailure(error=e.message)</div>
<div class="line">        <span class="keywordflow">except</span> Exception <span class="keyword">as</span> e:</div>
<div class="line">             <span class="comment"># Handle unexpected errors during execution</span></div>
<div class="line">            <span class="keywordflow">return</span> ToolFailure(error=f<span class="stringliteral">&quot;Unexpected error executing tool {name}: {e}&quot;</span>)</div>
<div class="line"> </div>
<div class="line">    <span class="comment"># ... other methods like add_tool, __iter__ ...</span></div>
<div class="ttc" id="apybind__kv__service_8cpp_html_abe6524afb3a69dc9a4c314e11f96f29f"><div class="ttname"><a href="../../d7/da6/pybind__kv__service_8cpp.html#abe6524afb3a69dc9a4c314e11f96f29f">get</a></div><div class="ttdeci">std::string get(std::string key, std::string config_path)</div><div class="ttdef"><b>Definition</b> <a href="../../d7/da6/pybind__kv__service_8cpp_source.html#l00039">pybind_kv_service.cpp:39</a></div></div>
</div><!-- fragment --><p><b>Explanation:</b></p>
<ul>
<li>The <code>__init__</code> method takes tool instances and stores them in <code>self.tools</code> (a tuple) and <code>self.tool_map</code> (a dictionary mapping name to instance).</li>
<li><code>to_params</code> iterates through <code>self.tools</code> and calls each tool's <code>to_param()</code> method (defined in <code>BaseTool</code>) to get the LLM-compatible format.</li>
<li><code>execute</code> is the core method used by agents:<ul>
<li>It uses <code>self.tool_map.get(name)</code> to quickly find the correct tool instance based on the requested name.</li>
<li>If found, it calls <code>await tool(**(tool_input or {}))</code>. The <code>**</code> unpacks the <code>tool_input</code> dictionary into keyword arguments for the tool's <code>execute</code> method (e.g., <code>message="hello"</code> for our <code>EchoTool</code>, or <code>query="today's date"</code> for <code>WebSearch</code>).</li>
<li>It wraps the execution in <code>try...except</code> blocks to catch errors and return a standardized <code>ToolFailure</code> result if anything goes wrong.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md2652"></a>
Wrapping Up Chapter 4</h2>
<p>We've learned how <b>Tools</b> give agents specific skills beyond basic language understanding.</p><ul>
<li><code>BaseTool</code> is the abstract blueprint defining a tool's <code>name</code>, <code>description</code>, and expected <code>parameters</code>.</li>
<li>Concrete tools (like <code>WebSearch</code>, <code>Bash</code>, or our custom <code>EchoTool</code>) inherit from <code>BaseTool</code> and implement the actual <code>execute</code> logic.</li>
<li><code>ToolCollection</code> acts as the agent's toolbox, holding various tools and providing methods (<code>to_params</code>, <code>execute</code>) for the agent (often guided by its <a class="el" href="../../db/dc5/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_201__llm.html">LLM</a>) to discover and use these capabilities.</li>
</ul>
<p>With tools, agents can interact with external systems, run code, access real-time data, and perform complex actions, making them much more powerful.</p>
<p>But how do we coordinate multiple agents, potentially using different tools, to work together on a larger task? That's where Flows come in.</p>
<p>Let's move on to <a class="el" href="../../d0/d93/md__2github_2workspace_2ecosystem_2pocketflow_2docs_2OpenManus_205__baseflow.html">Chapter 5: BaseFlow</a> to see how we orchestrate complex workflows involving multiple agents and steps.</p>
<hr  />
<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2 </li>
  </ul>
</div>
</body>
</html>
